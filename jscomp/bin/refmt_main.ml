module Ppx_deriving_show = struct let sig_of_type ~options ~path decl = [] let str_of_type ~options ~path typ = [] end module Result = struct type ('a, 'b) result = Ok of 'a | Error of 'b end open Result
module Cmdliner : sig 
#1 "cmdliner.mli"
(*---------------------------------------------------------------------------
   Copyright (c) 2011 Daniel C. Bünzli. All rights reserved.
   Distributed under a BSD3 license, see license at the end of the file.
   cmdliner release 0.9.8
  ---------------------------------------------------------------------------*)

(** Declarative definition of command line interfaces.

    [Cmdliner] provides a simple and compositional mechanism
    to convert command line arguments to OCaml values and pass them to
    your functions. The module automatically handles syntax errors,
    help messages and UNIX man page generation. It supports programs
    with single or multiple commands
    (like [darcs] or [git]) and respect most of the
    {{:http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html}
    POSIX} and
    {{:http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html}
    GNU} conventions.

    Consult the {{!basics}basics}, details about the supported
    {{!cmdline}command line syntax} and {{!examples} examples} of
    use. Open the module to use it, it defines only three modules in
    your scope.

    {e Release 0.9.8 - Daniel Bünzli <daniel.buenzl i\@erratique.ch> } *)

(** {1:top Interface} *)

(** Man page specification.

    Man page generation is automatically handled by [Cmdliner]. The
    {!block} type is used to define a man page's content.

    The {!print} function can be useful if the client wants to define
    other man pages (e.g. to implement a help command). *)
module Manpage : sig

  (** {1:man Man pages} *)

  type block =
    [ `S of string | `P of string | `Pre of string | `I of string * string
    | `Noblank ]
  (** The type for a block of man page text.

      {ul
      {- [`S s] introduces a new section [s].}
      {- [`P t] is a new paragraph with text [t].}
      {- [`Pre t] is a new preformatted paragraph with text [t].}
      {- [`I (l,t)] is an indented paragraph with label
      [l] and text [t].}
      {- [`Noblank] suppresses the blank line introduced between two blocks.}}

      Except in [`Pre], whitespace and newlines are not significant
      and are all collapsed to a single space. In labels [l] and text
      strings [t], the syntax ["$(i,italic text)"] and ["$(b,bold
      text)"] can be used to respectively produce italic and bold
      text. *)

  type title = string * int * string * string * string
  (** The type for man page titles. Describes the man page
      [title], [section], [center_footer], [left_footer], [center_header]. *)

  type t = title * block list
  (** The type for a man page. A title and the page text as a list of blocks. *)

  val print : ?subst:(string -> string) ->
    [`Pager | `Plain | `Groff ] -> Format.formatter -> t -> unit
  (** [print ~subst fmt ppf page] prints [page] on [ppf] in the format [fmt].
      If [fmt] is [`Pager] the function tries to write the formatted
      result in a pager, if that fails the format [`Plain] is written
      on [ppf]. [subst] can be used to perform variable substitution,
      see {!Buffer.add_substitute} (defaults to the identity). *)
end

(** Terms.

    A term is evaluated by a program to produce a {{!result}result}.
    A term made of terms referring to {{!Arg}command line arguments}
    implicitly defines a command line syntax. *)
module Term : sig

  (** {1:terms Terms} *)

  type +'a t
  (** The type for terms evaluating to values of type 'a. *)

  val const : 'a -> 'a t
  (** [const v] is a term that evaluates to [v]. *)

  (**/**)
  val pure : 'a -> 'a t
  (** @deprecated use {!const} instead. *)
  (**/**)

  val ( $ ) : ('a -> 'b) t -> 'a t -> 'b t
  (** [f $ v] is a term that evaluates to the result of applying
      the evaluation of [v] to the one of [f]. *)

  val app : ('a -> 'b) t -> 'a t -> 'b t
  (** [app] is {!($)}. *)

  type 'a ret =
    [ `Help of [`Pager | `Plain | `Groff] * string option
    | `Error of (bool * string)
    | `Ok of 'a ]
  (** The type for command return values. See {!ret}. *)

  val ret : 'a ret t -> 'a t
  (** [ret v] is a term whose evaluation depends on the case
      to which [v] evaluates. With :
      {ul
      {- [`Ok r], it evaluates to [r].}
      {- [`Error (usage,e)], the evaluation fails and [Cmdliner] prints
         the error [e] and the term's usage if [usage] is [true].}
      {- [`Help (format, name)], the evaluation fails and [Cmdliner] prints the
         term's man page in the given [format] (or the man page for a
         specific [name] term in case of multiple term evaluation).}}   *)

  val main_name : string t
  (** [main_name] is a term that evaluates to the "main" term's name. *)

  val choice_names : string list t
  (** [choice_names] is a term that evaluates to the names of the terms
      to choose from. *)

  val man_format : [`Pager | `Plain | `Groff] t
  (** [man_format] is a term that defines a [--man-format] option and
      evaluates to a value that can be used with {!Manpage.print}. *)

  (** {1:tinfo Term information}

      Term information defines the name and man page of a term.
      For simple evaluation this is the name of the program and its
      man page. For multiple term evaluation, this is
      the name of a command and its man page. *)

  type info
  (** The type for term information. *)

  val info : ?sdocs:string -> ?man:Manpage.block list ->
    ?docs:string -> ?doc:string -> ?version:string -> string -> info
  (** [info sdocs man docs doc version name] is a term information
      such that:
      {ul
      {- [name] is the name of the program or the command.}
      {- [version] is the version string of the program, ignored
         for commands.}
      {- [doc] is a one line description of the program or command used
         for the [NAME] section of the term's man page. For commands this
         description is also used in the list of commands of the main
         term's man page.}
      {- [docs], only for commands, the title of the section of the main
         term's man page where it should be listed (defaults to ["COMMANDS"]).}
      {- [man] is the text of the man page for the term. In the text,
         the variables ["$(tname)"] and ["$(mname)"] can respectively be
         used to refer to the value of [name] and the main term's name.
      }
      {- [sdocs] defines the title of the section in which the
         standard [--help] and [--version] arguments are listed.}} *)

  val name : info -> string
  (** [name ti] is the name of the term information. *)

 (** {1:evaluation Evaluation} *)

  type 'a result = [
    | `Ok of 'a | `Error of [`Parse | `Term | `Exn ] | `Version | `Help ]
  (** The type for evaluation results.
      {ul
      {- [`Ok v], the term evaluated successfully and [v] is the result.}
      {- [`Version], the version string of the main term was printed
       on the help formatter.}
      {- [`Help], man page about the term was printed on the help formatter.}
      {- [`Error `Parse], a command line parse error occured and was
         reported on the error formatter.}
      {- [`Error `Term], a term evaluation error occured and was reported
         on the error formatter (see {!Term.ret}).}
      {- [`Error `Exn], an exception [e] was caught and reported
         on the error formatter (see the [~catch] parameter of {!eval}).}} *)

  val eval : ?help:Format.formatter ->
    ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) ->
    ?argv:string array -> ('a t * info) -> 'a result
  (** [eval help err catch argv (t,i)]  is the evaluation result
      of [t] with command line arguments [argv] (defaults to {!Sys.argv}).

      If [catch] is [true] (default) uncaught exeptions
      are intercepted and their stack trace is written to the [err]
      formatter.

      [help] is the formatter used to print help or version messages
      (defaults to {!Format.std_formatter}). [err] is the formatter
      used to print error messages (defaults to {!Format.err_formatter}).

      [env] is used for environment variable lookup, the default
      uses {!Sys.getenv}. *)

  val eval_choice : ?help:Format.formatter ->
    ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) ->
    ?argv:string array -> 'a t * info -> ('a t * info) list ->
    'a result
  (** [eval_choice help err catch argv default (t,i) choices] is like {!eval}
      except that if the first argument on the command line is not an option
      name it will look in [choices] for a term whose information has this
      name and evaluate it.

      If the command name is unknown an error is reported. If the name
      is unspecified the "main" term [t] is evaluated. [i] defines the
      name and man page of the program. *)

  val eval_peek_opts : ?version_opt:bool ->
    ?env:(string -> string option) ->
    ?argv:string array -> 'a t ->
    'a option * 'a result
  (** [eval_peek_opts version_opt argv t] evaluates [t], a term made
      of optional arguments only, with the command line [argv]
      (defaults to {!Sys.argv}). In this evaluation, unknown optional
      arguments and positional arguments are ignored.

      The evaluation returns a pair. The first component is
      the result of parsing the command line [argv] stripped from
      any help and version option if [version_opt] is [true] (defaults
      to [false]). It results in:
      {ul
      {- [Some _] if the command line would be parsed correctly given the
         {e partial} knowledge in [t].}
      {- [None] if a parse error would occur on the options of [t]}}

      The second component is the result of parsing the command line
      [argv] without stripping the help and version options. It
      indicates what the evaluation would result in on [argv] given
      the partial knowledge in [t] (for example it would return
      [`Help] if there's a help option in [argv]). However in
      contrasts to {!eval} and {!eval_choice} no side effects like
      error reporting or help output occurs.

      {b Note.} Positional arguments can't be peeked without the full
      specification of the command line: we can't tell apart a
      positional argument from the value of an unknown optional
      argument.  *)
end

(** Terms for command line arguments.

    This module provides functions to define terms that evaluate
    to the arguments provided on the command line.

    Basic constraints, like the argument type or repeatability, are
    specified by defining a value of type {!t}. Further contraints can
    be specified during the {{!argterms}conversion} to a term. *)
module Arg : sig

(** {1:argconv Argument converters}

    An argument converter transforms a string argument of the command
    line to an OCaml value. {{!converters}Predefined converters}
    are provided for many types of the standard library. *)

  type 'a parser = string -> [ `Ok of 'a | `Error of string ]
  (** The type for argument parsers. *)

  type 'a printer = Format.formatter -> 'a -> unit
  (** The type for converted argument printers. *)

  type 'a converter = 'a parser * 'a printer
  (** The type for argument converters. *)

  val some : ?none:string -> 'a converter -> 'a option converter
  (** [some none c] is like the converter [c] except it returns
      [Some] value. It is used for command line arguments
      that default to [None] when absent. [none] is what to print to
      document the absence (defaults to [""]). *)

(** {1:arginfo Arguments and their information}

    Argument information defines the man page information of an
    argument and, for optional arguments, its names. An environment
    variable can also be specified to read the argument value from
    if the argument is absent from the command line and the variable
    is defined. *)

  type env
  (** The type for environment variables and their documentation. *)

  val env_var : ?docs:string -> ?doc:string -> string -> env
  (** [env_var docs doc var] is an environment variables [var]. [doc]
      is the man page information of the environment variable; the
      variables mentioned in {!info} can be used in this documentation
      string. [doc] defaults to ["See option $(opt)."]. [docs] is the
      title of the man page section in which the environment variable
      will be listed, it defaults to ["ENVIRONMENT VARIABLES"]. *)

  type 'a t
  (** The type for arguments holding data of type ['a]. *)

  type info
  (** The type for information about command line arguments. *)

  val info : ?docs:string -> ?docv:string -> ?doc:string -> ?env:env ->
    string list -> info
  (** [info docs docv doc env names] defines information for
      an argument.

      [names] defines the names under which an optional argument
      can be referred to. Strings of length [1] (["c"]) define short
      option names (["-c"]), longer strings (["count"]) define long
      option names (["--count"]). [names] must be empty for positional
      arguments.

      [env] defines the name of an environment variable which is
      looked up for defining the argument if it is absent from the
      command line. See {{!envlookup}environment variables} for
      details.
      {ul
      {- [doc] is the man page information of the argument. The
         variable ["$(docv)"] can be used to refer to the value of
         [docv] (see below). The variable ["$(opt)"] will refer to a
         long option of [names] or a short one if there is no long
         option. The variable ["$(env)"] will refer to the environment
         variable specified by [env] (if any).  {{!doc_helpers}These
         functions} can help with formatting argument values.}
      {- [docv] is for positional and non-flag optional arguments.
         It is a variable name used in the man page to stand for their value.}
      {- [docs] is the title of the man page section in which the argument
         will be listed. For optional arguments this defaults
         to ["OPTIONS"]. For positional arguments this defaults
         to ["ARGUMENTS"]. However a positional argument is only listed
         if it has both a [doc] and [docv] specified.}} *)

  val ( & ) : ('a -> 'b) -> 'a -> 'b
  (** [f & v] is [f v], a right associative composition operator for
      specifying argument terms. *)

(** {1:optargs Optional arguments}

    The information of an optional argument must have at least
    one name or [Invalid_argument] is raised. *)

  val flag : info -> bool t
  (** [flag i] is a [bool] argument defined by an optional flag
      that may appear {e at most} once on the command line under one of
      the names specified by [i]. The argument holds [true] if the
      flag is present on the command line and [false] otherwise. *)

  val flag_all : info -> bool list t
  (** [flag_all] is like {!flag} except the flag may appear more than
      once. The argument holds a list that contains one [true] value per
      occurence of the flag. It holds the empty list if the flag
      is absent from the command line. *)

  val vflag : 'a -> ('a * info) list -> 'a t
  (** [vflag v \[v]{_0}[,i]{_0}[;...\]] is an ['a] argument defined
      by an optional flag that may appear {e at most} once on
      the command line under one of the names specified in the [i]{_k}
      values. The argument holds [v] if the flag is absent from the
      command line and the value [v]{_k} if the name under which it appears
      is in [i]{_k}.

      {b Note.} Environment variable lookup is unsupported for
      for these arguments. *)

  val vflag_all : 'a list -> ('a * info) list -> 'a list t
  (** [vflag_all v l] is like {!vflag} except the flag may appear more
      than once. The argument holds the list [v] if the flag is absent
      from the command line. Otherwise it holds a list that contains one
      corresponding value per occurence of the flag, in the order found on
      the command line.

      {b Note.} Environment variable lookup is unsupported for
      for these arguments. *)

  val opt : ?vopt:'a -> 'a converter -> 'a -> info -> 'a t
  (** [opt vopt c v i] is an ['a] argument defined by the value of
      an optional argument that may appear {e at most} once on the command
      line under one of the names specified by [i]. The argument holds
      [v] if the option is absent from the command line. Otherwise
      it has the value of the option as converted by [c].

      If [vopt] is provided the value of the optional argument is itself
      optional, taking the value [vopt] if unspecified on the command line. *)

  val opt_all : ?vopt:'a -> 'a converter -> 'a list -> info -> 'a list t
  (** [opt_all vopt c v i] is like {!opt} except the optional argument may
      appear more than once. The argument holds a list that contains one value
      per occurence of the flag in the order found on the command line.
      It holds the list [v] if the flag is absent from the command line. *)

  (** {1:posargs Positional arguments}

      The information of a positional argument must have no name
      or [Invalid_argument] is raised. Positional arguments indexing
      is zero-based. *)

  val pos : ?rev:bool -> int -> 'a converter -> 'a -> info -> 'a t
  (** [pos rev n c v i] is an ['a] argument defined by the [n]th
      positional argument of the command line as converted by [c].
      If the positional argument is absent from the command line
      the argument is [v].

      If [rev] is [true] (defaults to [false]), the computed
      position is [max-n] where [max] is the position of
      the last positional argument present on the command line. *)

  val pos_all : 'a converter -> 'a list -> info -> 'a list t
  (** [pos_all c v i] is an ['a list] argument that holds
      all the positional arguments of the command line as converted
      by [c] or [v] if there are none. *)

  val pos_left : ?rev:bool -> int -> 'a converter -> 'a list -> info ->
    'a list t
  (** [pos_left rev n c v i] is an ['a list] argument that holds
      all the positional arguments as converted by [c] found on the left
      of the [n]th positional argument or [v] if there are none.

      If [rev] is [true] (defaults to [false]), the computed
      position is [max-n] where [max] is the position of
      the last positional argument present on the command line. *)

  val pos_right : ?rev:bool -> int -> 'a converter -> 'a list -> info ->
    'a list t
  (** [pos_right] is like {!pos_left} except it holds all the positional
      arguments found on the right of the specified positional argument. *)

  (** {1:argterms Arguments as terms} *)

  val value : 'a t -> 'a Term.t
  (** [value a] is a term that evaluates to [a]'s value. *)

  val required : 'a option t -> 'a Term.t
  (** [required a] is a term that fails if [a]'s value is [None] and
      evaluates to the value of [Some] otherwise. Use this for required
      positional arguments (it can also be used for defining required
      optional arguments, but from a user interface perspective this
      shouldn't be done, it is a contradiction in terms). *)

  val non_empty : 'a list t -> 'a list Term.t
  (** [non_empty a] is term that fails if [a]'s list is empty and
      evaluates to [a]'s list otherwise. Use this for non empty lists
      of positional arguments. *)

  val last : 'a list t -> 'a Term.t
  (** [last a] is a term that fails if [a]'s list is empty and evaluates
      to the value of the last element of the list otherwise. Use this
      for lists of flags or options where the last occurence takes precedence
      over the others. *)

  (** {1:converters Predefined converters} *)

  val bool : bool converter
  (** [bool] converts values with {!bool_of_string}. *)

  val char : char converter
  (** [char] converts values by ensuring the argument has a single char. *)

  val int : int converter
  (** [int] converts values with {!int_of_string}. *)

  val nativeint : nativeint converter
  (** [nativeint] converts values with {!Nativeint.of_string}. *)

  val int32 : int32 converter
  (** [int32] converts values with {!Int32.of_string}. *)

  val int64 : int64 converter
  (** [int64] converts values with {!Int64.of_string}. *)

  val float : float converter
  (** [float] converts values with {!float_of_string}. *)

  val string : string converter
  (** [string] converts values with the identity function. *)

  val enum : (string * 'a) list -> 'a converter
  (** [enum l p] converts values such that unambiguous prefixes of string names
      in [l] map to the corresponding value of type ['a].

      {b Warning.} The type ['a] must be comparable with {!Pervasives.compare}.

      @raise Invalid_argument if [l] is empty. *)

  val file : string converter
  (** [file] converts a value with the identity function and
      checks with {!Sys.file_exists} that a file with that name exists. *)

  val dir : string converter
  (** [dir] converts a value with the identity function and checks
      with {!Sys.file_exists} and {!Sys.is_directory}
      that a directory with that name exists. *)

  val non_dir_file : string converter
  (** [non_dir_file] converts a value with the identity function and checks
      with {!Sys.file_exists} and {!Sys.is_directory}
      that a non directory file with that name exists. *)

  val list : ?sep:char -> 'a converter -> 'a list converter
  (** [list sep c] splits the argument at each [sep] (defaults to [','])
      character and converts each substrings with [c]. *)

  val array : ?sep:char -> 'a converter -> 'a array converter
  (** [array sep c] splits the argument at each [sep] (defaults to [','])
      character and converts each substring with [c]. *)

  val pair : ?sep:char -> 'a converter -> 'b converter -> ('a * 'b) converter
  (** [pair sep c0 c1] splits the argument at the {e first} [sep] character
      (defaults to [',']) and respectively converts the substrings with
      [c0] and [c1]. *)

  val t2 : ?sep:char -> 'a converter -> 'b converter -> ('a * 'b) converter
  (** {!t2} is {!pair}. *)

  val t3 : ?sep:char -> 'a converter ->'b converter -> 'c converter ->
    ('a * 'b * 'c) converter
  (** [t3 sep c0 c1 c2] splits the argument at the {e first} two [sep]
      characters (defaults to [',']) and respectively converts the
      substrings with [c0], [c1] and [c2]. *)

  val t4 : ?sep:char -> 'a converter ->'b converter -> 'c converter ->
    'd converter -> ('a * 'b * 'c * 'd) converter
  (** [t4 sep c0 c1 c2 c3] splits the argument at the {e first} three [sep]
      characters (defaults to [',']) respectively converts the substrings
      with [c0], [c1], [c2] and [c3]. *)

  (** {1:doc_helpers Documentation formatting helpers} *)

  val doc_quote : string -> string
  (** [doc_quote s] quotes the string [s]. *)

  val doc_alts : ?quoted:bool -> string list -> string
  (** [doc_alts alts] documents the alternative tokens [alts] according
      the number of alternatives. If [quoted] is [true] (default)
      the tokens are quoted. The resulting string can be used in
      sentences of the form ["$(docv) must be %s"].

      @raise Invalid_argument if [alts] is the empty string.  *)

  val doc_alts_enum : ?quoted:bool -> (string * 'a) list -> string
  (** [doc_alts_enum quoted alts] is [doc_alts quoted (List.map fst alts)]. *)
end

(**
    {1:basics Basics}

    With [Cmdliner] your program evaluates a term. A {e term}
    is a value of type {!Term.t}. The type parameter indicates
    the type of the result of the evaluation.

    One way to create terms is by lifting regular OCaml values with
    {!Term.const}. Terms can be applied to terms evaluating to
    functional values with {!Term.( $ )}. For example for the function:
{[let revolt () = print_endline "Revolt!"]}
    the term :
{[
open Cmdliner;;

let revolt_t = Term.(const revolt $ const ())]}
    is a term that evaluates to the result (and effect) of the [revolt]
    function.
    Terms are evaluated with {!Term.eval}:
{[let () = match Term.eval (revolt_t, Term.info "revolt") with
| `Error _ -> exit 1 | _ -> exit 0]}
    This defines a command line program named ["revolt"], without command line
    arguments arguments, that just prints ["Revolt!"] on [stdout].
{[> ./revolt
Revolt!]}
    The combinators in the {!Arg} module allow to extract command
    line argument data as terms. These terms can then be applied to
    lifted OCaml functions to be evaluated by the program.

    Terms corresponding to command line argument data that are part of
    a term evaluation implicitly define a command line syntax.  We
    show this on an concrete example.

    Consider the [chorus] function that prints repeatedly a
    given message :
{[let chorus count msg =
  for i = 1 to count do print_endline msg done]}
    we want to make it available from the command line
    with the synopsis:
{[chorus [-c COUNT | --count=COUNT] [MSG]]}
    where [COUNT] defaults to [10] and [MSG] defaults to ["Revolt!"].
    We first define a term corresponding to the [--count]
    option:
{[
let count =
  let doc = "Repeat the message $(docv) times." in
  Arg.(value & opt int 10 & info ["c"; "count"] ~docv:"COUNT" ~doc)
]}
    This says that [count] is a term that evaluates to the
    value of an optional argument of type [int] that
    defaults to [10] if unspecified and whose option name is
    either [-c] or [--count]. The arguments [doc] and [docv] are used to
    generate the option's man page information.

    The term for the positional argument [MSG] is:
{[
let msg =
  let doc = "Overrides the default message to print."
  let env = Arg.env "CHORUS_MSG" ~doc in
  let doc = "The message to print." in
  Arg.(value & pos 0 string "Revolt!" & info [] ~env ~docv:"MSG" ~doc)
]}
    which says that [msg] is a term whose value is the positional
    argument at index [0] of type [string] and defaults to ["Revolt!"]
    or the value of the environment variable [CHORUS_MSG] if the
    argument is unspecified on the command line. Here again [doc] and
    [docv] are used for the man page information.

    The term for executing [chorus] with these command line arguments
    is :
{[
let chorus_t = Term.(const chorus $ count $ msg)
]}
    and we are now ready to define our program:
{[
let info =
  let doc = "print a customizable message repeatedly" in
  let man = [ `S "BUGS"; `P "Email bug reports to <hehey at example.org>.";] in
  Term.info "chorus" ~version:"1.6.1" ~doc ~man

let () = match Term.eval (chorus_t, info) with `Error _ -> exit 1 | _ -> exit 0
]}
    The [info] value created with {!Term.info} gives more information
    about the term we execute and is used to generate the program's
    man page. Since we provided a [~version] string, the program will
    automatically respond to the [--version] option by printing this
    string.

    A program using {!Term.eval} always responds to the
    [--help] option by showing the man page about the program generated
    using the information you provided with {!Term.info} and {!Arg.info}.
    Here is the output generated by our example :
{v > ./chorus --help
NAME
       chorus - print a customizable message repeatedly

SYNOPSIS
       chorus [OPTION]... [MSG]

ARGUMENTS
       MSG (absent=Revolt! or CHORUS_MSG env)
           The message to print.

OPTIONS
       -c COUNT, --count=COUNT (absent=10)
           Repeat the message COUNT times.

       --help[=FMT] (default=pager)
           Show this help in format FMT (pager, plain or groff).

       --version
           Show version information.

BUGS
       Email bug reports to <hehey at example.org>.
v}

    If a pager is available, this output is written to a pager.
    This help is also available in plain text or in the
    {{:http://www.gnu.org/software/groff/groff.html}groff} man page format by
    invoking the program with the option [--help=plain] or [--help=groff].

    For examples of more complex command line definitions look and
    run the {{!examples}examples}.

    {2:multiterms Multiple terms}

    [Cmdliner] also provides support for programs like [darcs] or
    [git] that have multiple commands each with their own syntax:
    {[prog COMMAND [OPTION]... ARG...]}
    A command is defined by coupling a term with
    {{!Term.tinfo}term information}. The term information defines the
    command name and its man page. Given a list of commands the function
    {!Term.eval_choice} will execute the term corresponding to the
    [COMMAND] argument or or a specific "main" term if there is
    no [COMMAND] argument.

    {2:manual Manual}

    Man page sections are printed in the order specified by
    {!Term.info}. The man page information of an argument is listed in
    alphabetical order at the end of the text of the section specified
    by its {{!Arg.info}argument information}. Positional arguments are
    also listed iff both the [docv] and [doc] string is specified in
    their argument information.

    If an argument information mentions a section not specified in
    {!Term.info}, an empty section is created for it. This section is
    inserted just after the ["SYNOPSIS"] section or after a section
    named ["DESCRIPTION"] if there is one.

    The ["SYNOPSIS"] section of a man page is generated automatically
    from a term's information and its arguments. To substitute your
    own instead, start the term's information man page with
    a ["SYNOPSIS"] section.

    Ideally all manual strings should be UTF-8 encoded. However at the
    moment Groff (at least [1.19.2]) doesn't seem to cope with UTF-8
    input and UTF-8 characters beyond the ASCII set will look garbled.
    Regarding UTF-8 output, generating the man page with [-Tutf8] maps
    the hyphen-minus [U+002D] to the minus sign [U+2212] which makes it
    difficult to search it in the pager, so [-Tascii] is used for now.
    Conclusion is that it may be better to stick to the ASCII set for now.
    Please contact the author if something seems wrong in this reasoning
    or if you know a work around this.

    {2:misc Miscellaneous}

    {ul
    {- The option name [--help], (and [--version] if you specify a
       version string) is reserved by the module. Using it as a term or
       option name may result in undefined behaviour.}
    {- The evaluation of a term in which the same option name is defined
       by more than one argument is undefined.}}

    {1:cmdline Command line syntax}

    For programs evaluating a single term the most general form of invocation
    is:
    {ul{- [prog [OPTION]... [ARG]...]}}
    The program automatically reponds to the [--help] option by
    printing the help. If a version string is provided in
    the {{!Term.tinfo}term information}, it also automatically responds
    to the [--version] option by printing this string.

    Command line arguments are either {{!optargs}{e optional}} or
    {{!posargs}{e positional}}. Both can be freely interleaved but
    since [Cmdliner] accepts many optional forms this may result in
    ambiguities. The special {{!posargs} token [--]} can be used to resolve
    them.

    Programs evaluating multiple terms also add this form of invocation:
    {ul{- [prog COMMAND [OPTION]... [ARG]...]}}
    Commands automatically respond to the [--help] option
    by printing their help. The [COMMAND] string must
    be the first string following the program name and may be specified
    by a prefix as long as it is not ambiguous.

    {2:optargs Optional arguments}

    An optional argument is specified on the command line by a {e
    name} possibly followed by a {e value}.

    The name of an option can be short or long.
    {ul
    {- A {e short} name is a dash followed by a single alphanumeric
       character: ["-h"], ["-q"], ["-I"].}
    {- A {e long} name is two dashes followed by alphanumeric
       characters and dashes: ["--help"], ["--silent"], ["--ignore-case"].}}

    More than one name may refer to the same optional argument.  For
    example in a given program the names ["-q"], ["--quiet"] and
    ["--silent"] may all stand for the same boolean argument
    indicating the program to be quiet.  Long names
    can be specified by any non ambiguous prefix.

    The value of an option can be specified in three different ways.
    {ul
    {- As the next token on the command line: ["-o a.out"],
       ["--output a.out"].}
    {- Glued to a short name: ["-oa.out"].}
    {- Glued to a long name after an equal character:
    ["--output=a.out"].}}
    Glued forms are especially useful if
    the value itself starts with a dash as is the case for negative numbers,
    ["--min=-10"].

    An optional argument without a value is either a {e flag}
    (see {!Arg.flag}, {!Arg.vflag}) or an optional argument with an optional
    value (see the [~vopt] argument of {!Arg.opt}).

    Short flags can be grouped together to share a single dash and the group
    can end with a short option. For example assuming ["-v"] and ["-x"]
    are flags and ["-f"] is a short option:
    {ul
      {- ["-vx"] will be parsed as ["-v -x"].}
      {- ["-vxfopt"] will be parsed as ["-v -x -fopt"].}
      {- ["-vxf opt"] will be parsed as ["-v -x -fopt"].}
      {- ["-fvx"] will be parsed as ["-f=vx"].}}

    {2:posargs Positional arguments}

    Positional arguments are tokens on the command line that are not
    option names and are not the value of an optional argument. They
    are numbered from left to right starting with zero.

    Since positional arguments may be mistaken as the optional value
    of an optional argument or they may need to look like option
    names, anything that follows the special token ["--"] on the command
    line is considered to be a positional argument.

    {2:envlookup Environment variables}

    Non-required command line arguments can be backed up by an environment
    variable.  If the argument is absent from the command line and
    that the environment variable is defined, its value is parsed
    using the argument converter and defines the value of the
    argument.

    For {!Arg.flag} and {!Arg.flag_all} that do not have an argument
    converter a boolean is parsed from the lowercased variable value
    as follows:
    {ul
    {- [""], ["false"], ["no"], ["n"] or ["0"] is [false].}
    {- ["true"], ["yes"], ["y"] or ["1"] is [true].}
    {- Any other string is an error.}}

    Note that environment variables are not supported for {!Arg.vflag}
    and {!Arg.vflag_all}.

    {1:examples Examples}

    These examples are in the [test] directory of the distribution.

 {2:exrm A [rm] command}

    We define the command line interface of a
    [rm] command with the synopsis:
{[
rm [OPTION]... FILE...
]}
    The [-f], [-i] and [-I] flags define the prompt behaviour of [rm],
    represented in our program by the [prompt] type. If more than one
    of these flags is present on the command line the last one takes
    precedence.

    To implement this behaviour we map the presence of these flags
    to values of the [prompt] type by using {!Arg.vflag_all}.  This
    argument will contain all occurences of the flag on the command
    line and we just take the {!Arg.last} one to define our term value
    (if there's no occurence the last value of the default list [[Always]] is
    taken, i.e. the default is [Always]).
{[
(* Implementation of the command, we just print the args. *)

type prompt = Always | Once | Never
let prompt_str = function
| Always -> "always" | Once -> "once" | Never -> "never"

let rm prompt recurse files =
  Printf.printf "prompt = %s\nrecurse = %b\nfiles = %s\n"
    (prompt_str prompt) recurse (String.concat ", " files)

(* Command line interface *)

open Cmdliner;;

let files = Arg.(non_empty & pos_all file [] & info [] ~docv:"FILE")
let prompt =
  let doc = "Prompt before every removal." in
  let always = Always, Arg.info ["i"] ~doc in
  let doc = "Ignore nonexistent files and never prompt." in
  let never = Never, Arg.info ["f"; "force"] ~doc in
  let doc = "Prompt once before removing more than three files, or when
             removing recursively. Less intrusive than $(b,-i), while
             still giving protection against most mistakes."
  in
  let once = Once, Arg.info ["I"] ~doc in
  Arg.(last & vflag_all [Always] [always; never; once])

let recursive =
  let doc = "Remove directories and their contents recursively." in
  Arg.(value & flag & info ["r"; "R"; "recursive"] ~doc)

let cmd =
  let doc = "remove files or directories" in
  let man = [
    `S "DESCRIPTION";
    `P "$(tname) removes each specified $(i,FILE). By default it does not
        remove directories, to also remove them and their contents, use the
        option $(b,--recursive) ($(b,-r) or $(b,-R)).";
    `P "To remove a file whose name starts with a `-', for example
        `-foo', use one of these commands:";
    `P "rm -- -foo"; `Noblank;
    `P "rm ./-foo";
    `P "$(tname) removes symbolic links, not the files referenced by the
        links.";
    `S "BUGS"; `P "Report bugs to <hehey at example.org>.";
    `S "SEE ALSO"; `P "$(b,rmdir)(1), $(b,unlink)(2)" ]
  in
  Term.(const rm $ prompt $ recursive $ files),
  Term.info "rm" ~version:"1.6.1" ~doc ~man

let () = match Term.eval cmd with `Error _ -> exit 1 | _ -> exit 0
]}
    {2:excp A [cp] command}

    We define the command line interface of a
    [cp] command with the synopsis:
{[cp [OPTION]... SOURCE... DEST ]}
    The [DEST] argument must be a directory if there is more than
    one [SOURCE]. This constraint is too complex to be expressed by the
    combinators of {!Arg}. Hence we just give it the {!Arg.string} type
    and verify the constraint at the beginning of the [cp]
    implementation. If unsatisfied we return an [`Error] and
    by using {!Term.ret} on the lifted result [cp_t] of [cp],
    [Cmdliner] handles the error reporting.
{[
(* Implementation, we check the dest argument and print the args *)

let cp verbose recurse force srcs dest =
  if List.length srcs > 1 &&
  (not (Sys.file_exists dest) || not (Sys.is_directory dest))
  then
    `Error (false, dest ^ " is not a directory")
  else
    `Ok (Printf.printf
     "verbose = %b\nrecurse = %b\nforce = %b\nsrcs = %s\ndest = %s\n"
      verbose recurse force (String.concat ", " srcs) dest)

(* Command line interface *)

open Cmdliner;;

let verbose =
  let doc = "Print file names as they are copied." in
  Arg.(value & flag & info ["v"; "verbose"] ~doc)

let recurse =
  let doc = "Copy directories recursively." in
  Arg.(value & flag & info ["r"; "R"; "recursive"] ~doc)

let force =
  let doc = "If a destination file cannot be opened, remove it and try again."in
  Arg.(value & flag & info ["f"; "force"] ~doc)

let srcs =
  let doc = "Source file(s) to copy." in
  Arg.(non_empty & pos_left ~rev:true 0 file [] & info [] ~docv:"SOURCE" ~doc)

let dest =
  let doc = "Destination of the copy. Must be a directory if there is more
             than one $(i,SOURCE)." in
  Arg.(required & pos ~rev:true 0 (some string) None & info [] ~docv:"DEST"
         ~doc)

let cmd =
  let doc = "copy files" in
  let man = [
    `S "BUGS";
    `P "Email them to <hehey at example.org>.";
    `S "SEE ALSO";
    `P "$(b,mv)(1), $(b,scp)(1), $(b,umask)(2), $(b,symlink)(7)" ]
  in
  Term.(ret (const cp $ verbose $ recurse $ force $ srcs $ dest)),
  Term.info "cp" ~version:"1.6.1" ~doc ~man

let () = match Term.eval cmd with `Error _ -> exit 1 | _ -> exit 0
]}

{2:extail A [tail] command}

We define the command line interface of a [tail] command with the
synopsis:
{[tail [OPTION]... [FILE]...]}

The [--lines] option whose value specifies the number of last lines to
print has a special syntax where a [+] prefix indicates to start
printing from that line number. In the program this is represented by
the [loc] type. We define a custom [loc] {{!Arg.argconv}argument converter}
for this option.

The [--follow] option has an optional enumerated value. The argument
converter [follow], created with {!Arg.enum} parses the option value
into the enumeration. By using {!Arg.some} and the [~vopt] argument of
{!Arg.opt}, the term corresponding to the option [--follow] evaluates to
[None] if [--follow] is absent from the command line, to [Some Descriptor]
if present but without a value and to [Some v] if present with a value
[v] specified.

{[
(* Implementation of the command, we just print the args. *)

type loc = bool * int
type verb = Verbose | Quiet
type follow = Name | Descriptor

let str = Printf.sprintf
let opt_str sv = function None -> "None" | Some v -> str "Some(%s)" (sv v)
let loc_str (rev, k) = if rev then str "%d" k else str "+%d" k
let follow_str = function Name -> "name" | Descriptor -> "descriptor"
let verb_str = function Verbose -> "verbose" | Quiet -> "quiet"

let tail lines follow verb pid files =
  Printf.printf "lines = %s\nfollow = %s\nverb = %s\npid = %s\nfiles = %s\n"
    (loc_str lines) (opt_str follow_str follow) (verb_str verb)
    (opt_str string_of_int pid) (String.concat ", " files)

(* Command line interface *)

open Cmdliner;;

let lines =
  let loc =
    let parse s = try
      if s <> "" && s.[0] <> '+' then `Ok (true, int_of_string s) else
      `Ok (false, int_of_string (String.sub s 1 (String.length s - 1)))
    with Failure _ -> `Error "unable to parse integer"
    in
    parse, fun ppf p -> Format.fprintf ppf "%s" (loc_str p)
  in
  Arg.(value & opt loc (true, 10) & info ["n"; "lines"] ~docv:"N"
   ~doc:"Output the last $(docv) lines or use $(i,+)$(docv) to start
         output after the $(i,N)-1th line.")
let follow =
  let doc = "Output appended data as the file grows. $(docv) specifies how the
             file should be tracked, by its `name' or by its `descriptor'." in
  let follow = Arg.enum ["name", Name; "descriptor", Descriptor] in
  Arg.(value & opt (some follow) ~vopt:(Some Descriptor) None &
       info ["f"; "follow"] ~docv:"ID" ~doc)

let verb =
  let doc = "Never output headers giving file names." in
  let quiet = Quiet, Arg.info ["q"; "quiet"; "silent"] ~doc in
  let doc = "Always output headers giving file names." in
  let verbose = Verbose, Arg.info ["v"; "verbose"] ~doc in
  Arg.(last & vflag_all [Quiet] [quiet; verbose])

let pid =
  let doc = "With -f, terminate after process $(docv) dies." in
  Arg.(value & opt (some int) None & info ["pid"] ~docv:"PID" ~doc)

let files = Arg.(value & (pos_all non_dir_file []) & info [] ~docv:"FILE")

let cmd =
  let doc = "display the last part of a file" in
  let man = [
    `S "DESCRIPTION";
    `P "$(tname) prints the last lines of each $(i,FILE) to standard output. If
        no file is specified reads standard input. The number of printed
        lines can be  specified with the $(b,-n) option.";
    `S "BUGS";
    `P "Report them to <hehey at example.org>.";
    `S "SEE ALSO";
    `P "$(b,cat)(1), $(b,head)(1)" ]
  in
  Term.(const tail $ lines $ follow $ verb $ pid $ files),
  Term.info "tail" ~version:"1.6.1" ~doc ~man

let () = match Term.eval cmd with `Error _ -> exit 1 | _ -> exit 0
]}

{2:exdarcs A [darcs] command}

We define the command line interface of a [darcs] command with the synopsis:
{[darcs [COMMAND] ...]}

The [--debug], [-q], [-v] and [--prehook] options are available in
each command.  To avoid having to pass them individually to each
command we gather them in a record of type [copts]. By lifting the
record constructor [copts] into the term [copts_t] we now have a term
that we can pass to the commands to stand for an argument of type
[copts]. These options are documented in a section called [COMMON
OPTIONS], since we also want to put [--help] and [--version] in this
section, the term information of commands makes a judicious use of the
[sdocs] parameter of {!Term.info}.

The [help] command shows help about commands or other topics. The help
shown for commands is generated by [Cmdliner] by making an approriate
use of {!Term.ret} on the lifted [help] function.

If the program is invoked without a command we just want to show the
help of the program as printed by [Cmdliner] with [--help]. This is
done by the [no_cmd] term.

{[
(* Implementations, just print the args. *)

type verb = Normal | Quiet | Verbose
type copts = { debug : bool; verb : verb; prehook : string option }

let str = Printf.sprintf
let opt_str sv = function None -> "None" | Some v -> str "Some(%s)" (sv v)
let opt_str_str = opt_str (fun s -> s)
let verb_str = function
  | Normal -> "normal" | Quiet -> "quiet" | Verbose -> "verbose"

let pr_copts oc copts = Printf.fprintf oc
    "debug = %b\nverbosity = %s\nprehook = %s\n"
    copts.debug (verb_str copts.verb) (opt_str_str copts.prehook)

let initialize copts repodir = Printf.printf
    "%arepodir = %s\n" pr_copts copts repodir

let record copts name email all ask_deps files = Printf.printf
    "%aname = %s\nemail = %s\nall = %b\nask-deps = %b\nfiles = %s\n"
    pr_copts copts (opt_str_str name) (opt_str_str email) all ask_deps
    (String.concat ", " files)

let help copts man_format cmds topic = match topic with
| None -> `Help (`Pager, None) (* help about the program. *)
| Some topic ->
    let topics = "topics" :: "patterns" :: "environment" :: cmds in
    let conv, _ = Cmdliner.Arg.enum (List.rev_map (fun s -> (s, s)) topics) in
    match conv topic with
    | `Error e -> `Error (false, e)
    | `Ok t when t = "topics" -> List.iter print_endline topics; `Ok ()
    | `Ok t when List.mem t cmds -> `Help (man_format, Some t)
    | `Ok t ->
        let page = (topic, 7, "", "", ""), [`S topic; `P "Say something";] in
        `Ok (Cmdliner.Manpage.print man_format Format.std_formatter page)

open Cmdliner;;

(* Help sections common to all commands *)

let copts_sect = "COMMON OPTIONS"
let help_secs = [
 `S copts_sect;
 `P "These options are common to all commands.";
 `S "MORE HELP";
 `P "Use `$(mname) $(i,COMMAND) --help' for help on a single command.";`Noblank;
 `P "Use `$(mname) help patterns' for help on patch matching."; `Noblank;
 `P "Use `$(mname) help environment' for help on environment variables.";
 `S "BUGS"; `P "Check bug reports at http://bugs.example.org.";]

(* Options common to all commands *)

let copts debug verb prehook = { debug; verb; prehook }
let copts_t =
  let docs = copts_sect in
  let debug =
    let doc = "Give only debug output." in
    Arg.(value & flag & info ["debug"] ~docs ~doc)
  in
  let verb =
    let doc = "Suppress informational output." in
    let quiet = Quiet, Arg.info ["q"; "quiet"] ~docs ~doc in
    let doc = "Give verbose output." in
    let verbose = Verbose, Arg.info ["v"; "verbose"] ~docs ~doc in
    Arg.(last & vflag_all [Normal] [quiet; verbose])
  in
  let prehook =
    let doc = "Specify command to run before this $(mname) command." in
    Arg.(value & opt (some string) None & info ["prehook"] ~docs ~doc)
  in
  Term.(const copts $ debug $ verb $ prehook)

(* Commands *)

let initialize_cmd =
  let repodir =
    let doc = "Run the program in repository directory $(docv)." in
    Arg.(value & opt file Filename.current_dir_name & info ["repodir"]
           ~docv:"DIR" ~doc)
  in
  let doc = "make the current directory a repository" in
  let man = [
    `S "DESCRIPTION";
    `P "Turns the current directory into a Darcs repository. Any
       existing files and subdirectories become ..."] @ help_secs
  in
  Term.(const initialize $ copts_t $ repodir),
  Term.info "initialize" ~sdocs:copts_sect ~doc ~man

let record_cmd =
  let pname =
    let doc = "Name of the patch." in
    Arg.(value & opt (some string) None & info ["m"; "patch-name"] ~docv:"NAME"
         ~doc)
  in
  let author =
    let doc = "Specifies the author's identity." in
    Arg.(value & opt (some string) None & info ["A"; "author"] ~docv:"EMAIL"
         ~doc)
  in
  let all =
    let doc = "Answer yes to all patches." in
    Arg.(value & flag & info ["a"; "all"] ~doc)
  in
  let ask_deps =
    let doc = "Ask for extra dependencies." in
    Arg.(value & flag & info ["ask-deps"] ~doc)
  in
  let files = Arg.(value & (pos_all file) [] & info [] ~docv:"FILE or DIR") in
  let doc = "create a patch from unrecorded changes" in
  let man =
    [`S "DESCRIPTION";
     `P "Creates a patch from changes in the working tree. If you specify
      a set of files ..."] @ help_secs
  in
  Term.(const record $ copts_t $ pname $ author $ all $ ask_deps $ files),
  Term.info "record" ~doc ~sdocs:copts_sect ~man

let help_cmd =
  let topic =
    let doc = "The topic to get help on. `topics' lists the topics." in
    Arg.(value & pos 0 (some string) None & info [] ~docv:"TOPIC" ~doc)
  in
  let doc = "display help about darcs and darcs commands" in
  let man =
    [`S "DESCRIPTION";
     `P "Prints help about darcs commands and other subjects..."] @ help_secs
  in
  Term.(ret
          (const help $ copts_t $ Term.man_format $ Term.choice_names $topic)),
  Term.info "help" ~doc ~man

let default_cmd =
  let doc = "a revision control system" in
  let man = help_secs in
  Term.(ret (const (fun _ -> `Help (`Pager, None)) $ copts_t)),
  Term.info "darcs" ~version:"1.6.1" ~sdocs:copts_sect ~doc ~man

let cmds = [initialize_cmd; record_cmd; help_cmd]

let () = match Term.eval_choice default_cmd cmds with
| `Error _ -> exit 1 | _ -> exit 0
]}
*)

(*---------------------------------------------------------------------------
   Copyright (c) 2011 Daniel C. Bünzli
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

   3. Neither the name of Daniel C. Bünzli nor the names of
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  ---------------------------------------------------------------------------*)

end = struct
#1 "cmdliner.ml"
(*---------------------------------------------------------------------------
   Copyright (c) 2011 Daniel C. Bünzli. All rights reserved.
   Distributed under a BSD3 license, see license at the end of the file.
   cmdliner release 0.9.8
  ---------------------------------------------------------------------------*)

let str = Printf.sprintf

(* Invalid_arg strings *)

let err_argv = "argv array must have at least one element"
let err_not_opt = "Option argument without name"
let err_not_pos = "Positional argument with a name"
let err_help s = "Term error, help requested for unknown command " ^ s
let err_empty_list = "Empty list"
let err_incomplete_enum = "Incomplete enumeration for the type"
let err_doc_string s =
  str "Variable substitution failed on documentation fragment `%s'" s

(* A few useful definitions. *)

let rev_compare n n' = compare n' n
let pr = Format.fprintf
let pr_str = Format.pp_print_string
let pr_char = Format.pp_print_char
let str_of_pp pp v = pp Format.str_formatter v; Format.flush_str_formatter ()
let quote s = str "`%s'" s
let alts_str ?(quoted = true) alts =
  let quote = if quoted then quote else (fun s -> s) in
  match alts with
  | [] -> invalid_arg err_empty_list
  | [a] -> (quote a)
  | [a; b] -> str "either %s or %s" (quote a) (quote b)
  | alts ->
      let rev_alts = List.rev alts in
      str "one of %s or %s"
        (String.concat ", " (List.rev_map quote (List.tl rev_alts)))
        (quote (List.hd rev_alts))

let pr_white_str spaces ppf s =  (* spaces and new lines with Format's funs *)
  let left = ref 0 and right = ref 0 and len = String.length s in
  let flush () =
    Format.pp_print_string ppf (String.sub s !left (!right - !left));
    incr right; left := !right;
  in
  while (!right <> len) do
    if s.[!right] = '\n' then (flush (); Format.pp_force_newline ppf ()) else
    if spaces && s.[!right] = ' ' then (flush (); Format.pp_print_space ppf ())
    else incr right;
  done;
  if !left <> len then flush ()

let pr_text = pr_white_str true
let pr_lines = pr_white_str false
let pr_to_temp_file pr v = try
  let exec = Filename.basename Sys.argv.(0) in
  let file, oc = Filename.open_temp_file exec "out" in
  let ppf = Format.formatter_of_out_channel oc in
  pr ppf v; Format.pp_print_flush ppf (); close_out oc;
  at_exit (fun () -> try Sys.remove file with Sys_error e -> ());
  Some file
with Sys_error _ -> None

(* Levenshtein distance, for making spelling suggestions in case of error. *)

let levenshtein_distance s t =
  (* As found here http://rosettacode.org/wiki/Levenshtein_distance#OCaml *)
  let minimum a b c = min a (min b c) in
  let m = String.length s in
  let n = String.length t in
  (* for all i and j, d.(i).(j) will hold the Levenshtein distance between
     the first i characters of s and the first j characters of t *)
  let d = Array.make_matrix (m+1) (n+1) 0 in
  for i = 0 to m do d.(i).(0) <- i done;
  for j = 0 to n do d.(0).(j) <- j done;
  for j = 1 to n do
    for i = 1 to m do
      if s.[i-1] = t.[j-1] then
        d.(i).(j) <- d.(i-1).(j-1)  (* no operation required *)
      else
        d.(i).(j) <- minimum
            (d.(i-1).(j) + 1)   (* a deletion *)
            (d.(i).(j-1) + 1)   (* an insertion *)
            (d.(i-1).(j-1) + 1) (* a substitution *)
    done;
  done;
  d.(m).(n)

let suggest s candidates =
  let add (min, acc) name =
    let d = levenshtein_distance s name in
    if d = min then min, (name :: acc) else
    if d < min then d, [name] else
    min, acc
  in
  let dist, suggs = List.fold_left add (max_int, []) candidates in
  if dist < 3 (* suggest only if not too far *) then suggs else []

(* Tries. This implementation also maps any non ambiguous prefix of a
   key to its value. *)

module Trie : sig
  type 'a t
  val empty : 'a t
  val is_empty : 'a t -> bool
  val add : 'a t -> string -> 'a -> 'a t
  val find : 'a t -> string -> [ `Ok of 'a | `Ambiguous | `Not_found ]
  val ambiguities : 'a t -> string -> string list
  val of_list : (string * 'a) list -> 'a t
end = struct
  module Cmap = Map.Make (Char)                           (* character maps. *)
  type 'a value =                         (* type for holding a bound value. *)
    | Pre of 'a                    (* value is bound by the prefix of a key. *)
    | Key of 'a                          (* value is bound by an entire key. *)
    | Amb                     (* no value bound because of ambiguous prefix. *)
    | Nil                            (* not bound (only for the empty trie). *)

  type 'a t = { v : 'a value; succs : 'a t Cmap.t }
  let empty = { v = Nil; succs = Cmap.empty }
  let is_empty t = t = empty

  (* N.B. If we replace a non-ambiguous key, it becomes ambiguous but it's
     not important for our use. Also the following is not tail recursive but
     the stack is bounded by key length. *)
  let add t k d =
    let rec aux t k len i d pre_d =
      if i = len then { v = Key d; succs = t.succs } else
      let v = match t.v with
      | Amb | Pre _ -> Amb | Key _ as v -> v | Nil -> pre_d
      in
      let succs =
        let t' = try Cmap.find k.[i] t.succs with Not_found -> empty in
        Cmap.add k.[i] (aux t' k len (i + 1) d pre_d) t.succs
      in
      { v; succs }
    in
    aux t k (String.length k) 0 d (Pre d (* allocate less *))

  let find_node t k =
    let rec aux t k len i =
      if i = len then t else
      aux (Cmap.find k.[i] t.succs) k len (i + 1)
    in
    aux t k (String.length k) 0

  let find t k =
    try match (find_node t k).v with
    | Key v | Pre v -> `Ok v | Amb -> `Ambiguous | Nil -> `Not_found
    with Not_found -> `Not_found

  let ambiguities t p =                        (* ambiguities of [p] in [t]. *)
    try
      let t = find_node t p in
      match t.v with
      | Key _ | Pre _ | Nil -> []
      | Amb ->
          let add_char s c = s ^ (String.make 1 c) in
          let rem_char s = String.sub s 0 ((String.length s) - 1) in
          let to_list m = Cmap.fold (fun k t acc -> (k,t) :: acc) m [] in
          let rec aux acc p = function
          | ((c, t) :: succs) :: rest ->
              let p' = add_char p c in
              let acc' = match t.v with
              | Pre _ | Amb -> acc
              | Key _ -> (p' :: acc)
              | Nil -> assert false
              in
              aux acc' p' ((to_list t.succs) :: succs :: rest)
          | [] :: [] -> acc
          | [] :: rest -> aux acc (rem_char p) rest
          | [] -> assert false
          in
          aux [] p (to_list t.succs :: [])
    with Not_found -> []

  let of_list l = List.fold_left (fun t (s, v) -> add t s v) empty l
end

(* The following types keep untyped information about arguments and
   terms. This data is used to parse the command line, report errors
   and format man page information. *)

type env_info =                (* information about an environment variable. *)
  { env_var : string;                                       (* the variable. *)
    env_doc : string;                                               (* help. *)
    env_docs : string; }              (* title of help section where listed. *)

type absence =        (* what happens if the argument is absent from the cl. *)
  | Error                                           (* an error is reported. *)
  | Val of string Lazy.t         (* if <> "", takes the given default value. *)

type opt_kind =                              (* kinds of optional arguments. *)
  | Flag                                      (* just a flag, without value. *)
  | Opt                                                (* value is required. *)
  | Opt_vopt of string     (* option value is optional, takes given default. *)

type pos_kind =                            (* kinds of positional arguments. *)
  | All                                         (* all positional arguments. *)
  | Nth of bool * int                                  (* specific position. *)
  | Left of bool * int                (* all args on the left of a position. *)
  | Right of bool * int              (* all args on the right of a position. *)

type arg_info =                (* information about a command line argument. *)
  { id : int;                               (* unique id for the argument. *)
    absent : absence;                              (* behaviour if absent. *)
    env_info : env_info option;                   (* environment variable. *)
    doc : string;                                                 (* help. *)
    docv : string;              (* variable name for the argument in help. *)
    docs : string;                  (* title of help section where listed. *)
    p_kind : pos_kind;                             (* positional arg kind. *)
    o_kind : opt_kind;                               (* optional arg kind. *)
    o_names : string list;                        (* names (for opt args). *)
    o_all : bool; }                          (* repeatable (for opt args). *)

let arg_id =        (* thread-safe UIDs, Oo.id (object end) was used before. *)
  let c = ref 0 in
  fun () ->
    let id = !c in
    incr c; if id > !c then assert false (* too many ids *) else id

let is_opt a = a.o_names <> []
let is_pos a = a.o_names = []

module Amap = Map.Make                                     (* arg info maps. *)
    (struct type t = arg_info let compare a a' = compare a.id a'.id end)

type arg =        (* unconverted argument data as found on the command line. *)
  | O of (int * string * (string option)) list (* (pos, name, value) of opt. *)
  | P of string list

type cmdline = arg Amap.t      (* command line, maps arg_infos to arg value. *)

type man_block = [                                 (* block of manpage text. *)
  | `S of string | `P of string | `Pre of string | `I of string * string
  | `Noblank ]

type term_info =
  { name : string;                                    (* name of the term. *)
    version : string option;                   (* version (for --version). *)
    tdoc : string;                        (* one line description of term. *)
    tdocs : string;       (* title of man section where listed (commands). *)
    sdocs : string;    (* standard options, title of section where listed. *)
    man : man_block list; }                              (* man page text. *)

type eval_info =                 (* informatin about the evaluation context. *)
  { term : term_info * arg_info list;               (* term being evaluated. *)
    main : term_info * arg_info list;                          (* main term. *)
    choices : (term_info * arg_info list) list;         (* all term choices. *)
    env : string -> string option }          (* environment variable lookup. *)

let eval_kind ei =                       (* evaluation with multiple terms ? *)
  if ei.choices = [] then `Simple else
  if (fst ei.term) == (fst ei.main) then `M_main else `M_choice

module Manpage = struct
  type title = string * int * string * string * string
  type block = man_block
  type t = title * block list

  let p_indent = 7                                  (* paragraph indentation. *)
  let l_indent = 4                                      (* label indentation. *)
  let escape subst esc buf s =
    let subst s =
      let len = String.length s in
      if not (len > 1 && s.[1] = ',') then (subst s) else
      if len = 2 then "" else
      esc s.[0] (String.sub s 2 (len - 2))
    in
    try
      Buffer.clear buf; Buffer.add_substitute buf subst s;
      let s = Buffer.contents buf in (* twice for $(i,$(mname)). *)
      Buffer.clear buf; Buffer.add_substitute buf subst s;
      Buffer.contents buf
    with Not_found -> invalid_arg (err_doc_string s)

  let pr_tokens ?(groff = false) ppf s =
    let is_space = function ' ' | '\n' | '\r' | '\t' -> true | _ -> false in
    let len = String.length s in
    let i = ref 0 in
    try while (true) do
        while (!i < len && is_space s.[!i]) do incr i done;
        let start = !i in
        if start = len then raise Exit;
        while (!i < len && not (is_space s.[!i]) && not (s.[!i] = '-')) do
          incr i
        done;
        pr_str ppf (String.sub s start (!i - start));
        if !i = len then raise Exit;
        if s.[!i] = '-' then
          (incr i; if groff then pr_str ppf "\\-" else pr_char ppf '-');
        if (!i < len && is_space s.[!i]) then
          (if groff then pr_char ppf ' ' else Format.pp_print_space ppf ())
      done with Exit -> ()

  (* Plain text output *)

  let plain_esc c s = match c with 'g' -> "" (* groff specific *) | _ ->  s
  let pr_indent ppf c = for i = 1 to c do pr_char ppf ' ' done
  let pr_plain_blocks subst ppf ts =
    let buf = Buffer.create 1024 in
    let escape t = escape subst plain_esc buf t in
    let pr_tokens ppf t = pr_tokens ppf (escape t) in
    let rec aux = function
    | [] -> ()
    | t :: ts ->
        begin match t with
        | `Noblank -> ()
        | `P s -> pr ppf "%a@[%a@]@," pr_indent p_indent pr_tokens s
        | `S s -> pr ppf "@[%a@]" pr_tokens s
        | `Pre s -> pr ppf "%a@[%a@]@," pr_indent p_indent pr_lines (escape s)
        | `I (label, s) ->
            let label = escape label in
            let ll = String.length label in
            pr ppf "@[%a@[%a@]" pr_indent p_indent pr_tokens label;
            if s = "" then () else
            if ll < l_indent then
              pr ppf "%a@[%a@]@]@," pr_indent (l_indent - ll) pr_tokens s
            else
            pr ppf "@\n%a@[%a@]@]@,"
              pr_indent (p_indent + l_indent) pr_tokens s
        end;
        begin match ts with
        | `Noblank :: ts -> aux ts
        | ts -> Format.pp_print_cut ppf (); aux ts
        end
    in
    aux ts

  let pr_plain_page subst ppf (_, text) =
    pr ppf "@[<v>%a@]" (pr_plain_blocks subst) text

  (* Groff output *)

  let groff_esc c s = match c with
  | 'i' -> (str "\\fI%s\\fR" s)
  | 'b' -> (str "\\fB%s\\fR" s)
  | 'p' -> "" (* plain text specific *)
  | _ -> s

  let pr_groff_lines ppf s =
    let left = ref 0 and right = ref 0 and len = String.length s in
    let flush () =
      Format.pp_print_string ppf (String.sub s !left (!right - !left));
      incr right; left := !right;
    in
    while (!right <> len) do
      if s.[!right] = '\n' then (flush (); Format.pp_force_newline ppf ()) else
      if s.[!right] = '-' then (flush (); pr_str ppf "\\-") else
      incr right;
    done;
    if !left <> len then flush ()

  let pr_groff_blocks subst ppf text =
    let buf = Buffer.create 1024 in
    let escape t = escape subst groff_esc buf t in
    let pr_tokens ppf t = pr_tokens ~groff:true ppf (escape t) in
    let pr_block = function
    | `P s -> pr ppf "@\n.P@\n%a" pr_tokens s
    | `Pre s -> pr ppf "@\n.P@\n.nf@\n%a@\n.fi" pr_groff_lines (escape s)
    | `S s -> pr ppf "@\n.SH %a" pr_tokens s
    | `Noblank -> pr ppf "@\n.sp -1"
    | `I (l, s) -> pr ppf "@\n.TP 4@\n%a@\n%a" pr_tokens l pr_tokens s
    in
    List.iter pr_block text

  let pr_groff_page subst ppf ((n, s, a1, a2, a3), t) =
    pr ppf ".\\\" Pipe this output to groff -man -Tutf8 | less@\n\
            .\\\"@\n\
            .TH \"%s\" %d \"%s\" \"%s\" \"%s\"@\n\
            .\\\" Disable hyphenation and ragged-right@\n\
            .nh@\n\
      .ad l\
      %a@?"
      n s a1 a2 a3 (pr_groff_blocks subst) t

  (* Printing to a pager *)

  let find_cmd cmds =
    let test, null = match Sys.os_type with
    | "Win32" -> "where", " NUL"
    | _ -> "type", "/dev/null"
    in
    let cmd c = Sys.command (str "%s %s 1>%s 2>%s" test c null null) = 0 in
    try Some (List.find cmd cmds) with Not_found -> None

  let pr_to_pager print ppf v =
    let pager =
      let cmds = ["less"; "more"] in
      let cmds = try (Sys.getenv "PAGER") :: cmds with Not_found -> cmds in
      let cmds = try (Sys.getenv "MANPAGER") :: cmds with Not_found -> cmds in
      find_cmd cmds
    in
    match pager with
    | None -> print `Plain ppf v
    | Some pager ->
        let cmd = match (find_cmd ["groff"; "nroff"]) with
        | None ->
            begin match pr_to_temp_file (print `Plain) v with
            | None -> None
            | Some f -> Some (str "%s < %s" pager f)
            end
        | Some c ->
            begin match pr_to_temp_file (print `Groff) v with
            | None -> None
            | Some f ->
                (* TODO use -Tutf8, but annoyingly maps U+002D to U+2212. *)
                let xroff = if c = "groff" then c ^ " -Tascii -P-c" else c in
                Some (str "%s -man < %s | %s" xroff f pager)
            end
        in
        match cmd with
        | None -> print `Plain ppf v
        | Some cmd -> if (Sys.command cmd) <> 0 then print `Plain ppf v

  let rec print ?(subst = fun x -> x) fmt ppf page = match fmt with
  | `Pager -> pr_to_pager (print ~subst) ppf page
  | `Plain -> pr_plain_page subst ppf page
  | `Groff -> pr_groff_page subst ppf page
end

module Help = struct
  let invocation ?(sep = ' ') ei = match eval_kind ei with
  | `Simple | `M_main -> (fst ei.main).name
  | `M_choice -> str "%s%c%s" (fst ei.main).name sep (fst ei.term).name

  let title ei =
    let prog = String.capitalize (fst ei.main).name in
    let name = String.uppercase (invocation ~sep:'-' ei) in
    let left_footer = prog ^ match (fst ei.main).version with
      | None -> "" | Some v -> str " %s" v
    in
    let center_header = str "%s Manual" prog in
    name, 1, "", left_footer, center_header

  let name_section ei =
    let tdoc d = if d = "" then "" else (str " - %s" d) in
    [`S "NAME"; `P (str "%s%s" (invocation ~sep:'-' ei)
                      (tdoc (fst ei.term).tdoc)); ]

  let synopsis ei = match eval_kind ei with
  | `M_main -> str "$(b,%s) $(i,COMMAND) ..." (invocation ei)
  | `Simple | `M_choice ->
      let rev_cmp (p, _) (p', _) = match p', p with        (* best effort. *)
      | p, All -> -1 | All, p -> 1
      | Left _, Right _ -> -1 | Right _, Left _ -> 1
      | Left (false, k), Nth (false, k')
      | Nth (false, k), Nth (false, k')
      | Nth (false, k), Right (false, k') -> if k <= k' then -1 else 1
      | Nth (false, k), Left (false, k')
      | Right (false, k), Nth (false, k') -> if k >= k' then 1 else -1
      | Left (true, k), Nth (true, k')
      | Nth (true, k), Nth (true, k')
      | Nth (true, k), Right (true, k') -> if k >= k' then -1 else 1
      | Nth (true, k), Left (true, k')
      | Right (true, k), Nth (true, k') -> if k <= k' then 1 else -1
      | p, p' -> compare p p'
      in
      let rec format_pos acc = function
      | a :: al ->
          if is_opt a then format_pos acc al else
          let v = if a.docv = "" then "$(i,ARG)" else str "$(i,%s)" a.docv in
          let v = if a.absent = Error then str "%s" v else str "[%s]" v in
          let v = v ^ match a.p_kind with Nth _ -> "" | _ -> "..." in
          format_pos ((a.p_kind, v) :: acc) al
      | [] -> acc
      in
      let args = List.sort rev_cmp (format_pos [] (snd ei.term)) in
      let args = String.concat " " (List.rev_map snd args) in
      str "$(b,%s) [$(i,OPTION)]... %s" (invocation ei) args

  let get_synopsis_section ei =
    let rec extract_synopsis syn = function
    | `S _ :: _ as man -> List.rev syn, man
    |  block :: rest -> extract_synopsis (block :: syn) rest
    | [] -> List.rev syn, []
    in
    match (fst ei.term).man with
    | `S "SYNOPSIS" as s :: rest -> extract_synopsis [s] rest (* user-defined *)
    | man -> [ `S "SYNOPSIS"; `P (synopsis ei); ], man           (* automatic *)

  let or_env a = match a.env_info with
  | None -> ""
  | Some v -> str " or $(i,%s) env" v.env_var

  let make_arg_label a =
    if is_pos a then str "$(i,%s)" a.docv else
    let fmt_name var = match a.o_kind with
    | Flag -> fun n -> str "$(b,%s)%s" n (or_env a)
    | Opt ->
        fun n ->
          if String.length n > 2 then str "$(b,%s)=$(i,%s)" n var else
          str "$(b,%s) $(i,%s)" n var
    | Opt_vopt _ ->
        fun n ->
          if String.length n > 2 then str "$(b,%s)[=$(i,%s)]" n var else
          str "$(b,%s) [$(i,%s)]" n var
    in
    let var = if a.docv = "" then "VAL" else a.docv in
    let names = List.sort compare a.o_names in
    let s = String.concat ", " (List.rev_map (fmt_name var) names) in
    s

  let arg_info_substs ~buf a doc =
    let subst = function
    | "docv" -> str "$(i,%s)" a.docv
    | "opt" when is_opt a ->
        let k = String.lowercase (List.hd (List.sort compare a.o_names)) in
        str "$(b,%s)" k
    | "env" when a.env_info <> None ->
        begin match a.env_info with
        | None -> assert false
        | Some v -> str "$(i,%s)" v.env_var
        end
    | s -> str "$(%s)" s in
    try
      Buffer.clear buf;
      Buffer.add_substitute buf subst doc;
      Buffer.contents buf
    with Not_found -> invalid_arg (err_doc_string doc)

  let make_arg_items ei =
    let buf = Buffer.create 200 in
    let cmp a a' =
      let c = compare a.docs a'.docs in
      if c <> 0 then c else
      match is_opt a, is_opt a' with
      | true, true ->
          let key names =
            let k = String.lowercase (List.hd (List.sort rev_compare names)) in
            if k.[1] = '-' then String.sub k 1 (String.length k - 1) else k
          in
          compare (key a.o_names) (key a'.o_names)
      | false, false ->
          compare (String.lowercase a.docv) (String.lowercase a'.docv)
      | true, false -> -1
      | false, true -> 1
    in
    let format a =
      let absent = match a.absent with
      | Error -> ""
      | Val v -> match Lazy.force v with
      | "" -> ""
      | v -> str "absent=%s%s" v (or_env a)
      in
      let optvopt = match a.o_kind with
      | Opt_vopt v -> str "default=%s" v
      | _ -> ""
      in
      let argvdoc = match optvopt, absent with
      | "", "" -> ""
      | s, "" | "", s -> str " (%s)" s
      | s, s' -> str " (%s) (%s)" s s'
      in
      (a.docs, `I (make_arg_label a ^ argvdoc, (arg_info_substs ~buf a a.doc)))
    in
    let is_arg_item a = not (is_pos a && (a.docv = "" || a.doc = "")) in
    let l = List.sort cmp (List.filter is_arg_item (snd ei.term)) in
    List.rev_map format l

  let make_env_items_rev ei =
    let buf = Buffer.create 200 in
    let cmp a a' =
      let e' = match a'.env_info with None -> assert false | Some a' -> a' in
      let e = match a.env_info with None -> assert false | Some a -> a in
      let c = compare e.env_docs e'.env_docs in
      if c <> 0 then c else
      compare e.env_var e'.env_var
    in
    let format a =
      let e = match a.env_info with None -> assert false | Some a -> a in
      (e.env_docs,
       `I (str "$(i,%s)" e.env_var, arg_info_substs ~buf a e.env_doc))
    in
    let is_env_item a = a.env_info <> None in
    let l = List.sort cmp (List.filter is_env_item (snd ei.term)) in
    List.rev_map format l

  let make_cmd_items ei = match eval_kind ei with
  | `Simple | `M_choice -> []
  | `M_main ->
      let add_cmd acc (ti, _) =
        (ti.tdocs, `I ((str "$(b,%s)" ti.name), ti.tdoc)) :: acc
      in
      List.sort rev_compare (List.fold_left add_cmd [] ei.choices)

  let text ei =                  (* man that code is particulary unreadable. *)
    let rec merge_items acc to_insert mark il = function
    | `S s as sec :: ts ->
        let acc = List.rev_append to_insert acc in
        let acc = if mark then sec :: `Orphan_mark :: acc else sec :: acc in
        let to_insert, il = List.partition (fun (n, _) -> n = s) il in
        let to_insert = List.rev_map (fun (_, i) -> i) to_insert in
        let to_insert = (to_insert :> [ `Orphan_mark | Manpage.block] list) in
        merge_items acc to_insert (s = "DESCRIPTION") il ts
    | t :: ts ->
        let t = (t :> [`Orphan_mark | Manpage.block]) in
        merge_items (t :: acc) to_insert mark il ts
    | [] ->
        let acc = List.rev_append to_insert acc in
        (if mark then `Orphan_mark :: acc else acc), il
    in
    let rec merge_orphans acc orphans = function
    | `Orphan_mark :: ts ->
        let rec merge acc s = function
        | [] -> (`S s) :: acc
        | (s', i) :: ss ->
            let i = (i :> Manpage.block) in
            if s = s' then merge (i :: acc) s ss else
            merge (i :: (`S s) :: acc) s' ss
        in
        let acc = match orphans with
        | [] -> acc | (s, _) :: _ -> merge acc s orphans
        in
        merge_orphans acc [] ts
    | (#Manpage.block as e) :: ts -> merge_orphans (e :: acc) orphans ts
    | [] -> acc
    in
    let cmds = make_cmd_items ei in
    let args = make_arg_items ei in
    let envs_rev = make_env_items_rev ei in
    let items_rev = List.rev_append cmds (List.rev_append args envs_rev) in
    let cmp (s, _) (s', _) = match s, s with
    | "ENVIRONMENT VARIABLES", _ -> 1  (* Put env vars at the end. *)
    | s, "ENVIRONMENT VARIABLES" -> -1
    | s, s' -> compare s s' (* other predefined sec. names order correctly *)
    in
    let items = List.rev (List.stable_sort cmp items_rev) in
    let synopsis, man = get_synopsis_section ei in
    let rev_text, orphans = merge_items [`Orphan_mark] [] false items man in
    synopsis @ merge_orphans [] orphans rev_text

  let ei_subst ei = function
  | "tname" -> (fst ei.term).name
  | "mname" -> (fst ei.main).name
  | s -> str "$(%s)" s

  let man ei =
    title ei, (name_section ei) @ (text ei)

  let print fmt ppf ei = Manpage.print ~subst:(ei_subst ei) fmt ppf (man ei)
  let pr_synopsis ppf ei =
    pr ppf "@[%s@]"
      (Manpage.escape (ei_subst ei)
         Manpage.plain_esc (Buffer.create 100) (synopsis ei))

  let pr_version ppf ei = match (fst ei.main).version with
  | None -> assert false
  | Some v -> pr ppf "@[%a@]@." pr_text v
end

(* Errors for the command line user *)

module Err = struct
  let invalid kind s exp = str "invalid %s %s, %s" kind (quote s) exp
  let invalid_val = invalid "value"
  let no kind s = str "no %s %s" (quote s) kind
  let not_dir s = str "%s is not a directory" (quote s)
  let is_dir s = str "%s is a directory" (quote s)
  let element kind s exp = str "invalid element in %s (`%s'): %s" kind s exp
  let sep_miss sep s = invalid_val s (str "missing a `%c' separator" sep)
  let unknown kind ?(hints = []) v =
    let did_you_mean s = str ", did you mean %s ?" s in
    let hints = match hints with [] -> "." | hs -> did_you_mean (alts_str hs) in
    str "unknown %s %s%s" kind (quote v) hints

  let ambiguous kind s ambs =
    str "%s %s ambiguous and could be %s" kind (quote s) (alts_str ambs)

  let pos_excess excess =
    str "too many arguments, don't know what to do with %s"
      (String.concat ", " (List.map quote excess))

  let flag_value f v =
    str "option %s is a flag, it cannot take the argument %s"
      (quote f) (quote v)

  let opt_value_missing f = str "option %s needs an argument" (quote f)
  let opt_parse_value f e = str "option %s: %s" (quote f) e
  let env_parse_value var e = str "environment variable %s: %s" (quote var) e
  let opt_repeated f f' =
    if f = f' then str "option %s cannot be repeated" (quote f) else
    str "options %s and %s cannot be present at the same time" (quote f)
      (quote f')

  let pos_parse_value a e =
    if a.docv = "" then e else match a.p_kind with
    | Nth _ -> str "%s argument: %s" a.docv e
    | _ -> str "%s... arguments: %s" a.docv e

  let arg_missing a =
    if is_opt a then
      let rec long_name = function
      | n :: l -> if (String.length n) > 2 || l = [] then n else long_name l
      | [] -> assert false
      in
      str "required option %s is missing" (long_name a.o_names)
    else
    if a.docv = "" then str "a required argument is missing" else
    str "required argument %s is missing" a.docv

  (* Error printers *)

  let print ppf ei e = pr ppf "%s: @[%a@]@." (fst ei.main).name pr_text e
  let pr_backtrace err ei e bt =
    let bt =
      let len = String.length bt in
      if len > 0 then String.sub bt 0 (len - 1) (* remove final '\n' *) else bt
    in
    pr err
      "%s: @[internal error, uncaught exception:@\n%a@]@."
      (fst ei.main).name pr_lines (str "%s\n%s" (Printexc.to_string e) bt)

  let pr_try_help ppf ei =
    let exec = Help.invocation ei in
    let main = (fst ei.main).name in
    if exec = main then
      pr ppf "@[<2>Try `%s --help' for more information.@]" exec
    else
    pr ppf "@[<2>Try `%s --help' or `%s --help' for more information.@]"
      exec main

  let pr_usage ppf ei e =
    pr ppf "@[<v>%s: @[%a@]@,@[Usage: @[%a@]@]@,%a@]@."
      (fst ei.main).name pr_text e Help.pr_synopsis ei pr_try_help ei
end

(* Command lines. A command line stores pre-parsed information about
   the command line's arguments in a more structured way. Given the
   [arg_info] values mentionned in a term and Sys.argv (whithout exec
   name) we parse the command line into a map of [arg_info] values to
   [arg] values. This map is used by the term's closures to retrieve
   and convert command line arguments (see the Arg module). *)

module Cmdline :sig
  exception Error of string
  val choose_term : term_info -> (term_info * 'a) list -> string list ->
    term_info * string list
  val create : ?peek_opts:bool -> arg_info list -> string list -> cmdline
  val opt_arg : cmdline -> arg_info -> (int * string * (string option)) list
  val pos_arg : cmdline -> arg_info -> string list
end = struct
  exception Error of string

  let opt_arg cl a = match try Amap.find a cl with Not_found -> assert false
  with O l -> l | _ -> assert false

  let pos_arg cl a = match try Amap.find a cl with Not_found -> assert false
  with P l -> l | _ -> assert false

  let choose_term ti choices = function
  | [] -> ti, []
  | maybe :: args' as args ->
      if String.length maybe > 1 && maybe.[0] = '-' then ti, args else
      let index =
        let add acc (choice, _) = Trie.add acc choice.name choice in
        List.fold_left add Trie.empty choices
      in
      match Trie.find index maybe with
      | `Ok choice -> choice, args'
      | `Not_found ->
        let all = Trie.ambiguities index "" in
        let hints = suggest maybe all in
        raise (Error (Err.unknown "command" ~hints maybe))
      | `Ambiguous ->
          let ambs = List.sort compare (Trie.ambiguities index maybe) in
          raise (Error (Err.ambiguous "command" maybe ambs))

  let arg_info_indexes al =
    (* from [al] returns a trie mapping the names of optional arguments to
       their arg_info, a list with all arg_info for positional arguments and
       a cmdline mapping each arg_info to an empty [arg]. *)
    let rec aux opti posi cl = function
    | a :: l ->
        if is_pos a then aux opti (a :: posi) (Amap.add a (P []) cl) l else
        let add t name = Trie.add t name a in
        aux (List.fold_left add opti a.o_names) posi (Amap.add a (O []) cl) l
    | [] -> opti, posi, cl
    in
    aux Trie.empty [] Amap.empty al

  let parse_opt_arg s =          (* (name,value) of opt arg, assert len > 1. *)
    let l = String.length s in
    if s.[1] <> '-' then
      if l = 2 then s, None else
      String.sub s 0 2, Some (String.sub s 2 (l - 2))
    else try
      let i = String.index s '=' in
      String.sub s 0 i, Some (String.sub s (i + 1) (l - i - 1))
    with Not_found -> s, None

  let parse_args ~peek_opts opti cl args =
    (* returns an updated [cl] cmdline according to the options found in [args]
       with the trie index [opti]. Positional arguments are returned in order
       in a list. *)
    let rec aux k opti cl pargs = function
    | [] -> cl, (List.rev pargs)
    | "--" :: args -> cl, (List.rev_append pargs args)
    | s :: args ->
        let is_opt s = String.length s > 1 && s.[0] = '-' in
        let is_short_opt s = String.length s = 2 && s.[0] = '-' in
        if not (is_opt s) then aux (k+1) opti cl (s :: pargs) args else
        let name, value = parse_opt_arg s in
        match Trie.find opti name with
        | `Ok a ->
            let value, args = match value, a.o_kind with
            | Some v, Flag when is_short_opt name -> None, ("-" ^ v) :: args
            | Some v, _ -> value, args
            | None, Flag -> value, args
            | None, _ ->
                match args with
                | v :: rest -> if is_opt v then None, args else Some v, rest
                | [] -> None, args
            in
            let arg = O ((k, name, value) :: opt_arg cl a) in
            aux (k+1) opti (Amap.add a arg cl) pargs args
        | `Not_found when peek_opts -> aux (k+1) opti cl pargs args (* skip *)
        | `Not_found ->
            let hints =
              if String.length s <= 2 then [] else
              let short_opt, long_opt =
                if s.[1] <> '-'
                then s, Printf.sprintf "-%s" s
                else String.sub s 1 (String.length s - 1), s
              in
              let short_opt, _ = parse_opt_arg short_opt in
              let long_opt, _ = parse_opt_arg long_opt in
              let all = Trie.ambiguities opti "-" in
              match List.mem short_opt all, suggest long_opt all with
              | false, [] -> []
              | false, l -> l
              | true, [] -> [short_opt]
              | true, l -> if List.mem short_opt l then l else short_opt :: l
            in
            raise (Error (Err.unknown "option" ~hints name))
        | `Ambiguous ->
            let ambs = List.sort compare (Trie.ambiguities opti name) in
            raise (Error (Err.ambiguous "option" name ambs))
    in
    aux 0 opti cl [] args

  let process_pos_args posi cl pargs =
    (* returns an updated [cl] cmdline in which each positional arg mentionned
       in the list index posi, is given a value according the list
       of positional arguments values [pargs]. *)
    if pargs = [] then cl else
    let rec take n acc l =
      if n = 0 then List.rev acc else
      take (n - 1) (List.hd l :: acc) (List.tl l)
    in
    let rec aux pargs last cl max_spec = function
    | a :: al ->
        let arg, max_spec = match a.p_kind with
        | All -> P pargs, last
        | Nth (rev, k) ->
            let k = if rev then last - k else k in
            let max_spec = max k max_spec in
            if k < 0 || k > last then P [], max_spec else
            P ([List.nth pargs k]), max_spec
        | Left (rev, k) ->
            let k = if rev then last - k else k in
            let max_spec = max k max_spec in
            if k <= 0 || k > last then P [], max_spec else
            P (take k [] pargs), max_spec
        | Right (rev, k) ->
            let k = if rev then last - k else k in
            if k < 0 || k >= last then P [], last else
            P (List.rev (take (last - k) [] (List.rev pargs))), last
        in
        aux pargs last (Amap.add a arg cl) max_spec al
    | [] -> cl, max_spec
    in
    let last = List.length pargs - 1 in
    let cl, max_spec = aux pargs last cl (-1) posi in
    if last <= max_spec then cl else
    let excess = List.rev (take (last - max_spec) [] (List.rev pargs)) in
    raise (Error (Err.pos_excess excess))

  let create ?(peek_opts = false) al args =
    let opti, posi, cl = arg_info_indexes al in
    let cl, pargs = parse_args ~peek_opts opti cl args in
    if peek_opts then cl (* skip positional arguments *) else
    process_pos_args posi cl pargs
end

module Arg = struct
  type 'a parser = string -> [ `Ok of 'a | `Error of string ]
  type 'a printer = Format.formatter -> 'a -> unit
  type 'a converter = 'a parser * 'a printer
  type env = env_info
  type 'a arg_converter = (eval_info -> cmdline -> 'a)
  type 'a t = arg_info list * 'a arg_converter
  type info = arg_info

  let env_var ?(docs = "ENVIRONMENT VARIABLES") ?(doc = "See option $(opt).")
      env_var
    =
    { env_var = env_var; env_doc = doc; env_docs = docs }

  let ( & ) f x = f x
  let parse_error e = raise (Cmdline.Error e)
  let some ?(none = "") (parse, print) =
    (fun s -> match parse s with `Ok v -> `Ok (Some v) | `Error _ as e -> e),
    (fun ppf v -> match v with None -> pr_str ppf none| Some v -> print ppf v)

  let info ?docs ?(docv = "") ?(doc = "") ?env names =
    let dash n = if String.length n = 1 then "-" ^ n else "--" ^ n in
    let docs = match docs with
    | None -> if names = [] then "ARGUMENTS" else "OPTIONS"
    | Some s -> s
    in
    { id = arg_id (); absent = Val (lazy "");
      env_info = env;
      doc = doc; docv = docv; docs = docs;
      p_kind = All; o_kind = Flag; o_names = List.rev_map dash names;
      o_all = false; }

  let env_bool_parse s = match String.lowercase s with
  | "" | "false" | "no" | "n" | "0" -> `Ok false
  | "true" | "yes" | "y" | "1" -> `Ok true
  | s -> `Error (Err.invalid_val s (alts_str ["true"; "yes"; "false"; "no" ]))

  let parse_to_list parser s = match parser s with
  | `Ok v -> `Ok [v]
  | `Error _ as e -> e

  let try_env ei a parse ~absent = match a.env_info with
  | None -> absent
  | Some env ->
      match ei.env env.env_var with
      | None -> absent
      | Some v ->
          match parse v with
          | `Ok v -> v
          | `Error e ->
              parse_error (Err.env_parse_value env.env_var e)

  let flag a =
    if is_pos a then invalid_arg err_not_opt else
    let convert ei cl = match Cmdline.opt_arg cl a with
    | [] -> try_env ei a env_bool_parse ~absent:false
    | [_, _, None] -> true
    | [_, f, Some v] -> parse_error (Err.flag_value f v)
    | (_, f, _) :: (_ ,g, _) :: _  -> parse_error (Err.opt_repeated f g)
    in
    [a], convert

  let flag_all a =
    if is_pos a then invalid_arg err_not_opt else
    let a = { a with o_all = true } in
    let convert ei cl = match Cmdline.opt_arg cl a with
    | [] -> try_env ei a (parse_to_list env_bool_parse) ~absent:[]
    | l ->
        let truth (_, f, v) = match v with
        | None -> true | Some v -> parse_error (Err.flag_value f v)
        in
        List.rev_map truth l
    in
    [a], convert

  let vflag v l =
    let convert _ cl =
      let rec aux fv = function
      | (v, a) :: rest ->
          begin match Cmdline.opt_arg cl a with
          | [] -> aux fv rest
          | [_, f, None] ->
              begin match fv with
              | None -> aux (Some (f, v)) rest
              | Some (g, _) -> parse_error (Err.opt_repeated g f)
              end
          | [_, f, Some v] -> parse_error (Err.flag_value f v)
          | (_, f, _) :: (_, g, _) :: _ -> parse_error (Err.opt_repeated g f)
          end
      | [] -> match fv with None -> v | Some (_, v) -> v
      in
      aux None l
    in
    let flag (_, a) = if is_pos a then invalid_arg err_not_opt else a in
    List.rev_map flag l, convert

  let vflag_all v l =
    let convert _ cl =
      let rec aux acc = function
      | (fv, a) :: rest ->
          begin match Cmdline.opt_arg cl a with
          | [] -> aux acc rest
          | l ->
              let fval (k, f, v) = match v with
              | None -> (k, fv) | Some v -> parse_error (Err.flag_value f v)
              in
              aux (List.rev_append (List.rev_map fval l) acc) rest
          end
      | [] ->
          if acc = [] then v else List.rev_map snd (List.sort rev_compare acc)
      in
      aux [] l
    in
    let flag (_, a) =
      if is_pos a then invalid_arg err_not_opt else { a with o_all = true }
    in
    List.rev_map flag l, convert

  let parse_opt_value parse f v = match parse v with
  | `Ok v -> v | `Error e -> parse_error (Err.opt_parse_value f e)

  let opt ?vopt (parse, print) v a =
    if is_pos a then invalid_arg err_not_opt else
    let a = { a with absent = Val (lazy (str_of_pp print v));
                     o_kind = match vopt with
                     | None -> Opt | Some dv -> Opt_vopt (str_of_pp print dv) }
    in
    let convert ei cl = match Cmdline.opt_arg cl a with
    | [] -> try_env ei a parse ~absent:v
    | [_, f, Some v] -> parse_opt_value parse f v
    | [_, f, None] ->
        begin match vopt with
        | None -> parse_error (Err.opt_value_missing f)
        | Some optv -> optv
        end
    | (_, f, _) :: (_, g, _) :: _ -> parse_error (Err.opt_repeated g f)
    in
    [a], convert

  let opt_all ?vopt (parse, print) v a =
    if is_pos a then invalid_arg err_not_opt else
    let a = { a with absent = Val (lazy ""); o_all = true;
                     o_kind = match vopt with
                     | None -> Opt | Some dv -> Opt_vopt (str_of_pp print dv) }
    in
    let convert ei cl = match Cmdline.opt_arg cl a with
    | [] -> try_env ei a (parse_to_list parse) ~absent:v
    | l ->
        let parse (k, f, v) = match v with
        | Some v -> (k, parse_opt_value parse f v)
        | None -> match vopt with
        | None -> parse_error (Err.opt_value_missing f)
        | Some dv -> (k, dv)
        in
        List.rev_map snd (List.sort rev_compare (List.rev_map parse l))
    in
    [a], convert

  (* Positional arguments *)

  let parse_pos_value parse a v = match parse v with
  | `Ok v -> v | `Error e -> parse_error (Err.pos_parse_value a e)

  let pos ?(rev = false) k (parse, print) v a =
    if is_opt a then invalid_arg err_not_pos else
    let a = { a with p_kind = Nth (rev, k);
                     absent = Val (lazy (str_of_pp print v)) }
    in
    let convert ei cl = match Cmdline.pos_arg cl a with
    | [] -> try_env ei a parse ~absent:v
    | [v] -> parse_pos_value parse a v
    | _ -> assert false
    in
    [a], convert

  let pos_list kind (parse, _) v a =
    if is_opt a then invalid_arg err_not_pos else
    let a = { a with p_kind = kind } in
    let convert ei cl = match Cmdline.pos_arg cl a with
    | [] -> try_env ei a (parse_to_list parse) ~absent:v
    | l -> List.rev (List.rev_map (parse_pos_value parse a) l)
    in
    [a], convert

  let pos_all c v a = pos_list All c v a
  let pos_left ?(rev = false) k = pos_list (Left (rev, k))
  let pos_right ?(rev = false) k = pos_list (Right (rev, k))

  (* Arguments as terms *)

  let absent_error al = List.rev_map (fun a -> { a with absent = Error }) al
  let value a = a
  let required (al, convert) =
    let al = absent_error al in
    let convert ei cl = match convert ei cl with
    | Some v -> v
    | None -> parse_error (Err.arg_missing (List.hd al))
    in
    al, convert

  let non_empty (al, convert) =
    let al = absent_error al in
    let convert ei cl = match convert ei cl with
    | [] -> parse_error (Err.arg_missing (List.hd al))
    | l -> l
    in
    al, convert

  let last (al, convert) =
    let convert ei cl = match convert ei cl with
    | [] -> parse_error (Err.arg_missing (List.hd al))
    | l -> List.hd (List.rev l)
    in
    al, convert

  (* Predefined converters. *)

  let bool =
    (fun s -> try `Ok (bool_of_string s) with Invalid_argument _ ->
        `Error (Err.invalid_val s (alts_str ["true"; "false"]))),
    Format.pp_print_bool

  let char =
    (fun s -> if String.length s = 1 then `Ok s.[0] else
      `Error (Err.invalid_val s "expected a character")),
    pr_char

  let parse_with t_of_str exp s =
    try `Ok (t_of_str s) with Failure _ -> `Error (Err.invalid_val s exp)

  let int =
    parse_with int_of_string "expected an integer", Format.pp_print_int

  let int32 =
    parse_with Int32.of_string "expected a 32-bit integer",
    (fun ppf -> pr ppf "%ld")

  let int64 =
    parse_with Int64.of_string "expected a 64-bit integer",
    (fun ppf -> pr ppf "%Ld")

  let nativeint =
    parse_with Nativeint.of_string "expected a processor-native integer",
    (fun ppf -> pr ppf "%nd")

  let float =
    parse_with float_of_string "expected a floating point number",
    Format.pp_print_float

  let string = (fun s -> `Ok s), pr_str
  let enum sl =
    if sl = [] then invalid_arg err_empty_list else
    let t = Trie.of_list sl in
    let parse s = match Trie.find t s with
    | `Ok _ as r -> r
    | `Ambiguous ->
        let ambs = List.sort compare (Trie.ambiguities t s) in
        `Error (Err.ambiguous "enum value" s ambs)
    | `Not_found ->
        let alts = List.rev (List.rev_map (fun (s, _) -> s) sl) in
        `Error (Err.invalid_val s ("expected " ^ (alts_str alts)))
    in
    let print ppf v =
      let sl_inv = List.rev_map (fun (s,v) -> (v,s)) sl in
      try pr_str ppf (List.assoc v sl_inv)
      with Not_found -> invalid_arg err_incomplete_enum
    in
    parse, print

  let file =
    (fun s -> if Sys.file_exists s then `Ok s else
      `Error (Err.no "file or directory" s)),
    pr_str

  let dir =
    (fun s ->
       if Sys.file_exists s then
         if Sys.is_directory s then `Ok s else `Error (Err.not_dir s)
       else
       `Error (Err.no "directory" s)),
    pr_str

  let non_dir_file =
    (fun s ->
       if Sys.file_exists s then
         if not (Sys.is_directory s) then `Ok s else `Error (Err.is_dir s)
       else
       `Error (Err.no "file" s)),
    pr_str

  let split_and_parse sep parse s =
    let parse sub = match parse sub with
    | `Error e -> failwith e | `Ok v -> v in
    let rec split accum j =
      let i = try String.rindex_from s j sep with Not_found -> -1 in
      if (i = -1) then
        let p = String.sub s 0 (j + 1) in
        if p <> "" then parse p :: accum else accum
      else
      let p = String.sub s (i + 1) (j - i) in
      let accum' = if p <> "" then parse p :: accum else accum in
      split accum' (i - 1)
    in
    split [] (String.length s - 1)

  let list ?(sep = ',') (parse, pr_e) =
    let parse s = try `Ok (split_and_parse sep parse s) with
    | Failure e -> `Error (Err.element "list" s e)
    in
    let rec print ppf = function
    | v :: l -> pr_e ppf v; if (l <> []) then (pr_char ppf sep; print ppf l)
    | [] -> ()
    in
    parse, print

  let array ?(sep = ',') (parse, pr_e) =
    let parse s = try `Ok (Array.of_list (split_and_parse sep parse s)) with
    | Failure e -> `Error (Err.element "array" s e)
    in
    let print ppf v =
      let max = Array.length v - 1 in
      for i = 0 to max do pr_e ppf v.(i); if i <> max then pr_char ppf sep done
    in
    parse, print

  let split_left sep s =
    try
      let i = String.index s sep in
      let len = String.length s in
      Some ((String.sub s 0 i), (String.sub s (i + 1) (len - i - 1)))
    with Not_found -> None

  let pair ?(sep = ',') (pa0, pr0) (pa1, pr1) =
    let parser s = match split_left sep s with
    | None -> `Error (Err.sep_miss sep s)
    | Some (v0, v1) ->
        match pa0 v0, pa1 v1 with
        | `Ok v0, `Ok v1 -> `Ok (v0, v1)
        | `Error e, _ | _, `Error e -> `Error (Err.element "pair" s e)
    in
    let printer ppf (v0, v1) = pr ppf "%a%c%a" pr0 v0 sep pr1 v1 in
    parser, printer

  let t2 = pair
  let t3 ?(sep = ',') (pa0, pr0) (pa1, pr1) (pa2, pr2) =
    let parse s = match split_left sep s with
    | None -> `Error (Err.sep_miss sep s)
    | Some (v0, s) ->
        match split_left sep s with
        | None -> `Error (Err.sep_miss sep s)
        | Some (v1, v2) ->
            match pa0 v0, pa1 v1, pa2 v2 with
            | `Ok v0, `Ok v1, `Ok v2 -> `Ok (v0, v1, v2)
            | `Error e, _, _ | _, `Error e, _ | _, _, `Error e ->
                `Error (Err.element "triple" s e)
    in
    let print ppf (v0, v1, v2) =
      pr ppf "%a%c%a%c%a" pr0 v0 sep pr1 v1 sep pr2 v2
    in
    parse, print

  let t4 ?(sep = ',') (pa0, pr0) (pa1, pr1) (pa2, pr2) (pa3, pr3) =
    let parse s = match split_left sep s with
    | None -> `Error (Err.sep_miss sep s)
    | Some(v0, s) ->
        match split_left sep s with
        | None -> `Error (Err.sep_miss sep s)
        | Some (v1, s) ->
            match split_left sep s with
            | None -> `Error (Err.sep_miss sep s)
            | Some (v2, v3) ->
                match pa0 v0, pa1 v1, pa2 v2, pa3 v3 with
                | `Ok v1, `Ok v2, `Ok v3, `Ok v4 -> `Ok (v1, v2, v3, v4)
                | `Error e, _, _, _ | _, `Error e, _, _ | _, _, `Error e, _
                | _, _, _, `Error e -> `Error (Err.element "quadruple" s e)
    in
    let print ppf (v0, v1, v2, v3) =
      pr ppf "%a%c%a%c%a%c%a" pr0 v0 sep pr1 v1 sep pr2 v2 sep pr3 v3
    in
    parse, print

  (* Documentation formatting helpers *)

  let doc_quote = quote
  let doc_alts = alts_str
  let doc_alts_enum ?quoted enum = alts_str ?quoted (List.map fst enum)
end

module Term = struct
  type info = term_info
  type +'a t = arg_info list * (eval_info -> cmdline -> 'a)
  type 'a result = [
    | `Ok of 'a | `Error of [`Parse | `Term | `Exn ] | `Version | `Help ]

  exception Term of
      [ `Help of [`Pager | `Plain | `Groff] * string option
      | `Error of bool * string ]

  let info  ?(sdocs = "OPTIONS") ?(man = []) ?(docs = "COMMANDS") ?(doc = "")
      ?version name =
    { name = name; version = version; tdoc = doc; tdocs = docs; sdocs = sdocs;
      man = man }

  let name ti = ti.name
  let const v = [], (fun _ _ -> v)
  let pure (* deprecated *) = const
  let app (al, f) (al', v) =
    List.rev_append al al',
    fun ei cl -> (f ei cl) (v ei cl)

  let ( $ ) = app

  type 'a ret =
    [ `Help of [`Pager | `Plain | `Groff] * string option
    | `Error of (bool * string)
    | `Ok of 'a ]

  let ret (al, v) =
    al, fun ei cl -> match v ei cl with
    | `Ok v -> v
    | `Error (u,e) -> raise (Term (`Error (u,e)))
    | `Help h -> raise (Term (`Help h))

  let main_name = [], (fun ei _ -> (fst ei.main).name)
  let choice_names =
    [], fun ei _ -> List.rev_map (fun e -> (fst e).name) ei.choices

  let man_format =
    let fmts = ["pager", `Pager; "groff", `Groff; "plain", `Plain] in
    let doc = "Show output in format $(docv) (pager, plain or groff)."in
    Arg.(value & opt (enum fmts) `Pager & info ["man-format"] ~docv:"FMT" ~doc)

  (* Evaluation *)

  let remove_exec argv =
    try List.tl (Array.to_list argv) with Failure _ -> invalid_arg err_argv

  let add_std_opts ei =
    let docs = (fst ei.term).sdocs in
    let args, v_lookup =
      if (fst ei.main).version = None then [], None else
      let (a, lookup) =
        Arg.flag (Arg.info ["version"] ~docs ~doc:"Show version information.")
      in
      a, Some lookup
    in
    let args, h_lookup =
      let (a, lookup) =
        let fmt = Arg.enum ["pager",`Pager; "groff",`Groff; "plain",`Plain] in
        let doc = "Show this help in format $(docv) (pager, plain or groff)."in
        let a = Arg.info ["help"] ~docv:"FMT" ~docs ~doc in
        Arg.opt ~vopt:(Some `Pager) (Arg.some fmt) None a
      in
      List.rev_append a args, lookup
    in
    h_lookup, v_lookup,
    { ei with term = (fst ei.term), List.rev_append args (snd ei.term) }

  let eval_term help err ei f args =
    let help_arg, vers_arg, ei = add_std_opts ei in
    try
      let cl = Cmdline.create (snd ei.term) args in
      match help_arg ei cl, vers_arg with
      | Some fmt, _ -> Help.print fmt help ei; `Help
      | None, Some v_arg when v_arg ei cl -> Help.pr_version help ei; `Version
      | _ -> `Ok (f ei cl)
    with
    | Cmdline.Error e -> Err.pr_usage err ei e; `Error `Parse
    | Term (`Error (usage, e)) ->
        if usage then Err.pr_usage err ei e else Err.print err ei e;
        `Error `Term
    | Term (`Help (fmt, cmd)) ->
        let ei = match cmd with
        | Some cmd ->
            let cmd =
              try List.find (fun (i, _) -> i.name = cmd) ei.choices
              with Not_found -> invalid_arg (err_help cmd)
            in
            {ei with term = cmd }
        | None -> { ei with term = ei.main }
        in
        let _, _, ei = add_std_opts ei in
        Help.print fmt help ei; `Help

  let env_default v = try Some (Sys.getenv v) with Not_found -> None

  let eval ?(help = Format.std_formatter) ?(err = Format.err_formatter)
      ?(catch = true) ?(env = env_default) ?(argv = Sys.argv) ((al, f), ti) =
    let term = ti, al in
    let ei = { term = term; main = term; choices = []; env = env } in
    try eval_term help err ei f (remove_exec argv) with
    | e when catch ->
        Err.pr_backtrace err ei e (Printexc.get_backtrace ()); `Error `Exn

  let eval_choice ?(help = Format.std_formatter) ?(err = Format.err_formatter)
      ?(catch = true) ?(env = env_default) ?(argv = Sys.argv)
      (((al, f) as t), ti) choices =
    let ei_choices = List.rev_map (fun ((al, _), ti) -> ti, al) choices in
    let main = (ti, al) in
    let ei = { term = main; main = main; choices = ei_choices; env = env } in
    try
      let chosen, args = Cmdline.choose_term ti ei_choices (remove_exec argv) in
      let find_chosen (_, ti) = ti = chosen in
      let (al, f), _ = List.find find_chosen ((t, ti) :: choices) in
      let ei = { ei with term = (chosen, al) } in
      eval_term help err ei f args
    with
    | Cmdline.Error e ->                    (* may be raised by choose_term. *)
        Err.pr_usage err ei e; `Error `Parse
    | e when catch ->
        Err.pr_backtrace err ei e (Printexc.get_backtrace ()); `Error `Exn

  let eval_peek_opts ?(version_opt = false) ?(env = env_default)
      ?(argv = Sys.argv) (al, f) =
    let args = remove_exec argv in
    let version = if version_opt then Some "dummy" else None in
    let term = info ?version "dummy", al in
    let ei = { term = term; main = term; choices = []; env = env } in
    let help_arg, vers_arg, ei = add_std_opts ei in
    try
      let cl = Cmdline.create ~peek_opts:true (snd ei.term) args in
      match help_arg ei cl, vers_arg with
      | Some fmt, _ ->
          (try (Some (f ei cl), `Help) with e -> None, `Help)
      | None, Some v_arg when v_arg ei cl ->
          (try (Some (f ei cl), `Version) with e -> None, `Version)
      | _ ->
          let v = f ei cl in
          Some v, `Ok v
    with
    | Cmdline.Error _ -> None, (`Error `Parse)
    | Term _ -> None, (`Error `Term)
    | e -> None, (`Error `Exn)
end

(*---------------------------------------------------------------------------
   Copyright (c) 2011 Daniel C. Bünzli
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

   3. Neither the name of Daniel C. Bünzli nor the names of
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  ---------------------------------------------------------------------------*)

end
module Package
= struct
#1 "package.ml"

let version = "1.13.6"
let git_version = "3cacdcbeec6493573d96db05af29bc47273ff60d"
let git_short_version = "3cacdcb"

end
module Ast_404
= struct
#1 "ast_404.ml"
# 1 "src/ast_404.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*            Jérémie Dimino and Leo White, Jane Street Europe            *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)
(*                         Alain Frisch, LexiFi                           *)
(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Location = Location
module Longident = Longident

module Asttypes = struct
  (** Auxiliary AST types used by parsetree and typedtree. *)

  type constant (*IF_CURRENT = Asttypes.constant *) =
      Const_int of int
    | Const_char of char
    | Const_string of string * string option
    | Const_float of string
    | Const_int32 of int32
    | Const_int64 of int64
    | Const_nativeint of nativeint

  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive

  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto

  (* Order matters, used in polymorphic comparison *)
  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public

  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable

  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete

  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh

  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open

  type label = string

  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =
      Nolabel
    | Labelled of string (*  label:T -> ... *)
    | Optional of string (* ?label:T -> ... *)

  type 'a loc = 'a Location.loc = {
    txt : 'a;
    loc : Location.t;
  }


  type variance (*IF_CURRENT = Asttypes.variance *) =
    | Covariant
    | Contravariant
    | Invariant
end

module Parsetree = struct
  (** Abstract syntax tree produced by parsing *)

  open Asttypes

  type constant (*IF_CURRENT = Parsetree.constant *) =
      Pconst_integer of string * char option
    (* 3 3l 3L 3n

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker
    *)
    | Pconst_char of char
    (* 'c' *)
    | Pconst_string of string * string option
    (* "constant"
       {delim|other constant|delim}
    *)
    | Pconst_float of string * char option
    (* 3.4 2e5 1.4e-4

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes are rejected by the typechecker.
    *)

  (** {2 Extension points} *)

  type attribute = string loc * payload
         (* [@id ARG]
            [@@id ARG]

            Metadata containers passed around within the AST.
            The compiler ignores unknown attributes.
         *)

  and extension = string loc * payload
        (* [%id ARG]
           [%%id ARG]

           Sub-language placeholder -- rejected by the typechecker.
        *)

  and attributes = attribute list

  and payload (*IF_CURRENT = Parsetree.payload *) =
    | PStr of structure
    | PSig of signature (* : SIG *)
    | PTyp of core_type  (* : T *)
    | PPat of pattern * expression option  (* ? P  or  ? P when E *)

  (** {2 Core language} *)

  (* Type expressions *)

  and core_type (*IF_CURRENT = Parsetree.core_type *) =
      {
       ptyp_desc: core_type_desc;
       ptyp_loc: Location.t;
       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =
    | Ptyp_any
          (*  _ *)
    | Ptyp_var of string
          (* 'a *)
    | Ptyp_arrow of arg_label * core_type * core_type
          (* T1 -> T2       Simple
             ~l:T1 -> T2    Labelled
             ?l:T1 -> T2    Otional
           *)
    | Ptyp_tuple of core_type list
          (* T1 * ... * Tn

             Invariant: n >= 2
          *)
    | Ptyp_constr of Longident.t loc * core_type list
          (* tconstr
             T tconstr
             (T1, ..., Tn) tconstr
           *)
    | Ptyp_object of (string * attributes * core_type) list * closed_flag
          (* < l1:T1; ...; ln:Tn >     (flag = Closed)
             < l1:T1; ...; ln:Tn; .. > (flag = Open)
           *)
    | Ptyp_class of Longident.t loc * core_type list
          (* #tconstr
             T #tconstr
             (T1, ..., Tn) #tconstr
           *)
    | Ptyp_alias of core_type * string
          (* T as 'a *)
    | Ptyp_variant of row_field list * closed_flag * label list option
          (* [ `A|`B ]         (flag = Closed; labels = None)
             [> `A|`B ]        (flag = Open;   labels = None)
             [< `A|`B ]        (flag = Closed; labels = Some [])
             [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
           *)
    | Ptyp_poly of string list * core_type
          (* 'a1 ... 'an. T

             Can only appear in the following context:

             - As the core_type of a Ppat_constraint node corresponding
               to a constraint on a let-binding: let x : 'a1 ... 'an. T
               = e ...

             - Under Cfk_virtual for methods (not values).

             - As the core_type of a Pctf_method node.

             - As the core_type of a Pexp_poly node.

             - As the pld_type field of a label_declaration.

             - As a core_type of a Ptyp_object node.
           *)

    | Ptyp_package of package_type
          (* (module S) *)
    | Ptyp_extension of extension
          (* [%id] *)

  and package_type = Longident.t loc * (Longident.t loc * core_type) list
        (*
          (module S)
          (module S with type t1 = T1 and ... and tn = Tn)
         *)

  and row_field (*IF_CURRENT = Parsetree.row_field *) =
    | Rtag of label * attributes * bool * core_type list
          (* [`A]                   ( true,  [] )
             [`A of T]              ( false, [T] )
             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

            - The 2nd field is true if the tag contains a
              constant (empty) constructor.
            - '&' occurs when several types are used for the same constructor
              (see 4.2 in the manual)

            - TODO: switch to a record representation, and keep location
          *)
    | Rinherit of core_type
          (* [ T ] *)

  (* Patterns *)

  and pattern (*IF_CURRENT = Parsetree.pattern *) =
      {
       ppat_desc: pattern_desc;
       ppat_loc: Location.t;
       ppat_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =
    | Ppat_any
          (* _ *)
    | Ppat_var of string loc
          (* x *)
    | Ppat_alias of pattern * string loc
          (* P as 'a *)
    | Ppat_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Ppat_interval of constant * constant
          (* 'a'..'z'

             Other forms of interval are recognized by the parser
             but rejected by the type-checker. *)
    | Ppat_tuple of pattern list
          (* (P1, ..., Pn)

             Invariant: n >= 2
          *)
    | Ppat_construct of Longident.t loc * pattern option
          (* C                None
             C P              Some P
             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
           *)
    | Ppat_variant of label * pattern option
          (* `A             (None)
             `A P           (Some P)
           *)
    | Ppat_record of (Longident.t loc * pattern) list * closed_flag
          (* { l1=P1; ...; ln=Pn }     (flag = Closed)
             { l1=P1; ...; ln=Pn; _}   (flag = Open)

             Invariant: n > 0
           *)
    | Ppat_array of pattern list
          (* [| P1; ...; Pn |] *)
    | Ppat_or of pattern * pattern
          (* P1 | P2 *)
    | Ppat_constraint of pattern * core_type
          (* (P : T) *)
    | Ppat_type of Longident.t loc
          (* #tconst *)
    | Ppat_lazy of pattern
          (* lazy P *)
    | Ppat_unpack of string loc
          (* (module P)
             Note: (module P : S) is represented as
             Ppat_constraint(Ppat_unpack, Ptyp_package)
           *)
    | Ppat_exception of pattern
          (* exception P *)
    | Ppat_extension of extension
          (* [%id] *)
    | Ppat_open of Longident.t loc * pattern

  (* Value expressions *)

  and expression (*IF_CURRENT = Parsetree.expression *) =
      {
       pexp_desc: expression_desc;
       pexp_loc: Location.t;
       pexp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =
    | Pexp_ident of Longident.t loc
          (* x
             M.x
           *)
    | Pexp_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Pexp_let of rec_flag * value_binding list * expression
          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
           *)
    | Pexp_function of case list
          (* function P1 -> E1 | ... | Pn -> En *)
    | Pexp_fun of arg_label * expression option * pattern * expression
          (* fun P -> E1                          (Simple, None)
             fun ~l:P -> E1                       (Labelled l, None)
             fun ?l:P -> E1                       (Optional l, None)
             fun ?l:(P = E0) -> E1                (Optional l, Some E0)

             Notes:
             - If E0 is provided, only Optional is allowed.
             - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
             - "let f P = E" is represented using Pexp_fun.
           *)
    | Pexp_apply of expression * (arg_label * expression) list
          (* E0 ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pexp_match of expression * case list
          (* match E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_try of expression * case list
          (* try E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_tuple of expression list
          (* (E1, ..., En)

             Invariant: n >= 2
          *)
    | Pexp_construct of Longident.t loc * expression option
          (* C                None
             C E              Some E
             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
          *)
    | Pexp_variant of label * expression option
          (* `A             (None)
             `A E           (Some E)
           *)
    | Pexp_record of (Longident.t loc * expression) list * expression option
          (* { l1=P1; ...; ln=Pn }     (None)
             { E0 with l1=P1; ...; ln=Pn }   (Some E0)

             Invariant: n > 0
           *)
    | Pexp_field of expression * Longident.t loc
          (* E.l *)
    | Pexp_setfield of expression * Longident.t loc * expression
          (* E1.l <- E2 *)
    | Pexp_array of expression list
          (* [| E1; ...; En |] *)
    | Pexp_ifthenelse of expression * expression * expression option
          (* if E1 then E2 else E3 *)
    | Pexp_sequence of expression * expression
          (* E1; E2 *)
    | Pexp_while of expression * expression
          (* while E1 do E2 done *)
    | Pexp_for of
        pattern *  expression * expression * direction_flag * expression
          (* for i = E1 to E2 do E3 done      (flag = Upto)
             for i = E1 downto E2 do E3 done  (flag = Downto)
           *)
    | Pexp_constraint of expression * core_type
          (* (E : T) *)
    | Pexp_coerce of expression * core_type option * core_type
          (* (E :> T)        (None, T)
             (E : T0 :> T)   (Some T0, T)
           *)
    | Pexp_send of expression * string
          (*  E # m *)
    | Pexp_new of Longident.t loc
          (* new M.c *)
    | Pexp_setinstvar of string loc * expression
          (* x <- 2 *)
    | Pexp_override of (string loc * expression) list
          (* {< x1 = E1; ...; Xn = En >} *)
    | Pexp_letmodule of string loc * module_expr * expression
          (* let module M = ME in E *)
    | Pexp_letexception of extension_constructor * expression
          (* let exception C in E *)
    | Pexp_assert of expression
          (* assert E
             Note: "assert false" is treated in a special way by the
             type-checker. *)
    | Pexp_lazy of expression
          (* lazy E *)
    | Pexp_poly of expression * core_type option
          (* Used for method bodies.

             Can only be used as the expression under Cfk_concrete
             for methods (not values). *)
    | Pexp_object of class_structure
          (* object ... end *)
    | Pexp_newtype of string * expression
          (* fun (type t) -> E *)
    | Pexp_pack of module_expr
          (* (module ME)

             (module ME : S) is represented as
             Pexp_constraint(Pexp_pack, Ptyp_package S) *)
    | Pexp_open of override_flag * Longident.t loc * expression
          (* let open M in E
             let! open M in E
          *)
    | Pexp_extension of extension
          (* [%id] *)
    | Pexp_unreachable
          (* . *)

  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)
      {
       pc_lhs: pattern;
       pc_guard: expression option;
       pc_rhs: expression;
      }

  (* Value descriptions *)

  and value_description (*IF_CURRENT = Parsetree.value_description *) =
      {
       pval_name: string loc;
       pval_type: core_type;
       pval_prim: string list;
       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
       pval_loc: Location.t;
      }

  (*
    val x: T                            (prim = [])
    external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])
  *)

  (* Type declarations *)

  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =
      {
       ptype_name: string loc;
       ptype_params: (core_type * variance) list;
             (* ('a1,...'an) t; None represents  _*)
       ptype_cstrs: (core_type * core_type * Location.t) list;
             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
       ptype_kind: type_kind;
       ptype_private: private_flag;   (* = private ... *)
       ptype_manifest: core_type option;  (* = T *)
       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       ptype_loc: Location.t;
      }

  (*
    type t                     (abstract, no manifest)
    type t = T0                (abstract, manifest=T0)
    type t = C of T | ...      (variant,  no manifest)
    type t = T0 = C of T | ... (variant,  manifest=T0)
    type t = {l: T; ...}       (record,   no manifest)
    type t = T0 = {l : T; ...} (record,   manifest=T0)
    type t = ..                (open,     no manifest)
  *)

  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =
    | Ptype_abstract
    | Ptype_variant of constructor_declaration list
          (* Invariant: non-empty list *)
    | Ptype_record of label_declaration list
          (* Invariant: non-empty list *)
    | Ptype_open

  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =
      {
       pld_name: string loc;
       pld_mutable: mutable_flag;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes; (* l [@id1] [@id2] : T *)
      }

  (*  { ...; l: T; ... }            (mutable=Immutable)
      { ...; mutable l: T; ... }    (mutable=Mutable)

      Note: T can be a Ptyp_poly.
  *)

  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =
      {
       pcd_name: string loc;
       pcd_args: constructor_arguments;
       pcd_res: core_type option;
       pcd_loc: Location.t;
       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =
    | Pcstr_tuple of core_type list
    | Pcstr_record of label_declaration list

  (*
    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])
    | C: T0                  (res = Some T0, args = [])
    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)
    | C of {...}             (res = None,    args = Pcstr_record)
    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)
    | C of {...} as t        (res = None,    args = Pcstr_record)
  *)

  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =
      {
       ptyext_path: Longident.t loc;
       ptyext_params: (core_type * variance) list;
       ptyext_constructors: extension_constructor list;
       ptyext_private: private_flag;
       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
      }
  (*
    type t += ...
  *)

  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =
      {
       pext_name: string loc;
       pext_kind : extension_constructor_kind;
       pext_loc : Location.t;
       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =
      Pext_decl of constructor_arguments * core_type option
        (*
           | C of T1 * ... * Tn     ([T1; ...; Tn], None)
           | C: T0                  ([], Some T0)
           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
         *)
    | Pext_rebind of Longident.t loc
        (*
           | C = D
         *)

  (** {2 Class language} *)

  (* Type expressions for the class language *)

  and class_type (*IF_CURRENT = Parsetree.class_type *) =
      {
       pcty_desc: class_type_desc;
       pcty_loc: Location.t;
       pcty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =
    | Pcty_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcty_signature of class_signature
          (* object ... end *)
    | Pcty_arrow of arg_label * core_type * class_type
          (* T -> CT       Simple
             ~l:T -> CT    Labelled l
             ?l:T -> CT    Optional l
           *)
    | Pcty_extension of extension
          (* [%id] *)

  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =
      {
       pcsig_self: core_type;
       pcsig_fields: class_type_field list;
      }
  (* object('selfpat) ... end
     object ... end             (self = Ptyp_any)
   *)

  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =
      {
       pctf_desc: class_type_field_desc;
       pctf_loc: Location.t;
       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =
    | Pctf_inherit of class_type
          (* inherit CT *)
    | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
          (* val x: T *)
    | Pctf_method  of (string * private_flag * virtual_flag * core_type)
          (* method x: T

             Note: T can be a Ptyp_poly.
           *)
    | Pctf_constraint  of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pctf_attribute of attribute
          (* [@@@id] *)
    | Pctf_extension of extension
          (* [%%id] *)

  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =
      {
       pci_virt: virtual_flag;
       pci_params: (core_type * variance) list;
       pci_name: string loc;
       pci_expr: 'a;
       pci_loc: Location.t;
       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
      }
  (* class c = ...
     class ['a1,...,'an] c = ...
     class virtual c = ...

     Also used for "class type" declaration.
  *)

  and class_description = class_type class_infos

  and class_type_declaration = class_type class_infos

  (* Value expressions for the class language *)

  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =
      {
       pcl_desc: class_expr_desc;
       pcl_loc: Location.t;
       pcl_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =
    | Pcl_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcl_structure of class_structure
          (* object ... end *)
    | Pcl_fun of arg_label * expression option * pattern * class_expr
          (* fun P -> CE                          (Simple, None)
             fun ~l:P -> CE                       (Labelled l, None)
             fun ?l:P -> CE                       (Optional l, None)
             fun ?l:(P = E0) -> CE                (Optional l, Some E0)
           *)
    | Pcl_apply of class_expr * (arg_label * expression) list
          (* CE ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pcl_let of rec_flag * value_binding list * class_expr
          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
           *)
    | Pcl_constraint of class_expr * class_type
          (* (CE : CT) *)
    | Pcl_extension of extension
          (* [%id] *)

  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =
      {
       pcstr_self: pattern;
       pcstr_fields: class_field list;
      }
  (* object(selfpat) ... end
     object ... end           (self = Ppat_any)
   *)

  and class_field (*IF_CURRENT = Parsetree.class_field *) =
      {
       pcf_desc: class_field_desc;
       pcf_loc: Location.t;
       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =
    | Pcf_inherit of override_flag * class_expr * string option
          (* inherit CE
             inherit CE as x
             inherit! CE
             inherit! CE as x
           *)
    | Pcf_val of (string loc * mutable_flag * class_field_kind)
          (* val x = E
             val virtual x: T
           *)
    | Pcf_method of (string loc * private_flag * class_field_kind)
          (* method x = E            (E can be a Pexp_poly)
             method virtual x: T     (T can be a Ptyp_poly)
           *)
    | Pcf_constraint of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pcf_initializer of expression
          (* initializer E *)
    | Pcf_attribute of attribute
          (* [@@@id] *)
    | Pcf_extension of extension
          (* [%%id] *)

  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =
    | Cfk_virtual of core_type
    | Cfk_concrete of override_flag * expression

  and class_declaration = class_expr class_infos

  (** {2 Module language} *)

  (* Type expressions for the module language *)

  and module_type (*IF_CURRENT = Parsetree.module_type *) =
      {
       pmty_desc: module_type_desc;
       pmty_loc: Location.t;
       pmty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =
    | Pmty_ident of Longident.t loc
          (* S *)
    | Pmty_signature of signature
          (* sig ... end *)
    | Pmty_functor of string loc * module_type option * module_type
          (* functor(X : MT1) -> MT2 *)
    | Pmty_with of module_type * with_constraint list
          (* MT with ... *)
    | Pmty_typeof of module_expr
          (* module type of ME *)
    | Pmty_extension of extension
          (* [%id] *)
    | Pmty_alias of Longident.t loc
          (* (module M) *)

  and signature = signature_item list

  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =
      {
       psig_desc: signature_item_desc;
       psig_loc: Location.t;
      }

  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =
    | Psig_value of value_description
          (*
            val x: T
            external x: T = "s1" ... "sn"
           *)
    | Psig_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Psig_typext of type_extension
          (* type t1 += ... *)
    | Psig_exception of extension_constructor
          (* exception C of T *)
    | Psig_module of module_declaration
          (* module X : MT *)
    | Psig_recmodule of module_declaration list
          (* module rec X1 : MT1 and ... and Xn : MTn *)
    | Psig_modtype of module_type_declaration
          (* module type S = MT
             module type S *)
    | Psig_open of open_description
          (* open X *)
    | Psig_include of include_description
          (* include MT *)
    | Psig_class of class_description list
          (* class c1 : ... and ... and cn : ... *)
    | Psig_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Psig_attribute of attribute
          (* [@@@id] *)
    | Psig_extension of extension * attributes
          (* [%%id] *)

  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =
      {
       pmd_name: string loc;
       pmd_type: module_type;
       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmd_loc: Location.t;
      }
  (* S : MT *)

  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =
      {
       pmtd_name: string loc;
       pmtd_type: module_type option;
       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmtd_loc: Location.t;
      }
  (* S = MT
     S       (abstract module type declaration, pmtd_type = None)
  *)

  and open_description (*IF_CURRENT = Parsetree.open_description *) =
      {
       popen_lid: Longident.t loc;
       popen_override: override_flag;
       popen_loc: Location.t;
       popen_attributes: attributes;
      }
  (* open! X - popen_override = Override (silences the 'used identifier
                                shadowing' warning)
     open  X - popen_override = Fresh
   *)

  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =
      {
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
      }

  and include_description = module_type include_infos
  (* include MT *)

  and include_declaration = module_expr include_infos
  (* include ME *)

  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =
    | Pwith_type of Longident.t loc * type_declaration
          (* with type X.t = ...

             Note: the last component of the longident must match
             the name of the type_declaration. *)
    | Pwith_module of Longident.t loc * Longident.t loc
          (* with module X.Y = Z *)
    | Pwith_typesubst of type_declaration
          (* with type t := ... *)
    | Pwith_modsubst of string loc * Longident.t loc
          (* with module X := Z *)

  (* Value expressions for the module language *)

  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =
      {
       pmod_desc: module_expr_desc;
       pmod_loc: Location.t;
       pmod_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =
    | Pmod_ident of Longident.t loc
          (* X *)
    | Pmod_structure of structure
          (* struct ... end *)
    | Pmod_functor of string loc * module_type option * module_expr
          (* functor(X : MT1) -> ME *)
    | Pmod_apply of module_expr * module_expr
          (* ME1(ME2) *)
    | Pmod_constraint of module_expr * module_type
          (* (ME : MT) *)
    | Pmod_unpack of expression
          (* (val E) *)
    | Pmod_extension of extension
          (* [%id] *)

  and structure = structure_item list

  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =
      {
       pstr_desc: structure_item_desc;
       pstr_loc: Location.t;
      }

  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =
    | Pstr_eval of expression * attributes
          (* E *)
    | Pstr_value of rec_flag * value_binding list
          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
           *)
    | Pstr_primitive of value_description
          (*  val x: T
              external x: T = "s1" ... "sn" *)
    | Pstr_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Pstr_typext of type_extension
          (* type t1 += ... *)
    | Pstr_exception of extension_constructor
          (* exception C of T
             exception C = M.X *)
    | Pstr_module of module_binding
          (* module X = ME *)
    | Pstr_recmodule of module_binding list
          (* module rec X1 = ME1 and ... and Xn = MEn *)
    | Pstr_modtype of module_type_declaration
          (* module type S = MT *)
    | Pstr_open of open_description
          (* open X *)
    | Pstr_class of class_declaration list
          (* class c1 = ... and ... and cn = ... *)
    | Pstr_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Pstr_include of include_declaration
          (* include ME *)
    | Pstr_attribute of attribute
          (* [@@@id] *)
    | Pstr_extension of extension * attributes
          (* [%%id] *)

  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =
    {
      pvb_pat: pattern;
      pvb_expr: expression;
      pvb_attributes: attributes;
      pvb_loc: Location.t;
    }

  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =
      {
       pmb_name: string loc;
       pmb_expr: module_expr;
       pmb_attributes: attributes;
       pmb_loc: Location.t;
      }
  (* X = ME *)

  (** {2 Toplevel} *)

  (* Toplevel phrases *)

  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =
    | Ptop_def of structure
    | Ptop_dir of string * directive_argument
       (* #use, #load ... *)

  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =
    | Pdir_none
    | Pdir_string of string
    | Pdir_int of string * char option
    | Pdir_ident of Longident.t
    | Pdir_bool of bool
end

module Docstrings : sig
  (** {3 Docstrings} *)

  (** Documentation comments *)
  type docstring

  (** Create a docstring *)
  val docstring : string -> Location.t -> docstring

  (** Get the text of a docstring *)
  val docstring_body : docstring -> string

  (** Get the location of a docstring *)
  val docstring_loc : docstring -> Location.t

  (** {3 Items}

      The {!docs} type represents documentation attached to an item. *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  val empty_docs : docs

  val docs_attr : docstring -> Parsetree.attribute

  (** Convert item documentation to attributes and add them to an
      attribute list *)
  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. *)

  type info = docstring option

  val empty_info : info

  val info_attr : docstring -> Parsetree.attribute

  (** Convert field info to attributes and add them to an
      attribute list *)
  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. *)

  type text = docstring list

  val empty_text : text

  val text_attr : docstring -> Parsetree.attribute

  (** Convert text to attributes and add them to an attribute list *)
  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

end = struct
  open Location

  (* Docstrings *)

  type docstring =
    { ds_body: string;
      ds_loc: Location.t; }

  (* Docstring constructors and destructors *)

  let docstring body loc =
    let ds =
      { ds_body = body;
        ds_loc = loc; }
    in
    ds

  let docstring_body ds = ds.ds_body

  let docstring_loc ds = ds.ds_loc

  (* Docstrings attached to items *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  let empty_docs = { docs_pre = None; docs_post = None }

  let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

  let docs_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (doc_loc, PStr [item])

  let add_docs_attrs docs attrs =
    let attrs =
      match docs.docs_pre with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> docs_attr ds :: attrs
    in
    let attrs =
      match docs.docs_post with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> attrs @ [docs_attr ds]
    in
    attrs

  (* Docstrings attached to constructors or fields *)

  type info = docstring option

  let empty_info = None

  let info_attr = docs_attr

  let add_info_attrs info attrs =
    match info with
    | None | Some {ds_body=""; _} -> attrs
    | Some ds -> attrs @ [info_attr ds]

  (* Docstrings not attached to a specific item *)

  type text = docstring list

  let empty_text = []

  let text_loc = {txt = "ocaml.text"; loc = Location.none}

  let text_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (text_loc, PStr [item])

  let add_text_attrs dsl attrs =
    let fdsl = List.filter (function {ds_body=""; _} -> false| _ ->true) dsl in
    (List.map text_attr fdsl) @ attrs

end

module Ast_helper : sig
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Docstrings
  open Parsetree

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  (** {2 Default locations} *)

  val default_loc: loc ref
      (** Default value for all optional location arguments. *)

  val with_default_loc: loc -> (unit -> 'a) -> 'a
      (** Set the [default_loc] within the scope of the execution
          of the provided function. *)

  (** {2 Constants} *)

  module Const : sig
    val char : char -> constant
    val string : ?quotation_delimiter:string -> string -> constant
    val integer : ?suffix:char -> string -> constant
    val int : ?suffix:char -> int -> constant
    val int32 : ?suffix:char -> int32 -> constant
    val int64 : ?suffix:char -> int64 -> constant
    val nativeint : ?suffix:char -> nativeint -> constant
    val float : ?suffix:char -> string -> constant
  end

  (** {2 Core language} *)

  (** Type expressions *)
  module Typ :
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
      val attr: core_type -> attribute -> core_type

      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type
                 -> core_type
      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val object_: ?loc:loc -> ?attrs:attrs ->
                    (string * attributes * core_type) list -> closed_flag ->
                    core_type
      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                   -> label list option -> core_type
      val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type
      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                   -> core_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

      val force_poly: core_type -> core_type
    end

  (** Patterns *)
  module Pat:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
      val attr:pattern -> attribute -> pattern

      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                  -> pattern
      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern
      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
    end

  (** Expressions *)
  module Exp:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
      val attr: expression -> attribute -> expression

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
                -> expression -> expression
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option
                -> pattern -> expression -> expression
      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
      val apply: ?loc:loc -> ?attrs:attrs -> expression
                 -> (arg_label * expression) list -> expression
      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                  -> expression
      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                     -> expression
      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                   -> expression
      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                  -> expression option -> expression
      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                    -> expression
      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                      -> expression option -> expression
      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression
      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
                -> direction_flag -> expression -> expression
      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                  -> core_type -> expression
      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                       -> expression
      val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression
      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                    -> expression
      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                     -> expression
      val letexception:
        ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression
        -> expression
      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> expression
      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
      val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression
      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression
                 -> expression
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression

      val case: pattern -> ?guard:expression -> expression -> case
    end

  (** Value declarations *)
  module Val:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        ?prim:string list -> str -> core_type -> value_description
    end

  (** Type declarations *)
  module Type:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?params:(core_type * variance) list ->
        ?cstrs:(core_type * core_type * loc) list ->
        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
        type_declaration

      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        constructor_declaration
      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?mut:mutable_flag -> str -> core_type -> label_declaration
    end

  (** Type extensions *)
  module Te:
    sig
      val mk: ?attrs:attrs -> ?docs:docs ->
        ?params:(core_type * variance) list -> ?priv:private_flag ->
        lid -> extension_constructor list -> type_extension

      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> extension_constructor_kind -> extension_constructor

      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        extension_constructor
      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> lid -> extension_constructor
    end

  (** {2 Module language} *)

  (** Module type expressions *)
  module Mty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
      val attr: module_type -> attribute -> module_type

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_type -> module_type
      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->
        with_constraint list -> module_type
      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
    end

  (** Module expressions *)
  module Mod:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
      val attr: module_expr -> attribute -> module_expr

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_expr -> module_expr
      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->
        module_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->
        module_expr
      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
    end

  (** Signature items *)
  module Sig:
    sig
      val mk: ?loc:loc -> signature_item_desc -> signature_item

      val value: ?loc:loc -> value_description -> signature_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item
      val type_extension: ?loc:loc -> type_extension -> signature_item
      val exception_: ?loc:loc -> extension_constructor -> signature_item
      val module_: ?loc:loc -> module_declaration -> signature_item
      val rec_module: ?loc:loc -> module_declaration list -> signature_item
      val modtype: ?loc:loc -> module_type_declaration -> signature_item
      val open_: ?loc:loc -> open_description -> signature_item
      val include_: ?loc:loc -> include_description -> signature_item
      val class_: ?loc:loc -> class_description list -> signature_item
      val class_type: ?loc:loc -> class_type_declaration list -> signature_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
      val attribute: ?loc:loc -> attribute -> signature_item
      val text: text -> signature_item list
    end

  (** Structure items *)
  module Str:
    sig
      val mk: ?loc:loc -> structure_item_desc -> structure_item

      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
      val primitive: ?loc:loc -> value_description -> structure_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item
      val type_extension: ?loc:loc -> type_extension -> structure_item
      val exception_: ?loc:loc -> extension_constructor -> structure_item
      val module_: ?loc:loc -> module_binding -> structure_item
      val rec_module: ?loc:loc -> module_binding list -> structure_item
      val modtype: ?loc:loc -> module_type_declaration -> structure_item
      val open_: ?loc:loc -> open_description -> structure_item
      val class_: ?loc:loc -> class_declaration list -> structure_item
      val class_type: ?loc:loc -> class_type_declaration list -> structure_item
      val include_: ?loc:loc -> include_declaration -> structure_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
      val attribute: ?loc:loc -> attribute -> structure_item
      val text: text -> structure_item list
    end

  (** Module declarations *)
  module Md:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_type -> module_declaration
    end

  (** Module type declarations *)
  module Mtd:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?typ:module_type -> str -> module_type_declaration
    end

  (** Module bindings *)
  module Mb:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_expr -> module_binding
    end

  (** Opens *)
  module Opn:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
        ?override:override_flag -> lid -> open_description
    end

  (** Includes *)
  module Incl:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
    end

  (** Value bindings *)
  module Vb:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        pattern -> expression -> value_binding
    end


  (** {2 Class language} *)

  (** Class type expressions *)
  module Cty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
      val attr: class_type -> attribute -> class_type

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->
        class_type -> class_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
    end

  (** Class type fields *)
  module Ctf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        class_type_field_desc -> class_type_field
      val attr: class_type_field -> attribute -> class_type_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
      val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag ->
        virtual_flag -> core_type -> class_type_field
      val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag ->
        virtual_flag -> core_type -> class_type_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_type_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
      val attribute: ?loc:loc -> attribute -> class_type_field
      val text: text -> class_type_field list
    end

  (** Class expressions *)
  module Cl:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
      val attr: class_expr -> attribute -> class_expr

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->
        pattern -> class_expr -> class_expr
      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->
        (arg_label * expression) list -> class_expr
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->
        class_expr -> class_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->
        class_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
    end

  (** Class fields *)
  module Cf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->
        class_field
      val attr: class_field -> attribute -> class_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->
        string option -> class_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        class_field_kind -> class_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        class_field_kind -> class_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_field
      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
      val attribute: ?loc:loc -> attribute -> class_field
      val text: text -> class_field list

      val virtual_: core_type -> class_field_kind
      val concrete: override_flag -> expression -> class_field_kind

    end

  (** Classes *)
  module Ci:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?virt:virtual_flag -> ?params:(core_type * variance) list ->
        str -> 'a -> 'a class_infos
    end

  (** Class signatures *)
  module Csig:
    sig
      val mk: core_type -> class_type_field list -> class_signature
    end

  (** Class structures *)
  module Cstr:
    sig
      val mk: pattern -> class_field list -> class_structure
    end

end = struct
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Parsetree
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  let default_loc = ref Location.none

  let with_default_loc l f =
    let old = !default_loc in
    default_loc := l;
    try let r = f () in default_loc := old; r
    with exn -> default_loc := old; raise exn

  module Const = struct
    let integer ?suffix i = Pconst_integer (i, suffix)
    let int ?suffix i = integer ?suffix (string_of_int i)
    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
    let float ?suffix f = Pconst_float (f, suffix)
    let char c = Pconst_char c
    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)
  end

  module Typ = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

    let force_poly t =
      match t.ptyp_desc with
      | Ptyp_poly _ -> t
      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)
  end

  module Pat = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
    let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))
    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
  end

  module Exp = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
    let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))
    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable

    let case lhs ?guard rhs =
      {
       pc_lhs = lhs;
       pc_guard = guard;
       pc_rhs = rhs;
      }
  end

  module Mty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
  end

  module Mod = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
    let functor_ ?loc ?attrs arg arg_ty body =
      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
  end

  module Sig = struct
    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

    let value ?loc a = mk ?loc (Psig_value a)
    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Psig_typext a)
    let exception_ ?loc a = mk ?loc (Psig_exception a)
    let module_ ?loc a = mk ?loc (Psig_module a)
    let rec_module ?loc a = mk ?loc (Psig_recmodule a)
    let modtype ?loc a = mk ?loc (Psig_modtype a)
    let open_ ?loc a = mk ?loc (Psig_open a)
    let include_ ?loc a = mk ?loc (Psig_include a)
    let class_ ?loc a = mk ?loc (Psig_class a)
    let class_type ?loc a = mk ?loc (Psig_class_type a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Psig_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Str = struct
    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
    let value ?loc a b = mk ?loc (Pstr_value (a, b))
    let primitive ?loc a = mk ?loc (Pstr_primitive a)
    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Pstr_typext a)
    let exception_ ?loc a = mk ?loc (Pstr_exception a)
    let module_ ?loc a = mk ?loc (Pstr_module a)
    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
    let modtype ?loc a = mk ?loc (Pstr_modtype a)
    let open_ ?loc a = mk ?loc (Pstr_open a)
    let class_ ?loc a = mk ?loc (Pstr_class a)
    let class_type ?loc a = mk ?loc (Pstr_class_type a)
    let include_ ?loc a = mk ?loc (Pstr_include a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Pstr_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Cl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcl_desc = d;
       pcl_loc = loc;
       pcl_attributes = attrs;
      }
    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
  end

  module Cty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcty_desc = d;
       pcty_loc = loc;
       pcty_attributes = attrs;
      }
    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
  end

  module Ctf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
             ?(docs = empty_docs) d =
      {
       pctf_desc = d;
       pctf_loc = loc;
       pctf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
    let attribute ?loc a = mk ?loc (Pctf_attribute a)
    let text txt =
     let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
       List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

  end

  module Cf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) d =
      {
       pcf_desc = d;
       pcf_loc = loc;
       pcf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
    let attribute ?loc a = mk ?loc (Pcf_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let virtual_ ct = Cfk_virtual ct
    let concrete o e = Cfk_concrete (o, e)

    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

  end

  module Val = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(prim = []) name typ =
      {
       pval_name = name;
       pval_type = typ;
       pval_attributes = add_docs_attrs docs attrs;
       pval_loc = loc;
       pval_prim = prim;
      }
  end

  module Md = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name typ =
      {
       pmd_name = name;
       pmd_type = typ;
       pmd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmd_loc = loc;
      }
  end

  module Mtd = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) ?typ name =
      {
       pmtd_name = name;
       pmtd_type = typ;
       pmtd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmtd_loc = loc;
      }
  end

  module Mb = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name expr =
      {
       pmb_name = name;
       pmb_expr = expr;
       pmb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmb_loc = loc;
      }
  end

  module Opn = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(override = Fresh) lid =
      {
       popen_lid = lid;
       popen_override = override;
       popen_loc = loc;
       popen_attributes = add_docs_attrs docs attrs;
      }
  end

  module Incl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
      {
       pincl_mod = mexpr;
       pincl_loc = loc;
       pincl_attributes = add_docs_attrs docs attrs;
      }

  end

  module Vb = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(text = []) pat expr =
      {
       pvb_pat = pat;
       pvb_expr = expr;
       pvb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pvb_loc = loc;
      }
  end

  module Ci = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
          ?(virt = Concrete) ?(params = []) name expr =
      {
       pci_virt = virt;
       pci_params = params;
       pci_name = name;
       pci_expr = expr;
       pci_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pci_loc = loc;
      }
  end

  module Type = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
        ?(params = [])
        ?(cstrs = [])
        ?(kind = Ptype_abstract)
        ?(priv = Public)
        ?manifest
        name =
      {
       ptype_name = name;
       ptype_params = params;
       ptype_cstrs = cstrs;
       ptype_kind = kind;
       ptype_private = priv;
       ptype_manifest = manifest;
       ptype_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       ptype_loc = loc;
      }

    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(args = Pcstr_tuple []) ?res name =
      {
       pcd_name = name;
       pcd_args = args;
       pcd_res = res;
       pcd_loc = loc;
       pcd_attributes = add_info_attrs info attrs;
      }

    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(mut = Immutable) name typ =
      {
       pld_name = name;
       pld_mutable = mut;
       pld_type = typ;
       pld_loc = loc;
       pld_attributes = add_info_attrs info attrs;
      }

  end

  (** Type extensions *)
  module Te = struct
    let mk ?(attrs = []) ?(docs = empty_docs)
          ?(params = []) ?(priv = Public) path constructors =
      {
       ptyext_path = path;
       ptyext_params = params;
       ptyext_constructors = constructors;
       ptyext_private = priv;
       ptyext_attributes = add_docs_attrs docs attrs;
      }

    let constructor ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name kind =
      {
       pext_name = name;
       pext_kind = kind;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =
      {
       pext_name = name;
       pext_kind = Pext_decl(args, res);
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let rebind ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name lid =
      {
       pext_name = name;
       pext_kind = Pext_rebind lid;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

  end

  module Csig = struct
    let mk self fields =
      {
       pcsig_self = self;
       pcsig_fields = fields;
      }
  end

  module Cstr = struct
    let mk self fields =
      {
       pcstr_self = self;
       pcstr_fields = fields;
      }
  end

end

module Ast_mapper : sig
  (** The interface of a -ppx rewriter

    A -ppx rewriter is a program that accepts a serialized abstract syntax
    tree and outputs another, possibly modified, abstract syntax tree.
    This module encapsulates the interface between the compiler and
    the -ppx rewriters, handling such details as the serialization format,
    forwarding of command-line flags, and storing state.

    {!mapper} allows to implement AST rewriting using open recursion.
    A typical mapper would be based on {!default_mapper}, a deep
    identity mapper, and will fall back on it for handling the syntax it
    does not modify. For example:

    {[
  open Asttypes
  open Parsetree
  open Ast_mapper

  let test_mapper argv =
    { default_mapper with
      expr = fun mapper expr ->
        match expr with
        | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
          Ast_helper.Exp.constant (Const_int 42)
        | other -> default_mapper.expr mapper other; }

  let () =
    register "ppx_test" test_mapper]}

    This -ppx rewriter, which replaces [[%test]] in expressions with
    the constant [42], can be compiled using
    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

    *)

  open Parsetree

  (** {2 A generic Parsetree mapper} *)

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }
  (** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. *)

  val default_mapper: mapper
  (** A default mapper, which implements a "deep identity" mapping. *)

  (** {2 Convenience functions to write mappers} *)

  val map_opt: ('a -> 'b) -> 'a option -> 'b option

  val extension_of_error: Location.error -> extension
  (** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. *)

  val attribute_of_warning: Location.t -> string -> attribute
  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. *)

end = struct
  (* A generic Parsetree mapping class *)

  (*
  [@@@ocaml.warning "+9"]
    (* Ensure that record patterns don't miss any field. *)
  *)


  open Parsetree
  open Ast_helper
  open Location

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }

  let map_fst f (x, y) = (f x, y)
  let map_snd f (x, y) = (x, f y)
  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
  let map_opt f = function None -> None | Some x -> Some (f x)

  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

  module T = struct
    (* Type expressions for the core language *)

    let row_field sub = function
      | Rtag (l, attrs, b, tl) ->
          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
      | Rinherit t -> Rinherit (sub.typ sub t)

    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
      let open Typ in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ptyp_any -> any ~loc ~attrs ()
      | Ptyp_var s -> var ~loc ~attrs s
      | Ptyp_arrow (lab, t1, t2) ->
          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
      | Ptyp_constr (lid, tl) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_object (l, o) ->
          let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in
          object_ ~loc ~attrs (List.map f l) o
      | Ptyp_class (lid, tl) ->
          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
      | Ptyp_variant (rl, b, ll) ->
          variant ~loc ~attrs (List.map (row_field sub) rl) b ll
      | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)
      | Ptyp_package (lid, l) ->
          package ~loc ~attrs (map_loc sub lid)
            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_type_declaration sub
        {ptype_name; ptype_params; ptype_cstrs;
         ptype_kind;
         ptype_private;
         ptype_manifest;
         ptype_attributes;
         ptype_loc} =
      Type.mk (map_loc sub ptype_name)
        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
        ~priv:ptype_private
        ~cstrs:(List.map
                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                  ptype_cstrs)
        ~kind:(sub.type_kind sub ptype_kind)
        ?manifest:(map_opt (sub.typ sub) ptype_manifest)
        ~loc:(sub.location sub ptype_loc)
        ~attrs:(sub.attributes sub ptype_attributes)

    let map_type_kind sub = function
      | Ptype_abstract -> Ptype_abstract
      | Ptype_variant l ->
          Ptype_variant (List.map (sub.constructor_declaration sub) l)
      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
      | Ptype_open -> Ptype_open

    let map_constructor_arguments sub = function
      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)
      | Pcstr_record l ->
          Pcstr_record (List.map (sub.label_declaration sub) l)

    let map_type_extension sub
        {ptyext_path; ptyext_params;
         ptyext_constructors;
         ptyext_private;
         ptyext_attributes} =
      Te.mk
        (map_loc sub ptyext_path)
        (List.map (sub.extension_constructor sub) ptyext_constructors)
        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
        ~priv:ptyext_private
        ~attrs:(sub.attributes sub ptyext_attributes)

    let map_extension_constructor_kind sub = function
        Pext_decl(ctl, cto) ->
          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)
      | Pext_rebind li ->
          Pext_rebind (map_loc sub li)

    let map_extension_constructor sub
        {pext_name;
         pext_kind;
         pext_loc;
         pext_attributes} =
      Te.constructor
        (map_loc sub pext_name)
        (map_extension_constructor_kind sub pext_kind)
        ~loc:(sub.location sub pext_loc)
        ~attrs:(sub.attributes sub pext_attributes)

  end

  module CT = struct
    (* Type expressions for the class language *)

    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
      let open Cty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcty_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
      | Pcty_arrow (lab, t, ct) ->
          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
      =
      let open Ctf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
      | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)
      | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)
      | Pctf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_signature sub {pcsig_self; pcsig_fields} =
      Csig.mk
        (sub.typ sub pcsig_self)
        (List.map (sub.class_type_field sub) pcsig_fields)
  end

  module MT = struct
    (* Type expressions for the module language *)

    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
      let open Mty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
      | Pmty_functor (s, mt1, mt2) ->
          functor_ ~loc ~attrs (map_loc sub s)
            (Misc.may_map (sub.module_type sub) mt1)
            (sub.module_type sub mt2)
      | Pmty_with (mt, l) ->
          with_ ~loc ~attrs (sub.module_type sub mt)
            (List.map (sub.with_constraint sub) l)
      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_with_constraint sub = function
      | Pwith_type (lid, d) ->
          Pwith_type (map_loc sub lid, sub.type_declaration sub d)
      | Pwith_module (lid, lid2) ->
          Pwith_module (map_loc sub lid, map_loc sub lid2)
      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
      | Pwith_modsubst (s, lid) ->
          Pwith_modsubst (map_loc sub s, map_loc sub lid)

    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
      let open Sig in
      let loc = sub.location sub loc in
      match desc with
      | Psig_value vd -> value ~loc (sub.value_description sub vd)
      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
      | Psig_recmodule l ->
          rec_module ~loc (List.map (sub.module_declaration sub) l)
      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Psig_open x -> open_ ~loc (sub.open_description sub x)
      | Psig_include x -> include_ ~loc (sub.include_description sub x)
      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
      | Psig_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Psig_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
  end


  module M = struct
    (* Value expressions for the module language *)

    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
      let open Mod in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
      | Pmod_functor (arg, arg_ty, body) ->
          functor_ ~loc ~attrs (map_loc sub arg)
            (Misc.may_map (sub.module_type sub) arg_ty)
            (sub.module_expr sub body)
      | Pmod_apply (m1, m2) ->
          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
      | Pmod_constraint (m, mty) ->
          constraint_ ~loc ~attrs (sub.module_expr sub m)
                      (sub.module_type sub mty)
      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
      let open Str in
      let loc = sub.location sub loc in
      match desc with
      | Pstr_eval (x, attrs) ->
          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Pstr_open x -> open_ ~loc (sub.open_description sub x)
      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
      | Pstr_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
      | Pstr_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
  end

  module E = struct
    (* Value expressions for the core language *)

    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
      let open Exp in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pexp_constant x -> constant ~loc ~attrs x
      | Pexp_let (r, vbs, e) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.expr sub e)
      | Pexp_fun (lab, def, p, e) ->
          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
            (sub.expr sub e)
      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
      | Pexp_apply (e, l) ->
          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
      | Pexp_match (e, pel) ->
          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_construct (lid, arg) ->
          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
      | Pexp_variant (lab, eo) ->
          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
      | Pexp_record (l, eo) ->
          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
            (map_opt (sub.expr sub) eo)
      | Pexp_field (e, lid) ->
          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
      | Pexp_setfield (e1, lid, e2) ->
          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
            (sub.expr sub e2)
      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_ifthenelse (e1, e2, e3) ->
          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
            (map_opt (sub.expr sub) e3)
      | Pexp_sequence (e1, e2) ->
          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_while (e1, e2) ->
          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_for (p, e1, e2, d, e3) ->
          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
            (sub.expr sub e3)
      | Pexp_coerce (e, t1, t2) ->
          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
            (sub.typ sub t2)
      | Pexp_constraint (e, t) ->
          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
      | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s
      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
      | Pexp_setinstvar (s, e) ->
          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_override sel ->
          override ~loc ~attrs
            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
      | Pexp_letmodule (s, me, e) ->
          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
            (sub.expr sub e)
      | Pexp_letexception (cd, e) ->
          letexception ~loc ~attrs
            (sub.extension_constructor sub cd)
            (sub.expr sub e)
      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
      | Pexp_poly (e, t) ->
          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
      | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)
      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
      | Pexp_open (ovf, lid, e) ->
          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
      | Pexp_unreachable -> unreachable ~loc ~attrs ()
  end

  module P = struct
    (* Patterns *)

    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
      let open Pat in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ppat_any -> any ~loc ~attrs ()
      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
      | Ppat_constant c -> constant ~loc ~attrs c
      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_construct (l, p) ->
          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
      | Ppat_record (lpl, cf) ->
          record ~loc ~attrs
                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
      | Ppat_constraint (p, t) ->
          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
      | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)
      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module CE = struct
    (* Value expressions for the class language *)

    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
      let open Cl in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcl_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcl_structure s ->
          structure ~loc ~attrs (sub.class_structure sub s)
      | Pcl_fun (lab, e, p, ce) ->
          fun_ ~loc ~attrs lab
            (map_opt (sub.expr sub) e)
            (sub.pat sub p)
            (sub.class_expr sub ce)
      | Pcl_apply (ce, l) ->
          apply ~loc ~attrs (sub.class_expr sub ce)
            (List.map (map_snd (sub.expr sub)) l)
      | Pcl_let (r, vbs, ce) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.class_expr sub ce)
      | Pcl_constraint (ce, ct) ->
          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_kind sub = function
      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
      let open Cf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s
      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
      | Pcf_method (s, p, k) ->
          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
      | Pcf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure sub {pcstr_self; pcstr_fields} =
      {
        pcstr_self = sub.pat sub pcstr_self;
        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
      }

    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                           pci_loc; pci_attributes} =
      Ci.mk
       ~virt:pci_virt
       ~params:(List.map (map_fst (sub.typ sub)) pl)
        (map_loc sub pci_name)
        (f pci_expr)
        ~loc:(sub.location sub pci_loc)
        ~attrs:(sub.attributes sub pci_attributes)
  end

  (* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. *)

  let default_mapper =
    {
      structure = (fun this l -> List.map (this.structure_item this) l);
      structure_item = M.map_structure_item;
      module_expr = M.map;
      signature = (fun this l -> List.map (this.signature_item this) l);
      signature_item = MT.map_signature_item;
      module_type = MT.map;
      with_constraint = MT.map_with_constraint;
      class_declaration =
        (fun this -> CE.class_infos this (this.class_expr this));
      class_expr = CE.map;
      class_field = CE.map_field;
      class_structure = CE.map_structure;
      class_type = CT.map;
      class_type_field = CT.map_field;
      class_signature = CT.map_signature;
      class_type_declaration =
        (fun this -> CE.class_infos this (this.class_type this));
      class_description =
        (fun this -> CE.class_infos this (this.class_type this));
      type_declaration = T.map_type_declaration;
      type_kind = T.map_type_kind;
      typ = T.map;
      type_extension = T.map_type_extension;
      extension_constructor = T.map_extension_constructor;
      value_description =
        (fun this {pval_name; pval_type; pval_prim; pval_loc;
                   pval_attributes} ->
          Val.mk
            (map_loc this pval_name)
            (this.typ this pval_type)
            ~attrs:(this.attributes this pval_attributes)
            ~loc:(this.location this pval_loc)
            ~prim:pval_prim
        );

      pat = P.map;
      expr = E.map;

      module_declaration =
        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
           Md.mk
             (map_loc this pmd_name)
             (this.module_type this pmd_type)
             ~attrs:(this.attributes this pmd_attributes)
             ~loc:(this.location this pmd_loc)
        );

      module_type_declaration =
        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
           Mtd.mk
             (map_loc this pmtd_name)
             ?typ:(map_opt (this.module_type this) pmtd_type)
             ~attrs:(this.attributes this pmtd_attributes)
             ~loc:(this.location this pmtd_loc)
        );

      module_binding =
        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
             ~attrs:(this.attributes this pmb_attributes)
             ~loc:(this.location this pmb_loc)
        );


      open_description =
        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
           Opn.mk (map_loc this popen_lid)
             ~override:popen_override
             ~loc:(this.location this popen_loc)
             ~attrs:(this.attributes this popen_attributes)
        );


      include_description =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_type this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );

      include_declaration =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_expr this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );


      value_binding =
        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
           Vb.mk
             (this.pat this pvb_pat)
             (this.expr this pvb_expr)
             ~loc:(this.location this pvb_loc)
             ~attrs:(this.attributes this pvb_attributes)
        );


      constructor_declaration =
        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
          Type.constructor
            (map_loc this pcd_name)
            ~args:(T.map_constructor_arguments this pcd_args)
            ?res:(map_opt (this.typ this) pcd_res)
            ~loc:(this.location this pcd_loc)
            ~attrs:(this.attributes this pcd_attributes)
        );

      label_declaration =
        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
           Type.field
             (map_loc this pld_name)
             (this.typ this pld_type)
             ~mut:pld_mutable
             ~loc:(this.location this pld_loc)
             ~attrs:(this.attributes this pld_attributes)
        );

      cases = (fun this l -> List.map (this.case this) l);
      case =
        (fun this {pc_lhs; pc_guard; pc_rhs} ->
           {
             pc_lhs = this.pat this pc_lhs;
             pc_guard = map_opt (this.expr this) pc_guard;
             pc_rhs = this.expr this pc_rhs;
           }
        );



      location = (fun _this l -> l);

      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attributes = (fun this l -> List.map (this.attribute this) l);
      payload =
        (fun this -> function
           | PStr x -> PStr (this.structure this x)
           | PSig x -> PSig (this.signature this x)
           | PTyp x -> PTyp (this.typ this x)
           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
        );
    }

  let rec extension_of_error {loc; msg; if_highlight; sub} =
    { loc; txt = "ocaml.error" },
    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));
           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @
          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

  let attribute_of_warning loc s =
    { loc; txt = "ocaml.ppwarning" },
    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])

end

module Outcometree = struct
  (* Module [Outcometree]: results displayed by the toplevel *)

  (* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
        [Toploop.print_out_value]
        [Toploop.print_out_type]
        [Toploop.print_out_sig_item]
        [Toploop.print_out_phrase] *)

  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =
    | Oide_apply of out_ident * out_ident
    | Oide_dot of out_ident * string
    | Oide_ident of string

  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =
    { oattr_name: string }

  type out_value (*IF_CURRENT = Outcometree.out_value *) =
    | Oval_array of out_value list
    | Oval_char of char
    | Oval_constr of out_ident * out_value list
    | Oval_ellipsis
    | Oval_float of float
    | Oval_int of int
    | Oval_int32 of int32
    | Oval_int64 of int64
    | Oval_nativeint of nativeint
    | Oval_list of out_value list
    | Oval_printer of (Format.formatter -> unit)
    | Oval_record of (out_ident * out_value) list
    | Oval_string of string
    | Oval_stuff of string
    | Oval_tuple of out_value list
    | Oval_variant of string * out_value option

  type out_type (*IF_CURRENT = Outcometree.out_type *) =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias of out_type * string
    | Otyp_arrow of string * out_type * out_type
    | Otyp_class of bool * out_ident * out_type list
    | Otyp_constr of out_ident * out_type list
    | Otyp_manifest of out_type * out_type
    | Otyp_object of (string * out_type) list * bool option
    | Otyp_record of (string * bool * out_type) list
    | Otyp_stuff of string
    | Otyp_sum of (string * out_type list * out_type option) list
    | Otyp_tuple of out_type list
    | Otyp_var of bool * string
    | Otyp_variant of
        bool * out_variant * bool * (string list) option
    | Otyp_poly of string list * out_type
    | Otyp_module of string * string list * out_type list
    | Otyp_attribute of out_type * out_attribute

  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =
    | Ovar_fields of (string * bool * out_type list) list
    | Ovar_name of out_ident * out_type list

  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =
    | Octy_constr of out_ident * out_type list
    | Octy_arrow of string * out_type * out_class_type
    | Octy_signature of out_type option * out_class_sig_item list
  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =
    | Ocsg_constraint of out_type * out_type
    | Ocsg_method of string * bool * bool * out_type
    | Ocsg_value of string * bool * bool * out_type

  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =
    | Omty_abstract
    | Omty_functor of string * out_module_type option * out_module_type
    | Omty_ident of out_ident
    | Omty_signature of out_sig_item list
    | Omty_alias of out_ident
  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =
    | Osig_class of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_class_type of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_typext of out_extension_constructor * out_ext_status
    | Osig_modtype of string * out_module_type
    | Osig_module of string * out_module_type * out_rec_status
    | Osig_type of out_type_decl * out_rec_status
    | Osig_value of out_val_decl
    | Osig_ellipsis
  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =
    { otype_name: string;
      otype_params: (string * (bool * bool)) list;
      otype_type: out_type;
      otype_private: Asttypes.private_flag;
      otype_immediate: bool;
      otype_unboxed: bool;
      otype_cstrs: (out_type * out_type) list }
  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =
    { oext_name: string;
      oext_type_name: string;
      oext_type_params: string list;
      oext_args: out_type list;
      oext_ret_type: out_type option;
      oext_private: Asttypes.private_flag }
  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =
    { otyext_name: string;
      otyext_params: string list;
      otyext_constructors: (string * out_type list * out_type option) list;
      otyext_private: Asttypes.private_flag }
  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =
    { oval_name: string;
      oval_type: out_type;
      oval_prims: string list;
      oval_attributes: out_attribute list }
  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =
    | Oext_first
    | Oext_next
    | Oext_exception

  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =
    | Ophr_eval of out_value * out_type
    | Ophr_signature of (out_sig_item * out_value option) list
    | Ophr_exception of (exn * out_value)

end

module Config = struct
  let ast_impl_magic_number = "Caml1999M020"
  let ast_intf_magic_number = "Caml1999N018"
end

let map_signature mapper = mapper.Ast_mapper.signature mapper
let map_structure mapper = mapper.Ast_mapper.structure mapper

let failing_mapper =
  let fail _ _ =
    invalid_arg "failing_mapper: this mapper function should never get called"
  in
  {
    Ast_mapper.
    structure               = fail;
    structure_item          = fail;
    module_expr             = fail;
    signature               = fail;
    signature_item          = fail;
    module_type             = fail;
    with_constraint         = fail;
    class_declaration       = fail;
    class_expr              = fail;
    class_field             = fail;
    class_structure         = fail;
    class_type              = fail;
    class_type_field        = fail;
    class_signature         = fail;
    class_type_declaration  = fail;
    class_description       = fail;
    type_declaration        = fail;
    type_kind               = fail;
    typ                     = fail;
    type_extension          = fail;
    extension_constructor   = fail;
    value_description       = fail;
    pat                     = fail;
    expr                    = fail;
    module_declaration      = fail;
    module_type_declaration = fail;
    module_binding          = fail;
    open_description        = fail;
    include_description     = fail;
    include_declaration     = fail;
    value_binding           = fail;
    constructor_declaration = fail;
    label_declaration       = fail;
    cases                   = fail;
    case                    = fail;
    location                = fail;
    extension               = fail;
    attribute               = fail;
    attributes              = fail;
    payload                 = fail;
  }

let make_top_mapper ~signature ~structure =
  {failing_mapper with Ast_mapper.
                    signature = (fun _ x -> signature x);
                    structure = (fun _ x -> structure x) }

end
module Ast_402
= struct
#1 "ast_402.ml"
# 1 "src/ast_402.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*            Jérémie Dimino and Leo White, Jane Street Europe            *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)
(*                         Alain Frisch, LexiFi                           *)
(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Location = Location
module Longident = Longident

module Asttypes = struct
  (* Auxiliary a.s.t. types used by parsetree and typedtree. *)

  type constant              = Asttypes.constant    =
      Const_int of int
    | Const_char of char
    | Const_string of string * string option
    | Const_float of string
    | Const_int32 of int32
    | Const_int64 of int64
    | Const_nativeint of nativeint

  type rec_flag              = Asttypes.rec_flag    = Nonrecursive | Recursive

  type direction_flag              = Asttypes.direction_flag    = Upto | Downto

  type private_flag              = Asttypes.private_flag    = Private | Public

  type mutable_flag              = Asttypes.mutable_flag    = Immutable | Mutable

  type virtual_flag              = Asttypes.virtual_flag    = Virtual | Concrete

  type override_flag              = Asttypes.override_flag    = Override | Fresh

  type closed_flag              = Asttypes.closed_flag    = Closed | Open

  type label = string

  type 'a loc = 'a Location.loc = {
    txt : 'a;
    loc : Location.t;
  }


  type variance              = Asttypes.variance    =
    | Covariant
    | Contravariant
    | Invariant
end

module Parsetree = struct
  (** Abstract syntax tree produced by parsing *)

  open Asttypes

  (** {2 Extension points} *)

  type attribute = string loc * payload
         (* [@id ARG]
            [@@id ARG]

            Metadata containers passed around within the AST.
            The compiler ignores unknown attributes.
         *)

  and extension = string loc * payload
        (* [%id ARG]
           [%%id ARG]

           Sub-language placeholder -- rejected by the typechecker.
        *)

  and attributes = attribute list

  and payload              = Parsetree.payload    =
    | PStr of structure
    | PTyp of core_type  (* : T *)
    | PPat of pattern * expression option  (* ? P  or  ? P when E *)

  (** {2 Core language} *)

  (* Type expressions *)

  and core_type              = Parsetree.core_type    =
      {
       ptyp_desc: core_type_desc;
       ptyp_loc: Location.t;
       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and core_type_desc              = Parsetree.core_type_desc    =
    | Ptyp_any
          (*  _ *)
    | Ptyp_var of string
          (* 'a *)
    | Ptyp_arrow of label * core_type * core_type
          (* T1 -> T2       (label = "")
             ~l:T1 -> T2    (label = "l")
             ?l:T1 -> T2    (label = "?l")
           *)
    | Ptyp_tuple of core_type list
          (* T1 * ... * Tn

             Invariant: n >= 2
          *)
    | Ptyp_constr of Longident.t loc * core_type list
          (* tconstr
             T tconstr
             (T1, ..., Tn) tconstr
           *)
    | Ptyp_object of (string * attributes * core_type) list * closed_flag
          (* < l1:T1; ...; ln:Tn >     (flag = Closed)
             < l1:T1; ...; ln:Tn; .. > (flag = Open)
           *)
    | Ptyp_class of Longident.t loc * core_type list
          (* #tconstr
             T #tconstr
             (T1, ..., Tn) #tconstr
           *)
    | Ptyp_alias of core_type * string
          (* T as 'a *)
    | Ptyp_variant of row_field list * closed_flag * label list option
          (* [ `A|`B ]         (flag = Closed; labels = None)
             [> `A|`B ]        (flag = Open;   labels = None)
             [< `A|`B ]        (flag = Closed; labels = Some [])
             [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
           *)
    | Ptyp_poly of string list * core_type
          (* 'a1 ... 'an. T

             Can only appear in the following context:

             - As the core_type of a Ppat_constraint node corresponding
               to a constraint on a let-binding: let x : 'a1 ... 'an. T
               = e ...

             - Under Cfk_virtual for methods (not values).

             - As the core_type of a Pctf_method node.

             - As the core_type of a Pexp_poly node.

             - As the pld_type field of a label_declaration.

             - As a core_type of a Ptyp_object node.
           *)

    | Ptyp_package of package_type
          (* (module S) *)
    | Ptyp_extension of extension
          (* [%id] *)

  and package_type = Longident.t loc * (Longident.t loc * core_type) list
        (*
          (module S)
          (module S with type t1 = T1 and ... and tn = Tn)
         *)

  and row_field              = Parsetree.row_field    =
    | Rtag of label * attributes * bool * core_type list
          (* [`A]                   ( true,  [] )
             [`A of T]              ( false, [T] )
             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

            - The 2nd field is true if the tag contains a
              constant (empty) constructor.
            - '&' occurs when several types are used for the same constructor
              (see 4.2 in the manual)

            - TODO: switch to a record representation, and keep location
          *)
    | Rinherit of core_type
          (* [ T ] *)

  (* Patterns *)

  and pattern              = Parsetree.pattern    =
      {
       ppat_desc: pattern_desc;
       ppat_loc: Location.t;
       ppat_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and pattern_desc              = Parsetree.pattern_desc    =
    | Ppat_any
          (* _ *)
    | Ppat_var of string loc
          (* x *)
    | Ppat_alias of pattern * string loc
          (* P as 'a *)
    | Ppat_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Ppat_interval of constant * constant
          (* 'a'..'z'

             Other forms of interval are recognized by the parser
             but rejected by the type-checker. *)
    | Ppat_tuple of pattern list
          (* (P1, ..., Pn)

             Invariant: n >= 2
          *)
    | Ppat_construct of Longident.t loc * pattern option
          (* C                None
             C P              Some P
             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
           *)
    | Ppat_variant of label * pattern option
          (* `A             (None)
             `A P           (Some P)
           *)
    | Ppat_record of (Longident.t loc * pattern) list * closed_flag
          (* { l1=P1; ...; ln=Pn }     (flag = Closed)
             { l1=P1; ...; ln=Pn; _}   (flag = Open)

             Invariant: n > 0
           *)
    | Ppat_array of pattern list
          (* [| P1; ...; Pn |] *)
    | Ppat_or of pattern * pattern
          (* P1 | P2 *)
    | Ppat_constraint of pattern * core_type
          (* (P : T) *)
    | Ppat_type of Longident.t loc
          (* #tconst *)
    | Ppat_lazy of pattern
          (* lazy P *)
    | Ppat_unpack of string loc
          (* (module P)
             Note: (module P : S) is represented as
             Ppat_constraint(Ppat_unpack, Ptyp_package)
           *)
    | Ppat_exception of pattern
          (* exception P *)
    | Ppat_extension of extension
          (* [%id] *)

  (* Value expressions *)

  and expression              = Parsetree.expression    =
      {
       pexp_desc: expression_desc;
       pexp_loc: Location.t;
       pexp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and expression_desc              = Parsetree.expression_desc    =
    | Pexp_ident of Longident.t loc
          (* x
             M.x
           *)
    | Pexp_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Pexp_let of rec_flag * value_binding list * expression
          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
           *)
    | Pexp_function of case list
          (* function P1 -> E1 | ... | Pn -> En *)
    | Pexp_fun of label * expression option * pattern * expression
          (* fun P -> E1                          (lab = "", None)
             fun ~l:P -> E1                       (lab = "l", None)
             fun ?l:P -> E1                       (lab = "?l", None)
             fun ?l:(P = E0) -> E1                (lab = "?l", Some E0)

             Notes:
             - If E0 is provided, lab must start with '?'.
             - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
             - "let f P = E" is represented using Pexp_fun.
           *)
    | Pexp_apply of expression * (label * expression) list
          (* E0 ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pexp_match of expression * case list
          (* match E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_try of expression * case list
          (* try E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_tuple of expression list
          (* (E1, ..., En)

             Invariant: n >= 2
          *)
    | Pexp_construct of Longident.t loc * expression option
          (* C                None
             C E              Some E
             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
          *)
    | Pexp_variant of label * expression option
          (* `A             (None)
             `A E           (Some E)
           *)
    | Pexp_record of (Longident.t loc * expression) list * expression option
          (* { l1=P1; ...; ln=Pn }     (None)
             { E0 with l1=P1; ...; ln=Pn }   (Some E0)

             Invariant: n > 0
           *)
    | Pexp_field of expression * Longident.t loc
          (* E.l *)
    | Pexp_setfield of expression * Longident.t loc * expression
          (* E1.l <- E2 *)
    | Pexp_array of expression list
          (* [| E1; ...; En |] *)
    | Pexp_ifthenelse of expression * expression * expression option
          (* if E1 then E2 else E3 *)
    | Pexp_sequence of expression * expression
          (* E1; E2 *)
    | Pexp_while of expression * expression
          (* while E1 do E2 done *)
    | Pexp_for of
        pattern *  expression * expression * direction_flag * expression
          (* for i = E1 to E2 do E3 done      (flag = Upto)
             for i = E1 downto E2 do E3 done  (flag = Downto)
           *)
    | Pexp_constraint of expression * core_type
          (* (E : T) *)
    | Pexp_coerce of expression * core_type option * core_type
          (* (E :> T)        (None, T)
             (E : T0 :> T)   (Some T0, T)
           *)
    | Pexp_send of expression * string
          (*  E # m *)
    | Pexp_new of Longident.t loc
          (* new M.c *)
    | Pexp_setinstvar of string loc * expression
          (* x <- 2 *)
    | Pexp_override of (string loc * expression) list
          (* {< x1 = E1; ...; Xn = En >} *)
    | Pexp_letmodule of string loc * module_expr * expression
          (* let module M = ME in E *)
    | Pexp_assert of expression
          (* assert E
             Note: "assert false" is treated in a special way by the
             type-checker. *)
    | Pexp_lazy of expression
          (* lazy E *)
    | Pexp_poly of expression * core_type option
          (* Used for method bodies.

             Can only be used as the expression under Cfk_concrete
             for methods (not values). *)
    | Pexp_object of class_structure
          (* object ... end *)
    | Pexp_newtype of string * expression
          (* fun (type t) -> E *)
    | Pexp_pack of module_expr
          (* (module ME)

             (module ME : S) is represented as
             Pexp_constraint(Pexp_pack, Ptyp_package S) *)
    | Pexp_open of override_flag * Longident.t loc * expression
          (* let open M in E
             let! open M in E
          *)
    | Pexp_extension of extension
          (* [%id] *)

  and case              = Parsetree.case    =   (* (P -> E) or (P when E0 -> E) *)
      {
       pc_lhs: pattern;
       pc_guard: expression option;
       pc_rhs: expression;
      }

  (* Value descriptions *)

  and value_description              = Parsetree.value_description    =
      {
       pval_name: string loc;
       pval_type: core_type;
       pval_prim: string list;
       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
       pval_loc: Location.t;
      }

  (*
    val x: T                            (prim = [])
    external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])

    Note: when used under Pstr_primitive, prim cannot be empty
  *)

  (* Type declarations *)

  and type_declaration              = Parsetree.type_declaration    =
      {
       ptype_name: string loc;
       ptype_params: (core_type * variance) list;
             (* ('a1,...'an) t; None represents  _*)
       ptype_cstrs: (core_type * core_type * Location.t) list;
             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
       ptype_kind: type_kind;
       ptype_private: private_flag;   (* = private ... *)
       ptype_manifest: core_type option;  (* = T *)
       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       ptype_loc: Location.t;
      }

  (*
    type t                     (abstract, no manifest)
    type t = T0                (abstract, manifest=T0)
    type t = C of T | ...      (variant,  no manifest)
    type t = T0 = C of T | ... (variant,  manifest=T0)
    type t = {l: T; ...}       (record,   no manifest)
    type t = T0 = {l : T; ...} (record,   manifest=T0)
    type t = ..                (open,     no manifest)
  *)

  and type_kind              = Parsetree.type_kind    =
    | Ptype_abstract
    | Ptype_variant of constructor_declaration list
          (* Invariant: non-empty list *)
    | Ptype_record of label_declaration list
          (* Invariant: non-empty list *)
    | Ptype_open

  and label_declaration              = Parsetree.label_declaration    =
      {
       pld_name: string loc;
       pld_mutable: mutable_flag;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes; (* l [@id1] [@id2] : T *)
      }

  (*  { ...; l: T; ... }            (mutable=Immutable)
      { ...; mutable l: T; ... }    (mutable=Mutable)

      Note: T can be a Ptyp_poly.
  *)

  and constructor_declaration              = Parsetree.constructor_declaration    =
      {
       pcd_name: string loc;
       pcd_args: core_type list;
       pcd_res: core_type option;
       pcd_loc: Location.t;
       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }
  (*
    | C of T1 * ... * Tn     (res = None)
    | C: T0                  (args = [], res = Some T0)
    | C: T1 * ... * Tn -> T0 (res = Some T0)
  *)

  and type_extension              = Parsetree.type_extension    =
      {
       ptyext_path: Longident.t loc;
       ptyext_params: (core_type * variance) list;
       ptyext_constructors: extension_constructor list;
       ptyext_private: private_flag;
       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
      }
  (*
    type t += ...
  *)

  and extension_constructor              = Parsetree.extension_constructor    =
      {
       pext_name: string loc;
       pext_kind : extension_constructor_kind;
       pext_loc : Location.t;
       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and extension_constructor_kind              = Parsetree.extension_constructor_kind    =
      Pext_decl of core_type list * core_type option
        (*
           | C of T1 * ... * Tn     ([T1; ...; Tn], None)
           | C: T0                  ([], Some T0)
           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
         *)
    | Pext_rebind of Longident.t loc
        (*
           | C = D
         *)

  (** {2 Class language} *)

  (* Type expressions for the class language *)

  and class_type              = Parsetree.class_type    =
      {
       pcty_desc: class_type_desc;
       pcty_loc: Location.t;
       pcty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_type_desc              = Parsetree.class_type_desc    =
    | Pcty_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcty_signature of class_signature
          (* object ... end *)
    | Pcty_arrow of label * core_type * class_type
          (* T -> CT       (label = "")
             ~l:T -> CT    (label = "l")
             ?l:T -> CT    (label = "?l")
           *)
    | Pcty_extension of extension
          (* [%id] *)

  and class_signature              = Parsetree.class_signature    =
      {
       pcsig_self: core_type;
       pcsig_fields: class_type_field list;
      }
  (* object('selfpat) ... end
     object ... end             (self = Ptyp_any)
   *)

  and class_type_field              = Parsetree.class_type_field    =
      {
       pctf_desc: class_type_field_desc;
       pctf_loc: Location.t;
       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_type_field_desc              = Parsetree.class_type_field_desc    =
    | Pctf_inherit of class_type
          (* inherit CT *)
    | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
          (* val x: T *)
    | Pctf_method  of (string * private_flag * virtual_flag * core_type)
          (* method x: T

             Note: T can be a Ptyp_poly.
           *)
    | Pctf_constraint  of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pctf_attribute of attribute
          (* [@@@id] *)
    | Pctf_extension of extension
          (* [%%id] *)

  and 'a class_infos              = 'a Parsetree.class_infos    =
      {
       pci_virt: virtual_flag;
       pci_params: (core_type * variance) list;
       pci_name: string loc;
       pci_expr: 'a;
       pci_loc: Location.t;
       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
      }
  (* class c = ...
     class ['a1,...,'an] c = ...
     class virtual c = ...

     Also used for "class type" declaration.
  *)

  and class_description = class_type class_infos

  and class_type_declaration = class_type class_infos

  (* Value expressions for the class language *)

  and class_expr              = Parsetree.class_expr    =
      {
       pcl_desc: class_expr_desc;
       pcl_loc: Location.t;
       pcl_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_expr_desc              = Parsetree.class_expr_desc    =
    | Pcl_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcl_structure of class_structure
          (* object ... end *)
    | Pcl_fun of label * expression option * pattern * class_expr
          (* fun P -> CE                          (lab = "", None)
             fun ~l:P -> CE                       (lab = "l", None)
             fun ?l:P -> CE                       (lab = "?l", None)
             fun ?l:(P = E0) -> CE                (lab = "?l", Some E0)
           *)
    | Pcl_apply of class_expr * (label * expression) list
          (* CE ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pcl_let of rec_flag * value_binding list * class_expr
          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
           *)
    | Pcl_constraint of class_expr * class_type
          (* (CE : CT) *)
    | Pcl_extension of extension
          (* [%id] *)

  and class_structure              = Parsetree.class_structure    =
      {
       pcstr_self: pattern;
       pcstr_fields: class_field list;
      }
  (* object(selfpat) ... end
     object ... end           (self = Ppat_any)
   *)

  and class_field              = Parsetree.class_field    =
      {
       pcf_desc: class_field_desc;
       pcf_loc: Location.t;
       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_field_desc              = Parsetree.class_field_desc    =
    | Pcf_inherit of override_flag * class_expr * string option
          (* inherit CE
             inherit CE as x
             inherit! CE
             inherit! CE as x
           *)
    | Pcf_val of (string loc * mutable_flag * class_field_kind)
          (* val x = E
             val virtual x: T
           *)
    | Pcf_method of (string loc * private_flag * class_field_kind)
          (* method x = E            (E can be a Pexp_poly)
             method virtual x: T     (T can be a Ptyp_poly)
           *)
    | Pcf_constraint of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pcf_initializer of expression
          (* initializer E *)
    | Pcf_attribute of attribute
          (* [@@@id] *)
    | Pcf_extension of extension
          (* [%%id] *)

  and class_field_kind              = Parsetree.class_field_kind    =
    | Cfk_virtual of core_type
    | Cfk_concrete of override_flag * expression

  and class_declaration = class_expr class_infos

  (** {2 Module language} *)

  (* Type expressions for the module language *)

  and module_type              = Parsetree.module_type    =
      {
       pmty_desc: module_type_desc;
       pmty_loc: Location.t;
       pmty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_type_desc              = Parsetree.module_type_desc    =
    | Pmty_ident of Longident.t loc
          (* S *)
    | Pmty_signature of signature
          (* sig ... end *)
    | Pmty_functor of string loc * module_type option * module_type
          (* functor(X : MT1) -> MT2 *)
    | Pmty_with of module_type * with_constraint list
          (* MT with ... *)
    | Pmty_typeof of module_expr
          (* module type of ME *)
    | Pmty_extension of extension
          (* [%id] *)
    | Pmty_alias of Longident.t loc
          (* (module M) *)

  and signature = signature_item list

  and signature_item              = Parsetree.signature_item    =
      {
       psig_desc: signature_item_desc;
       psig_loc: Location.t;
      }

  and signature_item_desc              = Parsetree.signature_item_desc    =
    | Psig_value of value_description
          (*
            val x: T
            external x: T = "s1" ... "sn"
           *)
    | Psig_type of type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Psig_typext of type_extension
          (* type t1 += ... *)
    | Psig_exception of extension_constructor
          (* exception C of T *)
    | Psig_module of module_declaration
          (* module X : MT *)
    | Psig_recmodule of module_declaration list
          (* module rec X1 : MT1 and ... and Xn : MTn *)
    | Psig_modtype of module_type_declaration
          (* module type S = MT
             module type S *)
    | Psig_open of open_description
          (* open X *)
    | Psig_include of include_description
          (* include MT *)
    | Psig_class of class_description list
          (* class c1 : ... and ... and cn : ... *)
    | Psig_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Psig_attribute of attribute
          (* [@@@id] *)
    | Psig_extension of extension * attributes
          (* [%%id] *)

  and module_declaration              = Parsetree.module_declaration    =
      {
       pmd_name: string loc;
       pmd_type: module_type;
       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmd_loc: Location.t;
      }
  (* S : MT *)

  and module_type_declaration              = Parsetree.module_type_declaration    =
      {
       pmtd_name: string loc;
       pmtd_type: module_type option;
       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmtd_loc: Location.t;
      }
  (* S = MT
     S       (abstract module type declaration, pmtd_type = None)
  *)

  and open_description              = Parsetree.open_description    =
      {
       popen_lid: Longident.t loc;
       popen_override: override_flag;
       popen_loc: Location.t;
       popen_attributes: attributes;
      }
  (* open! X - popen_override = Override (silences the 'used identifier
                                shadowing' warning)
     open  X - popen_override = Fresh
   *)

  and 'a include_infos              = 'a Parsetree.include_infos    =
      {
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
      }

  and include_description = module_type include_infos
  (* include MT *)

  and include_declaration = module_expr include_infos
  (* include ME *)

  and with_constraint              = Parsetree.with_constraint    =
    | Pwith_type of Longident.t loc * type_declaration
          (* with type X.t = ...

             Note: the last component of the longident must match
             the name of the type_declaration. *)
    | Pwith_module of Longident.t loc * Longident.t loc
          (* with module X.Y = Z *)
    | Pwith_typesubst of type_declaration
          (* with type t := ... *)
    | Pwith_modsubst of string loc * Longident.t loc
          (* with module X := Z *)

  (* Value expressions for the module language *)

  and module_expr              = Parsetree.module_expr    =
      {
       pmod_desc: module_expr_desc;
       pmod_loc: Location.t;
       pmod_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_expr_desc              = Parsetree.module_expr_desc    =
    | Pmod_ident of Longident.t loc
          (* X *)
    | Pmod_structure of structure
          (* struct ... end *)
    | Pmod_functor of string loc * module_type option * module_expr
          (* functor(X : MT1) -> ME *)
    | Pmod_apply of module_expr * module_expr
          (* ME1(ME2) *)
    | Pmod_constraint of module_expr * module_type
          (* (ME : MT) *)
    | Pmod_unpack of expression
          (* (val E) *)
    | Pmod_extension of extension
          (* [%id] *)

  and structure = structure_item list

  and structure_item              = Parsetree.structure_item    =
      {
       pstr_desc: structure_item_desc;
       pstr_loc: Location.t;
      }

  and structure_item_desc              = Parsetree.structure_item_desc    =
    | Pstr_eval of expression * attributes
          (* E *)
    | Pstr_value of rec_flag * value_binding list
          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
           *)
    | Pstr_primitive of value_description
          (* external x: T = "s1" ... "sn" *)
    | Pstr_type of type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Pstr_typext of type_extension
          (* type t1 += ... *)
    | Pstr_exception of extension_constructor
          (* exception C of T
             exception C = M.X *)
    | Pstr_module of module_binding
          (* module X = ME *)
    | Pstr_recmodule of module_binding list
          (* module rec X1 = ME1 and ... and Xn = MEn *)
    | Pstr_modtype of module_type_declaration
          (* module type S = MT *)
    | Pstr_open of open_description
          (* open X *)
    | Pstr_class of class_declaration list
          (* class c1 = ... and ... and cn = ... *)
    | Pstr_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Pstr_include of include_declaration
          (* include ME *)
    | Pstr_attribute of attribute
          (* [@@@id] *)
    | Pstr_extension of extension * attributes
          (* [%%id] *)

  and value_binding              = Parsetree.value_binding    =
    {
      pvb_pat: pattern;
      pvb_expr: expression;
      pvb_attributes: attributes;
      pvb_loc: Location.t;
    }

  and module_binding              = Parsetree.module_binding    =
      {
       pmb_name: string loc;
       pmb_expr: module_expr;
       pmb_attributes: attributes;
       pmb_loc: Location.t;
      }
  (* X = ME *)

  (** {2 Toplevel} *)

  (* Toplevel phrases *)

  type toplevel_phrase              = Parsetree.toplevel_phrase    =
    | Ptop_def of structure
    | Ptop_dir of string * directive_argument
       (* #use, #load ... *)

  and directive_argument              = Parsetree.directive_argument    =
    | Pdir_none
    | Pdir_string of string
    | Pdir_int of int
    | Pdir_ident of Longident.t
    | Pdir_bool of bool
end

module Docstrings : sig
  (** {3 Docstrings} *)

  (** Documentation comments *)
  type docstring

  (** Create a docstring *)
  val docstring : string -> Location.t -> docstring

  (** Get the text of a docstring *)
  val docstring_body : docstring -> string

  (** Get the location of a docstring *)
  val docstring_loc : docstring -> Location.t

  (** {3 Items}

      The {!docs} type represents documentation attached to an item. *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  val empty_docs : docs

  val docs_attr : docstring -> Parsetree.attribute

  (** Convert item documentation to attributes and add them to an
      attribute list *)
  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. *)

  type info = docstring option

  val empty_info : info

  val info_attr : docstring -> Parsetree.attribute

  (** Convert field info to attributes and add them to an
      attribute list *)
  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. *)

  type text = docstring list

  val empty_text : text

  val text_attr : docstring -> Parsetree.attribute

  (** Convert text to attributes and add them to an attribute list *)
  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

end = struct
  open Location

  (* Docstrings *)

  type docstring =
    { ds_body: string;
      ds_loc: Location.t; }

  (* Docstring constructors and destructors *)

  let docstring body loc =
    let ds =
      { ds_body = body;
        ds_loc = loc; }
    in
    ds

  let docstring_body ds = ds.ds_body

  let docstring_loc ds = ds.ds_loc

  (* Docstrings attached to items *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  let empty_docs = { docs_pre = None; docs_post = None }

  let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

  let docs_attr ds =
    let open Asttypes in
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (doc_loc, PStr [item])

  let add_docs_attrs docs attrs =
    let attrs =
      match docs.docs_pre with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> docs_attr ds :: attrs
    in
    let attrs =
      match docs.docs_post with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> attrs @ [docs_attr ds]
    in
    attrs

  (* Docstrings attached to constructors or fields *)

  type info = docstring option

  let empty_info = None

  let info_attr = docs_attr

  let add_info_attrs info attrs =
    match info with
    | None | Some {ds_body=""; _} -> attrs
    | Some ds -> attrs @ [info_attr ds]

  (* Docstrings not attached to a specific item *)

  type text = docstring list

  let empty_text = []

  let text_loc = {txt = "ocaml.text"; loc = Location.none}

  let text_attr ds =
    let open Asttypes in
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (text_loc, PStr [item])

  let add_text_attrs dsl attrs =
    let fdsl = List.filter (function {ds_body=""; _} -> false| _ ->true) dsl in
    (List.map text_attr fdsl) @ attrs

end

module Ast_helper : sig
  (** Helpers to produce Parsetree fragments *)

  open Parsetree
  open Asttypes
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  (** {2 Default locations} *)

  val default_loc: loc ref
      (** Default value for all optional location arguments. *)

  val with_default_loc: loc -> (unit -> 'a) -> 'a
      (** Set the [default_loc] within the scope of the execution
          of the provided function. *)

  (** {2 Core language} *)

  (** Type expressions *)
  module Typ :
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
      val attr: core_type -> attribute -> core_type

      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
      val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> core_type
                 -> core_type
      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val object_: ?loc:loc -> ?attrs:attrs ->
                    (string * attributes * core_type) list -> closed_flag ->
                    core_type
      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                   -> label list option -> core_type
      val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type
      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                   -> core_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

      val force_poly: core_type -> core_type
    end

  (** Patterns *)
  module Pat:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
      val attr:pattern -> attribute -> pattern

      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                  -> pattern
      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
    end

  (** Expressions *)
  module Exp:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
      val attr: expression -> attribute -> expression

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
                -> expression -> expression
      val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern
                -> expression -> expression
      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
      val apply: ?loc:loc -> ?attrs:attrs -> expression
                 -> (label * expression) list -> expression
      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                  -> expression
      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                     -> expression
      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                   -> expression
      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                  -> expression option -> expression
      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                    -> expression
      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                      -> expression option -> expression
      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression
      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
                -> direction_flag -> expression -> expression
      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                  -> core_type -> expression
      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                       -> expression
      val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression
      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                    -> expression
      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                     -> expression
      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option -> expression
      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
      val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression
      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression -> expression
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression

      val case: pattern -> ?guard:expression -> expression -> case
    end

  (** Value declarations *)
  module Val:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        ?prim:string list -> str -> core_type -> value_description
    end

  (** Type declarations *)
  module Type:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?params:(core_type * variance) list -> ?cstrs:(core_type * core_type * loc) list ->
        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
        type_declaration

      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?args:core_type list -> ?res:core_type -> str -> constructor_declaration
      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?mut:mutable_flag -> str -> core_type -> label_declaration
    end

  (** Type extensions *)
  module Te:
    sig
      val mk: ?attrs:attrs -> ?docs:docs ->
        ?params:(core_type * variance) list -> ?priv:private_flag ->
        lid -> extension_constructor list -> type_extension

      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> extension_constructor_kind -> extension_constructor

      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        ?args:core_type list -> ?res:core_type -> str -> extension_constructor
      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> lid -> extension_constructor
    end

  (** {2 Module language} *)

  (** Module type expressions *)
  module Mty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
      val attr: module_type -> attribute -> module_type

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_type -> module_type
      val with_: ?loc:loc -> ?attrs:attrs -> module_type -> with_constraint list -> module_type
      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
    end

  (** Module expressions *)
  module Mod:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
      val attr: module_expr -> attribute -> module_expr

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_expr -> module_expr
      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr -> module_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type -> module_expr
      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
    end

  (** Signature items *)
  module Sig:
    sig
      val mk: ?loc:loc -> signature_item_desc -> signature_item

      val value: ?loc:loc -> value_description -> signature_item
      val type_: ?loc:loc -> type_declaration list -> signature_item
      val type_extension: ?loc:loc -> type_extension -> signature_item
      val exception_: ?loc:loc -> extension_constructor -> signature_item
      val module_: ?loc:loc -> module_declaration -> signature_item
      val rec_module: ?loc:loc -> module_declaration list -> signature_item
      val modtype: ?loc:loc -> module_type_declaration -> signature_item
      val open_: ?loc:loc -> open_description -> signature_item
      val include_: ?loc:loc -> include_description -> signature_item
      val class_: ?loc:loc -> class_description list -> signature_item
      val class_type: ?loc:loc -> class_type_declaration list -> signature_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
      val attribute: ?loc:loc -> attribute -> signature_item
      val text: text -> signature_item list
    end

  (** Structure items *)
  module Str:
    sig
      val mk: ?loc:loc -> structure_item_desc -> structure_item

      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
      val primitive: ?loc:loc -> value_description -> structure_item
      val type_: ?loc:loc -> type_declaration list -> structure_item
      val type_extension: ?loc:loc -> type_extension -> structure_item
      val exception_: ?loc:loc -> extension_constructor -> structure_item
      val module_: ?loc:loc -> module_binding -> structure_item
      val rec_module: ?loc:loc -> module_binding list -> structure_item
      val modtype: ?loc:loc -> module_type_declaration -> structure_item
      val open_: ?loc:loc -> open_description -> structure_item
      val class_: ?loc:loc -> class_declaration list -> structure_item
      val class_type: ?loc:loc -> class_type_declaration list -> structure_item
      val include_: ?loc:loc -> include_declaration -> structure_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
      val attribute: ?loc:loc -> attribute -> structure_item
      val text: text -> structure_item list
    end

  (** Module declarations *)
  module Md:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_type -> module_declaration
    end

  (** Module type declarations *)
  module Mtd:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?typ:module_type -> str -> module_type_declaration
    end

  (** Module bindings *)
  module Mb:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_expr -> module_binding
    end

  (* Opens *)
  module Opn:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
        ?override:override_flag -> lid -> open_description
    end

  (* Includes *)
  module Incl:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
    end

  (** Value bindings *)

  module Vb:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        pattern -> expression -> value_binding
    end


  (** {2 Class language} *)

  (** Class type expressions *)
  module Cty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
      val attr: class_type -> attribute -> class_type

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
      val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> class_type -> class_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
    end

  (** Class type fields *)
  module Ctf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        class_type_field_desc -> class_type_field
      val attr: class_type_field -> attribute -> class_type_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
      val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag -> virtual_flag -> core_type -> class_type_field
      val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag -> virtual_flag -> core_type -> class_type_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_type_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
      val attribute: ?loc:loc -> attribute -> class_type_field
      val text: text -> class_type_field list
    end

  (** Class expressions *)
  module Cl:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
      val attr: class_expr -> attribute -> class_expr

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
      val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern -> class_expr -> class_expr
      val apply: ?loc:loc -> ?attrs:attrs -> class_expr -> (label * expression) list -> class_expr
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list -> class_expr -> class_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type -> class_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
    end

  (** Class fields *)
  module Cf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc -> class_field
      val attr: class_field -> attribute -> class_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr -> string option -> class_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag -> class_field_kind -> class_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag -> class_field_kind -> class_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_field
      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
      val attribute: ?loc:loc -> attribute -> class_field
      val text: text -> class_field list

      val virtual_: core_type -> class_field_kind
      val concrete: override_flag -> expression -> class_field_kind

    end

  (** Classes *)
  module Ci:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?virt:virtual_flag -> ?params:(core_type * variance) list ->
        str -> 'a -> 'a class_infos
    end

  (** Class signatures *)
  module Csig:
    sig
      val mk: core_type -> class_type_field list -> class_signature
    end

  (** Class structures *)
  module Cstr:
    sig
      val mk: pattern -> class_field list -> class_structure
    end

end = struct
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Parsetree
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  let default_loc = ref Location.none

  let with_default_loc l f =
    let old = !default_loc in
    default_loc := l;
    try let r = f () in default_loc := old; r
    with exn -> default_loc := old; raise exn

  module Typ = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

    let force_poly t =
      match t.ptyp_desc with
      | Ptyp_poly _ -> t
      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)
  end

  module Pat = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
  end

  module Exp = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)

    let case lhs ?guard rhs =
      {
       pc_lhs = lhs;
       pc_guard = guard;
       pc_rhs = rhs;
      }
  end

  module Mty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
  end

  module Mod = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
    let functor_ ?loc ?attrs arg arg_ty body =
      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
  end

  module Sig = struct
    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

    let value ?loc a = mk ?loc (Psig_value a)
    let type_ ?loc a = mk ?loc (Psig_type a)
    let type_extension ?loc a = mk ?loc (Psig_typext a)
    let exception_ ?loc a = mk ?loc (Psig_exception a)
    let module_ ?loc a = mk ?loc (Psig_module a)
    let rec_module ?loc a = mk ?loc (Psig_recmodule a)
    let modtype ?loc a = mk ?loc (Psig_modtype a)
    let open_ ?loc a = mk ?loc (Psig_open a)
    let include_ ?loc a = mk ?loc (Psig_include a)
    let class_ ?loc a = mk ?loc (Psig_class a)
    let class_type ?loc a = mk ?loc (Psig_class_type a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Psig_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt
  end

  module Str = struct
    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
    let value ?loc a b = mk ?loc (Pstr_value (a, b))
    let primitive ?loc a = mk ?loc (Pstr_primitive a)
    let type_ ?loc a = mk ?loc (Pstr_type a)
    let type_extension ?loc a = mk ?loc (Pstr_typext a)
    let exception_ ?loc a = mk ?loc (Pstr_exception a)
    let module_ ?loc a = mk ?loc (Pstr_module a)
    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
    let modtype ?loc a = mk ?loc (Pstr_modtype a)
    let open_ ?loc a = mk ?loc (Pstr_open a)
    let class_ ?loc a = mk ?loc (Pstr_class a)
    let class_type ?loc a = mk ?loc (Pstr_class_type a)
    let include_ ?loc a = mk ?loc (Pstr_include a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Pstr_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt
  end

  module Cl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcl_desc = d;
       pcl_loc = loc;
       pcl_attributes = attrs;
      }
    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
  end

  module Cty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcty_desc = d;
       pcty_loc = loc;
       pcty_attributes = attrs;
      }
    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
  end

  module Ctf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
             ?(docs = empty_docs) d =
      {
       pctf_desc = d;
       pctf_loc = loc;
       pctf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
    let attribute ?loc a = mk ?loc (Pctf_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt

    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

  end

  module Cf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) d =
      {
       pcf_desc = d;
       pcf_loc = loc;
       pcf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
    let attribute ?loc a = mk ?loc (Pcf_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt

    let virtual_ ct = Cfk_virtual ct
    let concrete o e = Cfk_concrete (o, e)

    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

  end

  module Val = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(prim = []) name typ =
      {
       pval_name = name;
       pval_type = typ;
       pval_attributes = add_docs_attrs docs attrs;
       pval_loc = loc;
       pval_prim = prim;
      }
  end

  module Md = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name typ =
      {
       pmd_name = name;
       pmd_type = typ;
       pmd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmd_loc = loc;
      }
  end

  module Mtd = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) ?typ name =
      {
       pmtd_name = name;
       pmtd_type = typ;
       pmtd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmtd_loc = loc;
      }
  end

  module Mb = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name expr =
      {
       pmb_name = name;
       pmb_expr = expr;
       pmb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmb_loc = loc;
      }
  end

  module Opn = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(override = Fresh) lid =
      {
       popen_lid = lid;
       popen_override = override;
       popen_loc = loc;
       popen_attributes = add_docs_attrs docs attrs;
      }
  end

  module Incl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
      {
       pincl_mod = mexpr;
       pincl_loc = loc;
       pincl_attributes = add_docs_attrs docs attrs;
      }

  end

  module Vb = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(text = []) pat expr =
      {
       pvb_pat = pat;
       pvb_expr = expr;
       pvb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pvb_loc = loc;
      }
  end

  module Ci = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
          ?(virt = Concrete) ?(params = []) name expr =
      {
       pci_virt = virt;
       pci_params = params;
       pci_name = name;
       pci_expr = expr;
       pci_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pci_loc = loc;
      }
  end

  module Type = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
        ?(params = [])
        ?(cstrs = [])
        ?(kind = Ptype_abstract)
        ?(priv = Public)
        ?manifest
        name =
      {
       ptype_name = name;
       ptype_params = params;
       ptype_cstrs = cstrs;
       ptype_kind = kind;
       ptype_private = priv;
       ptype_manifest = manifest;
       ptype_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       ptype_loc = loc;
      }

    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(args = []) ?res name =
      {
       pcd_name = name;
       pcd_args = args;
       pcd_res = res;
       pcd_loc = loc;
       pcd_attributes = add_info_attrs info attrs;
      }

    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(mut = Immutable) name typ =
      {
       pld_name = name;
       pld_mutable = mut;
       pld_type = typ;
       pld_loc = loc;
       pld_attributes = add_info_attrs info attrs;
      }

  end

  (** Type extensions *)
  module Te = struct
    let mk ?(attrs = []) ?(docs = empty_docs)
          ?(params = []) ?(priv = Public) path constructors =
      {
       ptyext_path = path;
       ptyext_params = params;
       ptyext_constructors = constructors;
       ptyext_private = priv;
       ptyext_attributes = add_docs_attrs docs attrs;
      }

    let constructor ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name kind =
      {
       pext_name = name;
       pext_kind = kind;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let decl ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) ?(args = []) ?res name =
      {
       pext_name = name;
       pext_kind = Pext_decl(args, res);
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let rebind ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name lid =
      {
       pext_name = name;
       pext_kind = Pext_rebind lid;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

  end

  module Csig = struct
    let mk self fields =
      {
       pcsig_self = self;
       pcsig_fields = fields;
      }
  end

  module Cstr = struct
    let mk self fields =
      {
       pcstr_self = self;
       pcstr_fields = fields;
      }
  end

end

module Ast_mapper : sig
  (** The interface of a -ppx rewriter

    A -ppx rewriter is a program that accepts a serialized abstract syntax
    tree and outputs another, possibly modified, abstract syntax tree.
    This module encapsulates the interface between the compiler and
    the -ppx rewriters, handling such details as the serialization format,
    forwarding of command-line flags, and storing state.

    {!mapper} allows to implement AST rewriting using open recursion.
    A typical mapper would be based on {!default_mapper}, a deep
    identity mapper, and will fall back on it for handling the syntax it
    does not modify. For example:

    {[
  open Asttypes
  open Parsetree
  open Ast_mapper

  let test_mapper argv =
    { default_mapper with
      expr = fun mapper expr ->
        match expr with
        | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
          Ast_helper.Exp.constant (Const_int 42)
        | other -> default_mapper.expr mapper other; }

  let () =
    register "ppx_test" test_mapper]}

    This -ppx rewriter, which replaces [[%test]] in expressions with
    the constant [42], can be compiled using
    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

    *)

  open Parsetree

  (** {2 A generic Parsetree mapper} *)

  type mapper              = Ast_mapper.mapper   = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }
  (** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. *)

  val default_mapper: mapper
  (** A default mapper, which implements a "deep identity" mapping. *)

  (** {2 Convenience functions to write mappers} *)

  val map_opt: ('a -> 'b) -> 'a option -> 'b option

  val extension_of_error: Location.error -> extension
  (** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. *)

  val attribute_of_warning: Location.t -> string -> attribute
  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. *)

end = struct
  (* A generic Parsetree mapping class *)

  (*
  [@@@ocaml.warning "+9"]
    (* Ensure that record patterns don't miss any field. *)
  *)


  open Parsetree
  open Ast_helper
  open Location

  type mapper              = Ast_mapper.mapper   = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }

  let map_fst f (x, y) = (f x, y)
  let map_snd f (x, y) = (x, f y)
  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
  let map_opt f = function None -> None | Some x -> Some (f x)

  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

  module T = struct
    (* Type expressions for the core language *)

    let row_field sub = function
      | Rtag (l, attrs, b, tl) ->
          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
      | Rinherit t -> Rinherit (sub.typ sub t)

    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
      let open Typ in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ptyp_any -> any ~loc ~attrs ()
      | Ptyp_var s -> var ~loc ~attrs s
      | Ptyp_arrow (lab, t1, t2) ->
          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
      | Ptyp_constr (lid, tl) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_object (l, o) ->
          let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in
          object_ ~loc ~attrs (List.map f l) o
      | Ptyp_class (lid, tl) ->
          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
      | Ptyp_variant (rl, b, ll) ->
          variant ~loc ~attrs (List.map (row_field sub) rl) b ll
      | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)
      | Ptyp_package (lid, l) ->
          package ~loc ~attrs (map_loc sub lid)
            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_type_declaration sub
        {ptype_name; ptype_params; ptype_cstrs;
         ptype_kind;
         ptype_private;
         ptype_manifest;
         ptype_attributes;
         ptype_loc} =
      Type.mk (map_loc sub ptype_name)
        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
        ~priv:ptype_private
        ~cstrs:(List.map
                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                  ptype_cstrs)
        ~kind:(sub.type_kind sub ptype_kind)
        ?manifest:(map_opt (sub.typ sub) ptype_manifest)
        ~loc:(sub.location sub ptype_loc)
        ~attrs:(sub.attributes sub ptype_attributes)

    let map_type_kind sub = function
      | Ptype_abstract -> Ptype_abstract
      | Ptype_variant l ->
          Ptype_variant (List.map (sub.constructor_declaration sub) l)
      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
      | Ptype_open -> Ptype_open

    let map_type_extension sub
        {ptyext_path; ptyext_params;
         ptyext_constructors;
         ptyext_private;
         ptyext_attributes} =
      Te.mk
        (map_loc sub ptyext_path)
        (List.map (sub.extension_constructor sub) ptyext_constructors)
        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
        ~priv:ptyext_private
        ~attrs:(sub.attributes sub ptyext_attributes)

    let map_extension_constructor_kind sub = function
        Pext_decl(ctl, cto) ->
          Pext_decl(List.map (sub.typ sub) ctl, map_opt (sub.typ sub) cto)
      | Pext_rebind li ->
          Pext_rebind (map_loc sub li)

    let map_extension_constructor sub
        {pext_name;
         pext_kind;
         pext_loc;
         pext_attributes} =
      Te.constructor
        (map_loc sub pext_name)
        (map_extension_constructor_kind sub pext_kind)
        ~loc:(sub.location sub pext_loc)
        ~attrs:(sub.attributes sub pext_attributes)

  end

  module CT = struct
    (* Type expressions for the class language *)

    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
      let open Cty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcty_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
      | Pcty_arrow (lab, t, ct) ->
          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
      =
      let open Ctf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
      | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)
      | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)
      | Pctf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_signature sub {pcsig_self; pcsig_fields} =
      Csig.mk
        (sub.typ sub pcsig_self)
        (List.map (sub.class_type_field sub) pcsig_fields)
  end

  module MT = struct
    (* Type expressions for the module language *)

    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
      let open Mty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
      | Pmty_functor (s, mt1, mt2) ->
          functor_ ~loc ~attrs (map_loc sub s)
            (Misc.may_map (sub.module_type sub) mt1)
            (sub.module_type sub mt2)
      | Pmty_with (mt, l) ->
          with_ ~loc ~attrs (sub.module_type sub mt)
            (List.map (sub.with_constraint sub) l)
      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_with_constraint sub = function
      | Pwith_type (lid, d) ->
          Pwith_type (map_loc sub lid, sub.type_declaration sub d)
      | Pwith_module (lid, lid2) ->
          Pwith_module (map_loc sub lid, map_loc sub lid2)
      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
      | Pwith_modsubst (s, lid) ->
          Pwith_modsubst (map_loc sub s, map_loc sub lid)

    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
      let open Sig in
      let loc = sub.location sub loc in
      match desc with
      | Psig_value vd -> value ~loc (sub.value_description sub vd)
      | Psig_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)
      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
      | Psig_recmodule l ->
          rec_module ~loc (List.map (sub.module_declaration sub) l)
      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Psig_open x -> open_ ~loc (sub.open_description sub x)
      | Psig_include x -> include_ ~loc (sub.include_description sub x)
      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
      | Psig_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Psig_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
  end


  module M = struct
    (* Value expressions for the module language *)

    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
      let open Mod in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
      | Pmod_functor (arg, arg_ty, body) ->
          functor_ ~loc ~attrs (map_loc sub arg)
            (Misc.may_map (sub.module_type sub) arg_ty)
            (sub.module_expr sub body)
      | Pmod_apply (m1, m2) ->
          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
      | Pmod_constraint (m, mty) ->
          constraint_ ~loc ~attrs (sub.module_expr sub m)
                      (sub.module_type sub mty)
      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
      let open Str in
      let loc = sub.location sub loc in
      match desc with
      | Pstr_eval (x, attrs) ->
          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
      | Pstr_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)
      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Pstr_open x -> open_ ~loc (sub.open_description sub x)
      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
      | Pstr_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
      | Pstr_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
  end

  module E = struct
    (* Value expressions for the core language *)

    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
      let open Exp in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pexp_constant x -> constant ~loc ~attrs x
      | Pexp_let (r, vbs, e) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.expr sub e)
      | Pexp_fun (lab, def, p, e) ->
          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
            (sub.expr sub e)
      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
      | Pexp_apply (e, l) ->
          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
      | Pexp_match (e, pel) ->
          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_construct (lid, arg) ->
          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
      | Pexp_variant (lab, eo) ->
          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
      | Pexp_record (l, eo) ->
          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
            (map_opt (sub.expr sub) eo)
      | Pexp_field (e, lid) ->
          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
      | Pexp_setfield (e1, lid, e2) ->
          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
            (sub.expr sub e2)
      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_ifthenelse (e1, e2, e3) ->
          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
            (map_opt (sub.expr sub) e3)
      | Pexp_sequence (e1, e2) ->
          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_while (e1, e2) ->
          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_for (p, e1, e2, d, e3) ->
          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
            (sub.expr sub e3)
      | Pexp_coerce (e, t1, t2) ->
          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
            (sub.typ sub t2)
      | Pexp_constraint (e, t) ->
          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
      | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s
      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
      | Pexp_setinstvar (s, e) ->
          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_override sel ->
          override ~loc ~attrs
            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
      | Pexp_letmodule (s, me, e) ->
          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
            (sub.expr sub e)
      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
      | Pexp_poly (e, t) ->
          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
      | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)
      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
      | Pexp_open (ovf, lid, e) ->
          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module P = struct
    (* Patterns *)

    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
      let open Pat in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ppat_any -> any ~loc ~attrs ()
      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
      | Ppat_constant c -> constant ~loc ~attrs c
      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_construct (l, p) ->
          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
      | Ppat_record (lpl, cf) ->
          record ~loc ~attrs
                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
      | Ppat_constraint (p, t) ->
          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module CE = struct
    (* Value expressions for the class language *)

    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
      let open Cl in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcl_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcl_structure s ->
          structure ~loc ~attrs (sub.class_structure sub s)
      | Pcl_fun (lab, e, p, ce) ->
          fun_ ~loc ~attrs lab
            (map_opt (sub.expr sub) e)
            (sub.pat sub p)
            (sub.class_expr sub ce)
      | Pcl_apply (ce, l) ->
          apply ~loc ~attrs (sub.class_expr sub ce)
            (List.map (map_snd (sub.expr sub)) l)
      | Pcl_let (r, vbs, ce) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.class_expr sub ce)
      | Pcl_constraint (ce, ct) ->
          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_kind sub = function
      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
      let open Cf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s
      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
      | Pcf_method (s, p, k) ->
          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
      | Pcf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure sub {pcstr_self; pcstr_fields} =
      {
        pcstr_self = sub.pat sub pcstr_self;
        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
      }

    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                           pci_loc; pci_attributes} =
      Ci.mk
       ~virt:pci_virt
       ~params:(List.map (map_fst (sub.typ sub)) pl)
        (map_loc sub pci_name)
        (f pci_expr)
        ~loc:(sub.location sub pci_loc)
        ~attrs:(sub.attributes sub pci_attributes)
  end

  (* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. *)

  let default_mapper =
    {
      structure = (fun this l -> List.map (this.structure_item this) l);
      structure_item = M.map_structure_item;
      module_expr = M.map;
      signature = (fun this l -> List.map (this.signature_item this) l);
      signature_item = MT.map_signature_item;
      module_type = MT.map;
      with_constraint = MT.map_with_constraint;
      class_declaration =
        (fun this -> CE.class_infos this (this.class_expr this));
      class_expr = CE.map;
      class_field = CE.map_field;
      class_structure = CE.map_structure;
      class_type = CT.map;
      class_type_field = CT.map_field;
      class_signature = CT.map_signature;
      class_type_declaration =
        (fun this -> CE.class_infos this (this.class_type this));
      class_description =
        (fun this -> CE.class_infos this (this.class_type this));
      type_declaration = T.map_type_declaration;
      type_kind = T.map_type_kind;
      typ = T.map;
      type_extension = T.map_type_extension;
      extension_constructor = T.map_extension_constructor;
      value_description =
        (fun this {pval_name; pval_type; pval_prim; pval_loc;
                   pval_attributes} ->
          Val.mk
            (map_loc this pval_name)
            (this.typ this pval_type)
            ~attrs:(this.attributes this pval_attributes)
            ~loc:(this.location this pval_loc)
            ~prim:pval_prim
        );

      pat = P.map;
      expr = E.map;

      module_declaration =
        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
           Md.mk
             (map_loc this pmd_name)
             (this.module_type this pmd_type)
             ~attrs:(this.attributes this pmd_attributes)
             ~loc:(this.location this pmd_loc)
        );

      module_type_declaration =
        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
           Mtd.mk
             (map_loc this pmtd_name)
             ?typ:(map_opt (this.module_type this) pmtd_type)
             ~attrs:(this.attributes this pmtd_attributes)
             ~loc:(this.location this pmtd_loc)
        );

      module_binding =
        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
             ~attrs:(this.attributes this pmb_attributes)
             ~loc:(this.location this pmb_loc)
        );


      open_description =
        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
           Opn.mk (map_loc this popen_lid)
             ~override:popen_override
             ~loc:(this.location this popen_loc)
             ~attrs:(this.attributes this popen_attributes)
        );


      include_description =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_type this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );

      include_declaration =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_expr this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );


      value_binding =
        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
           Vb.mk
             (this.pat this pvb_pat)
             (this.expr this pvb_expr)
             ~loc:(this.location this pvb_loc)
             ~attrs:(this.attributes this pvb_attributes)
        );


      constructor_declaration =
        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
          Type.constructor
            (map_loc this pcd_name)
            ~args:(List.map (this.typ this) pcd_args)
            ?res:(map_opt (this.typ this) pcd_res)
            ~loc:(this.location this pcd_loc)
            ~attrs:(this.attributes this pcd_attributes)
        );

      label_declaration =
        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
           Type.field
             (map_loc this pld_name)
             (this.typ this pld_type)
             ~mut:pld_mutable
             ~loc:(this.location this pld_loc)
             ~attrs:(this.attributes this pld_attributes)
        );

      cases = (fun this l -> List.map (this.case this) l);
      case =
        (fun this {pc_lhs; pc_guard; pc_rhs} ->
           {
             pc_lhs = this.pat this pc_lhs;
             pc_guard = map_opt (this.expr this) pc_guard;
             pc_rhs = this.expr this pc_rhs;
           }
        );



      location = (fun _this l -> l);

      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attributes = (fun this l -> List.map (this.attribute this) l);
      payload =
        (fun this -> function
           | PStr x -> PStr (this.structure this x)
           | PTyp x -> PTyp (this.typ this x)
           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
        );
    }

  let rec extension_of_error {loc; msg; if_highlight; sub} =
    { loc; txt = "ocaml.error" },
    PStr ([Str.eval (Exp.constant (Asttypes.Const_string (msg, None)));
           Str.eval (Exp.constant (Asttypes.Const_string (if_highlight, None)))] @
          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

  let attribute_of_warning loc s =
    { loc; txt = "ocaml.ppwarning" },
    PStr ([Str.eval ~loc (Exp.constant (Asttypes.Const_string (s, None)))])
end

module Outcometree = struct
  (* Module [Outcometree]: results displayed by the toplevel *)

  (* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
        [Toploop.print_out_value]
        [Toploop.print_out_type]
        [Toploop.print_out_sig_item]
        [Toploop.print_out_phrase] *)

  type out_ident              = Outcometree.out_ident    =
    | Oide_apply of out_ident * out_ident
    | Oide_dot of out_ident * string
    | Oide_ident of string

  type out_value              = Outcometree.out_value    =
    | Oval_array of out_value list
    | Oval_char of char
    | Oval_constr of out_ident * out_value list
    | Oval_ellipsis
    | Oval_float of float
    | Oval_int of int
    | Oval_int32 of int32
    | Oval_int64 of int64
    | Oval_nativeint of nativeint
    | Oval_list of out_value list
    | Oval_printer of (Format.formatter -> unit)
    | Oval_record of (out_ident * out_value) list
    | Oval_string of string
    | Oval_stuff of string
    | Oval_tuple of out_value list
    | Oval_variant of string * out_value option

  type out_type              = Outcometree.out_type    =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias of out_type * string
    | Otyp_arrow of string * out_type * out_type
    | Otyp_class of bool * out_ident * out_type list
    | Otyp_constr of out_ident * out_type list
    | Otyp_manifest of out_type * out_type
    | Otyp_object of (string * out_type) list * bool option
    | Otyp_record of (string * bool * out_type) list
    | Otyp_stuff of string
    | Otyp_sum of (string * out_type list * out_type option) list
    | Otyp_tuple of out_type list
    | Otyp_var of bool * string
    | Otyp_variant of
        bool * out_variant * bool * (string list) option
    | Otyp_poly of string list * out_type
    | Otyp_module of string * string list * out_type list

  and out_variant              = Outcometree.out_variant    =
    | Ovar_fields of (string * bool * out_type list) list
    | Ovar_name of out_ident * out_type list

  type out_class_type              = Outcometree.out_class_type    =
    | Octy_constr of out_ident * out_type list
    | Octy_arrow of string * out_type * out_class_type
    | Octy_signature of out_type option * out_class_sig_item list
  and out_class_sig_item               = Outcometree.out_class_sig_item    =
    | Ocsg_constraint of out_type * out_type
    | Ocsg_method of string * bool * bool * out_type
    | Ocsg_value of string * bool * bool * out_type

  type out_module_type              = Outcometree.out_module_type    =
    | Omty_abstract
    | Omty_functor of string * out_module_type option * out_module_type
    | Omty_ident of out_ident
    | Omty_signature of out_sig_item list
    | Omty_alias of out_ident
  and out_sig_item               = Outcometree.out_sig_item    =
    | Osig_class of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_class_type of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_typext of out_extension_constructor * out_ext_status
    | Osig_modtype of string * out_module_type
    | Osig_module of string * out_module_type * out_rec_status
    | Osig_type of out_type_decl * out_rec_status
    | Osig_value of string * out_type * string list
  and out_type_decl               = Outcometree.out_type_decl    =
    { otype_name: string;
      otype_params: (string * (bool * bool)) list;
      otype_type: out_type;
      otype_private: Asttypes.private_flag;
      otype_cstrs: (out_type * out_type) list }
  and out_extension_constructor              = Outcometree.out_extension_constructor    =
    { oext_name: string;
      oext_type_name: string;
      oext_type_params: string list;
      oext_args: out_type list;
      oext_ret_type: out_type option;
      oext_private: Asttypes.private_flag }
  and out_type_extension              = Outcometree.out_type_extension    =
    { otyext_name: string;
      otyext_params: string list;
      otyext_constructors: (string * out_type list * out_type option) list;
      otyext_private: Asttypes.private_flag }
  and out_rec_status              = Outcometree.out_rec_status    =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status              = Outcometree.out_ext_status   =
    | Oext_first
    | Oext_next
    | Oext_exception

  type out_phrase              = Outcometree.out_phrase    =
    | Ophr_eval of out_value * out_type
    | Ophr_signature of (out_sig_item * out_value option) list
    | Ophr_exception of (exn * out_value)

end

module Config = struct
  let ast_impl_magic_number = "Caml1999M016"
  let ast_intf_magic_number = "Caml1999N015"
end

let map_signature mapper = mapper.Ast_mapper.signature mapper
let map_structure mapper = mapper.Ast_mapper.structure mapper

let failing_mapper =
  let fail _ _ =
    invalid_arg "failing_mapper: this mapper function should never get called"
  in
  {
    Ast_mapper.
    structure               = fail;
    structure_item          = fail;
    module_expr             = fail;
    signature               = fail;
    signature_item          = fail;
    module_type             = fail;
    with_constraint         = fail;
    class_declaration       = fail;
    class_expr              = fail;
    class_field             = fail;
    class_structure         = fail;
    class_type              = fail;
    class_type_field        = fail;
    class_signature         = fail;
    class_type_declaration  = fail;
    class_description       = fail;
    type_declaration        = fail;
    type_kind               = fail;
    typ                     = fail;
    type_extension          = fail;
    extension_constructor   = fail;
    value_description       = fail;
    pat                     = fail;
    expr                    = fail;
    module_declaration      = fail;
    module_type_declaration = fail;
    module_binding          = fail;
    open_description        = fail;
    include_description     = fail;
    include_declaration     = fail;
    value_binding           = fail;
    constructor_declaration = fail;
    label_declaration       = fail;
    cases                   = fail;
    case                    = fail;
    location                = fail;
    extension               = fail;
    attribute               = fail;
    attributes              = fail;
    payload                 = fail;
  }

let make_top_mapper ~signature ~structure =
  {failing_mapper with Ast_mapper.
                    signature = (fun _ x -> signature x);
                    structure = (fun _ x -> structure x) }

end
module Ast_403
= struct
#1 "ast_403.ml"
# 1 "src/ast_403.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*            Jérémie Dimino and Leo White, Jane Street Europe            *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)
(*                         Alain Frisch, LexiFi                           *)
(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Location = Location
module Longident = Longident

module Asttypes = struct
  (* Auxiliary a.s.t. types used by parsetree and typedtree. *)

  type constant (*IF_CURRENT = Asttypes.constant *) =
      Const_int of int
    | Const_char of char
    | Const_string of string * string option
    | Const_float of string
    | Const_int32 of int32
    | Const_int64 of int64
    | Const_nativeint of nativeint

  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive

  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto

  (* Order matters, used in polymorphic comparison *)
  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public

  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable

  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete

  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh

  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open

  type label = string

  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =
      Nolabel
    | Labelled of string (*  label:T -> ... *)
    | Optional of string (* ?label:T -> ... *)

  type 'a loc = 'a Location.loc = {
    txt : 'a;
    loc : Location.t;
  }


  type variance (*IF_CURRENT = Asttypes.variance *) =
    | Covariant
    | Contravariant
    | Invariant
end

module Parsetree = struct
  (** Abstract syntax tree produced by parsing *)

  open Asttypes

  type constant (*IF_CURRENT = Parsetree.constant *) =
      Pconst_integer of string * char option
    (* 3 3l 3L 3n

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker
    *)
    | Pconst_char of char
    (* 'c' *)
    | Pconst_string of string * string option
    (* "constant"
       {delim|other constant|delim}
    *)
    | Pconst_float of string * char option
    (* 3.4 2e5 1.4e-4

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes are rejected by the typechecker.
    *)

  (** {2 Extension points} *)

  type attribute = string loc * payload
         (* [@id ARG]
            [@@id ARG]

            Metadata containers passed around within the AST.
            The compiler ignores unknown attributes.
         *)

  and extension = string loc * payload
        (* [%id ARG]
           [%%id ARG]

           Sub-language placeholder -- rejected by the typechecker.
        *)

  and attributes = attribute list

  and payload (*IF_CURRENT = Parsetree.payload *) =
    | PStr of structure
    | PSig of signature (* : SIG *)
    | PTyp of core_type  (* : T *)
    | PPat of pattern * expression option  (* ? P  or  ? P when E *)

  (** {2 Core language} *)

  (* Type expressions *)

  and core_type (*IF_CURRENT = Parsetree.core_type *) =
      {
       ptyp_desc: core_type_desc;
       ptyp_loc: Location.t;
       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =
    | Ptyp_any
          (*  _ *)
    | Ptyp_var of string
          (* 'a *)
    | Ptyp_arrow of arg_label * core_type * core_type
          (* T1 -> T2       Simple
             ~l:T1 -> T2    Labelled
             ?l:T1 -> T2    Otional
           *)
    | Ptyp_tuple of core_type list
          (* T1 * ... * Tn

             Invariant: n >= 2
          *)
    | Ptyp_constr of Longident.t loc * core_type list
          (* tconstr
             T tconstr
             (T1, ..., Tn) tconstr
           *)
    | Ptyp_object of (string * attributes * core_type) list * closed_flag
          (* < l1:T1; ...; ln:Tn >     (flag = Closed)
             < l1:T1; ...; ln:Tn; .. > (flag = Open)
           *)
    | Ptyp_class of Longident.t loc * core_type list
          (* #tconstr
             T #tconstr
             (T1, ..., Tn) #tconstr
           *)
    | Ptyp_alias of core_type * string
          (* T as 'a *)
    | Ptyp_variant of row_field list * closed_flag * label list option
          (* [ `A|`B ]         (flag = Closed; labels = None)
             [> `A|`B ]        (flag = Open;   labels = None)
             [< `A|`B ]        (flag = Closed; labels = Some [])
             [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
           *)
    | Ptyp_poly of string list * core_type
          (* 'a1 ... 'an. T

             Can only appear in the following context:

             - As the core_type of a Ppat_constraint node corresponding
               to a constraint on a let-binding: let x : 'a1 ... 'an. T
               = e ...

             - Under Cfk_virtual for methods (not values).

             - As the core_type of a Pctf_method node.

             - As the core_type of a Pexp_poly node.

             - As the pld_type field of a label_declaration.

             - As a core_type of a Ptyp_object node.
           *)

    | Ptyp_package of package_type
          (* (module S) *)
    | Ptyp_extension of extension
          (* [%id] *)

  and package_type = Longident.t loc * (Longident.t loc * core_type) list
        (*
          (module S)
          (module S with type t1 = T1 and ... and tn = Tn)
         *)

  and row_field (*IF_CURRENT = Parsetree.row_field *) =
    | Rtag of label * attributes * bool * core_type list
          (* [`A]                   ( true,  [] )
             [`A of T]              ( false, [T] )
             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

            - The 2nd field is true if the tag contains a
              constant (empty) constructor.
            - '&' occurs when several types are used for the same constructor
              (see 4.2 in the manual)

            - TODO: switch to a record representation, and keep location
          *)
    | Rinherit of core_type
          (* [ T ] *)

  (* Patterns *)

  and pattern (*IF_CURRENT = Parsetree.pattern *) =
      {
       ppat_desc: pattern_desc;
       ppat_loc: Location.t;
       ppat_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =
    | Ppat_any
          (* _ *)
    | Ppat_var of string loc
          (* x *)
    | Ppat_alias of pattern * string loc
          (* P as 'a *)
    | Ppat_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Ppat_interval of constant * constant
          (* 'a'..'z'

             Other forms of interval are recognized by the parser
             but rejected by the type-checker. *)
    | Ppat_tuple of pattern list
          (* (P1, ..., Pn)

             Invariant: n >= 2
          *)
    | Ppat_construct of Longident.t loc * pattern option
          (* C                None
             C P              Some P
             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
           *)
    | Ppat_variant of label * pattern option
          (* `A             (None)
             `A P           (Some P)
           *)
    | Ppat_record of (Longident.t loc * pattern) list * closed_flag
          (* { l1=P1; ...; ln=Pn }     (flag = Closed)
             { l1=P1; ...; ln=Pn; _}   (flag = Open)

             Invariant: n > 0
           *)
    | Ppat_array of pattern list
          (* [| P1; ...; Pn |] *)
    | Ppat_or of pattern * pattern
          (* P1 | P2 *)
    | Ppat_constraint of pattern * core_type
          (* (P : T) *)
    | Ppat_type of Longident.t loc
          (* #tconst *)
    | Ppat_lazy of pattern
          (* lazy P *)
    | Ppat_unpack of string loc
          (* (module P)
             Note: (module P : S) is represented as
             Ppat_constraint(Ppat_unpack, Ptyp_package)
           *)
    | Ppat_exception of pattern
          (* exception P *)
    | Ppat_extension of extension
          (* [%id] *)

  (* Value expressions *)

  and expression (*IF_CURRENT = Parsetree.expression *) =
      {
       pexp_desc: expression_desc;
       pexp_loc: Location.t;
       pexp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =
    | Pexp_ident of Longident.t loc
          (* x
             M.x
           *)
    | Pexp_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Pexp_let of rec_flag * value_binding list * expression
          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
           *)
    | Pexp_function of case list
          (* function P1 -> E1 | ... | Pn -> En *)
    | Pexp_fun of arg_label * expression option * pattern * expression
          (* fun P -> E1                          (Simple, None)
             fun ~l:P -> E1                       (Labelled l, None)
             fun ?l:P -> E1                       (Optional l, None)
             fun ?l:(P = E0) -> E1                (Optional l, Some E0)

             Notes:
             - If E0 is provided, only Optional is allowed.
             - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
             - "let f P = E" is represented using Pexp_fun.
           *)
    | Pexp_apply of expression * (arg_label * expression) list
          (* E0 ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pexp_match of expression * case list
          (* match E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_try of expression * case list
          (* try E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_tuple of expression list
          (* (E1, ..., En)

             Invariant: n >= 2
          *)
    | Pexp_construct of Longident.t loc * expression option
          (* C                None
             C E              Some E
             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
          *)
    | Pexp_variant of label * expression option
          (* `A             (None)
             `A E           (Some E)
           *)
    | Pexp_record of (Longident.t loc * expression) list * expression option
          (* { l1=P1; ...; ln=Pn }     (None)
             { E0 with l1=P1; ...; ln=Pn }   (Some E0)

             Invariant: n > 0
           *)
    | Pexp_field of expression * Longident.t loc
          (* E.l *)
    | Pexp_setfield of expression * Longident.t loc * expression
          (* E1.l <- E2 *)
    | Pexp_array of expression list
          (* [| E1; ...; En |] *)
    | Pexp_ifthenelse of expression * expression * expression option
          (* if E1 then E2 else E3 *)
    | Pexp_sequence of expression * expression
          (* E1; E2 *)
    | Pexp_while of expression * expression
          (* while E1 do E2 done *)
    | Pexp_for of
        pattern *  expression * expression * direction_flag * expression
          (* for i = E1 to E2 do E3 done      (flag = Upto)
             for i = E1 downto E2 do E3 done  (flag = Downto)
           *)
    | Pexp_constraint of expression * core_type
          (* (E : T) *)
    | Pexp_coerce of expression * core_type option * core_type
          (* (E :> T)        (None, T)
             (E : T0 :> T)   (Some T0, T)
           *)
    | Pexp_send of expression * string
          (*  E # m *)
    | Pexp_new of Longident.t loc
          (* new M.c *)
    | Pexp_setinstvar of string loc * expression
          (* x <- 2 *)
    | Pexp_override of (string loc * expression) list
          (* {< x1 = E1; ...; Xn = En >} *)
    | Pexp_letmodule of string loc * module_expr * expression
          (* let module M = ME in E *)
    | Pexp_assert of expression
          (* assert E
             Note: "assert false" is treated in a special way by the
             type-checker. *)
    | Pexp_lazy of expression
          (* lazy E *)
    | Pexp_poly of expression * core_type option
          (* Used for method bodies.

             Can only be used as the expression under Cfk_concrete
             for methods (not values). *)
    | Pexp_object of class_structure
          (* object ... end *)
    | Pexp_newtype of string * expression
          (* fun (type t) -> E *)
    | Pexp_pack of module_expr
          (* (module ME)

             (module ME : S) is represented as
             Pexp_constraint(Pexp_pack, Ptyp_package S) *)
    | Pexp_open of override_flag * Longident.t loc * expression
          (* let open M in E
             let! open M in E
          *)
    | Pexp_extension of extension
          (* [%id] *)
    | Pexp_unreachable
          (* . *)

  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)
      {
       pc_lhs: pattern;
       pc_guard: expression option;
       pc_rhs: expression;
      }

  (* Value descriptions *)

  and value_description (*IF_CURRENT = Parsetree.value_description *) =
      {
       pval_name: string loc;
       pval_type: core_type;
       pval_prim: string list;
       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
       pval_loc: Location.t;
      }

  (*
    val x: T                            (prim = [])
    external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])
  *)

  (* Type declarations *)

  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =
      {
       ptype_name: string loc;
       ptype_params: (core_type * variance) list;
             (* ('a1,...'an) t; None represents  _*)
       ptype_cstrs: (core_type * core_type * Location.t) list;
             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
       ptype_kind: type_kind;
       ptype_private: private_flag;   (* = private ... *)
       ptype_manifest: core_type option;  (* = T *)
       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       ptype_loc: Location.t;
      }

  (*
    type t                     (abstract, no manifest)
    type t = T0                (abstract, manifest=T0)
    type t = C of T | ...      (variant,  no manifest)
    type t = T0 = C of T | ... (variant,  manifest=T0)
    type t = {l: T; ...}       (record,   no manifest)
    type t = T0 = {l : T; ...} (record,   manifest=T0)
    type t = ..                (open,     no manifest)
  *)

  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =
    | Ptype_abstract
    | Ptype_variant of constructor_declaration list
          (* Invariant: non-empty list *)
    | Ptype_record of label_declaration list
          (* Invariant: non-empty list *)
    | Ptype_open

  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =
      {
       pld_name: string loc;
       pld_mutable: mutable_flag;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes; (* l [@id1] [@id2] : T *)
      }

  (*  { ...; l: T; ... }            (mutable=Immutable)
      { ...; mutable l: T; ... }    (mutable=Mutable)

      Note: T can be a Ptyp_poly.
  *)

  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =
      {
       pcd_name: string loc;
       pcd_args: constructor_arguments;
       pcd_res: core_type option;
       pcd_loc: Location.t;
       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =
    | Pcstr_tuple of core_type list
    | Pcstr_record of label_declaration list

  (*
    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])
    | C: T0                  (res = Some T0, args = [])
    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)
    | C of {...}             (res = None,    args = Pcstr_record)
    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)
    | C of {...} as t        (res = None,    args = Pcstr_record)
  *)

  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =
      {
       ptyext_path: Longident.t loc;
       ptyext_params: (core_type * variance) list;
       ptyext_constructors: extension_constructor list;
       ptyext_private: private_flag;
       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
      }
  (*
    type t += ...
  *)

  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =
      {
       pext_name: string loc;
       pext_kind : extension_constructor_kind;
       pext_loc : Location.t;
       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =
      Pext_decl of constructor_arguments * core_type option
        (*
           | C of T1 * ... * Tn     ([T1; ...; Tn], None)
           | C: T0                  ([], Some T0)
           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
         *)
    | Pext_rebind of Longident.t loc
        (*
           | C = D
         *)

  (** {2 Class language} *)

  (* Type expressions for the class language *)

  and class_type (*IF_CURRENT = Parsetree.class_type *) =
      {
       pcty_desc: class_type_desc;
       pcty_loc: Location.t;
       pcty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =
    | Pcty_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcty_signature of class_signature
          (* object ... end *)
    | Pcty_arrow of arg_label * core_type * class_type
          (* T -> CT       Simple
             ~l:T -> CT    Labelled l
             ?l:T -> CT    Optional l
           *)
    | Pcty_extension of extension
          (* [%id] *)

  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =
      {
       pcsig_self: core_type;
       pcsig_fields: class_type_field list;
      }
  (* object('selfpat) ... end
     object ... end             (self = Ptyp_any)
   *)

  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =
      {
       pctf_desc: class_type_field_desc;
       pctf_loc: Location.t;
       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =
    | Pctf_inherit of class_type
          (* inherit CT *)
    | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
          (* val x: T *)
    | Pctf_method  of (string * private_flag * virtual_flag * core_type)
          (* method x: T

             Note: T can be a Ptyp_poly.
           *)
    | Pctf_constraint  of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pctf_attribute of attribute
          (* [@@@id] *)
    | Pctf_extension of extension
          (* [%%id] *)

  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =
      {
       pci_virt: virtual_flag;
       pci_params: (core_type * variance) list;
       pci_name: string loc;
       pci_expr: 'a;
       pci_loc: Location.t;
       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
      }
  (* class c = ...
     class ['a1,...,'an] c = ...
     class virtual c = ...

     Also used for "class type" declaration.
  *)

  and class_description = class_type class_infos

  and class_type_declaration = class_type class_infos

  (* Value expressions for the class language *)

  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =
      {
       pcl_desc: class_expr_desc;
       pcl_loc: Location.t;
       pcl_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =
    | Pcl_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcl_structure of class_structure
          (* object ... end *)
    | Pcl_fun of arg_label * expression option * pattern * class_expr
          (* fun P -> CE                          (Simple, None)
             fun ~l:P -> CE                       (Labelled l, None)
             fun ?l:P -> CE                       (Optional l, None)
             fun ?l:(P = E0) -> CE                (Optional l, Some E0)
           *)
    | Pcl_apply of class_expr * (arg_label * expression) list
          (* CE ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pcl_let of rec_flag * value_binding list * class_expr
          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
           *)
    | Pcl_constraint of class_expr * class_type
          (* (CE : CT) *)
    | Pcl_extension of extension
          (* [%id] *)

  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =
      {
       pcstr_self: pattern;
       pcstr_fields: class_field list;
      }
  (* object(selfpat) ... end
     object ... end           (self = Ppat_any)
   *)

  and class_field (*IF_CURRENT = Parsetree.class_field *) =
      {
       pcf_desc: class_field_desc;
       pcf_loc: Location.t;
       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =
    | Pcf_inherit of override_flag * class_expr * string option
          (* inherit CE
             inherit CE as x
             inherit! CE
             inherit! CE as x
           *)
    | Pcf_val of (string loc * mutable_flag * class_field_kind)
          (* val x = E
             val virtual x: T
           *)
    | Pcf_method of (string loc * private_flag * class_field_kind)
          (* method x = E            (E can be a Pexp_poly)
             method virtual x: T     (T can be a Ptyp_poly)
           *)
    | Pcf_constraint of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pcf_initializer of expression
          (* initializer E *)
    | Pcf_attribute of attribute
          (* [@@@id] *)
    | Pcf_extension of extension
          (* [%%id] *)

  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =
    | Cfk_virtual of core_type
    | Cfk_concrete of override_flag * expression

  and class_declaration = class_expr class_infos

  (** {2 Module language} *)

  (* Type expressions for the module language *)

  and module_type (*IF_CURRENT = Parsetree.module_type *) =
      {
       pmty_desc: module_type_desc;
       pmty_loc: Location.t;
       pmty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =
    | Pmty_ident of Longident.t loc
          (* S *)
    | Pmty_signature of signature
          (* sig ... end *)
    | Pmty_functor of string loc * module_type option * module_type
          (* functor(X : MT1) -> MT2 *)
    | Pmty_with of module_type * with_constraint list
          (* MT with ... *)
    | Pmty_typeof of module_expr
          (* module type of ME *)
    | Pmty_extension of extension
          (* [%id] *)
    | Pmty_alias of Longident.t loc
          (* (module M) *)

  and signature = signature_item list

  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =
      {
       psig_desc: signature_item_desc;
       psig_loc: Location.t;
      }

  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =
    | Psig_value of value_description
          (*
            val x: T
            external x: T = "s1" ... "sn"
           *)
    | Psig_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Psig_typext of type_extension
          (* type t1 += ... *)
    | Psig_exception of extension_constructor
          (* exception C of T *)
    | Psig_module of module_declaration
          (* module X : MT *)
    | Psig_recmodule of module_declaration list
          (* module rec X1 : MT1 and ... and Xn : MTn *)
    | Psig_modtype of module_type_declaration
          (* module type S = MT
             module type S *)
    | Psig_open of open_description
          (* open X *)
    | Psig_include of include_description
          (* include MT *)
    | Psig_class of class_description list
          (* class c1 : ... and ... and cn : ... *)
    | Psig_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Psig_attribute of attribute
          (* [@@@id] *)
    | Psig_extension of extension * attributes
          (* [%%id] *)

  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =
      {
       pmd_name: string loc;
       pmd_type: module_type;
       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmd_loc: Location.t;
      }
  (* S : MT *)

  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =
      {
       pmtd_name: string loc;
       pmtd_type: module_type option;
       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmtd_loc: Location.t;
      }
  (* S = MT
     S       (abstract module type declaration, pmtd_type = None)
  *)

  and open_description (*IF_CURRENT = Parsetree.open_description *) =
      {
       popen_lid: Longident.t loc;
       popen_override: override_flag;
       popen_loc: Location.t;
       popen_attributes: attributes;
      }
  (* open! X - popen_override = Override (silences the 'used identifier
                                shadowing' warning)
     open  X - popen_override = Fresh
   *)

  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =
      {
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
      }

  and include_description = module_type include_infos
  (* include MT *)

  and include_declaration = module_expr include_infos
  (* include ME *)

  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =
    | Pwith_type of Longident.t loc * type_declaration
          (* with type X.t = ...

             Note: the last component of the longident must match
             the name of the type_declaration. *)
    | Pwith_module of Longident.t loc * Longident.t loc
          (* with module X.Y = Z *)
    | Pwith_typesubst of type_declaration
          (* with type t := ... *)
    | Pwith_modsubst of string loc * Longident.t loc
          (* with module X := Z *)

  (* Value expressions for the module language *)

  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =
      {
       pmod_desc: module_expr_desc;
       pmod_loc: Location.t;
       pmod_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =
    | Pmod_ident of Longident.t loc
          (* X *)
    | Pmod_structure of structure
          (* struct ... end *)
    | Pmod_functor of string loc * module_type option * module_expr
          (* functor(X : MT1) -> ME *)
    | Pmod_apply of module_expr * module_expr
          (* ME1(ME2) *)
    | Pmod_constraint of module_expr * module_type
          (* (ME : MT) *)
    | Pmod_unpack of expression
          (* (val E) *)
    | Pmod_extension of extension
          (* [%id] *)

  and structure = structure_item list

  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =
      {
       pstr_desc: structure_item_desc;
       pstr_loc: Location.t;
      }

  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =
    | Pstr_eval of expression * attributes
          (* E *)
    | Pstr_value of rec_flag * value_binding list
          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
           *)
    | Pstr_primitive of value_description
          (*  val x: T
              external x: T = "s1" ... "sn" *)
    | Pstr_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Pstr_typext of type_extension
          (* type t1 += ... *)
    | Pstr_exception of extension_constructor
          (* exception C of T
             exception C = M.X *)
    | Pstr_module of module_binding
          (* module X = ME *)
    | Pstr_recmodule of module_binding list
          (* module rec X1 = ME1 and ... and Xn = MEn *)
    | Pstr_modtype of module_type_declaration
          (* module type S = MT *)
    | Pstr_open of open_description
          (* open X *)
    | Pstr_class of class_declaration list
          (* class c1 = ... and ... and cn = ... *)
    | Pstr_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Pstr_include of include_declaration
          (* include ME *)
    | Pstr_attribute of attribute
          (* [@@@id] *)
    | Pstr_extension of extension * attributes
          (* [%%id] *)

  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =
    {
      pvb_pat: pattern;
      pvb_expr: expression;
      pvb_attributes: attributes;
      pvb_loc: Location.t;
    }

  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =
      {
       pmb_name: string loc;
       pmb_expr: module_expr;
       pmb_attributes: attributes;
       pmb_loc: Location.t;
      }
  (* X = ME *)

  (** {2 Toplevel} *)

  (* Toplevel phrases *)

  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =
    | Ptop_def of structure
    | Ptop_dir of string * directive_argument
       (* #use, #load ... *)

  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =
    | Pdir_none
    | Pdir_string of string
    | Pdir_int of string * char option
    | Pdir_ident of Longident.t
    | Pdir_bool of bool
end

module Docstrings : sig
  (** {3 Docstrings} *)

  (** Documentation comments *)
  type docstring

  (** Create a docstring *)
  val docstring : string -> Location.t -> docstring

  (** Get the text of a docstring *)
  val docstring_body : docstring -> string

  (** Get the location of a docstring *)
  val docstring_loc : docstring -> Location.t

  (** {3 Items}

      The {!docs} type represents documentation attached to an item. *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  val empty_docs : docs

  val docs_attr : docstring -> Parsetree.attribute

  (** Convert item documentation to attributes and add them to an
      attribute list *)
  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. *)

  type info = docstring option

  val empty_info : info

  val info_attr : docstring -> Parsetree.attribute

  (** Convert field info to attributes and add them to an
      attribute list *)
  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. *)

  type text = docstring list

  val empty_text : text

  val text_attr : docstring -> Parsetree.attribute

  (** Convert text to attributes and add them to an attribute list *)
  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

end = struct
  open Location

  (* Docstrings *)

  type docstring =
    { ds_body: string;
      ds_loc: Location.t; }

  (* Docstring constructors and destructors *)

  let docstring body loc =
    let ds =
      { ds_body = body;
        ds_loc = loc; }
    in
    ds

  let docstring_body ds = ds.ds_body

  let docstring_loc ds = ds.ds_loc

  (* Docstrings attached to items *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  let empty_docs = { docs_pre = None; docs_post = None }

  let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

  let docs_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (doc_loc, PStr [item])

  let add_docs_attrs docs attrs =
    let attrs =
      match docs.docs_pre with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> docs_attr ds :: attrs
    in
    let attrs =
      match docs.docs_post with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> attrs @ [docs_attr ds]
    in
    attrs

  (* Docstrings attached to constructors or fields *)

  type info = docstring option

  let empty_info = None

  let info_attr = docs_attr

  let add_info_attrs info attrs =
    match info with
    | None | Some {ds_body=""; _} -> attrs
    | Some ds -> attrs @ [info_attr ds]

  (* Docstrings not attached to a specific item *)

  type text = docstring list

  let empty_text = []

  let text_loc = {txt = "ocaml.text"; loc = Location.none}

  let text_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (text_loc, PStr [item])

  let add_text_attrs dsl attrs =
    let fdsl = List.filter (function {ds_body=""; _} -> false| _ ->true) dsl in
    (List.map text_attr fdsl) @ attrs

end

module Ast_helper : sig
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Docstrings
  open Parsetree

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  (** {2 Default locations} *)

  val default_loc: loc ref
      (** Default value for all optional location arguments. *)

  val with_default_loc: loc -> (unit -> 'a) -> 'a
      (** Set the [default_loc] within the scope of the execution
          of the provided function. *)

  (** {2 Constants} *)

  module Const : sig
    val char : char -> constant
    val string : ?quotation_delimiter:string -> string -> constant
    val integer : ?suffix:char -> string -> constant
    val int : ?suffix:char -> int -> constant
    val int32 : ?suffix:char -> int32 -> constant
    val int64 : ?suffix:char -> int64 -> constant
    val nativeint : ?suffix:char -> nativeint -> constant
    val float : ?suffix:char -> string -> constant
  end

  (** {2 Core language} *)

  (** Type expressions *)
  module Typ :
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
      val attr: core_type -> attribute -> core_type

      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type
                 -> core_type
      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val object_: ?loc:loc -> ?attrs:attrs ->
                    (string * attributes * core_type) list -> closed_flag ->
                    core_type
      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                   -> label list option -> core_type
      val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type
      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                   -> core_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

      val force_poly: core_type -> core_type
    end

  (** Patterns *)
  module Pat:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
      val attr:pattern -> attribute -> pattern

      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                  -> pattern
      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
    end

  (** Expressions *)
  module Exp:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
      val attr: expression -> attribute -> expression

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
                -> expression -> expression
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option
                -> pattern -> expression -> expression
      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
      val apply: ?loc:loc -> ?attrs:attrs -> expression
                 -> (arg_label * expression) list -> expression
      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                  -> expression
      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                     -> expression
      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                   -> expression
      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                  -> expression option -> expression
      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                    -> expression
      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                      -> expression option -> expression
      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression
      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
                -> direction_flag -> expression -> expression
      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                  -> core_type -> expression
      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                       -> expression
      val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression
      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                    -> expression
      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                     -> expression
      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> expression
      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
      val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression
      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression
                 -> expression
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression

      val case: pattern -> ?guard:expression -> expression -> case
    end

  (** Value declarations *)
  module Val:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        ?prim:string list -> str -> core_type -> value_description
    end

  (** Type declarations *)
  module Type:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?params:(core_type * variance) list ->
        ?cstrs:(core_type * core_type * loc) list ->
        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
        type_declaration

      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        constructor_declaration
      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?mut:mutable_flag -> str -> core_type -> label_declaration
    end

  (** Type extensions *)
  module Te:
    sig
      val mk: ?attrs:attrs -> ?docs:docs ->
        ?params:(core_type * variance) list -> ?priv:private_flag ->
        lid -> extension_constructor list -> type_extension

      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> extension_constructor_kind -> extension_constructor

      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        extension_constructor
      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> lid -> extension_constructor
    end

  (** {2 Module language} *)

  (** Module type expressions *)
  module Mty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
      val attr: module_type -> attribute -> module_type

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_type -> module_type
      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->
        with_constraint list -> module_type
      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
    end

  (** Module expressions *)
  module Mod:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
      val attr: module_expr -> attribute -> module_expr

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_expr -> module_expr
      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->
        module_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->
        module_expr
      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
    end

  (** Signature items *)
  module Sig:
    sig
      val mk: ?loc:loc -> signature_item_desc -> signature_item

      val value: ?loc:loc -> value_description -> signature_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item
      val type_extension: ?loc:loc -> type_extension -> signature_item
      val exception_: ?loc:loc -> extension_constructor -> signature_item
      val module_: ?loc:loc -> module_declaration -> signature_item
      val rec_module: ?loc:loc -> module_declaration list -> signature_item
      val modtype: ?loc:loc -> module_type_declaration -> signature_item
      val open_: ?loc:loc -> open_description -> signature_item
      val include_: ?loc:loc -> include_description -> signature_item
      val class_: ?loc:loc -> class_description list -> signature_item
      val class_type: ?loc:loc -> class_type_declaration list -> signature_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
      val attribute: ?loc:loc -> attribute -> signature_item
      val text: text -> signature_item list
    end

  (** Structure items *)
  module Str:
    sig
      val mk: ?loc:loc -> structure_item_desc -> structure_item

      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
      val primitive: ?loc:loc -> value_description -> structure_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item
      val type_extension: ?loc:loc -> type_extension -> structure_item
      val exception_: ?loc:loc -> extension_constructor -> structure_item
      val module_: ?loc:loc -> module_binding -> structure_item
      val rec_module: ?loc:loc -> module_binding list -> structure_item
      val modtype: ?loc:loc -> module_type_declaration -> structure_item
      val open_: ?loc:loc -> open_description -> structure_item
      val class_: ?loc:loc -> class_declaration list -> structure_item
      val class_type: ?loc:loc -> class_type_declaration list -> structure_item
      val include_: ?loc:loc -> include_declaration -> structure_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
      val attribute: ?loc:loc -> attribute -> structure_item
      val text: text -> structure_item list
    end

  (** Module declarations *)
  module Md:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_type -> module_declaration
    end

  (** Module type declarations *)
  module Mtd:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?typ:module_type -> str -> module_type_declaration
    end

  (** Module bindings *)
  module Mb:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_expr -> module_binding
    end

  (* Opens *)
  module Opn:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
        ?override:override_flag -> lid -> open_description
    end

  (* Includes *)
  module Incl:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
    end

  (** Value bindings *)

  module Vb:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        pattern -> expression -> value_binding
    end


  (** {2 Class language} *)

  (** Class type expressions *)
  module Cty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
      val attr: class_type -> attribute -> class_type

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->
        class_type -> class_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
    end

  (** Class type fields *)
  module Ctf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        class_type_field_desc -> class_type_field
      val attr: class_type_field -> attribute -> class_type_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
      val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag ->
        virtual_flag -> core_type -> class_type_field
      val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag ->
        virtual_flag -> core_type -> class_type_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_type_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
      val attribute: ?loc:loc -> attribute -> class_type_field
      val text: text -> class_type_field list
    end

  (** Class expressions *)
  module Cl:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
      val attr: class_expr -> attribute -> class_expr

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->
        pattern -> class_expr -> class_expr
      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->
        (arg_label * expression) list -> class_expr
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->
        class_expr -> class_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->
        class_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
    end

  (** Class fields *)
  module Cf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->
        class_field
      val attr: class_field -> attribute -> class_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->
        string option -> class_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        class_field_kind -> class_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        class_field_kind -> class_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_field
      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
      val attribute: ?loc:loc -> attribute -> class_field
      val text: text -> class_field list

      val virtual_: core_type -> class_field_kind
      val concrete: override_flag -> expression -> class_field_kind

    end

  (** Classes *)
  module Ci:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?virt:virtual_flag -> ?params:(core_type * variance) list ->
        str -> 'a -> 'a class_infos
    end

  (** Class signatures *)
  module Csig:
    sig
      val mk: core_type -> class_type_field list -> class_signature
    end

  (** Class structures *)
  module Cstr:
    sig
      val mk: pattern -> class_field list -> class_structure
    end

end = struct
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Parsetree
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  let default_loc = ref Location.none

  let with_default_loc l f =
    let old = !default_loc in
    default_loc := l;
    try let r = f () in default_loc := old; r
    with exn -> default_loc := old; raise exn

  module Const = struct
    let integer ?suffix i = Pconst_integer (i, suffix)
    let int ?suffix i = integer ?suffix (string_of_int i)
    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
    let float ?suffix f = Pconst_float (f, suffix)
    let char c = Pconst_char c
    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)
  end

  module Typ = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

    let force_poly t =
      match t.ptyp_desc with
      | Ptyp_poly _ -> t
      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)
  end

  module Pat = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
  end

  module Exp = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable

    let case lhs ?guard rhs =
      {
       pc_lhs = lhs;
       pc_guard = guard;
       pc_rhs = rhs;
      }
  end

  module Mty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
  end

  module Mod = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
    let functor_ ?loc ?attrs arg arg_ty body =
      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
  end

  module Sig = struct
    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

    let value ?loc a = mk ?loc (Psig_value a)
    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Psig_typext a)
    let exception_ ?loc a = mk ?loc (Psig_exception a)
    let module_ ?loc a = mk ?loc (Psig_module a)
    let rec_module ?loc a = mk ?loc (Psig_recmodule a)
    let modtype ?loc a = mk ?loc (Psig_modtype a)
    let open_ ?loc a = mk ?loc (Psig_open a)
    let include_ ?loc a = mk ?loc (Psig_include a)
    let class_ ?loc a = mk ?loc (Psig_class a)
    let class_type ?loc a = mk ?loc (Psig_class_type a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Psig_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt
  end

  module Str = struct
    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
    let value ?loc a b = mk ?loc (Pstr_value (a, b))
    let primitive ?loc a = mk ?loc (Pstr_primitive a)
    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Pstr_typext a)
    let exception_ ?loc a = mk ?loc (Pstr_exception a)
    let module_ ?loc a = mk ?loc (Pstr_module a)
    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
    let modtype ?loc a = mk ?loc (Pstr_modtype a)
    let open_ ?loc a = mk ?loc (Pstr_open a)
    let class_ ?loc a = mk ?loc (Pstr_class a)
    let class_type ?loc a = mk ?loc (Pstr_class_type a)
    let include_ ?loc a = mk ?loc (Pstr_include a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Pstr_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt
  end

  module Cl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcl_desc = d;
       pcl_loc = loc;
       pcl_attributes = attrs;
      }
    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
  end

  module Cty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcty_desc = d;
       pcty_loc = loc;
       pcty_attributes = attrs;
      }
    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
  end

  module Ctf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
             ?(docs = empty_docs) d =
      {
       pctf_desc = d;
       pctf_loc = loc;
       pctf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
    let attribute ?loc a = mk ?loc (Pctf_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt

    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

  end

  module Cf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) d =
      {
       pcf_desc = d;
       pcf_loc = loc;
       pcf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
    let attribute ?loc a = mk ?loc (Pcf_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt

    let virtual_ ct = Cfk_virtual ct
    let concrete o e = Cfk_concrete (o, e)

    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

  end

  module Val = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(prim = []) name typ =
      {
       pval_name = name;
       pval_type = typ;
       pval_attributes = add_docs_attrs docs attrs;
       pval_loc = loc;
       pval_prim = prim;
      }
  end

  module Md = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name typ =
      {
       pmd_name = name;
       pmd_type = typ;
       pmd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmd_loc = loc;
      }
  end

  module Mtd = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) ?typ name =
      {
       pmtd_name = name;
       pmtd_type = typ;
       pmtd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmtd_loc = loc;
      }
  end

  module Mb = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name expr =
      {
       pmb_name = name;
       pmb_expr = expr;
       pmb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmb_loc = loc;
      }
  end

  module Opn = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(override = Fresh) lid =
      {
       popen_lid = lid;
       popen_override = override;
       popen_loc = loc;
       popen_attributes = add_docs_attrs docs attrs;
      }
  end

  module Incl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
      {
       pincl_mod = mexpr;
       pincl_loc = loc;
       pincl_attributes = add_docs_attrs docs attrs;
      }

  end

  module Vb = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(text = []) pat expr =
      {
       pvb_pat = pat;
       pvb_expr = expr;
       pvb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pvb_loc = loc;
      }
  end

  module Ci = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
          ?(virt = Concrete) ?(params = []) name expr =
      {
       pci_virt = virt;
       pci_params = params;
       pci_name = name;
       pci_expr = expr;
       pci_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pci_loc = loc;
      }
  end

  module Type = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
        ?(params = [])
        ?(cstrs = [])
        ?(kind = Ptype_abstract)
        ?(priv = Public)
        ?manifest
        name =
      {
       ptype_name = name;
       ptype_params = params;
       ptype_cstrs = cstrs;
       ptype_kind = kind;
       ptype_private = priv;
       ptype_manifest = manifest;
       ptype_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       ptype_loc = loc;
      }

    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(args = Pcstr_tuple []) ?res name =
      {
       pcd_name = name;
       pcd_args = args;
       pcd_res = res;
       pcd_loc = loc;
       pcd_attributes = add_info_attrs info attrs;
      }

    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(mut = Immutable) name typ =
      {
       pld_name = name;
       pld_mutable = mut;
       pld_type = typ;
       pld_loc = loc;
       pld_attributes = add_info_attrs info attrs;
      }

  end

  (** Type extensions *)
  module Te = struct
    let mk ?(attrs = []) ?(docs = empty_docs)
          ?(params = []) ?(priv = Public) path constructors =
      {
       ptyext_path = path;
       ptyext_params = params;
       ptyext_constructors = constructors;
       ptyext_private = priv;
       ptyext_attributes = add_docs_attrs docs attrs;
      }

    let constructor ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name kind =
      {
       pext_name = name;
       pext_kind = kind;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =
      {
       pext_name = name;
       pext_kind = Pext_decl(args, res);
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let rebind ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name lid =
      {
       pext_name = name;
       pext_kind = Pext_rebind lid;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

  end

  module Csig = struct
    let mk self fields =
      {
       pcsig_self = self;
       pcsig_fields = fields;
      }
  end

  module Cstr = struct
    let mk self fields =
      {
       pcstr_self = self;
       pcstr_fields = fields;
      }
  end

end

module Ast_mapper : sig
  (** The interface of a -ppx rewriter

    A -ppx rewriter is a program that accepts a serialized abstract syntax
    tree and outputs another, possibly modified, abstract syntax tree.
    This module encapsulates the interface between the compiler and
    the -ppx rewriters, handling such details as the serialization format,
    forwarding of command-line flags, and storing state.

    {!mapper} allows to implement AST rewriting using open recursion.
    A typical mapper would be based on {!default_mapper}, a deep
    identity mapper, and will fall back on it for handling the syntax it
    does not modify. For example:

    {[
  open Asttypes
  open Parsetree
  open Ast_mapper

  let test_mapper argv =
    { default_mapper with
      expr = fun mapper expr ->
        match expr with
        | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
          Ast_helper.Exp.constant (Const_int 42)
        | other -> default_mapper.expr mapper other; }

  let () =
    register "ppx_test" test_mapper]}

    This -ppx rewriter, which replaces [[%test]] in expressions with
    the constant [42], can be compiled using
    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

    *)

  open Parsetree

  (** {2 A generic Parsetree mapper} *)

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }
  (** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. *)

  val default_mapper: mapper
  (** A default mapper, which implements a "deep identity" mapping. *)

  (** {2 Convenience functions to write mappers} *)

  val map_opt: ('a -> 'b) -> 'a option -> 'b option

  val extension_of_error: Location.error -> extension
  (** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. *)

  val attribute_of_warning: Location.t -> string -> attribute
  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. *)

end = struct
  (* A generic Parsetree mapping class *)

  (*
  [@@@ocaml.warning "+9"]
    (* Ensure that record patterns don't miss any field. *)
  *)


  open Parsetree
  open Ast_helper
  open Location

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }

  let map_fst f (x, y) = (f x, y)
  let map_snd f (x, y) = (x, f y)
  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
  let map_opt f = function None -> None | Some x -> Some (f x)

  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

  module T = struct
    (* Type expressions for the core language *)

    let row_field sub = function
      | Rtag (l, attrs, b, tl) ->
          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
      | Rinherit t -> Rinherit (sub.typ sub t)

    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
      let open Typ in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ptyp_any -> any ~loc ~attrs ()
      | Ptyp_var s -> var ~loc ~attrs s
      | Ptyp_arrow (lab, t1, t2) ->
          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
      | Ptyp_constr (lid, tl) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_object (l, o) ->
          let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in
          object_ ~loc ~attrs (List.map f l) o
      | Ptyp_class (lid, tl) ->
          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
      | Ptyp_variant (rl, b, ll) ->
          variant ~loc ~attrs (List.map (row_field sub) rl) b ll
      | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)
      | Ptyp_package (lid, l) ->
          package ~loc ~attrs (map_loc sub lid)
            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_type_declaration sub
        {ptype_name; ptype_params; ptype_cstrs;
         ptype_kind;
         ptype_private;
         ptype_manifest;
         ptype_attributes;
         ptype_loc} =
      Type.mk (map_loc sub ptype_name)
        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
        ~priv:ptype_private
        ~cstrs:(List.map
                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                  ptype_cstrs)
        ~kind:(sub.type_kind sub ptype_kind)
        ?manifest:(map_opt (sub.typ sub) ptype_manifest)
        ~loc:(sub.location sub ptype_loc)
        ~attrs:(sub.attributes sub ptype_attributes)

    let map_type_kind sub = function
      | Ptype_abstract -> Ptype_abstract
      | Ptype_variant l ->
          Ptype_variant (List.map (sub.constructor_declaration sub) l)
      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
      | Ptype_open -> Ptype_open

    let map_constructor_arguments sub = function
      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)
      | Pcstr_record l ->
          Pcstr_record (List.map (sub.label_declaration sub) l)

    let map_type_extension sub
        {ptyext_path; ptyext_params;
         ptyext_constructors;
         ptyext_private;
         ptyext_attributes} =
      Te.mk
        (map_loc sub ptyext_path)
        (List.map (sub.extension_constructor sub) ptyext_constructors)
        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
        ~priv:ptyext_private
        ~attrs:(sub.attributes sub ptyext_attributes)

    let map_extension_constructor_kind sub = function
        Pext_decl(ctl, cto) ->
          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)
      | Pext_rebind li ->
          Pext_rebind (map_loc sub li)

    let map_extension_constructor sub
        {pext_name;
         pext_kind;
         pext_loc;
         pext_attributes} =
      Te.constructor
        (map_loc sub pext_name)
        (map_extension_constructor_kind sub pext_kind)
        ~loc:(sub.location sub pext_loc)
        ~attrs:(sub.attributes sub pext_attributes)

  end

  module CT = struct
    (* Type expressions for the class language *)

    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
      let open Cty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcty_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
      | Pcty_arrow (lab, t, ct) ->
          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
      =
      let open Ctf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
      | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)
      | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)
      | Pctf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_signature sub {pcsig_self; pcsig_fields} =
      Csig.mk
        (sub.typ sub pcsig_self)
        (List.map (sub.class_type_field sub) pcsig_fields)
  end

  module MT = struct
    (* Type expressions for the module language *)

    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
      let open Mty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
      | Pmty_functor (s, mt1, mt2) ->
          functor_ ~loc ~attrs (map_loc sub s)
            (Misc.may_map (sub.module_type sub) mt1)
            (sub.module_type sub mt2)
      | Pmty_with (mt, l) ->
          with_ ~loc ~attrs (sub.module_type sub mt)
            (List.map (sub.with_constraint sub) l)
      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_with_constraint sub = function
      | Pwith_type (lid, d) ->
          Pwith_type (map_loc sub lid, sub.type_declaration sub d)
      | Pwith_module (lid, lid2) ->
          Pwith_module (map_loc sub lid, map_loc sub lid2)
      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
      | Pwith_modsubst (s, lid) ->
          Pwith_modsubst (map_loc sub s, map_loc sub lid)

    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
      let open Sig in
      let loc = sub.location sub loc in
      match desc with
      | Psig_value vd -> value ~loc (sub.value_description sub vd)
      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
      | Psig_recmodule l ->
          rec_module ~loc (List.map (sub.module_declaration sub) l)
      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Psig_open x -> open_ ~loc (sub.open_description sub x)
      | Psig_include x -> include_ ~loc (sub.include_description sub x)
      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
      | Psig_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Psig_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
  end


  module M = struct
    (* Value expressions for the module language *)

    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
      let open Mod in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
      | Pmod_functor (arg, arg_ty, body) ->
          functor_ ~loc ~attrs (map_loc sub arg)
            (Misc.may_map (sub.module_type sub) arg_ty)
            (sub.module_expr sub body)
      | Pmod_apply (m1, m2) ->
          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
      | Pmod_constraint (m, mty) ->
          constraint_ ~loc ~attrs (sub.module_expr sub m)
                      (sub.module_type sub mty)
      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
      let open Str in
      let loc = sub.location sub loc in
      match desc with
      | Pstr_eval (x, attrs) ->
          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Pstr_open x -> open_ ~loc (sub.open_description sub x)
      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
      | Pstr_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
      | Pstr_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
  end

  module E = struct
    (* Value expressions for the core language *)

    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
      let open Exp in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pexp_constant x -> constant ~loc ~attrs x
      | Pexp_let (r, vbs, e) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.expr sub e)
      | Pexp_fun (lab, def, p, e) ->
          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
            (sub.expr sub e)
      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
      | Pexp_apply (e, l) ->
          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
      | Pexp_match (e, pel) ->
          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_construct (lid, arg) ->
          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
      | Pexp_variant (lab, eo) ->
          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
      | Pexp_record (l, eo) ->
          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
            (map_opt (sub.expr sub) eo)
      | Pexp_field (e, lid) ->
          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
      | Pexp_setfield (e1, lid, e2) ->
          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
            (sub.expr sub e2)
      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_ifthenelse (e1, e2, e3) ->
          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
            (map_opt (sub.expr sub) e3)
      | Pexp_sequence (e1, e2) ->
          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_while (e1, e2) ->
          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_for (p, e1, e2, d, e3) ->
          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
            (sub.expr sub e3)
      | Pexp_coerce (e, t1, t2) ->
          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
            (sub.typ sub t2)
      | Pexp_constraint (e, t) ->
          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
      | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s
      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
      | Pexp_setinstvar (s, e) ->
          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_override sel ->
          override ~loc ~attrs
            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
      | Pexp_letmodule (s, me, e) ->
          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
            (sub.expr sub e)
      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
      | Pexp_poly (e, t) ->
          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
      | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)
      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
      | Pexp_open (ovf, lid, e) ->
          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
      | Pexp_unreachable -> unreachable ~loc ~attrs ()
  end

  module P = struct
    (* Patterns *)

    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
      let open Pat in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ppat_any -> any ~loc ~attrs ()
      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
      | Ppat_constant c -> constant ~loc ~attrs c
      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_construct (l, p) ->
          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
      | Ppat_record (lpl, cf) ->
          record ~loc ~attrs
                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
      | Ppat_constraint (p, t) ->
          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module CE = struct
    (* Value expressions for the class language *)

    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
      let open Cl in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcl_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcl_structure s ->
          structure ~loc ~attrs (sub.class_structure sub s)
      | Pcl_fun (lab, e, p, ce) ->
          fun_ ~loc ~attrs lab
            (map_opt (sub.expr sub) e)
            (sub.pat sub p)
            (sub.class_expr sub ce)
      | Pcl_apply (ce, l) ->
          apply ~loc ~attrs (sub.class_expr sub ce)
            (List.map (map_snd (sub.expr sub)) l)
      | Pcl_let (r, vbs, ce) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.class_expr sub ce)
      | Pcl_constraint (ce, ct) ->
          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_kind sub = function
      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
      let open Cf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s
      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
      | Pcf_method (s, p, k) ->
          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
      | Pcf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure sub {pcstr_self; pcstr_fields} =
      {
        pcstr_self = sub.pat sub pcstr_self;
        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
      }

    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                           pci_loc; pci_attributes} =
      Ci.mk
       ~virt:pci_virt
       ~params:(List.map (map_fst (sub.typ sub)) pl)
        (map_loc sub pci_name)
        (f pci_expr)
        ~loc:(sub.location sub pci_loc)
        ~attrs:(sub.attributes sub pci_attributes)
  end

  (* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. *)

  let default_mapper =
    {
      structure = (fun this l -> List.map (this.structure_item this) l);
      structure_item = M.map_structure_item;
      module_expr = M.map;
      signature = (fun this l -> List.map (this.signature_item this) l);
      signature_item = MT.map_signature_item;
      module_type = MT.map;
      with_constraint = MT.map_with_constraint;
      class_declaration =
        (fun this -> CE.class_infos this (this.class_expr this));
      class_expr = CE.map;
      class_field = CE.map_field;
      class_structure = CE.map_structure;
      class_type = CT.map;
      class_type_field = CT.map_field;
      class_signature = CT.map_signature;
      class_type_declaration =
        (fun this -> CE.class_infos this (this.class_type this));
      class_description =
        (fun this -> CE.class_infos this (this.class_type this));
      type_declaration = T.map_type_declaration;
      type_kind = T.map_type_kind;
      typ = T.map;
      type_extension = T.map_type_extension;
      extension_constructor = T.map_extension_constructor;
      value_description =
        (fun this {pval_name; pval_type; pval_prim; pval_loc;
                   pval_attributes} ->
          Val.mk
            (map_loc this pval_name)
            (this.typ this pval_type)
            ~attrs:(this.attributes this pval_attributes)
            ~loc:(this.location this pval_loc)
            ~prim:pval_prim
        );

      pat = P.map;
      expr = E.map;

      module_declaration =
        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
           Md.mk
             (map_loc this pmd_name)
             (this.module_type this pmd_type)
             ~attrs:(this.attributes this pmd_attributes)
             ~loc:(this.location this pmd_loc)
        );

      module_type_declaration =
        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
           Mtd.mk
             (map_loc this pmtd_name)
             ?typ:(map_opt (this.module_type this) pmtd_type)
             ~attrs:(this.attributes this pmtd_attributes)
             ~loc:(this.location this pmtd_loc)
        );

      module_binding =
        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
             ~attrs:(this.attributes this pmb_attributes)
             ~loc:(this.location this pmb_loc)
        );


      open_description =
        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
           Opn.mk (map_loc this popen_lid)
             ~override:popen_override
             ~loc:(this.location this popen_loc)
             ~attrs:(this.attributes this popen_attributes)
        );


      include_description =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_type this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );

      include_declaration =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_expr this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );


      value_binding =
        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
           Vb.mk
             (this.pat this pvb_pat)
             (this.expr this pvb_expr)
             ~loc:(this.location this pvb_loc)
             ~attrs:(this.attributes this pvb_attributes)
        );


      constructor_declaration =
        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
          Type.constructor
            (map_loc this pcd_name)
            ~args:(T.map_constructor_arguments this pcd_args)
            ?res:(map_opt (this.typ this) pcd_res)
            ~loc:(this.location this pcd_loc)
            ~attrs:(this.attributes this pcd_attributes)
        );

      label_declaration =
        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
           Type.field
             (map_loc this pld_name)
             (this.typ this pld_type)
             ~mut:pld_mutable
             ~loc:(this.location this pld_loc)
             ~attrs:(this.attributes this pld_attributes)
        );

      cases = (fun this l -> List.map (this.case this) l);
      case =
        (fun this {pc_lhs; pc_guard; pc_rhs} ->
           {
             pc_lhs = this.pat this pc_lhs;
             pc_guard = map_opt (this.expr this) pc_guard;
             pc_rhs = this.expr this pc_rhs;
           }
        );



      location = (fun _this l -> l);

      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attributes = (fun this l -> List.map (this.attribute this) l);
      payload =
        (fun this -> function
           | PStr x -> PStr (this.structure this x)
           | PSig x -> PSig (this.signature this x)
           | PTyp x -> PTyp (this.typ this x)
           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
        );
    }

  let rec extension_of_error {loc; msg; if_highlight; sub} =
    { loc; txt = "ocaml.error" },
    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));
           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @
          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

  let attribute_of_warning loc s =
    { loc; txt = "ocaml.ppwarning" },
    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])

end

module Outcometree = struct
  (* Module [Outcometree]: results displayed by the toplevel *)

  (* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
        [Toploop.print_out_value]
        [Toploop.print_out_type]
        [Toploop.print_out_sig_item]
        [Toploop.print_out_phrase] *)

  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =
    | Oide_apply of out_ident * out_ident
    | Oide_dot of out_ident * string
    | Oide_ident of string

  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =
    { oattr_name: string }

  type out_value (*IF_CURRENT = Outcometree.out_value *) =
    | Oval_array of out_value list
    | Oval_char of char
    | Oval_constr of out_ident * out_value list
    | Oval_ellipsis
    | Oval_float of float
    | Oval_int of int
    | Oval_int32 of int32
    | Oval_int64 of int64
    | Oval_nativeint of nativeint
    | Oval_list of out_value list
    | Oval_printer of (Format.formatter -> unit)
    | Oval_record of (out_ident * out_value) list
    | Oval_string of string
    | Oval_stuff of string
    | Oval_tuple of out_value list
    | Oval_variant of string * out_value option

  type out_type (*IF_CURRENT = Outcometree.out_type *) =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias of out_type * string
    | Otyp_arrow of string * out_type * out_type
    | Otyp_class of bool * out_ident * out_type list
    | Otyp_constr of out_ident * out_type list
    | Otyp_manifest of out_type * out_type
    | Otyp_object of (string * out_type) list * bool option
    | Otyp_record of (string * bool * out_type) list
    | Otyp_stuff of string
    | Otyp_sum of (string * out_type list * out_type option) list
    | Otyp_tuple of out_type list
    | Otyp_var of bool * string
    | Otyp_variant of
        bool * out_variant * bool * (string list) option
    | Otyp_poly of string list * out_type
    | Otyp_module of string * string list * out_type list
    | Otyp_attribute of out_type * out_attribute

  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =
    | Ovar_fields of (string * bool * out_type list) list
    | Ovar_name of out_ident * out_type list

  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =
    | Octy_constr of out_ident * out_type list
    | Octy_arrow of string * out_type * out_class_type
    | Octy_signature of out_type option * out_class_sig_item list
  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =
    | Ocsg_constraint of out_type * out_type
    | Ocsg_method of string * bool * bool * out_type
    | Ocsg_value of string * bool * bool * out_type

  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =
    | Omty_abstract
    | Omty_functor of string * out_module_type option * out_module_type
    | Omty_ident of out_ident
    | Omty_signature of out_sig_item list
    | Omty_alias of out_ident
  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =
    | Osig_class of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_class_type of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_typext of out_extension_constructor * out_ext_status
    | Osig_modtype of string * out_module_type
    | Osig_module of string * out_module_type * out_rec_status
    | Osig_type of out_type_decl * out_rec_status
    | Osig_value of out_val_decl
    | Osig_ellipsis
  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =
    { otype_name: string;
      otype_params: (string * (bool * bool)) list;
      otype_type: out_type;
      otype_private: Asttypes.private_flag;
      otype_immediate: bool;
      otype_cstrs: (out_type * out_type) list }
  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =
    { oext_name: string;
      oext_type_name: string;
      oext_type_params: string list;
      oext_args: out_type list;
      oext_ret_type: out_type option;
      oext_private: Asttypes.private_flag }
  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =
    { otyext_name: string;
      otyext_params: string list;
      otyext_constructors: (string * out_type list * out_type option) list;
      otyext_private: Asttypes.private_flag }
  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =
    { oval_name: string;
      oval_type: out_type;
      oval_prims: string list;
      oval_attributes: out_attribute list }
  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =
    | Oext_first
    | Oext_next
    | Oext_exception

  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =
    | Ophr_eval of out_value * out_type
    | Ophr_signature of (out_sig_item * out_value option) list
    | Ophr_exception of (exn * out_value)

end

module Config = struct
  let ast_impl_magic_number = "Caml1999M019"
  let ast_intf_magic_number = "Caml1999N018"
end

let map_signature mapper = mapper.Ast_mapper.signature mapper
let map_structure mapper = mapper.Ast_mapper.structure mapper

let failing_mapper =
  let fail _ _ =
    invalid_arg "failing_mapper: this mapper function should never get called"
  in
  {
    Ast_mapper.
    structure               = fail;
    structure_item          = fail;
    module_expr             = fail;
    signature               = fail;
    signature_item          = fail;
    module_type             = fail;
    with_constraint         = fail;
    class_declaration       = fail;
    class_expr              = fail;
    class_field             = fail;
    class_structure         = fail;
    class_type              = fail;
    class_type_field        = fail;
    class_signature         = fail;
    class_type_declaration  = fail;
    class_description       = fail;
    type_declaration        = fail;
    type_kind               = fail;
    typ                     = fail;
    type_extension          = fail;
    extension_constructor   = fail;
    value_description       = fail;
    pat                     = fail;
    expr                    = fail;
    module_declaration      = fail;
    module_type_declaration = fail;
    module_binding          = fail;
    open_description        = fail;
    include_description     = fail;
    include_declaration     = fail;
    value_binding           = fail;
    constructor_declaration = fail;
    label_declaration       = fail;
    cases                   = fail;
    case                    = fail;
    location                = fail;
    extension               = fail;
    attribute               = fail;
    attributes              = fail;
    payload                 = fail;
  }

let make_top_mapper ~signature ~structure =
  {failing_mapper with Ast_mapper.
                    signature = (fun _ x -> signature x);
                    structure = (fun _ x -> structure x) }

end
module Ast_405
= struct
#1 "ast_405.ml"
# 1 "src/ast_405.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*            Jérémie Dimino and Leo White, Jane Street Europe            *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)
(*                         Alain Frisch, LexiFi                           *)
(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Location = Location
module Longident = Longident

module Asttypes = struct
  (** Auxiliary AST types used by parsetree and typedtree. *)

  type constant (*IF_CURRENT = Asttypes.constant *) =
      Const_int of int
    | Const_char of char
    | Const_string of string * string option
    | Const_float of string
    | Const_int32 of int32
    | Const_int64 of int64
    | Const_nativeint of nativeint

  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive

  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto

  (* Order matters, used in polymorphic comparison *)
  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public

  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable

  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete

  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh

  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open

  type label = string

  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =
      Nolabel
    | Labelled of string (*  label:T -> ... *)
    | Optional of string (* ?label:T -> ... *)

  type 'a loc = 'a Location.loc = {
    txt : 'a;
    loc : Location.t;
  }


  type variance (*IF_CURRENT = Asttypes.variance *) =
    | Covariant
    | Contravariant
    | Invariant
end

module Parsetree = struct
  (** Abstract syntax tree produced by parsing *)

  open Asttypes

  type constant (*IF_CURRENT = Parsetree.constant *) =
      Pconst_integer of string * char option
    (* 3 3l 3L 3n

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker
    *)
    | Pconst_char of char
    (* 'c' *)
    | Pconst_string of string * string option
    (* "constant"
       {delim|other constant|delim}
    *)
    | Pconst_float of string * char option
    (* 3.4 2e5 1.4e-4

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes are rejected by the typechecker.
    *)

  (** {2 Extension points} *)

  type attribute = string loc * payload
         (* [@id ARG]
            [@@id ARG]

            Metadata containers passed around within the AST.
            The compiler ignores unknown attributes.
         *)

  and extension = string loc * payload
        (* [%id ARG]
           [%%id ARG]

           Sub-language placeholder -- rejected by the typechecker.
        *)

  and attributes = attribute list

  and payload (*IF_CURRENT = Parsetree.payload *) =
    | PStr of structure
    | PSig of signature (* : SIG *)
    | PTyp of core_type  (* : T *)
    | PPat of pattern * expression option  (* ? P  or  ? P when E *)

  (** {2 Core language} *)

  (* Type expressions *)

  and core_type (*IF_CURRENT = Parsetree.core_type *) =
      {
       ptyp_desc: core_type_desc;
       ptyp_loc: Location.t;
       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =
    | Ptyp_any
          (*  _ *)
    | Ptyp_var of string
          (* 'a *)
    | Ptyp_arrow of arg_label * core_type * core_type
          (* T1 -> T2       Simple
             ~l:T1 -> T2    Labelled
             ?l:T1 -> T2    Otional
           *)
    | Ptyp_tuple of core_type list
          (* T1 * ... * Tn

             Invariant: n >= 2
          *)
    | Ptyp_constr of Longident.t loc * core_type list
          (* tconstr
             T tconstr
             (T1, ..., Tn) tconstr
           *)
    | Ptyp_object of (string loc * attributes * core_type) list * closed_flag
          (* < l1:T1; ...; ln:Tn >     (flag = Closed)
             < l1:T1; ...; ln:Tn; .. > (flag = Open)
           *)
    | Ptyp_class of Longident.t loc * core_type list
          (* #tconstr
             T #tconstr
             (T1, ..., Tn) #tconstr
           *)
    | Ptyp_alias of core_type * string
          (* T as 'a *)
    | Ptyp_variant of row_field list * closed_flag * label list option
          (* [ `A|`B ]         (flag = Closed; labels = None)
             [> `A|`B ]        (flag = Open;   labels = None)
             [< `A|`B ]        (flag = Closed; labels = Some [])
             [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
           *)
    | Ptyp_poly of string loc list * core_type
          (* 'a1 ... 'an. T

             Can only appear in the following context:

             - As the core_type of a Ppat_constraint node corresponding
               to a constraint on a let-binding: let x : 'a1 ... 'an. T
               = e ...

             - Under Cfk_virtual for methods (not values).

             - As the core_type of a Pctf_method node.

             - As the core_type of a Pexp_poly node.

             - As the pld_type field of a label_declaration.

             - As a core_type of a Ptyp_object node.
           *)

    | Ptyp_package of package_type
          (* (module S) *)
    | Ptyp_extension of extension
          (* [%id] *)

  and package_type = Longident.t loc * (Longident.t loc * core_type) list
        (*
          (module S)
          (module S with type t1 = T1 and ... and tn = Tn)
         *)

  and row_field (*IF_CURRENT = Parsetree.row_field *) =
    | Rtag of label * attributes * bool * core_type list
          (* [`A]                   ( true,  [] )
             [`A of T]              ( false, [T] )
             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

            - The 2nd field is true if the tag contains a
              constant (empty) constructor.
            - '&' occurs when several types are used for the same constructor
              (see 4.2 in the manual)

            - TODO: switch to a record representation, and keep location
          *)
    | Rinherit of core_type
          (* [ T ] *)

  (* Patterns *)

  and pattern (*IF_CURRENT = Parsetree.pattern *) =
      {
       ppat_desc: pattern_desc;
       ppat_loc: Location.t;
       ppat_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =
    | Ppat_any
          (* _ *)
    | Ppat_var of string loc
          (* x *)
    | Ppat_alias of pattern * string loc
          (* P as 'a *)
    | Ppat_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Ppat_interval of constant * constant
          (* 'a'..'z'

             Other forms of interval are recognized by the parser
             but rejected by the type-checker. *)
    | Ppat_tuple of pattern list
          (* (P1, ..., Pn)

             Invariant: n >= 2
          *)
    | Ppat_construct of Longident.t loc * pattern option
          (* C                None
             C P              Some P
             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
           *)
    | Ppat_variant of label * pattern option
          (* `A             (None)
             `A P           (Some P)
           *)
    | Ppat_record of (Longident.t loc * pattern) list * closed_flag
          (* { l1=P1; ...; ln=Pn }     (flag = Closed)
             { l1=P1; ...; ln=Pn; _}   (flag = Open)

             Invariant: n > 0
           *)
    | Ppat_array of pattern list
          (* [| P1; ...; Pn |] *)
    | Ppat_or of pattern * pattern
          (* P1 | P2 *)
    | Ppat_constraint of pattern * core_type
          (* (P : T) *)
    | Ppat_type of Longident.t loc
          (* #tconst *)
    | Ppat_lazy of pattern
          (* lazy P *)
    | Ppat_unpack of string loc
          (* (module P)
             Note: (module P : S) is represented as
             Ppat_constraint(Ppat_unpack, Ptyp_package)
           *)
    | Ppat_exception of pattern
          (* exception P *)
    | Ppat_extension of extension
          (* [%id] *)
    | Ppat_open of Longident.t loc * pattern
          (* M.(P) *)

  (* Value expressions *)

  and expression (*IF_CURRENT = Parsetree.expression *) =
      {
       pexp_desc: expression_desc;
       pexp_loc: Location.t;
       pexp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =
    | Pexp_ident of Longident.t loc
          (* x
             M.x
           *)
    | Pexp_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Pexp_let of rec_flag * value_binding list * expression
          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
           *)
    | Pexp_function of case list
          (* function P1 -> E1 | ... | Pn -> En *)
    | Pexp_fun of arg_label * expression option * pattern * expression
          (* fun P -> E1                          (Simple, None)
             fun ~l:P -> E1                       (Labelled l, None)
             fun ?l:P -> E1                       (Optional l, None)
             fun ?l:(P = E0) -> E1                (Optional l, Some E0)

             Notes:
             - If E0 is provided, only Optional is allowed.
             - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
             - "let f P = E" is represented using Pexp_fun.
           *)
    | Pexp_apply of expression * (arg_label * expression) list
          (* E0 ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pexp_match of expression * case list
          (* match E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_try of expression * case list
          (* try E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_tuple of expression list
          (* (E1, ..., En)

             Invariant: n >= 2
          *)
    | Pexp_construct of Longident.t loc * expression option
          (* C                None
             C E              Some E
             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
          *)
    | Pexp_variant of label * expression option
          (* `A             (None)
             `A E           (Some E)
           *)
    | Pexp_record of (Longident.t loc * expression) list * expression option
          (* { l1=P1; ...; ln=Pn }     (None)
             { E0 with l1=P1; ...; ln=Pn }   (Some E0)

             Invariant: n > 0
           *)
    | Pexp_field of expression * Longident.t loc
          (* E.l *)
    | Pexp_setfield of expression * Longident.t loc * expression
          (* E1.l <- E2 *)
    | Pexp_array of expression list
          (* [| E1; ...; En |] *)
    | Pexp_ifthenelse of expression * expression * expression option
          (* if E1 then E2 else E3 *)
    | Pexp_sequence of expression * expression
          (* E1; E2 *)
    | Pexp_while of expression * expression
          (* while E1 do E2 done *)
    | Pexp_for of
        pattern *  expression * expression * direction_flag * expression
          (* for i = E1 to E2 do E3 done      (flag = Upto)
             for i = E1 downto E2 do E3 done  (flag = Downto)
           *)
    | Pexp_constraint of expression * core_type
          (* (E : T) *)
    | Pexp_coerce of expression * core_type option * core_type
          (* (E :> T)        (None, T)
             (E : T0 :> T)   (Some T0, T)
           *)
    | Pexp_send of expression * string loc
          (*  E # m *)
    | Pexp_new of Longident.t loc
          (* new M.c *)
    | Pexp_setinstvar of string loc * expression
          (* x <- 2 *)
    | Pexp_override of (string loc * expression) list
          (* {< x1 = E1; ...; Xn = En >} *)
    | Pexp_letmodule of string loc * module_expr * expression
          (* let module M = ME in E *)
    | Pexp_letexception of extension_constructor * expression
          (* let exception C in E *)
    | Pexp_assert of expression
          (* assert E
             Note: "assert false" is treated in a special way by the
             type-checker. *)
    | Pexp_lazy of expression
          (* lazy E *)
    | Pexp_poly of expression * core_type option
          (* Used for method bodies.

             Can only be used as the expression under Cfk_concrete
             for methods (not values). *)
    | Pexp_object of class_structure
          (* object ... end *)
    | Pexp_newtype of string loc * expression
          (* fun (type t) -> E *)
    | Pexp_pack of module_expr
          (* (module ME)

             (module ME : S) is represented as
             Pexp_constraint(Pexp_pack, Ptyp_package S) *)
    | Pexp_open of override_flag * Longident.t loc * expression
          (* M.(E)
             let open M in E
             let! open M in E *)
    | Pexp_extension of extension
          (* [%id] *)
    | Pexp_unreachable
          (* . *)

  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)
      {
       pc_lhs: pattern;
       pc_guard: expression option;
       pc_rhs: expression;
      }

  (* Value descriptions *)

  and value_description (*IF_CURRENT = Parsetree.value_description *) =
      {
       pval_name: string loc;
       pval_type: core_type;
       pval_prim: string list;
       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
       pval_loc: Location.t;
      }

  (*
    val x: T                            (prim = [])
    external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])
  *)

  (* Type declarations *)

  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =
      {
       ptype_name: string loc;
       ptype_params: (core_type * variance) list;
             (* ('a1,...'an) t; None represents  _*)
       ptype_cstrs: (core_type * core_type * Location.t) list;
             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
       ptype_kind: type_kind;
       ptype_private: private_flag;   (* = private ... *)
       ptype_manifest: core_type option;  (* = T *)
       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       ptype_loc: Location.t;
      }

  (*
    type t                     (abstract, no manifest)
    type t = T0                (abstract, manifest=T0)
    type t = C of T | ...      (variant,  no manifest)
    type t = T0 = C of T | ... (variant,  manifest=T0)
    type t = {l: T; ...}       (record,   no manifest)
    type t = T0 = {l : T; ...} (record,   manifest=T0)
    type t = ..                (open,     no manifest)
  *)

  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =
    | Ptype_abstract
    | Ptype_variant of constructor_declaration list
          (* Invariant: non-empty list *)
    | Ptype_record of label_declaration list
          (* Invariant: non-empty list *)
    | Ptype_open

  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =
      {
       pld_name: string loc;
       pld_mutable: mutable_flag;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes; (* l [@id1] [@id2] : T *)
      }

  (*  { ...; l: T; ... }            (mutable=Immutable)
      { ...; mutable l: T; ... }    (mutable=Mutable)

      Note: T can be a Ptyp_poly.
  *)

  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =
      {
       pcd_name: string loc;
       pcd_args: constructor_arguments;
       pcd_res: core_type option;
       pcd_loc: Location.t;
       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =
    | Pcstr_tuple of core_type list
    | Pcstr_record of label_declaration list

  (*
    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])
    | C: T0                  (res = Some T0, args = [])
    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)
    | C of {...}             (res = None,    args = Pcstr_record)
    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)
    | C of {...} as t        (res = None,    args = Pcstr_record)
  *)

  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =
      {
       ptyext_path: Longident.t loc;
       ptyext_params: (core_type * variance) list;
       ptyext_constructors: extension_constructor list;
       ptyext_private: private_flag;
       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
      }
  (*
    type t += ...
  *)

  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =
      {
       pext_name: string loc;
       pext_kind : extension_constructor_kind;
       pext_loc : Location.t;
       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =
      Pext_decl of constructor_arguments * core_type option
        (*
           | C of T1 * ... * Tn     ([T1; ...; Tn], None)
           | C: T0                  ([], Some T0)
           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
         *)
    | Pext_rebind of Longident.t loc
        (*
           | C = D
         *)

  (** {2 Class language} *)

  (* Type expressions for the class language *)

  and class_type (*IF_CURRENT = Parsetree.class_type *) =
      {
       pcty_desc: class_type_desc;
       pcty_loc: Location.t;
       pcty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =
    | Pcty_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcty_signature of class_signature
          (* object ... end *)
    | Pcty_arrow of arg_label * core_type * class_type
          (* T -> CT       Simple
             ~l:T -> CT    Labelled l
             ?l:T -> CT    Optional l
           *)
    | Pcty_extension of extension
          (* [%id] *)

  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =
      {
       pcsig_self: core_type;
       pcsig_fields: class_type_field list;
      }
  (* object('selfpat) ... end
     object ... end             (self = Ptyp_any)
   *)

  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =
      {
       pctf_desc: class_type_field_desc;
       pctf_loc: Location.t;
       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =
    | Pctf_inherit of class_type
          (* inherit CT *)
    | Pctf_val of (string loc * mutable_flag * virtual_flag * core_type)
          (* val x: T *)
    | Pctf_method  of (string loc * private_flag * virtual_flag * core_type)
          (* method x: T

             Note: T can be a Ptyp_poly.
           *)
    | Pctf_constraint  of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pctf_attribute of attribute
          (* [@@@id] *)
    | Pctf_extension of extension
          (* [%%id] *)

  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =
      {
       pci_virt: virtual_flag;
       pci_params: (core_type * variance) list;
       pci_name: string loc;
       pci_expr: 'a;
       pci_loc: Location.t;
       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
      }
  (* class c = ...
     class ['a1,...,'an] c = ...
     class virtual c = ...

     Also used for "class type" declaration.
  *)

  and class_description = class_type class_infos

  and class_type_declaration = class_type class_infos

  (* Value expressions for the class language *)

  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =
      {
       pcl_desc: class_expr_desc;
       pcl_loc: Location.t;
       pcl_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =
    | Pcl_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcl_structure of class_structure
          (* object ... end *)
    | Pcl_fun of arg_label * expression option * pattern * class_expr
          (* fun P -> CE                          (Simple, None)
             fun ~l:P -> CE                       (Labelled l, None)
             fun ?l:P -> CE                       (Optional l, None)
             fun ?l:(P = E0) -> CE                (Optional l, Some E0)
           *)
    | Pcl_apply of class_expr * (arg_label * expression) list
          (* CE ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pcl_let of rec_flag * value_binding list * class_expr
          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
           *)
    | Pcl_constraint of class_expr * class_type
          (* (CE : CT) *)
    | Pcl_extension of extension
          (* [%id] *)

  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =
      {
       pcstr_self: pattern;
       pcstr_fields: class_field list;
      }
  (* object(selfpat) ... end
     object ... end           (self = Ppat_any)
   *)

  and class_field (*IF_CURRENT = Parsetree.class_field *) =
      {
       pcf_desc: class_field_desc;
       pcf_loc: Location.t;
       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =
    | Pcf_inherit of override_flag * class_expr * string loc option
          (* inherit CE
             inherit CE as x
             inherit! CE
             inherit! CE as x
           *)
    | Pcf_val of (string loc * mutable_flag * class_field_kind)
          (* val x = E
             val virtual x: T
           *)
    | Pcf_method of (string loc * private_flag * class_field_kind)
          (* method x = E            (E can be a Pexp_poly)
             method virtual x: T     (T can be a Ptyp_poly)
           *)
    | Pcf_constraint of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pcf_initializer of expression
          (* initializer E *)
    | Pcf_attribute of attribute
          (* [@@@id] *)
    | Pcf_extension of extension
          (* [%%id] *)

  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =
    | Cfk_virtual of core_type
    | Cfk_concrete of override_flag * expression

  and class_declaration = class_expr class_infos

  (** {2 Module language} *)

  (* Type expressions for the module language *)

  and module_type (*IF_CURRENT = Parsetree.module_type *) =
      {
       pmty_desc: module_type_desc;
       pmty_loc: Location.t;
       pmty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =
    | Pmty_ident of Longident.t loc
          (* S *)
    | Pmty_signature of signature
          (* sig ... end *)
    | Pmty_functor of string loc * module_type option * module_type
          (* functor(X : MT1) -> MT2 *)
    | Pmty_with of module_type * with_constraint list
          (* MT with ... *)
    | Pmty_typeof of module_expr
          (* module type of ME *)
    | Pmty_extension of extension
          (* [%id] *)
    | Pmty_alias of Longident.t loc
          (* (module M) *)

  and signature = signature_item list

  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =
      {
       psig_desc: signature_item_desc;
       psig_loc: Location.t;
      }

  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =
    | Psig_value of value_description
          (*
            val x: T
            external x: T = "s1" ... "sn"
           *)
    | Psig_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Psig_typext of type_extension
          (* type t1 += ... *)
    | Psig_exception of extension_constructor
          (* exception C of T *)
    | Psig_module of module_declaration
          (* module X : MT *)
    | Psig_recmodule of module_declaration list
          (* module rec X1 : MT1 and ... and Xn : MTn *)
    | Psig_modtype of module_type_declaration
          (* module type S = MT
             module type S *)
    | Psig_open of open_description
          (* open X *)
    | Psig_include of include_description
          (* include MT *)
    | Psig_class of class_description list
          (* class c1 : ... and ... and cn : ... *)
    | Psig_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Psig_attribute of attribute
          (* [@@@id] *)
    | Psig_extension of extension * attributes
          (* [%%id] *)

  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =
      {
       pmd_name: string loc;
       pmd_type: module_type;
       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmd_loc: Location.t;
      }
  (* S : MT *)

  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =
      {
       pmtd_name: string loc;
       pmtd_type: module_type option;
       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmtd_loc: Location.t;
      }
  (* S = MT
     S       (abstract module type declaration, pmtd_type = None)
  *)

  and open_description (*IF_CURRENT = Parsetree.open_description *) =
      {
       popen_lid: Longident.t loc;
       popen_override: override_flag;
       popen_loc: Location.t;
       popen_attributes: attributes;
      }
  (* open! X - popen_override = Override (silences the 'used identifier
                                shadowing' warning)
     open  X - popen_override = Fresh
   *)

  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =
      {
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
      }

  and include_description = module_type include_infos
  (* include MT *)

  and include_declaration = module_expr include_infos
  (* include ME *)

  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =
    | Pwith_type of Longident.t loc * type_declaration
          (* with type X.t = ...

             Note: the last component of the longident must match
             the name of the type_declaration. *)
    | Pwith_module of Longident.t loc * Longident.t loc
          (* with module X.Y = Z *)
    | Pwith_typesubst of type_declaration
          (* with type t := ... *)
    | Pwith_modsubst of string loc * Longident.t loc
          (* with module X := Z *)

  (* Value expressions for the module language *)

  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =
      {
       pmod_desc: module_expr_desc;
       pmod_loc: Location.t;
       pmod_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =
    | Pmod_ident of Longident.t loc
          (* X *)
    | Pmod_structure of structure
          (* struct ... end *)
    | Pmod_functor of string loc * module_type option * module_expr
          (* functor(X : MT1) -> ME *)
    | Pmod_apply of module_expr * module_expr
          (* ME1(ME2) *)
    | Pmod_constraint of module_expr * module_type
          (* (ME : MT) *)
    | Pmod_unpack of expression
          (* (val E) *)
    | Pmod_extension of extension
          (* [%id] *)

  and structure = structure_item list

  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =
      {
       pstr_desc: structure_item_desc;
       pstr_loc: Location.t;
      }

  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =
    | Pstr_eval of expression * attributes
          (* E *)
    | Pstr_value of rec_flag * value_binding list
          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
           *)
    | Pstr_primitive of value_description
          (*  val x: T
              external x: T = "s1" ... "sn" *)
    | Pstr_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Pstr_typext of type_extension
          (* type t1 += ... *)
    | Pstr_exception of extension_constructor
          (* exception C of T
             exception C = M.X *)
    | Pstr_module of module_binding
          (* module X = ME *)
    | Pstr_recmodule of module_binding list
          (* module rec X1 = ME1 and ... and Xn = MEn *)
    | Pstr_modtype of module_type_declaration
          (* module type S = MT *)
    | Pstr_open of open_description
          (* open X *)
    | Pstr_class of class_declaration list
          (* class c1 = ... and ... and cn = ... *)
    | Pstr_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Pstr_include of include_declaration
          (* include ME *)
    | Pstr_attribute of attribute
          (* [@@@id] *)
    | Pstr_extension of extension * attributes
          (* [%%id] *)

  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =
    {
      pvb_pat: pattern;
      pvb_expr: expression;
      pvb_attributes: attributes;
      pvb_loc: Location.t;
    }

  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =
      {
       pmb_name: string loc;
       pmb_expr: module_expr;
       pmb_attributes: attributes;
       pmb_loc: Location.t;
      }
  (* X = ME *)

  (** {2 Toplevel} *)

  (* Toplevel phrases *)

  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =
    | Ptop_def of structure
    | Ptop_dir of string * directive_argument
       (* #use, #load ... *)

  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =
    | Pdir_none
    | Pdir_string of string
    | Pdir_int of string * char option
    | Pdir_ident of Longident.t
    | Pdir_bool of bool

end

module Docstrings : sig
  (** {3 Docstrings} *)

  (** Documentation comments *)
  type docstring

  (** Create a docstring *)
  val docstring : string -> Location.t -> docstring

  (** Get the text of a docstring *)
  val docstring_body : docstring -> string

  (** Get the location of a docstring *)
  val docstring_loc : docstring -> Location.t

  (** {3 Items}

      The {!docs} type represents documentation attached to an item. *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  val empty_docs : docs

  val docs_attr : docstring -> Parsetree.attribute

  (** Convert item documentation to attributes and add them to an
      attribute list *)
  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. *)

  type info = docstring option

  val empty_info : info

  val info_attr : docstring -> Parsetree.attribute

  (** Convert field info to attributes and add them to an
      attribute list *)
  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. *)

  type text = docstring list

  val empty_text : text

  val text_attr : docstring -> Parsetree.attribute

  (** Convert text to attributes and add them to an attribute list *)
  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

end = struct
  open Location

  (* Docstrings *)

  type docstring =
    { ds_body: string;
      ds_loc: Location.t;
    }

  (* Docstring constructors and destructors *)

  let docstring body loc =
    let ds =
      { ds_body = body;
        ds_loc = loc;
      }
    in
    ds

  let docstring_body ds = ds.ds_body

  let docstring_loc ds = ds.ds_loc

  (* Docstrings attached to items *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  let empty_docs = { docs_pre = None; docs_post = None }

  let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

  let docs_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (doc_loc, PStr [item])

  let add_docs_attrs docs attrs =
    let attrs =
      match docs.docs_pre with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> docs_attr ds :: attrs
    in
    let attrs =
      match docs.docs_post with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> attrs @ [docs_attr ds]
    in
    attrs

  (* Docstrings attached to constructors or fields *)

  type info = docstring option

  let empty_info = None

  let info_attr = docs_attr

  let add_info_attrs info attrs =
    match info with
    | None | Some {ds_body=""; _} -> attrs
    | Some ds -> attrs @ [info_attr ds]

  (* Docstrings not attached to a specific item *)

  type text = docstring list

  let empty_text = []

  let text_loc = {txt = "ocaml.text"; loc = Location.none}

  let text_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (text_loc, PStr [item])

  let add_text_attrs dsl attrs =
    let fdsl = List.filter (function {ds_body=""; _} -> false| _ ->true) dsl in
    (List.map text_attr fdsl) @ attrs

end

module Ast_helper : sig

  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Docstrings
  open Parsetree

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  (** {2 Default locations} *)

  val default_loc: loc ref
      (** Default value for all optional location arguments. *)

  val with_default_loc: loc -> (unit -> 'a) -> 'a
      (** Set the [default_loc] within the scope of the execution
          of the provided function. *)

  (** {2 Constants} *)

  module Const : sig
    val char : char -> constant
    val string : ?quotation_delimiter:string -> string -> constant
    val integer : ?suffix:char -> string -> constant
    val int : ?suffix:char -> int -> constant
    val int32 : ?suffix:char -> int32 -> constant
    val int64 : ?suffix:char -> int64 -> constant
    val nativeint : ?suffix:char -> nativeint -> constant
    val float : ?suffix:char -> string -> constant
  end

  (** {2 Core language} *)

  (** Type expressions *)
  module Typ :
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
      val attr: core_type -> attribute -> core_type

      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type
                 -> core_type
      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val object_: ?loc:loc -> ?attrs:attrs ->
                    (str * attributes * core_type) list -> closed_flag ->
                    core_type
      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                   -> label list option -> core_type
      val poly: ?loc:loc -> ?attrs:attrs -> str list -> core_type -> core_type
      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                   -> core_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

      val force_poly: core_type -> core_type

      val varify_constructors: str list -> core_type -> core_type
      (** [varify_constructors newtypes te] is type expression [te], of which
          any of nullary type constructor [tc] is replaced by type variable of
          the same name, if [tc]'s name appears in [newtypes].
          Raise [Syntaxerr.Variable_in_scope] if any type variable inside [te]
          appears in [newtypes].
          @since 4.05
       *)
    end

  (** Patterns *)
  module Pat:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
      val attr:pattern -> attribute -> pattern

      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                  -> pattern
      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern
      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
    end

  (** Expressions *)
  module Exp:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
      val attr: expression -> attribute -> expression

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
                -> expression -> expression
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option
                -> pattern -> expression -> expression
      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
      val apply: ?loc:loc -> ?attrs:attrs -> expression
                 -> (arg_label * expression) list -> expression
      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                  -> expression
      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                     -> expression
      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                   -> expression
      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                  -> expression option -> expression
      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                    -> expression
      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                      -> expression option -> expression
      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression
      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
                -> direction_flag -> expression -> expression
      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                  -> core_type -> expression
      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                       -> expression
      val send: ?loc:loc -> ?attrs:attrs -> expression -> str -> expression
      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                    -> expression
      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                     -> expression
      val letexception:
        ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression
        -> expression
      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> expression
      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
      val newtype: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression
                 -> expression
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression

      val case: pattern -> ?guard:expression -> expression -> case
    end

  (** Value declarations *)
  module Val:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        ?prim:string list -> str -> core_type -> value_description
    end

  (** Type declarations *)
  module Type:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?params:(core_type * variance) list ->
        ?cstrs:(core_type * core_type * loc) list ->
        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
        type_declaration

      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        constructor_declaration
      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?mut:mutable_flag -> str -> core_type -> label_declaration
    end

  (** Type extensions *)
  module Te:
    sig
      val mk: ?attrs:attrs -> ?docs:docs ->
        ?params:(core_type * variance) list -> ?priv:private_flag ->
        lid -> extension_constructor list -> type_extension

      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> extension_constructor_kind -> extension_constructor

      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        extension_constructor
      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> lid -> extension_constructor
    end

  (** {2 Module language} *)

  (** Module type expressions *)
  module Mty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
      val attr: module_type -> attribute -> module_type

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_type -> module_type
      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->
        with_constraint list -> module_type
      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
    end

  (** Module expressions *)
  module Mod:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
      val attr: module_expr -> attribute -> module_expr

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_expr -> module_expr
      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->
        module_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->
        module_expr
      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
    end

  (** Signature items *)
  module Sig:
    sig
      val mk: ?loc:loc -> signature_item_desc -> signature_item

      val value: ?loc:loc -> value_description -> signature_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item
      val type_extension: ?loc:loc -> type_extension -> signature_item
      val exception_: ?loc:loc -> extension_constructor -> signature_item
      val module_: ?loc:loc -> module_declaration -> signature_item
      val rec_module: ?loc:loc -> module_declaration list -> signature_item
      val modtype: ?loc:loc -> module_type_declaration -> signature_item
      val open_: ?loc:loc -> open_description -> signature_item
      val include_: ?loc:loc -> include_description -> signature_item
      val class_: ?loc:loc -> class_description list -> signature_item
      val class_type: ?loc:loc -> class_type_declaration list -> signature_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
      val attribute: ?loc:loc -> attribute -> signature_item
      val text: text -> signature_item list
    end

  (** Structure items *)
  module Str:
    sig
      val mk: ?loc:loc -> structure_item_desc -> structure_item

      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
      val primitive: ?loc:loc -> value_description -> structure_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item
      val type_extension: ?loc:loc -> type_extension -> structure_item
      val exception_: ?loc:loc -> extension_constructor -> structure_item
      val module_: ?loc:loc -> module_binding -> structure_item
      val rec_module: ?loc:loc -> module_binding list -> structure_item
      val modtype: ?loc:loc -> module_type_declaration -> structure_item
      val open_: ?loc:loc -> open_description -> structure_item
      val class_: ?loc:loc -> class_declaration list -> structure_item
      val class_type: ?loc:loc -> class_type_declaration list -> structure_item
      val include_: ?loc:loc -> include_declaration -> structure_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
      val attribute: ?loc:loc -> attribute -> structure_item
      val text: text -> structure_item list
    end

  (** Module declarations *)
  module Md:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_type -> module_declaration
    end

  (** Module type declarations *)
  module Mtd:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?typ:module_type -> str -> module_type_declaration
    end

  (** Module bindings *)
  module Mb:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_expr -> module_binding
    end

  (** Opens *)
  module Opn:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
        ?override:override_flag -> lid -> open_description
    end

  (** Includes *)
  module Incl:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
    end

  (** Value bindings *)
  module Vb:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        pattern -> expression -> value_binding
    end


  (** {2 Class language} *)

  (** Class type expressions *)
  module Cty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
      val attr: class_type -> attribute -> class_type

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->
        class_type -> class_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
    end

  (** Class type fields *)
  module Ctf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        class_type_field_desc -> class_type_field
      val attr: class_type_field -> attribute -> class_type_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        virtual_flag -> core_type -> class_type_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        virtual_flag -> core_type -> class_type_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_type_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
      val attribute: ?loc:loc -> attribute -> class_type_field
      val text: text -> class_type_field list
    end

  (** Class expressions *)
  module Cl:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
      val attr: class_expr -> attribute -> class_expr

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->
        pattern -> class_expr -> class_expr
      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->
        (arg_label * expression) list -> class_expr
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->
        class_expr -> class_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->
        class_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
    end

  (** Class fields *)
  module Cf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->
        class_field
      val attr: class_field -> attribute -> class_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->
        str option -> class_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        class_field_kind -> class_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        class_field_kind -> class_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_field
      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
      val attribute: ?loc:loc -> attribute -> class_field
      val text: text -> class_field list

      val virtual_: core_type -> class_field_kind
      val concrete: override_flag -> expression -> class_field_kind

    end

  (** Classes *)
  module Ci:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?virt:virtual_flag -> ?params:(core_type * variance) list ->
        str -> 'a -> 'a class_infos
    end

  (** Class signatures *)
  module Csig:
    sig
      val mk: core_type -> class_type_field list -> class_signature
    end

  (** Class structures *)
  module Cstr:
    sig
      val mk: pattern -> class_field list -> class_structure
    end

end = struct
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Parsetree
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  let default_loc = ref Location.none

  let with_default_loc l f =
    let old = !default_loc in
    default_loc := l;
    try let r = f () in default_loc := old; r
    with exn -> default_loc := old; raise exn

  module Const = struct
    let integer ?suffix i = Pconst_integer (i, suffix)
    let int ?suffix i = integer ?suffix (string_of_int i)
    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
    let float ?suffix f = Pconst_float (f, suffix)
    let char c = Pconst_char c
    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)
  end

  module Typ = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

    let force_poly t =
      match t.ptyp_desc with
      | Ptyp_poly _ -> t
      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)

    let varify_constructors var_names t =
      let check_variable vl loc v =
        if List.mem v vl then
          raise Syntaxerr.(Error(Variable_in_scope(loc,v))) in
      let var_names = List.map (fun v -> v.txt) var_names in
      let rec loop t =
        let desc =
          match t.ptyp_desc with
          | Ptyp_any -> Ptyp_any
          | Ptyp_var x ->
              check_variable var_names t.ptyp_loc x;
              Ptyp_var x
          | Ptyp_arrow (label,core_type,core_type') ->
              Ptyp_arrow(label, loop core_type, loop core_type')
          | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
          | Ptyp_constr( { txt = Longident.Lident s; _ }, [])
            when List.mem s var_names ->
              Ptyp_var s
          | Ptyp_constr(longident, lst) ->
              Ptyp_constr(longident, List.map loop lst)
          | Ptyp_object (lst, o) ->
              Ptyp_object
                (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)
          | Ptyp_class (longident, lst) ->
              Ptyp_class (longident, List.map loop lst)
          | Ptyp_alias(core_type, string) ->
              check_variable var_names t.ptyp_loc string;
              Ptyp_alias(loop core_type, string)
          | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
              Ptyp_variant(List.map loop_row_field row_field_list,
                           flag, lbl_lst_option)
          | Ptyp_poly(string_lst, core_type) ->
            List.iter (fun v ->
              check_variable var_names t.ptyp_loc v.txt) string_lst;
              Ptyp_poly(string_lst, loop core_type)
          | Ptyp_package(longident,lst) ->
              Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
          | Ptyp_extension (s, arg) ->
              Ptyp_extension (s, arg)
        in
        {t with ptyp_desc = desc}
      and loop_row_field  =
        function
          | Rtag(label,attrs,flag,lst) ->
              Rtag(label,attrs,flag,List.map loop lst)
          | Rinherit t ->
              Rinherit (loop t)
      in
      loop t

  end

  module Pat = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
    let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))
    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
  end

  module Exp = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
    let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))
    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable

    let case lhs ?guard rhs =
      {
       pc_lhs = lhs;
       pc_guard = guard;
       pc_rhs = rhs;
      }
  end

  module Mty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
  end

  module Mod = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
    let functor_ ?loc ?attrs arg arg_ty body =
      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
  end

  module Sig = struct
    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

    let value ?loc a = mk ?loc (Psig_value a)
    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Psig_typext a)
    let exception_ ?loc a = mk ?loc (Psig_exception a)
    let module_ ?loc a = mk ?loc (Psig_module a)
    let rec_module ?loc a = mk ?loc (Psig_recmodule a)
    let modtype ?loc a = mk ?loc (Psig_modtype a)
    let open_ ?loc a = mk ?loc (Psig_open a)
    let include_ ?loc a = mk ?loc (Psig_include a)
    let class_ ?loc a = mk ?loc (Psig_class a)
    let class_type ?loc a = mk ?loc (Psig_class_type a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Psig_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Str = struct
    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
    let value ?loc a b = mk ?loc (Pstr_value (a, b))
    let primitive ?loc a = mk ?loc (Pstr_primitive a)
    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Pstr_typext a)
    let exception_ ?loc a = mk ?loc (Pstr_exception a)
    let module_ ?loc a = mk ?loc (Pstr_module a)
    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
    let modtype ?loc a = mk ?loc (Pstr_modtype a)
    let open_ ?loc a = mk ?loc (Pstr_open a)
    let class_ ?loc a = mk ?loc (Pstr_class a)
    let class_type ?loc a = mk ?loc (Pstr_class_type a)
    let include_ ?loc a = mk ?loc (Pstr_include a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Pstr_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Cl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcl_desc = d;
       pcl_loc = loc;
       pcl_attributes = attrs;
      }
    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
  end

  module Cty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcty_desc = d;
       pcty_loc = loc;
       pcty_attributes = attrs;
      }
    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
  end

  module Ctf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
             ?(docs = empty_docs) d =
      {
       pctf_desc = d;
       pctf_loc = loc;
       pctf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
    let attribute ?loc a = mk ?loc (Pctf_attribute a)
    let text txt =
     let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
       List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

  end

  module Cf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) d =
      {
       pcf_desc = d;
       pcf_loc = loc;
       pcf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
    let attribute ?loc a = mk ?loc (Pcf_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let virtual_ ct = Cfk_virtual ct
    let concrete o e = Cfk_concrete (o, e)

    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

  end

  module Val = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(prim = []) name typ =
      {
       pval_name = name;
       pval_type = typ;
       pval_attributes = add_docs_attrs docs attrs;
       pval_loc = loc;
       pval_prim = prim;
      }
  end

  module Md = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name typ =
      {
       pmd_name = name;
       pmd_type = typ;
       pmd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmd_loc = loc;
      }
  end

  module Mtd = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) ?typ name =
      {
       pmtd_name = name;
       pmtd_type = typ;
       pmtd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmtd_loc = loc;
      }
  end

  module Mb = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name expr =
      {
       pmb_name = name;
       pmb_expr = expr;
       pmb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmb_loc = loc;
      }
  end

  module Opn = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(override = Fresh) lid =
      {
       popen_lid = lid;
       popen_override = override;
       popen_loc = loc;
       popen_attributes = add_docs_attrs docs attrs;
      }
  end

  module Incl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
      {
       pincl_mod = mexpr;
       pincl_loc = loc;
       pincl_attributes = add_docs_attrs docs attrs;
      }

  end

  module Vb = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(text = []) pat expr =
      {
       pvb_pat = pat;
       pvb_expr = expr;
       pvb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pvb_loc = loc;
      }
  end

  module Ci = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
          ?(virt = Concrete) ?(params = []) name expr =
      {
       pci_virt = virt;
       pci_params = params;
       pci_name = name;
       pci_expr = expr;
       pci_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pci_loc = loc;
      }
  end

  module Type = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
        ?(params = [])
        ?(cstrs = [])
        ?(kind = Ptype_abstract)
        ?(priv = Public)
        ?manifest
        name =
      {
       ptype_name = name;
       ptype_params = params;
       ptype_cstrs = cstrs;
       ptype_kind = kind;
       ptype_private = priv;
       ptype_manifest = manifest;
       ptype_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       ptype_loc = loc;
      }

    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(args = Pcstr_tuple []) ?res name =
      {
       pcd_name = name;
       pcd_args = args;
       pcd_res = res;
       pcd_loc = loc;
       pcd_attributes = add_info_attrs info attrs;
       }

    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(mut = Immutable) name typ =
      {
       pld_name = name;
       pld_mutable = mut;
       pld_type = typ;
       pld_loc = loc;
       pld_attributes = add_info_attrs info attrs;
      }

  end

  (** Type extensions *)
  module Te = struct
    let mk ?(attrs = []) ?(docs = empty_docs)
          ?(params = []) ?(priv = Public) path constructors =
      {
       ptyext_path = path;
       ptyext_params = params;
       ptyext_constructors = constructors;
       ptyext_private = priv;
       ptyext_attributes = add_docs_attrs docs attrs;
      }

    let constructor ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name kind =
      {
       pext_name = name;
       pext_kind = kind;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =
      {
       pext_name = name;
       pext_kind = Pext_decl(args, res);
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let rebind ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name lid =
      {
       pext_name = name;
       pext_kind = Pext_rebind lid;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

  end

  module Csig = struct
    let mk self fields =
      {
       pcsig_self = self;
       pcsig_fields = fields;
      }
  end

  module Cstr = struct
    let mk self fields =
      {
       pcstr_self = self;
       pcstr_fields = fields;
      }
  end

end

module Ast_mapper : sig
  (** The interface of a -ppx rewriter

    A -ppx rewriter is a program that accepts a serialized abstract syntax
    tree and outputs another, possibly modified, abstract syntax tree.
    This module encapsulates the interface between the compiler and
    the -ppx rewriters, handling such details as the serialization format,
    forwarding of command-line flags, and storing state.

    {!mapper} allows to implement AST rewriting using open recursion.
    A typical mapper would be based on {!default_mapper}, a deep
    identity mapper, and will fall back on it for handling the syntax it
    does not modify. For example:

    {[
  open Asttypes
  open Parsetree
  open Ast_mapper

  let test_mapper argv =
    { default_mapper with
      expr = fun mapper expr ->
        match expr with
        | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
          Ast_helper.Exp.constant (Const_int 42)
        | other -> default_mapper.expr mapper other; }

  let () =
    register "ppx_test" test_mapper]}

    This -ppx rewriter, which replaces [[%test]] in expressions with
    the constant [42], can be compiled using
    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

    *)

  open Parsetree

  (** {2 A generic Parsetree mapper} *)

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }
  (** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. *)

  val default_mapper: mapper
  (** A default mapper, which implements a "deep identity" mapping. *)

  (** {2 Convenience functions to write mappers} *)

  val map_opt: ('a -> 'b) -> 'a option -> 'b option

  val extension_of_error: Location.error -> extension
  (** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. *)

  val attribute_of_warning: Location.t -> string -> attribute
  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. *)

end = struct
  (* A generic Parsetree mapping class *)

  (*
  [@@@ocaml.warning "+9"]
    (* Ensure that record patterns don't miss any field. *)
  *)


  open Parsetree
  open Ast_helper
  open Location

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }

  let map_fst f (x, y) = (f x, y)
  let map_snd f (x, y) = (x, f y)
  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
  let map_opt f = function None -> None | Some x -> Some (f x)

  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

  module T = struct
    (* Type expressions for the core language *)

    let row_field sub = function
      | Rtag (l, attrs, b, tl) ->
          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
      | Rinherit t -> Rinherit (sub.typ sub t)

    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
      let open Typ in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ptyp_any -> any ~loc ~attrs ()
      | Ptyp_var s -> var ~loc ~attrs s
      | Ptyp_arrow (lab, t1, t2) ->
          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
      | Ptyp_constr (lid, tl) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_object (l, o) ->
          let f (s, a, t) =
            (map_loc sub s, sub.attributes sub a, sub.typ sub t) in
          object_ ~loc ~attrs (List.map f l) o
      | Ptyp_class (lid, tl) ->
          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
      | Ptyp_variant (rl, b, ll) ->
          variant ~loc ~attrs (List.map (row_field sub) rl) b ll
      | Ptyp_poly (sl, t) -> poly ~loc ~attrs
                               (List.map (map_loc sub) sl) (sub.typ sub t)
      | Ptyp_package (lid, l) ->
          package ~loc ~attrs (map_loc sub lid)
            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_type_declaration sub
        {ptype_name; ptype_params; ptype_cstrs;
         ptype_kind;
         ptype_private;
         ptype_manifest;
         ptype_attributes;
         ptype_loc} =
      Type.mk (map_loc sub ptype_name)
        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
        ~priv:ptype_private
        ~cstrs:(List.map
                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                  ptype_cstrs)
        ~kind:(sub.type_kind sub ptype_kind)
        ?manifest:(map_opt (sub.typ sub) ptype_manifest)
        ~loc:(sub.location sub ptype_loc)
        ~attrs:(sub.attributes sub ptype_attributes)

    let map_type_kind sub = function
      | Ptype_abstract -> Ptype_abstract
      | Ptype_variant l ->
          Ptype_variant (List.map (sub.constructor_declaration sub) l)
      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
      | Ptype_open -> Ptype_open

    let map_constructor_arguments sub = function
      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)
      | Pcstr_record l ->
          Pcstr_record (List.map (sub.label_declaration sub) l)

    let map_type_extension sub
        {ptyext_path; ptyext_params;
         ptyext_constructors;
         ptyext_private;
         ptyext_attributes} =
      Te.mk
        (map_loc sub ptyext_path)
        (List.map (sub.extension_constructor sub) ptyext_constructors)
        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
        ~priv:ptyext_private
        ~attrs:(sub.attributes sub ptyext_attributes)

    let map_extension_constructor_kind sub = function
        Pext_decl(ctl, cto) ->
          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)
      | Pext_rebind li ->
          Pext_rebind (map_loc sub li)

    let map_extension_constructor sub
        {pext_name;
         pext_kind;
         pext_loc;
         pext_attributes} =
      Te.constructor
        (map_loc sub pext_name)
        (map_extension_constructor_kind sub pext_kind)
        ~loc:(sub.location sub pext_loc)
        ~attrs:(sub.attributes sub pext_attributes)

  end

  module CT = struct
    (* Type expressions for the class language *)

    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
      let open Cty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcty_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
      | Pcty_arrow (lab, t, ct) ->
          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
      =
      let open Ctf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
      | Pctf_val (s, m, v, t) ->
          val_ ~loc ~attrs (map_loc sub s) m v (sub.typ sub t)
      | Pctf_method (s, p, v, t) ->
          method_ ~loc ~attrs (map_loc sub s) p v (sub.typ sub t)
      | Pctf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_signature sub {pcsig_self; pcsig_fields} =
      Csig.mk
        (sub.typ sub pcsig_self)
        (List.map (sub.class_type_field sub) pcsig_fields)
  end

  module MT = struct
    (* Type expressions for the module language *)

    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
      let open Mty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
      | Pmty_functor (s, mt1, mt2) ->
          functor_ ~loc ~attrs (map_loc sub s)
            (Misc.may_map (sub.module_type sub) mt1)
            (sub.module_type sub mt2)
      | Pmty_with (mt, l) ->
          with_ ~loc ~attrs (sub.module_type sub mt)
            (List.map (sub.with_constraint sub) l)
      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_with_constraint sub = function
      | Pwith_type (lid, d) ->
          Pwith_type (map_loc sub lid, sub.type_declaration sub d)
      | Pwith_module (lid, lid2) ->
          Pwith_module (map_loc sub lid, map_loc sub lid2)
      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
      | Pwith_modsubst (s, lid) ->
          Pwith_modsubst (map_loc sub s, map_loc sub lid)

    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
      let open Sig in
      let loc = sub.location sub loc in
      match desc with
      | Psig_value vd -> value ~loc (sub.value_description sub vd)
      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
      | Psig_recmodule l ->
          rec_module ~loc (List.map (sub.module_declaration sub) l)
      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Psig_open x -> open_ ~loc (sub.open_description sub x)
      | Psig_include x -> include_ ~loc (sub.include_description sub x)
      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
      | Psig_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Psig_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
  end


  module M = struct
    (* Value expressions for the module language *)

    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
      let open Mod in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
      | Pmod_functor (arg, arg_ty, body) ->
          functor_ ~loc ~attrs (map_loc sub arg)
            (Misc.may_map (sub.module_type sub) arg_ty)
            (sub.module_expr sub body)
      | Pmod_apply (m1, m2) ->
          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
      | Pmod_constraint (m, mty) ->
          constraint_ ~loc ~attrs (sub.module_expr sub m)
                      (sub.module_type sub mty)
      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
      let open Str in
      let loc = sub.location sub loc in
      match desc with
      | Pstr_eval (x, attrs) ->
          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Pstr_open x -> open_ ~loc (sub.open_description sub x)
      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
      | Pstr_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
      | Pstr_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
  end

  module E = struct
    (* Value expressions for the core language *)

    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
      let open Exp in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pexp_constant x -> constant ~loc ~attrs x
      | Pexp_let (r, vbs, e) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.expr sub e)
      | Pexp_fun (lab, def, p, e) ->
          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
            (sub.expr sub e)
      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
      | Pexp_apply (e, l) ->
          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
      | Pexp_match (e, pel) ->
          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_construct (lid, arg) ->
          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
      | Pexp_variant (lab, eo) ->
          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
      | Pexp_record (l, eo) ->
          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
            (map_opt (sub.expr sub) eo)
      | Pexp_field (e, lid) ->
          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
      | Pexp_setfield (e1, lid, e2) ->
          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
            (sub.expr sub e2)
      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_ifthenelse (e1, e2, e3) ->
          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
            (map_opt (sub.expr sub) e3)
      | Pexp_sequence (e1, e2) ->
          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_while (e1, e2) ->
          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_for (p, e1, e2, d, e3) ->
          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
            (sub.expr sub e3)
      | Pexp_coerce (e, t1, t2) ->
          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
            (sub.typ sub t2)
      | Pexp_constraint (e, t) ->
          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
      | Pexp_send (e, s) ->
          send ~loc ~attrs (sub.expr sub e) (map_loc sub s)
      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
      | Pexp_setinstvar (s, e) ->
          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_override sel ->
          override ~loc ~attrs
            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
      | Pexp_letmodule (s, me, e) ->
          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
            (sub.expr sub e)
      | Pexp_letexception (cd, e) ->
          letexception ~loc ~attrs
            (sub.extension_constructor sub cd)
            (sub.expr sub e)
      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
      | Pexp_poly (e, t) ->
          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
      | Pexp_newtype (s, e) ->
          newtype ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
      | Pexp_open (ovf, lid, e) ->
          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
      | Pexp_unreachable -> unreachable ~loc ~attrs ()
  end

  module P = struct
    (* Patterns *)

    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
      let open Pat in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ppat_any -> any ~loc ~attrs ()
      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
      | Ppat_constant c -> constant ~loc ~attrs c
      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_construct (l, p) ->
          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
      | Ppat_record (lpl, cf) ->
          record ~loc ~attrs
                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
      | Ppat_constraint (p, t) ->
          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
      | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)
      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module CE = struct
    (* Value expressions for the class language *)

    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
      let open Cl in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcl_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcl_structure s ->
          structure ~loc ~attrs (sub.class_structure sub s)
      | Pcl_fun (lab, e, p, ce) ->
          fun_ ~loc ~attrs lab
            (map_opt (sub.expr sub) e)
            (sub.pat sub p)
            (sub.class_expr sub ce)
      | Pcl_apply (ce, l) ->
          apply ~loc ~attrs (sub.class_expr sub ce)
            (List.map (map_snd (sub.expr sub)) l)
      | Pcl_let (r, vbs, ce) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.class_expr sub ce)
      | Pcl_constraint (ce, ct) ->
          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_kind sub = function
      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
      let open Cf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcf_inherit (o, ce, s) ->
          inherit_ ~loc ~attrs o (sub.class_expr sub ce)
            (map_opt (map_loc sub) s)
      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
      | Pcf_method (s, p, k) ->
          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
      | Pcf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure sub {pcstr_self; pcstr_fields} =
      {
        pcstr_self = sub.pat sub pcstr_self;
        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
      }

    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                           pci_loc; pci_attributes} =
      Ci.mk
       ~virt:pci_virt
       ~params:(List.map (map_fst (sub.typ sub)) pl)
        (map_loc sub pci_name)
        (f pci_expr)
        ~loc:(sub.location sub pci_loc)
        ~attrs:(sub.attributes sub pci_attributes)
  end

  (* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. *)

  let default_mapper =
    {
      structure = (fun this l -> List.map (this.structure_item this) l);
      structure_item = M.map_structure_item;
      module_expr = M.map;
      signature = (fun this l -> List.map (this.signature_item this) l);
      signature_item = MT.map_signature_item;
      module_type = MT.map;
      with_constraint = MT.map_with_constraint;
      class_declaration =
        (fun this -> CE.class_infos this (this.class_expr this));
      class_expr = CE.map;
      class_field = CE.map_field;
      class_structure = CE.map_structure;
      class_type = CT.map;
      class_type_field = CT.map_field;
      class_signature = CT.map_signature;
      class_type_declaration =
        (fun this -> CE.class_infos this (this.class_type this));
      class_description =
        (fun this -> CE.class_infos this (this.class_type this));
      type_declaration = T.map_type_declaration;
      type_kind = T.map_type_kind;
      typ = T.map;
      type_extension = T.map_type_extension;
      extension_constructor = T.map_extension_constructor;
      value_description =
        (fun this {pval_name; pval_type; pval_prim; pval_loc;
                   pval_attributes} ->
          Val.mk
            (map_loc this pval_name)
            (this.typ this pval_type)
            ~attrs:(this.attributes this pval_attributes)
            ~loc:(this.location this pval_loc)
            ~prim:pval_prim
        );

      pat = P.map;
      expr = E.map;

      module_declaration =
        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
           Md.mk
             (map_loc this pmd_name)
             (this.module_type this pmd_type)
             ~attrs:(this.attributes this pmd_attributes)
             ~loc:(this.location this pmd_loc)
        );

      module_type_declaration =
        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
           Mtd.mk
             (map_loc this pmtd_name)
             ?typ:(map_opt (this.module_type this) pmtd_type)
             ~attrs:(this.attributes this pmtd_attributes)
             ~loc:(this.location this pmtd_loc)
        );

      module_binding =
        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
             ~attrs:(this.attributes this pmb_attributes)
             ~loc:(this.location this pmb_loc)
        );


      open_description =
        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
           Opn.mk (map_loc this popen_lid)
             ~override:popen_override
             ~loc:(this.location this popen_loc)
             ~attrs:(this.attributes this popen_attributes)
        );


      include_description =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_type this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );

      include_declaration =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_expr this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );


      value_binding =
        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
           Vb.mk
             (this.pat this pvb_pat)
             (this.expr this pvb_expr)
             ~loc:(this.location this pvb_loc)
             ~attrs:(this.attributes this pvb_attributes)
        );


      constructor_declaration =
        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
          Type.constructor
            (map_loc this pcd_name)
            ~args:(T.map_constructor_arguments this pcd_args)
            ?res:(map_opt (this.typ this) pcd_res)
            ~loc:(this.location this pcd_loc)
            ~attrs:(this.attributes this pcd_attributes)
        );

      label_declaration =
        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
           Type.field
             (map_loc this pld_name)
             (this.typ this pld_type)
             ~mut:pld_mutable
             ~loc:(this.location this pld_loc)
             ~attrs:(this.attributes this pld_attributes)
        );

      cases = (fun this l -> List.map (this.case this) l);
      case =
        (fun this {pc_lhs; pc_guard; pc_rhs} ->
           {
             pc_lhs = this.pat this pc_lhs;
             pc_guard = map_opt (this.expr this) pc_guard;
             pc_rhs = this.expr this pc_rhs;
           }
        );



      location = (fun _this l -> l);

      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attributes = (fun this l -> List.map (this.attribute this) l);
      payload =
        (fun this -> function
           | PStr x -> PStr (this.structure this x)
           | PSig x -> PSig (this.signature this x)
           | PTyp x -> PTyp (this.typ this x)
           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
        );
    }

  let rec extension_of_error {loc; msg; if_highlight; sub} =
    { loc; txt = "ocaml.error" },
    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));
           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @
          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

  let attribute_of_warning loc s =
    { loc; txt = "ocaml.ppwarning" },
    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])

end

module Outcometree = struct
  (* Module [Outcometree]: results displayed by the toplevel *)

  (* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
        [Toploop.print_out_value]
        [Toploop.print_out_type]
        [Toploop.print_out_sig_item]
        [Toploop.print_out_phrase] *)

  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =
    | Oide_apply of out_ident * out_ident
    | Oide_dot of out_ident * string
    | Oide_ident of string

  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =
    { oattr_name: string }

  type out_value (*IF_CURRENT = Outcometree.out_value *) =
    | Oval_array of out_value list
    | Oval_char of char
    | Oval_constr of out_ident * out_value list
    | Oval_ellipsis
    | Oval_float of float
    | Oval_int of int
    | Oval_int32 of int32
    | Oval_int64 of int64
    | Oval_nativeint of nativeint
    | Oval_list of out_value list
    | Oval_printer of (Format.formatter -> unit)
    | Oval_record of (out_ident * out_value) list
    | Oval_string of string
    | Oval_stuff of string
    | Oval_tuple of out_value list
    | Oval_variant of string * out_value option

  type out_type (*IF_CURRENT = Outcometree.out_type *) =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias of out_type * string
    | Otyp_arrow of string * out_type * out_type
    | Otyp_class of bool * out_ident * out_type list
    | Otyp_constr of out_ident * out_type list
    | Otyp_manifest of out_type * out_type
    | Otyp_object of (string * out_type) list * bool option
    | Otyp_record of (string * bool * out_type) list
    | Otyp_stuff of string
    | Otyp_sum of (string * out_type list * out_type option) list
    | Otyp_tuple of out_type list
    | Otyp_var of bool * string
    | Otyp_variant of
        bool * out_variant * bool * (string list) option
    | Otyp_poly of string list * out_type
    | Otyp_module of string * string list * out_type list
    | Otyp_attribute of out_type * out_attribute

  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =
    | Ovar_fields of (string * bool * out_type list) list
    | Ovar_typ of out_type

  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =
    | Octy_constr of out_ident * out_type list
    | Octy_arrow of string * out_type * out_class_type
    | Octy_signature of out_type option * out_class_sig_item list
  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =
    | Ocsg_constraint of out_type * out_type
    | Ocsg_method of string * bool * bool * out_type
    | Ocsg_value of string * bool * bool * out_type

  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =
    | Omty_abstract
    | Omty_functor of string * out_module_type option * out_module_type
    | Omty_ident of out_ident
    | Omty_signature of out_sig_item list
    | Omty_alias of out_ident
  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =
    | Osig_class of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_class_type of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_typext of out_extension_constructor * out_ext_status
    | Osig_modtype of string * out_module_type
    | Osig_module of string * out_module_type * out_rec_status
    | Osig_type of out_type_decl * out_rec_status
    | Osig_value of out_val_decl
    | Osig_ellipsis
  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =
    { otype_name: string;
      otype_params: (string * (bool * bool)) list;
      otype_type: out_type;
      otype_private: Asttypes.private_flag;
      otype_immediate: bool;
      otype_unboxed: bool;
      otype_cstrs: (out_type * out_type) list }
  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =
    { oext_name: string;
      oext_type_name: string;
      oext_type_params: string list;
      oext_args: out_type list;
      oext_ret_type: out_type option;
      oext_private: Asttypes.private_flag }
  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =
    { otyext_name: string;
      otyext_params: string list;
      otyext_constructors: (string * out_type list * out_type option) list;
      otyext_private: Asttypes.private_flag }
  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =
    { oval_name: string;
      oval_type: out_type;
      oval_prims: string list;
      oval_attributes: out_attribute list }
  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =
    | Oext_first
    | Oext_next
    | Oext_exception

  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =
    | Ophr_eval of out_value * out_type
    | Ophr_signature of (out_sig_item * out_value option) list
    | Ophr_exception of (exn * out_value)

end

module Config = struct
  let ast_impl_magic_number = "Caml1999M020"
  let ast_intf_magic_number = "Caml1999N018"
end

let map_signature mapper = mapper.Ast_mapper.signature mapper
let map_structure mapper = mapper.Ast_mapper.structure mapper

let failing_mapper =
  let fail _ _ =
    invalid_arg "failing_mapper: this mapper function should never get called"
  in
  {
    Ast_mapper.
    structure               = fail;
    structure_item          = fail;
    module_expr             = fail;
    signature               = fail;
    signature_item          = fail;
    module_type             = fail;
    with_constraint         = fail;
    class_declaration       = fail;
    class_expr              = fail;
    class_field             = fail;
    class_structure         = fail;
    class_type              = fail;
    class_type_field        = fail;
    class_signature         = fail;
    class_type_declaration  = fail;
    class_description       = fail;
    type_declaration        = fail;
    type_kind               = fail;
    typ                     = fail;
    type_extension          = fail;
    extension_constructor   = fail;
    value_description       = fail;
    pat                     = fail;
    expr                    = fail;
    module_declaration      = fail;
    module_type_declaration = fail;
    module_binding          = fail;
    open_description        = fail;
    include_description     = fail;
    include_declaration     = fail;
    value_binding           = fail;
    constructor_declaration = fail;
    label_declaration       = fail;
    cases                   = fail;
    case                    = fail;
    location                = fail;
    extension               = fail;
    attribute               = fail;
    attributes              = fail;
    payload                 = fail;
  }

let make_top_mapper ~signature ~structure =
  {failing_mapper with Ast_mapper.
                    signature = (fun _ x -> signature x);
                    structure = (fun _ x -> structure x) }

end
module Migrate_parsetree_402_403_migrate
= struct
#1 "migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module From = Ast_402
module To = Ast_403

let extract_predef_option label typ =
  let open From in
  let open Longident in
  match label, typ.Parsetree.ptyp_desc with
  | To.Asttypes.Optional _,
    From.Parsetree.Ptyp_constr (
      {Location.txt = Ldot (Lident "*predef*", "option"); _}, [d]) ->
      d
  | _ -> typ

let rec copy_expression :
  From.Parsetree.expression ->
    To.Parsetree.expression
  =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc =
        (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc ->
    To.Parsetree.expression_desc
  =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant
        (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert
        (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy
        (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack
        (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension
        (copy_extension x0)

and copy_direction_flag :
  From.Asttypes.direction_flag ->
    To.Asttypes.direction_flag
  =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs =
        (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs =
        (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding ->
    To.Parsetree.value_binding
  =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat =
        (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc =
        (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc =
        (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc ->
    To.Parsetree.pattern_desc
  =
  function
  | From.Parsetree.Ppat_any  ->
      To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant
        (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy
        (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception
        (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension
        (copy_extension x0)

and copy_core_type :
  From.Parsetree.core_type ->
    To.Parsetree.core_type
  =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc =
        (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc ->
    To.Parsetree.core_type_desc
  =
  function
  | From.Parsetree.Ptyp_any  ->
      To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 ->
      To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      let label = copy_arg_label x0 in
      To.Parsetree.Ptyp_arrow
        (label,
         copy_core_type (extract_predef_option label x1),
         copy_core_type x2)
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option
             (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x) x0),
          (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package
        (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension
        (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type ->
    To.Parsetree.package_type
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc
                copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field ->
    To.Parsetree.row_field
  =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit
        (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes ->
    To.Parsetree.attributes
  = fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute ->
    To.Parsetree.attribute
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr
        (copy_structure x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp
        (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure ->
    To.Parsetree.structure
  = fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item ->
    To.Parsetree.structure_item
  =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc =
        (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type x0 ->
      let recflag, types = type_declarations x0 in
      To.Parsetree.Pstr_type (recflag, types)
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute
        (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos
      copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration ->
    To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr ->
    To.Parsetree.class_expr
  =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc =
        (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc ->
    To.Parsetree.class_expr_desc
  =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension
        (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure ->
    To.Parsetree.class_structure
  =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field ->
    To.Parsetree.class_field
  =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc =
        (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc ->
    To.Parsetree.class_field_desc
  =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension
        (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind ->
    To.Parsetree.class_field_kind
  =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual
        (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding ->
    To.Parsetree.module_binding
  =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc =
        (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr ->
    To.Parsetree.module_expr
  =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc =
        (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc ->
    To.Parsetree.module_expr_desc
  =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure
        (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack
        (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension
        (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type ->
    To.Parsetree.module_type
  =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc =
        (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc ->
    To.Parsetree.module_type_desc
  =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature
        (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof
        (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension
        (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident
           x0)

and copy_with_constraint :
  From.Parsetree.with_constraint ->
    To.Parsetree.with_constraint
  =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc
            copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc
            copy_longident x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc
             copy_longident x1))

and copy_signature :
  From.Parsetree.signature ->
    To.Parsetree.signature
  = fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item ->
    To.Parsetree.signature_item
  =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc =
        (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type x0 ->
      let recflag, types = type_declarations x0 in
      To.Parsetree.Psig_type (recflag, types)
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute
        (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_description :
  From.Parsetree.class_description ->
    To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_type :
  From.Parsetree.class_type ->
    To.Parsetree.class_type
  =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc =
        (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc ->
    To.Parsetree.class_type_desc
  =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      let label = copy_arg_label x0 in
      To.Parsetree.Pcty_arrow
        (label,
         copy_core_type (extract_predef_option label x1),
         copy_class_type x2)
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension
        (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature ->
    To.Parsetree.class_signature
  =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field
           pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field ->
    To.Parsetree.class_type_field
  =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc =
        (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit
        (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension
        (copy_extension x0)

and copy_extension :
  From.Parsetree.extension ->
    To.Parsetree.extension
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos ->
        'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc =
          (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag ->
    To.Asttypes.virtual_flag
  =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos
      copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc =
          (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description ->
    To.Parsetree.open_description
  =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident
           popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc =
        (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag ->
    To.Asttypes.override_flag
  =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc =
        (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc =
        (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension ->
    To.Parsetree.type_extension
  =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident
           ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc =
        (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        (To.Parsetree.Pcstr_tuple (List.map copy_core_type x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident
           x0)

and copy_type_declaration :
  From.Parsetree.type_declaration ->
    To.Parsetree.type_declaration
  =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc =
        (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag ->
    To.Asttypes.private_flag
  =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind ->
    To.Parsetree.type_kind
  =
  function
  | From.Parsetree.Ptype_abstract  ->
      To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  ->
      To.Parsetree.Ptype_open

and copy_label_declaration :
  From.Parsetree.label_declaration ->
    To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc =
        (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag ->
    To.Asttypes.mutable_flag
  =
  function
  | From.Asttypes.Immutable  ->
      To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        To.Parsetree.Pcstr_tuple (List.map copy_core_type pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc =
        (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  ->
      To.Asttypes.Covariant
  | From.Asttypes.Contravariant  ->
      To.Asttypes.Contravariant
  | From.Asttypes.Invariant  ->
      To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description ->
    To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim =
        (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc =
        (copy_location pval_loc)
    }

and copy_closed_flag :
  From.Asttypes.closed_flag ->
    To.Asttypes.closed_flag
  =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label =
  fun x ->
    x

and copy_arg_label :
  From.Asttypes.label -> To.Asttypes.arg_label =
  fun x ->
    if x <> "" then
      if x.[0] = '?' then To.Asttypes.Optional (String.sub x 1 (String.length x - 1))
      else To.Asttypes.Labelled x
    else
      To.Asttypes.Nolabel



and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  ->
      To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  ->
      To.Asttypes.Recursive

and copy_constant :
  From.Asttypes.constant -> To.Parsetree.constant =
  function
  | From.Asttypes.Const_int x0 ->
      To.Parsetree.Pconst_integer (string_of_int x0, None)
  | From.Asttypes.Const_char x0 ->
      To.Parsetree.Pconst_char x0
  | From.Asttypes.Const_string (x0,x1) ->
      To.Parsetree.Pconst_string
        (x0, (copy_option (fun x  -> x) x1))
  | From.Asttypes.Const_float x0 ->
      To.Parsetree.Pconst_float (x0, None)
  | From.Asttypes.Const_int32 x0 ->
      To.Parsetree.Pconst_integer (Int32.to_string x0, Some 'l')
  | From.Asttypes.Const_int64 x0 ->
      To.Parsetree.Pconst_integer (Int64.to_string x0, Some 'L')
  | From.Asttypes.Const_nativeint x0 ->
      To.Parsetree.Pconst_integer (Nativeint.to_string x0, Some 'n')

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident :
  From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 ->
      To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun
      { From.Asttypes.txt = txt;
        From.Asttypes.loc = loc }
       ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location :
  From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

and type_declarations types =
  let is_nonrec (attr,_) = attr.To.Location.txt = "nonrec" in
  match List.map copy_type_declaration types with
  | (x :: xs)
    when List.exists is_nonrec x.To.Parsetree.ptype_attributes ->
      let ptype_attributes =
        List.filter (fun x -> not (is_nonrec x)) x.To.Parsetree.ptype_attributes
      in
      (To.Asttypes.Nonrecursive,
       {x with To.Parsetree.ptype_attributes} :: xs)
  | types -> (To.Asttypes.Recursive, types)

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value (x0,x1,x2) ->
      To.Outcometree.Osig_value { To.Outcometree.
                                  oval_name = x0;
                                  oval_type = copy_out_type x1;
                                  oval_prims = List.map (fun x -> x) x2;
                                  oval_attributes = [] }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_private_flag otype_private);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
               (copy_out_type x1))) otype_cstrs);
      To.Outcometree.otype_immediate = false;
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_private_flag oext_private)
    }

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_name
        ((copy_out_ident x0),
          (List.map copy_out_type x1))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int x0 -> To.Parsetree.Pdir_int (string_of_int x0, None)
  | From.Parsetree.Pdir_ident x0 -> To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 -> To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_def : sig 
#1 "migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Features which are not available in all versions of the frontend *)
type missing_feature =
    Pexp_letexception
  | Ppat_open
  | Pexp_unreachable
  | PSig
  | Pcstr_record
  | Pconst_integer
  | Pconst_float

(** Exception thrown by migration functions when a feature is not supported. *)
exception Migration_error of missing_feature * Location.t

(** [missing_feature_description x] is a text describing the feature [x]. *)
val missing_feature_description : missing_feature -> string

(** [missing_feature_minimal_version x] is the OCaml version where x was
    introduced. *)
val missing_feature_minimal_version : missing_feature -> string

(** Turn a missing feature into a reasonable error message. *)
val migration_error_message : missing_feature -> string

end = struct
#1 "migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Errors that can happen when converting constructions that doesn't exist in
    older version of the AST. *)
type missing_feature =
  | Pexp_letexception
    (** 4.04 -> 4.03: local exception, let exception _ in ... *)
  | Ppat_open
    (** 4.04 -> 4.03: module open in pattern match x with M.(_) -> ... *)
  | Pexp_unreachable
    (** 4.04 -> 4.03: unreachable pattern -> . *)
  | PSig
    (** 4.03 -> 4.02: signature in attribute, [@: val x : int] *)
  | Pcstr_record
    (** 4.03 -> 4.02: inline record *)
  | Pconst_integer
    (** 4.03 -> 4.02: integer literal with invalid suffix, 1234d *)
  | Pconst_float
    (** 4.03 -> 4.02: float literal with invalid suffix, 1234.0g *)

exception Migration_error of missing_feature * Location.t

(** [missing_feature_description x] is a text describing the feature [x]. *)
let missing_feature_description = function
  | Pexp_letexception -> "local exceptions"
  | Ppat_open         -> "module open in patterns"
  | Pexp_unreachable  -> "unreachable patterns"
  | PSig              -> "signatures in attribute"
  | Pcstr_record      -> "inline records"
  | Pconst_integer    -> "custom integer literals"
  | Pconst_float      -> "custom float literals"

(** [missing_feature_minimal_version x] is the OCaml version where x was
    introduced. *)
let missing_feature_minimal_version = function
  | Pexp_letexception -> "OCaml 4.04"
  | Ppat_open         -> "OCaml 4.04"
  | Pexp_unreachable  -> "OCaml 4.03"
  | PSig              -> "OCaml 4.03"
  | Pcstr_record      -> "OCaml 4.03"
  | Pconst_integer    -> "OCaml 4.03"
  | Pconst_float      -> "OCaml 4.03"

(** Turn a missing feature into a reasonable error message. *)
let migration_error_message x =
  let feature = missing_feature_description x in
  let version = missing_feature_minimal_version x in
  feature ^ " are not supported before OCaml " ^ version

let () =
  let location_prefix l =
    if l = Location.none then "" else
      let {Location.loc_start; loc_end; _} = l in
      let bol = loc_start.Lexing.pos_bol in
      Printf.sprintf "File %S, line %d, characters %d-%d: "
        loc_start.Lexing.pos_fname
        loc_start.Lexing.pos_lnum
        (loc_start.Lexing.pos_cnum - bol)
        (loc_end.Lexing.pos_cnum - bol)
  in
  Printexc.register_printer (function
      | Migration_error (err, loc) ->
          Some (location_prefix loc ^ migration_error_message err)
      | _ -> None
    )

end
module Migrate_parsetree_403_402_migrate
= struct
#1 "migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Def = Migrate_parsetree_def
module From = Ast_403
module To = Ast_402

let inject_predef_option label d =
  let open To in
  let open Parsetree in
  match label with
  | From.Asttypes.Optional _ ->
    let loc = {d.ptyp_loc with Location.loc_ghost = true} in
    let txt = Longident.Ldot (Longident.Lident "*predef*", "option") in
    let ident = {Location. txt; loc} in
    { ptyp_desc = Ptyp_constr(ident,[d]); ptyp_loc = loc; ptyp_attributes = []}
  | _ -> d

let from_loc {From.Location. txt = _; loc} = loc

let migration_error location feature =
  raise (Def.Migration_error (feature, location))

let rec copy_expression :
  From.Parsetree.expression ->
    To.Parsetree.expression
  =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_loc pexp_desc);
      To.Parsetree.pexp_loc =
        (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc loc :
  From.Parsetree.expression_desc ->
    To.Parsetree.expression_desc
  =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant
        (copy_constant loc x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert
        (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy
        (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack
        (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension
        (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  ->
      migration_error loc Def.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag ->
    To.Asttypes.direction_flag
  =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs =
        (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs =
        (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding ->
    To.Parsetree.value_binding
  =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat =
        (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc =
        (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_loc ppat_desc);
      To.Parsetree.ppat_loc =
        (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc loc :
  From.Parsetree.pattern_desc ->
    To.Parsetree.pattern_desc
  =
  function
  | From.Parsetree.Ppat_any  ->
      To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant
        (copy_constant loc x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant loc x0),
          (copy_constant loc x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy
        (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception
        (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension
        (copy_extension x0)

and copy_core_type :
  From.Parsetree.core_type ->
    To.Parsetree.core_type
  =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc =
        (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc ->
    To.Parsetree.core_type_desc
  =
  function
  | From.Parsetree.Ptyp_any  ->
      To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 ->
      To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          inject_predef_option x0 (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option
             (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x) x0),
          (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package
        (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension
        (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type ->
    To.Parsetree.package_type
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc
                copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field ->
    To.Parsetree.row_field
  =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit
        (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes ->
    To.Parsetree.attributes
  = fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute ->
    To.Parsetree.attribute
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload (from_loc x0) x1))

and copy_payload loc :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr
        (copy_structure x0)
  | From.Parsetree.PSig _x0 ->
      migration_error loc Def.PSig
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp
        (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure ->
    To.Parsetree.structure
  = fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item ->
    To.Parsetree.structure_item
  =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc =
        (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type (type_declarations x0 x1)
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute
        (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos
      copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration ->
    To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr ->
    To.Parsetree.class_expr
  =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc =
        (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc ->
    To.Parsetree.class_expr_desc
  =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension
        (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure ->
    To.Parsetree.class_structure
  =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field ->
    To.Parsetree.class_field
  =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc =
        (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc ->
    To.Parsetree.class_field_desc
  =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension
        (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind ->
    To.Parsetree.class_field_kind
  =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual
        (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding ->
    To.Parsetree.module_binding
  =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc =
        (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr ->
    To.Parsetree.module_expr
  =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc =
        (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc ->
    To.Parsetree.module_expr_desc
  =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure
        (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack
        (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension
        (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type ->
    To.Parsetree.module_type
  =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc =
        (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc ->
    To.Parsetree.module_type_desc
  =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature
        (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof
        (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension
        (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident
           x0)

and copy_with_constraint :
  From.Parsetree.with_constraint ->
    To.Parsetree.with_constraint
  =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc
            copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc
            copy_longident x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc
             copy_longident x1))

and copy_signature :
  From.Parsetree.signature ->
    To.Parsetree.signature
  = fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item ->
    To.Parsetree.signature_item
  =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc =
        (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type (type_declarations x0 x1)
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute
        (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_description :
  From.Parsetree.class_description ->
    To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_type :
  From.Parsetree.class_type ->
    To.Parsetree.class_type
  =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc =
        (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc ->
    To.Parsetree.class_type_desc
  =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          inject_predef_option x0 (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension
        (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature ->
    To.Parsetree.class_signature
  =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field
           pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field ->
    To.Parsetree.class_type_field
  =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc =
        (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit
        (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension
        (copy_extension x0)

and copy_extension :
  From.Parsetree.extension ->
    To.Parsetree.extension
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload (from_loc x0) x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos ->
        'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc =
          (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag ->
    To.Asttypes.virtual_flag
  =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos
      copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc =
          (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description ->
    To.Parsetree.open_description
  =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident
           popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc =
        (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag ->
    To.Asttypes.override_flag
  =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc =
        (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc =
        (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension ->
    To.Parsetree.type_extension
  =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident
           ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind (from_loc pext_name) pext_kind);
      To.Parsetree.pext_loc =
        (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind loc :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments loc x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident
           x0)

and copy_type_declaration :
  From.Parsetree.type_declaration ->
    To.Parsetree.type_declaration
  =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc =
        (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag ->
    To.Asttypes.private_flag
  =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind ->
    To.Parsetree.type_kind
  =
  function
  | From.Parsetree.Ptype_abstract  ->
      To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  ->
      To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments (from_loc pcd_name) pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc =
        (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments loc :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.core_type list
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      List.map copy_core_type x0
  | From.Parsetree.Pcstr_record _x0 ->
      migration_error loc Def.Pcstr_record

and copy_label_declaration :
  From.Parsetree.label_declaration ->
    To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc =
        (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag ->
    To.Asttypes.mutable_flag
  =
  function
  | From.Asttypes.Immutable  ->
      To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  ->
      To.Asttypes.Covariant
  | From.Asttypes.Contravariant  ->
      To.Asttypes.Contravariant
  | From.Asttypes.Invariant  ->
      To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description ->
    To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim =
        (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc =
        (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> string
  =
  function
  | From.Asttypes.Nolabel  -> ""
  | From.Asttypes.Labelled x0 -> x0
  | From.Asttypes.Optional x0 -> "?" ^ x0

and copy_closed_flag :
  From.Asttypes.closed_flag ->
    To.Asttypes.closed_flag
  =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label =
  fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  ->
      To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  ->
      To.Asttypes.Recursive

and copy_constant loc :
  From.Parsetree.constant -> To.Asttypes.constant
  =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
     begin match x1 with
     | None -> To.Asttypes.Const_int (int_of_string x0)
     | Some 'l' ->
         To.Asttypes.Const_int32 (Int32.of_string x0)
     | Some 'L' ->
         To.Asttypes.Const_int64 (Int64.of_string x0)
     | Some 'n' ->
         To.Asttypes.Const_nativeint (Nativeint.of_string x0)
     | Some _ -> migration_error loc Def.Pconst_integer
     end
  | From.Parsetree.Pconst_char x0 ->
      To.Asttypes.Const_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Asttypes.Const_string (x0,x1)
  | From.Parsetree.Pconst_float (x0,x1) ->
      begin match x1 with
      | None -> To.Asttypes.Const_float x0
      | Some _ -> migration_error loc Def.Pconst_float
      end

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident : From.Longident.t -> To.Longident.t = function
  | From.Longident.Lident x0 ->
      To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot
        ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun
      { From.Asttypes.txt = txt;
        From.Asttypes.loc = loc }
       ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = copy_location loc
      }

and copy_location :
  From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

and type_declarations recflag types =
  match
    (recflag, List.map copy_type_declaration types)
  with
  | From.Asttypes.Recursive, types -> types
  | From.Asttypes.Nonrecursive, [] -> []
  | From.Asttypes.Nonrecursive, (x :: xs) ->
      let pos = {Lexing. pos_fname = "_none_"; pos_lnum = 1;
                 pos_bol = 0; pos_cnum = -1} in
      let loc = {To.Location. loc_start = pos; loc_end = pos;
                 loc_ghost = true} in
      let ptype_attributes =
        ({To.Asttypes.txt = "nonrec"; loc}, To.Parsetree.PStr []) ::
        x.To.Parsetree.ptype_attributes
      in
      {x with To.Parsetree.ptype_attributes} :: xs

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 -> copy_out_val_decl x0
  | From.Outcometree.Osig_ellipsis ->
      To.Outcometree.Osig_value ("...", To.Outcometree.Otyp_abstract, [])

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_sig_item =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = _ }
     ->
       To.Outcometree.Osig_value (
         oval_name,
         copy_out_type oval_type,
         List.map (fun x  -> x) oval_prims
       )

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = _;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      (*To.Outcometree.otype_immediate = (copy_bool otype_immediate);*)
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (_x0,_x1) ->
      To.Outcometree.Otyp_abstract
      (*To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))*)

(*and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }*)

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_name
        ((copy_out_ident x0),
          (List.map copy_out_type x1))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument ->
    To.Parsetree.directive_argument
  =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,_x1) ->
      To.Parsetree.Pdir_int (int_of_string x0)
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_402_403
= struct
#1 "migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_402_403_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     (*$*)
     payload
   } as mapper) ->
  let module R = Migrate_parsetree_403_402_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    (*$*)
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload Location.none x)))
  }

end
module Migrate_parsetree_403_402
= struct
#1 "migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_403_402_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     (*$*)
     payload
   } as mapper) ->
  let module R = Migrate_parsetree_402_403_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    (*$*)
    payload = (fun _ x -> copy_payload Location.none (payload mapper (R.copy_payload x)))
  }

end
module Migrate_parsetree_403_404_migrate
= struct
#1 "migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module From = Ast_403
module To = Ast_404

let rec copy_expression :
  From.Parsetree.expression ->
    To.Parsetree.expression
  =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc =
        (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc ->
    To.Parsetree.expression_desc
  =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant
        (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert
        (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy
        (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack
        (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension
        (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  ->
      To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag ->
    To.Asttypes.direction_flag
  =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs =
        (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs =
        (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding ->
    To.Parsetree.value_binding
  =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat =
        (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc =
        (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc =
        (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc ->
    To.Parsetree.pattern_desc
  =
  function
  | From.Parsetree.Ppat_any  ->
      To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant
        (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy
        (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception
        (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension
        (copy_extension x0)

and copy_core_type :
  From.Parsetree.core_type ->
    To.Parsetree.core_type
  =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc =
        (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc ->
    To.Parsetree.core_type_desc
  =
  function
  | From.Parsetree.Ptyp_any  ->
      To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 ->
      To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option
             (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x) x0),
          (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package
        (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension
        (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type ->
    To.Parsetree.package_type
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc
                copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field ->
    To.Parsetree.row_field
  =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit
        (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes ->
    To.Parsetree.attributes
  = fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute ->
    To.Parsetree.attribute
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr
        (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig
        (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp
        (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure ->
    To.Parsetree.structure
  = fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item ->
    To.Parsetree.structure_item
  =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc =
        (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute
        (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos
      copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration ->
    To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr ->
    To.Parsetree.class_expr
  =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc =
        (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc ->
    To.Parsetree.class_expr_desc
  =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension
        (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure ->
    To.Parsetree.class_structure
  =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field ->
    To.Parsetree.class_field
  =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc =
        (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc ->
    To.Parsetree.class_field_desc
  =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension
        (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind ->
    To.Parsetree.class_field_kind
  =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual
        (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding ->
    To.Parsetree.module_binding
  =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc =
        (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr ->
    To.Parsetree.module_expr
  =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc =
        (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc ->
    To.Parsetree.module_expr_desc
  =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure
        (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack
        (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension
        (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type ->
    To.Parsetree.module_type
  =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc =
        (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc ->
    To.Parsetree.module_type_desc
  =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature
        (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof
        (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension
        (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident
           x0)

and copy_with_constraint :
  From.Parsetree.with_constraint ->
    To.Parsetree.with_constraint
  =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc
            copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc
            copy_longident x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc
             copy_longident x1))

and copy_signature :
  From.Parsetree.signature ->
    To.Parsetree.signature
  = fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item ->
    To.Parsetree.signature_item
  =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc =
        (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute
        (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_description :
  From.Parsetree.class_description ->
    To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_type :
  From.Parsetree.class_type ->
    To.Parsetree.class_type
  =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc =
        (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc ->
    To.Parsetree.class_type_desc
  =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension
        (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature ->
    To.Parsetree.class_signature
  =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field
           pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field ->
    To.Parsetree.class_type_field
  =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc =
        (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit
        (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension
        (copy_extension x0)

and copy_extension :
  From.Parsetree.extension ->
    To.Parsetree.extension
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos ->
        'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc =
          (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag ->
    To.Asttypes.virtual_flag
  =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos
      copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc =
          (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description ->
    To.Parsetree.open_description
  =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident
           popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc =
        (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag ->
    To.Asttypes.override_flag
  =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc =
        (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc =
        (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension ->
    To.Parsetree.type_extension
  =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident
           ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc =
        (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident
           x0)

and copy_type_declaration :
  From.Parsetree.type_declaration ->
    To.Parsetree.type_declaration
  =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc =
        (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag ->
    To.Asttypes.private_flag
  =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind ->
    To.Parsetree.type_kind
  =
  function
  | From.Parsetree.Ptype_abstract  ->
      To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  ->
      To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc =
        (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration ->
    To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc =
        (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag ->
    To.Asttypes.mutable_flag
  =
  function
  | From.Asttypes.Immutable  ->
      To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  ->
      To.Asttypes.Covariant
  | From.Asttypes.Contravariant  ->
      To.Asttypes.Contravariant
  | From.Asttypes.Invariant  ->
      To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description ->
    To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim =
        (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc =
        (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label
  =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 ->
      To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 ->
      To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag ->
    To.Asttypes.closed_flag
  =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label =
  fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  ->
      To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  ->
      To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant
  =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer
        (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 ->
      To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string
        (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float
        (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident :
  From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 ->
      To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot
        ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun
      { From.Asttypes.txt = txt;
        From.Asttypes.loc = loc }
       ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location :
  From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_unboxed = false;
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_name
        ((copy_out_ident x0),
          (List.map copy_out_type x1))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply ((copy_out_ident x0), (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir (x0, copy_directive_argument x1)

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, copy_option (fun x  -> x) x1)
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_404_403_migrate
= struct
#1 "migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Def = Migrate_parsetree_def
module From = Ast_404
module To = Ast_403

let from_loc {From.Location. txt = _; loc} = loc

let migration_error location feature =
  raise (Def.Migration_error (feature, location))

let rec copy_expression :
  From.Parsetree.expression ->
    To.Parsetree.expression
  =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_loc pexp_desc);
      To.Parsetree.pexp_loc =
        (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc loc :
  From.Parsetree.expression_desc ->
    To.Parsetree.expression_desc
  =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant
        (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_letexception _ ->
      migration_error loc Def.Pexp_letexception
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert
        (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy
        (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack
        (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension
        (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  ->
      To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag ->
    To.Asttypes.direction_flag
  =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs =
        (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs =
        (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding ->
    To.Parsetree.value_binding
  =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat =
        (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc =
        (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_loc ppat_desc);
      To.Parsetree.ppat_loc =
        (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc loc :
  From.Parsetree.pattern_desc ->
    To.Parsetree.pattern_desc
  =
  function
  | From.Parsetree.Ppat_any  ->
      To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant
        (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy
        (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception
        (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension
        (copy_extension x0)
  | From.Parsetree.Ppat_open _ ->
      migration_error loc Def.Ppat_open
and copy_core_type :
  From.Parsetree.core_type ->
    To.Parsetree.core_type
  =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc =
        (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc ->
    To.Parsetree.core_type_desc
  =
  function
  | From.Parsetree.Ptyp_any  ->
      To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 ->
      To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option
             (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x) x0),
          (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package
        (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension
        (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type ->
    To.Parsetree.package_type
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc
                copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field ->
    To.Parsetree.row_field
  =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit
        (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes ->
    To.Parsetree.attributes
  = fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute ->
    To.Parsetree.attribute
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr
        (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig
        (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp
        (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure ->
    To.Parsetree.structure
  = fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item ->
    To.Parsetree.structure_item
  =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc =
        (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute
        (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos
      copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration ->
    To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr ->
    To.Parsetree.class_expr
  =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc =
        (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc ->
    To.Parsetree.class_expr_desc
  =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension
        (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure ->
    To.Parsetree.class_structure
  =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field ->
    To.Parsetree.class_field
  =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc =
        (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc ->
    To.Parsetree.class_field_desc
  =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension
        (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind ->
    To.Parsetree.class_field_kind
  =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual
        (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding ->
    To.Parsetree.module_binding
  =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc =
        (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr ->
    To.Parsetree.module_expr
  =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc =
        (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc ->
    To.Parsetree.module_expr_desc
  =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure
        (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack
        (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension
        (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type ->
    To.Parsetree.module_type
  =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc =
        (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc ->
    To.Parsetree.module_type_desc
  =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature
        (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof
        (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension
        (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident
           x0)

and copy_with_constraint :
  From.Parsetree.with_constraint ->
    To.Parsetree.with_constraint
  =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc
            copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc
            copy_longident x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc
             copy_longident x1))

and copy_signature :
  From.Parsetree.signature ->
    To.Parsetree.signature
  = fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item ->
    To.Parsetree.signature_item
  =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc =
        (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute
        (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_description :
  From.Parsetree.class_description ->
    To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_type :
  From.Parsetree.class_type ->
    To.Parsetree.class_type
  =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc =
        (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc ->
    To.Parsetree.class_type_desc
  =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension
        (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature ->
    To.Parsetree.class_signature
  =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field
           pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field ->
    To.Parsetree.class_type_field
  =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc =
        (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit
        (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension
        (copy_extension x0)

and copy_extension :
  From.Parsetree.extension ->
    To.Parsetree.extension
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos ->
        'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc =
          (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag ->
    To.Asttypes.virtual_flag
  =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos
      copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc =
          (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description ->
    To.Parsetree.open_description
  =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident
           popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc =
        (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag ->
    To.Asttypes.override_flag
  =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc =
        (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc =
        (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension ->
    To.Parsetree.type_extension
  =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident
           ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc =
        (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident
           x0)

and copy_type_declaration :
  From.Parsetree.type_declaration ->
    To.Parsetree.type_declaration
  =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc =
        (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag ->
    To.Asttypes.private_flag
  =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind ->
    To.Parsetree.type_kind
  =
  function
  | From.Parsetree.Ptype_abstract  ->
      To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  ->
      To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc =
        (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration ->
    To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc =
        (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag ->
    To.Asttypes.mutable_flag
  =
  function
  | From.Asttypes.Immutable  ->
      To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  ->
      To.Asttypes.Covariant
  | From.Asttypes.Contravariant  ->
      To.Asttypes.Contravariant
  | From.Asttypes.Invariant  ->
      To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description ->
    To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim =
        (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc =
        (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label
  =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 ->
      To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 ->
      To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag ->
    To.Asttypes.closed_flag
  =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label =
  fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  ->
      To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  ->
      To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant
  =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer
        (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 ->
      To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string
        (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float
        (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident :
  From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 ->
      To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot
        ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun
      { From.Asttypes.txt = txt;
        From.Asttypes.loc = loc }
       ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location :
  From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_unboxed = _otype_unboxed;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_name
        ((copy_out_ident x0),
          (List.map copy_out_type x1))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply ((copy_out_ident x0), (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_403_404
= struct
#1 "migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_403_404_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_404_403_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Migrate_parsetree_404_403
= struct
#1 "migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_404_403_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_403_404_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Migrate_parsetree_404_405_migrate
= struct
#1 "migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module From = Ast_404
module To = Ast_405

let noloc x = { Location. txt = x; loc = Location.none }

let rec copy_expression :
  From.Parsetree.expression -> To.Parsetree.expression =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc = (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc = (copy_location pexp_loc);
      To.Parsetree.pexp_attributes = (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), noloc x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_letexception (x0,x1) ->
      To.Parsetree.Pexp_letexception
        ((copy_extension_constructor x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (noloc x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs = (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding -> To.Parsetree.value_binding =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc = (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc = (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =
  function
  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension (copy_extension x0)
  | From.Parsetree.Ppat_open (x0,x1) ->
      To.Parsetree.Ppat_open
        ((copy_loc copy_longident x0),
          (copy_pattern x1))

and copy_core_type :
  From.Parsetree.core_type -> To.Parsetree.core_type =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =
  function
  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (noloc x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> noloc x) x0), (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type -> To.Parsetree.package_type =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field -> To.Parsetree.row_field =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes -> To.Parsetree.attributes =
  fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute -> To.Parsetree.attribute =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure -> To.Parsetree.structure =
  fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item -> To.Parsetree.structure_item =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc = (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration -> To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr -> To.Parsetree.class_expr =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc = (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure -> To.Parsetree.class_structure =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field -> To.Parsetree.class_field =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc = (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> noloc x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding -> To.Parsetree.module_binding =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc = (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr -> To.Parsetree.module_expr =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc = (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type -> To.Parsetree.module_type =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc = (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident x0)

and copy_with_constraint :
  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc copy_longident x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc copy_longident x1))

and copy_signature :
  From.Parsetree.signature -> To.Parsetree.signature =
  fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item -> To.Parsetree.signature_item =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc = (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_description :
  From.Parsetree.class_description -> To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_type :
  From.Parsetree.class_type -> To.Parsetree.class_type =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc = (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature -> To.Parsetree.class_signature =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc = (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (noloc x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (noloc x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension (copy_extension x0)

and copy_extension :
  From.Parsetree.extension -> To.Parsetree.extension =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc = (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc = (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description -> To.Parsetree.open_description =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc = (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag -> To.Asttypes.override_flag =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc = (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension -> To.Parsetree.type_extension =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc = (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident x0)

and copy_type_declaration :
  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc = (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind -> To.Parsetree.type_kind =
  function
  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc = (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration -> To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc = (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =
  function
  | From.Asttypes.Immutable  -> To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  -> To.Asttypes.Covariant
  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant
  | From.Asttypes.Invariant  -> To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description -> To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc = (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label = fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  -> To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident : From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 -> To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location : From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_unboxed = otype_unboxed;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_typ
        (To.Outcometree.Otyp_constr
           ((copy_out_ident x0),
            (List.map copy_out_type x1)))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_405_404_migrate
= struct
#1 "migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module From = Ast_405
module To = Ast_404

let rec copy_expression :
  From.Parsetree.expression -> To.Parsetree.expression =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc = (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1.From.Asttypes.txt)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_letexception (x0,x1) ->
      To.Parsetree.Pexp_letexception
        ((copy_extension_constructor x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0.From.Asttypes.txt, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs = (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding -> To.Parsetree.value_binding =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc = (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc = (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =
  function
  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension (copy_extension x0)
  | From.Parsetree.Ppat_open (x0,x1) ->
      To.Parsetree.Ppat_open
        ((copy_loc copy_longident x0),
          (copy_pattern x1))

and copy_core_type :
  From.Parsetree.core_type -> To.Parsetree.core_type =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =
  function
  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0.From.Asttypes.txt, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x.From.Asttypes.txt) x0), (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type -> To.Parsetree.package_type =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field -> To.Parsetree.row_field =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes -> To.Parsetree.attributes =
  fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute -> To.Parsetree.attribute =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure -> To.Parsetree.structure =
  fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item -> To.Parsetree.structure_item =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc = (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration -> To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr -> To.Parsetree.class_expr =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc = (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure -> To.Parsetree.class_structure =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field -> To.Parsetree.class_field =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc = (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x.From.Asttypes.txt) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding -> To.Parsetree.module_binding =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc = (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr -> To.Parsetree.module_expr =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc = (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type -> To.Parsetree.module_type =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc = (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident x0)

and copy_with_constraint :
  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc copy_longident x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc copy_longident x1))

and copy_signature :
  From.Parsetree.signature -> To.Parsetree.signature =
  fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item -> To.Parsetree.signature_item =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc = (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_description :
  From.Parsetree.class_description -> To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_type :
  From.Parsetree.class_type -> To.Parsetree.class_type =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc = (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature -> To.Parsetree.class_signature =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc = (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0.From.Asttypes.txt, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0.From.Asttypes.txt, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension (copy_extension x0)

and copy_extension :
  From.Parsetree.extension -> To.Parsetree.extension =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc = (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc = (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description -> To.Parsetree.open_description =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc = (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag -> To.Asttypes.override_flag =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc = (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension -> To.Parsetree.type_extension =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc = (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident x0)

and copy_type_declaration :
  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc = (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind -> To.Parsetree.type_kind =
  function
  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc = (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration -> To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc = (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =
  function
  | From.Asttypes.Immutable  -> To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  -> To.Asttypes.Covariant
  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant
  | From.Asttypes.Invariant  -> To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description -> To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc = (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label = fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  -> To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident : From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 -> To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location : From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_unboxed = otype_unboxed;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_typ (From.Outcometree.Otyp_constr (id,tyl)) ->
      To.Outcometree.Ovar_name (copy_out_ident id, List.map copy_out_type tyl)
  | From.Outcometree.Ovar_typ x0 ->
      To.Outcometree.Ovar_name
        (To.Outcometree.Oide_ident "", [copy_out_type x0])

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_404_405
= struct
#1 "migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_404_405_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_405_404_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Migrate_parsetree_405_404
= struct
#1 "migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_405_404_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_404_405_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Migrate_parsetree_versions : sig 
#1 "migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                   Jérémie Dimino, Jane Street Europe                   *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(*$ #use "src/cinaps_helpers" $*)

(** {1 Abstracting an OCaml frontend} *)

(** Abstract view of a version of an OCaml Ast *)
module type Ast = sig
  (*$ foreach_module (fun m types ->
        printf "module %s : sig\n" m;
        List.iter types ~f:(printf "type %s\n");
        printf "end\n"
      )
  *)
  module Parsetree : sig
    type structure
    type signature
    type toplevel_phrase
    type core_type
    type expression
    type pattern
    type case
    type type_declaration
    type type_extension
    type extension_constructor
  end
  module Outcometree : sig
    type out_value
    type out_type
    type out_class_type
    type out_module_type
    type out_sig_item
    type out_type_extension
    type out_phrase
  end
  module Ast_mapper : sig
    type mapper
  end
  (*$*)
  module Config : sig
    val ast_impl_magic_number : string
    val ast_intf_magic_number : string
  end
  val map_signature : Ast_mapper.mapper -> Parsetree.signature -> Parsetree.signature
  val map_structure : Ast_mapper.mapper -> Parsetree.structure -> Parsetree.structure
  val make_top_mapper
    :  signature:(Parsetree.signature -> Parsetree.signature)
    -> structure:(Parsetree.structure -> Parsetree.structure)
    -> Ast_mapper.mapper
end

(* Shortcuts for talking about ast types outside of the module language *)

type 'a _types = 'a constraint 'a
  = <
  (*$ foreach_type (fun _ s -> printf "%-21s : _;\n" s) *)
  structure             : _;
  signature             : _;
  toplevel_phrase       : _;
  core_type             : _;
  expression            : _;
  pattern               : _;
  case                  : _;
  type_declaration      : _;
  type_extension        : _;
  extension_constructor : _;
  out_value             : _;
  out_type              : _;
  out_class_type        : _;
  out_module_type       : _;
  out_sig_item          : _;
  out_type_extension    : _;
  out_phrase            : _;
  mapper                : _;
  (*$*)
  >
;;

(*$ foreach_type (fun _ s ->
      printf "type 'a get_%s = 'x constraint 'a _types = < %s : 'x; .. >\n" s s
    );
    printf ";;\n" *)
type 'a get_structure = 'x constraint 'a _types = < structure : 'x; .. >
type 'a get_signature = 'x constraint 'a _types = < signature : 'x; .. >
type 'a get_toplevel_phrase = 'x constraint 'a _types = < toplevel_phrase : 'x; .. >
type 'a get_core_type = 'x constraint 'a _types = < core_type : 'x; .. >
type 'a get_expression = 'x constraint 'a _types = < expression : 'x; .. >
type 'a get_pattern = 'x constraint 'a _types = < pattern : 'x; .. >
type 'a get_case = 'x constraint 'a _types = < case : 'x; .. >
type 'a get_type_declaration = 'x constraint 'a _types = < type_declaration : 'x; .. >
type 'a get_type_extension = 'x constraint 'a _types = < type_extension : 'x; .. >
type 'a get_extension_constructor = 'x constraint 'a _types = < extension_constructor : 'x; .. >
type 'a get_out_value = 'x constraint 'a _types = < out_value : 'x; .. >
type 'a get_out_type = 'x constraint 'a _types = < out_type : 'x; .. >
type 'a get_out_class_type = 'x constraint 'a _types = < out_class_type : 'x; .. >
type 'a get_out_module_type = 'x constraint 'a _types = < out_module_type : 'x; .. >
type 'a get_out_sig_item = 'x constraint 'a _types = < out_sig_item : 'x; .. >
type 'a get_out_type_extension = 'x constraint 'a _types = < out_type_extension : 'x; .. >
type 'a get_out_phrase = 'x constraint 'a _types = < out_phrase : 'x; .. >
type 'a get_mapper = 'x constraint 'a _types = < mapper : 'x; .. >
;;
(*$*)

(** A version of the OCaml frontend packs the ast with type witnesses
    so that equalities can be recovered dynamically. *)
type _ witnesses

(** [migration_info] is an opaque type that is used to generate migration
    functions. *)
type _ migration_info

(** An OCaml frontend versions an Ast, version number and some witnesses for
    conversion. *)
module type OCaml_version = sig

  (** Ast definition for this version *)
  module Ast : Ast

  (* Version number as an integer, 402, 403, 404, ... *)
  val version : int

  (* Version number as a user-friendly string *)
  val string_version : string (* 4.02, 4.03, 4.04, ... *)

  (** Shortcut for talking about Ast types *)
  type types = <
    (*$ foreach_type (fun m s -> printf "%-21s : Ast.%s.%s;\n" s m s) *)
    structure             : Ast.Parsetree.structure;
    signature             : Ast.Parsetree.signature;
    toplevel_phrase       : Ast.Parsetree.toplevel_phrase;
    core_type             : Ast.Parsetree.core_type;
    expression            : Ast.Parsetree.expression;
    pattern               : Ast.Parsetree.pattern;
    case                  : Ast.Parsetree.case;
    type_declaration      : Ast.Parsetree.type_declaration;
    type_extension        : Ast.Parsetree.type_extension;
    extension_constructor : Ast.Parsetree.extension_constructor;
    out_value             : Ast.Outcometree.out_value;
    out_type              : Ast.Outcometree.out_type;
    out_class_type        : Ast.Outcometree.out_class_type;
    out_module_type       : Ast.Outcometree.out_module_type;
    out_sig_item          : Ast.Outcometree.out_sig_item;
    out_type_extension    : Ast.Outcometree.out_type_extension;
    out_phrase            : Ast.Outcometree.out_phrase;
    mapper                : Ast.Ast_mapper.mapper;
    (*$*)
  > _types

  (** A construtor for recovering type equalities between two arbitrary
      versions. *)
  type _ witnesses += Version : types witnesses

  (** Information used to derive migration functions, see below *)
  val migration_info : types migration_info
end

(** Representing an ocaml version in type language *)
type 'types ocaml_version =
  (module OCaml_version
    (*$ let sep = with_then_and () in
        foreach_type (fun m s ->
          printf "%t type Ast.%s.%s = 'types get_%s\n" sep m s s) *)
    with type Ast.Parsetree.structure = 'types get_structure
     and type Ast.Parsetree.signature = 'types get_signature
     and type Ast.Parsetree.toplevel_phrase = 'types get_toplevel_phrase
     and type Ast.Parsetree.core_type = 'types get_core_type
     and type Ast.Parsetree.expression = 'types get_expression
     and type Ast.Parsetree.pattern = 'types get_pattern
     and type Ast.Parsetree.case = 'types get_case
     and type Ast.Parsetree.type_declaration = 'types get_type_declaration
     and type Ast.Parsetree.type_extension = 'types get_type_extension
     and type Ast.Parsetree.extension_constructor = 'types get_extension_constructor
     and type Ast.Outcometree.out_value = 'types get_out_value
     and type Ast.Outcometree.out_type = 'types get_out_type
     and type Ast.Outcometree.out_class_type = 'types get_out_class_type
     and type Ast.Outcometree.out_module_type = 'types get_out_module_type
     and type Ast.Outcometree.out_sig_item = 'types get_out_sig_item
     and type Ast.Outcometree.out_type_extension = 'types get_out_type_extension
     and type Ast.Outcometree.out_phrase = 'types get_out_phrase
     and type Ast.Ast_mapper.mapper = 'types get_mapper
     (*$*)
  )

(** {1 Concrete frontend instances} *)

(*$foreach_version (fun suffix _ ->
     printf "module OCaml_%s : OCaml_version with module Ast = Ast_%s\n"
       suffix suffix;
     printf "val ocaml_%s : OCaml_%s.types ocaml_version\n" suffix suffix;
  )*)
module OCaml_402 : OCaml_version with module Ast = Ast_402
val ocaml_402 : OCaml_402.types ocaml_version
module OCaml_403 : OCaml_version with module Ast = Ast_403
val ocaml_403 : OCaml_403.types ocaml_version
module OCaml_404 : OCaml_version with module Ast = Ast_404
val ocaml_404 : OCaml_404.types ocaml_version
module OCaml_405 : OCaml_version with module Ast = Ast_405
val ocaml_405 : OCaml_405.types ocaml_version
(*$*)

(* An alias to the current compiler version *)
module OCaml_current = OCaml_402          
val ocaml_current : OCaml_current.types ocaml_version

val all_versions : (module OCaml_version) list

(** {1 Migrating between different versions} *)

type ('a, 'b) type_comparison =
  | Lt : ('a, 'b) type_comparison
  | Eq : ('a, 'a) type_comparison
  | Gt : ('a, 'b) type_comparison

val compare_ocaml_version : 'a ocaml_version -> 'b ocaml_version -> ('a, 'b) type_comparison

(** A record for migrating each AST construct between two known versions *)
type ('from, 'to_) migration_functions = {
  (*$ foreach_type (fun _ s ->
        printf "copy_%s: 'from get_%s -> 'to_ get_%s;\n" s s s) *)
  copy_structure: 'from get_structure -> 'to_ get_structure;
  copy_signature: 'from get_signature -> 'to_ get_signature;
  copy_toplevel_phrase: 'from get_toplevel_phrase -> 'to_ get_toplevel_phrase;
  copy_core_type: 'from get_core_type -> 'to_ get_core_type;
  copy_expression: 'from get_expression -> 'to_ get_expression;
  copy_pattern: 'from get_pattern -> 'to_ get_pattern;
  copy_case: 'from get_case -> 'to_ get_case;
  copy_type_declaration: 'from get_type_declaration -> 'to_ get_type_declaration;
  copy_type_extension: 'from get_type_extension -> 'to_ get_type_extension;
  copy_extension_constructor: 'from get_extension_constructor -> 'to_ get_extension_constructor;
  copy_out_value: 'from get_out_value -> 'to_ get_out_value;
  copy_out_type: 'from get_out_type -> 'to_ get_out_type;
  copy_out_class_type: 'from get_out_class_type -> 'to_ get_out_class_type;
  copy_out_module_type: 'from get_out_module_type -> 'to_ get_out_module_type;
  copy_out_sig_item: 'from get_out_sig_item -> 'to_ get_out_sig_item;
  copy_out_type_extension: 'from get_out_type_extension -> 'to_ get_out_type_extension;
  copy_out_phrase: 'from get_out_phrase -> 'to_ get_out_phrase;
  copy_mapper: 'from get_mapper -> 'to_ get_mapper;
  (*$*)
}

(** Migrating to the same version is no-op *)
val migration_identity : ('a, 'a) migration_functions

(** Migrations can be composed *)
val migration_compose : ('a, 'b) migration_functions -> ('b, 'c) migration_functions -> ('a, 'c) migration_functions

(** Represent the next or previous version of an Ast *)

type 'from immediate_migration =
  | No_migration : 'from immediate_migration
  (** Cannot migrate earliest or latest supported version *)
  |
    Immediate_migration :
      ('from, 'to_) migration_functions * 'to_ ocaml_version -> 'from immediate_migration
  (** Pack the migration functions and the new version *)

val immediate_migration : 'types ocaml_version -> [< `Next | `Previous ] -> 'types immediate_migration

val migrate : 'from ocaml_version -> 'to_ ocaml_version -> ('from, 'to_) migration_functions

(** {1 Convenience definitions} *)

(** Module level migration *)
module Convert (A : OCaml_version) (B : OCaml_version) : sig
  (*$ foreach_type (fun m s ->
        let fq = sprintf "%s.%s" m s in
        printf "  val copy_%-21s : A.Ast.%-31s -> B.Ast.%s\n" s fq fq) *)
  val copy_structure             : A.Ast.Parsetree.structure             -> B.Ast.Parsetree.structure
  val copy_signature             : A.Ast.Parsetree.signature             -> B.Ast.Parsetree.signature
  val copy_toplevel_phrase       : A.Ast.Parsetree.toplevel_phrase       -> B.Ast.Parsetree.toplevel_phrase
  val copy_core_type             : A.Ast.Parsetree.core_type             -> B.Ast.Parsetree.core_type
  val copy_expression            : A.Ast.Parsetree.expression            -> B.Ast.Parsetree.expression
  val copy_pattern               : A.Ast.Parsetree.pattern               -> B.Ast.Parsetree.pattern
  val copy_case                  : A.Ast.Parsetree.case                  -> B.Ast.Parsetree.case
  val copy_type_declaration      : A.Ast.Parsetree.type_declaration      -> B.Ast.Parsetree.type_declaration
  val copy_type_extension        : A.Ast.Parsetree.type_extension        -> B.Ast.Parsetree.type_extension
  val copy_extension_constructor : A.Ast.Parsetree.extension_constructor -> B.Ast.Parsetree.extension_constructor
  val copy_out_value             : A.Ast.Outcometree.out_value           -> B.Ast.Outcometree.out_value
  val copy_out_type              : A.Ast.Outcometree.out_type            -> B.Ast.Outcometree.out_type
  val copy_out_class_type        : A.Ast.Outcometree.out_class_type      -> B.Ast.Outcometree.out_class_type
  val copy_out_module_type       : A.Ast.Outcometree.out_module_type     -> B.Ast.Outcometree.out_module_type
  val copy_out_sig_item          : A.Ast.Outcometree.out_sig_item        -> B.Ast.Outcometree.out_sig_item
  val copy_out_type_extension    : A.Ast.Outcometree.out_type_extension  -> B.Ast.Outcometree.out_type_extension
  val copy_out_phrase            : A.Ast.Outcometree.out_phrase          -> B.Ast.Outcometree.out_phrase
  val copy_mapper                : A.Ast.Ast_mapper.mapper               -> B.Ast.Ast_mapper.mapper
  (*$*)
end

end = struct
#1 "migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                   Jérémie Dimino, Jane Street Europe                   *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* BEGIN of BLACK MAGIC *)
(*$ #use "src/cinaps_helpers" $*)

type _ witnesses = ..

type _ migration = ..
type _ migration += Undefined : _ migration

type 'a migration_info = {
  mutable next_version : 'a migration;
  mutable previous_version : 'a migration;
}

(** Abstract view of a version of an OCaml Ast *)
module type Ast = sig
  (*$ foreach_module (fun m types ->
        printf "module %s : sig\n" m;
        List.iter types ~f:(printf "type %s\n");
        printf "end\n"
      )
  *)
  module Parsetree : sig
    type structure
    type signature
    type toplevel_phrase
    type core_type
    type expression
    type pattern
    type case
    type type_declaration
    type type_extension
    type extension_constructor
  end
  module Outcometree : sig
    type out_value
    type out_type
    type out_class_type
    type out_module_type
    type out_sig_item
    type out_type_extension
    type out_phrase
  end
  module Ast_mapper : sig
    type mapper
  end
  (*$*)
  module Config : sig
    val ast_impl_magic_number : string
    val ast_intf_magic_number : string
  end
  val map_signature : Ast_mapper.mapper -> Parsetree.signature -> Parsetree.signature
  val map_structure : Ast_mapper.mapper -> Parsetree.structure -> Parsetree.structure
  val make_top_mapper
    :  signature:(Parsetree.signature -> Parsetree.signature)
    -> structure:(Parsetree.structure -> Parsetree.structure)
    -> Ast_mapper.mapper
end

(* Shortcuts for talking about ast types outside of the module language *)

type 'a _types = 'a constraint 'a
  = <
  (*$ foreach_type (fun _ s -> printf "%-21s : _;\n" s) *)
  structure             : _;
  signature             : _;
  toplevel_phrase       : _;
  core_type             : _;
  expression            : _;
  pattern               : _;
  case                  : _;
  type_declaration      : _;
  type_extension        : _;
  extension_constructor : _;
  out_value             : _;
  out_type              : _;
  out_class_type        : _;
  out_module_type       : _;
  out_sig_item          : _;
  out_type_extension    : _;
  out_phrase            : _;
  mapper                : _;
  (*$*)
  >
;;

(*$ foreach_type (fun _ s ->
      printf "type 'a get_%s =\n" s;
      printf " 'x constraint 'a _types = < %s : 'x; .. >\n" s
    ) *)
type 'a get_structure =
  'x constraint 'a _types = < structure : 'x; .. >
type 'a get_signature =
  'x constraint 'a _types = < signature : 'x; .. >
type 'a get_toplevel_phrase =
  'x constraint 'a _types = < toplevel_phrase : 'x; .. >
type 'a get_core_type =
  'x constraint 'a _types = < core_type : 'x; .. >
type 'a get_expression =
  'x constraint 'a _types = < expression : 'x; .. >
type 'a get_pattern =
  'x constraint 'a _types = < pattern : 'x; .. >
type 'a get_case =
  'x constraint 'a _types = < case : 'x; .. >
type 'a get_type_declaration =
  'x constraint 'a _types = < type_declaration : 'x; .. >
type 'a get_type_extension =
  'x constraint 'a _types = < type_extension : 'x; .. >
type 'a get_extension_constructor =
  'x constraint 'a _types = < extension_constructor : 'x; .. >
type 'a get_out_value =
  'x constraint 'a _types = < out_value : 'x; .. >
type 'a get_out_type =
  'x constraint 'a _types = < out_type : 'x; .. >
type 'a get_out_class_type =
  'x constraint 'a _types = < out_class_type : 'x; .. >
type 'a get_out_module_type =
  'x constraint 'a _types = < out_module_type : 'x; .. >
type 'a get_out_sig_item =
  'x constraint 'a _types = < out_sig_item : 'x; .. >
type 'a get_out_type_extension =
  'x constraint 'a _types = < out_type_extension : 'x; .. >
type 'a get_out_phrase =
  'x constraint 'a _types = < out_phrase : 'x; .. >
type 'a get_mapper =
  'x constraint 'a _types = < mapper : 'x; .. >
       (*$*)

module type OCaml_version = sig
  module Ast : Ast
  val version : int
  val string_version : string
  type types = <
    (*$ foreach_type (fun m s -> printf "%-21s : Ast.%s.%s;\n" s m s)*)
    structure             : Ast.Parsetree.structure;
    signature             : Ast.Parsetree.signature;
    toplevel_phrase       : Ast.Parsetree.toplevel_phrase;
    core_type             : Ast.Parsetree.core_type;
    expression            : Ast.Parsetree.expression;
    pattern               : Ast.Parsetree.pattern;
    case                  : Ast.Parsetree.case;
    type_declaration      : Ast.Parsetree.type_declaration;
    type_extension        : Ast.Parsetree.type_extension;
    extension_constructor : Ast.Parsetree.extension_constructor;
    out_value             : Ast.Outcometree.out_value;
    out_type              : Ast.Outcometree.out_type;
    out_class_type        : Ast.Outcometree.out_class_type;
    out_module_type       : Ast.Outcometree.out_module_type;
    out_sig_item          : Ast.Outcometree.out_sig_item;
    out_type_extension    : Ast.Outcometree.out_type_extension;
    out_phrase            : Ast.Outcometree.out_phrase;
    mapper                : Ast.Ast_mapper.mapper;
    (*$*)
  > _types
  type _ witnesses += Version : types witnesses
  val migration_info : types migration_info
end

module Make_witness(Ast : Ast) =
struct
  type types = <
    (*$ foreach_type (fun m s -> printf "%-21s : Ast.%s.%s;\n" s m s)*)
    structure             : Ast.Parsetree.structure;
    signature             : Ast.Parsetree.signature;
    toplevel_phrase       : Ast.Parsetree.toplevel_phrase;
    core_type             : Ast.Parsetree.core_type;
    expression            : Ast.Parsetree.expression;
    pattern               : Ast.Parsetree.pattern;
    case                  : Ast.Parsetree.case;
    type_declaration      : Ast.Parsetree.type_declaration;
    type_extension        : Ast.Parsetree.type_extension;
    extension_constructor : Ast.Parsetree.extension_constructor;
    out_value             : Ast.Outcometree.out_value;
    out_type              : Ast.Outcometree.out_type;
    out_class_type        : Ast.Outcometree.out_class_type;
    out_module_type       : Ast.Outcometree.out_module_type;
    out_sig_item          : Ast.Outcometree.out_sig_item;
    out_type_extension    : Ast.Outcometree.out_type_extension;
    out_phrase            : Ast.Outcometree.out_phrase;
    mapper                : Ast.Ast_mapper.mapper;
    (*$*)
  > _types
  type _ witnesses += Version : types witnesses
  let migration_info : types migration_info =
    { next_version = Undefined; previous_version = Undefined }
end

type 'types ocaml_version =
  (module OCaml_version
    (*$ let sep = with_then_and () in
        foreach_type (fun m s ->
          printf "%t type Ast.%s.%s = 'types get_%s\n" sep m s s) *)
    with type Ast.Parsetree.structure = 'types get_structure
     and type Ast.Parsetree.signature = 'types get_signature
     and type Ast.Parsetree.toplevel_phrase = 'types get_toplevel_phrase
     and type Ast.Parsetree.core_type = 'types get_core_type
     and type Ast.Parsetree.expression = 'types get_expression
     and type Ast.Parsetree.pattern = 'types get_pattern
     and type Ast.Parsetree.case = 'types get_case
     and type Ast.Parsetree.type_declaration = 'types get_type_declaration
     and type Ast.Parsetree.type_extension = 'types get_type_extension
     and type Ast.Parsetree.extension_constructor = 'types get_extension_constructor
     and type Ast.Outcometree.out_value = 'types get_out_value
     and type Ast.Outcometree.out_type = 'types get_out_type
     and type Ast.Outcometree.out_class_type = 'types get_out_class_type
     and type Ast.Outcometree.out_module_type = 'types get_out_module_type
     and type Ast.Outcometree.out_sig_item = 'types get_out_sig_item
     and type Ast.Outcometree.out_type_extension = 'types get_out_type_extension
     and type Ast.Outcometree.out_phrase = 'types get_out_phrase
     and type Ast.Ast_mapper.mapper = 'types get_mapper
     (*$*)
  )

type ('a, 'b) type_comparison =
  | Lt : ('a, 'b) type_comparison
  | Eq : ('a, 'a) type_comparison
  | Gt : ('a, 'b) type_comparison

let compare_ocaml_version
    (*$ foreach_type (fun _ s -> printf "(type %s1) (type %s2)\n" s s) *)
    (type structure1) (type structure2)
    (type signature1) (type signature2)
    (type toplevel_phrase1) (type toplevel_phrase2)
    (type core_type1) (type core_type2)
    (type expression1) (type expression2)
    (type pattern1) (type pattern2)
    (type case1) (type case2)
    (type type_declaration1) (type type_declaration2)
    (type type_extension1) (type type_extension2)
    (type extension_constructor1) (type extension_constructor2)
    (type out_value1) (type out_value2)
    (type out_type1) (type out_type2)
    (type out_class_type1) (type out_class_type2)
    (type out_module_type1) (type out_module_type2)
    (type out_sig_item1) (type out_sig_item2)
    (type out_type_extension1) (type out_type_extension2)
    (type out_phrase1) (type out_phrase2)
    (type mapper1) (type mapper2)
    (*$*)
    ((module A) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s1;\n" s s) *)
     structure             : structure1;
     signature             : signature1;
     toplevel_phrase       : toplevel_phrase1;
     core_type             : core_type1;
     expression            : expression1;
     pattern               : pattern1;
     case                  : case1;
     type_declaration      : type_declaration1;
     type_extension        : type_extension1;
     extension_constructor : extension_constructor1;
     out_value             : out_value1;
     out_type              : out_type1;
     out_class_type        : out_class_type1;
     out_module_type       : out_module_type1;
     out_sig_item          : out_sig_item1;
     out_type_extension    : out_type_extension1;
     out_phrase            : out_phrase1;
     mapper                : mapper1;
     (*$*)
     > ocaml_version)
    ((module B) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s2;\n" s s) *)
     structure             : structure2;
     signature             : signature2;
     toplevel_phrase       : toplevel_phrase2;
     core_type             : core_type2;
     expression            : expression2;
     pattern               : pattern2;
     case                  : case2;
     type_declaration      : type_declaration2;
     type_extension        : type_extension2;
     extension_constructor : extension_constructor2;
     out_value             : out_value2;
     out_type              : out_type2;
     out_class_type        : out_class_type2;
     out_module_type       : out_module_type2;
     out_sig_item          : out_sig_item2;
     out_type_extension    : out_type_extension2;
     out_phrase            : out_phrase2;
     mapper                : mapper2;
     (*$*)
     > ocaml_version)
  : (A.types, B.types) type_comparison
  =
  match A.Version with
  | B.Version -> Eq
  | _ when A.version < B.version -> Lt
  | _ when A.version > B.version -> Gt
  | _ -> assert false

type ('from, 'to_) migration_functions = {
  (*$ foreach_type (fun _ s ->
        printf "copy_%s: 'from get_%s -> 'to_ get_%s;\n" s s s) *)
  copy_structure: 'from get_structure -> 'to_ get_structure;
  copy_signature: 'from get_signature -> 'to_ get_signature;
  copy_toplevel_phrase: 'from get_toplevel_phrase -> 'to_ get_toplevel_phrase;
  copy_core_type: 'from get_core_type -> 'to_ get_core_type;
  copy_expression: 'from get_expression -> 'to_ get_expression;
  copy_pattern: 'from get_pattern -> 'to_ get_pattern;
  copy_case: 'from get_case -> 'to_ get_case;
  copy_type_declaration: 'from get_type_declaration -> 'to_ get_type_declaration;
  copy_type_extension: 'from get_type_extension -> 'to_ get_type_extension;
  copy_extension_constructor: 'from get_extension_constructor -> 'to_ get_extension_constructor;
  copy_out_value: 'from get_out_value -> 'to_ get_out_value;
  copy_out_type: 'from get_out_type -> 'to_ get_out_type;
  copy_out_class_type: 'from get_out_class_type -> 'to_ get_out_class_type;
  copy_out_module_type: 'from get_out_module_type -> 'to_ get_out_module_type;
  copy_out_sig_item: 'from get_out_sig_item -> 'to_ get_out_sig_item;
  copy_out_type_extension: 'from get_out_type_extension -> 'to_ get_out_type_extension;
  copy_out_phrase: 'from get_out_phrase -> 'to_ get_out_phrase;
  copy_mapper: 'from get_mapper -> 'to_ get_mapper;
  (*$*)
}

let id x = x
let migration_identity : ('a, 'a) migration_functions = {
  (*$ foreach_type (fun _ s -> printf "copy_%s = id;\n" s) *)
  copy_structure = id;
  copy_signature = id;
  copy_toplevel_phrase = id;
  copy_core_type = id;
  copy_expression = id;
  copy_pattern = id;
  copy_case = id;
  copy_type_declaration = id;
  copy_type_extension = id;
  copy_extension_constructor = id;
  copy_out_value = id;
  copy_out_type = id;
  copy_out_class_type = id;
  copy_out_module_type = id;
  copy_out_sig_item = id;
  copy_out_type_extension = id;
  copy_out_phrase = id;
  copy_mapper = id;
  (*$*)
}

let compose f g x = f (g x)
let migration_compose (ab : ('a, 'b) migration_functions) (bc : ('b, 'c) migration_functions) : ('a, 'c) migration_functions = {
  (*$ foreach_type (fun _ s ->
        printf "copy_%-21s = compose bc.copy_%-21s ab.copy_%s;\n" s s s) *)
  copy_structure             = compose bc.copy_structure             ab.copy_structure;
  copy_signature             = compose bc.copy_signature             ab.copy_signature;
  copy_toplevel_phrase       = compose bc.copy_toplevel_phrase       ab.copy_toplevel_phrase;
  copy_core_type             = compose bc.copy_core_type             ab.copy_core_type;
  copy_expression            = compose bc.copy_expression            ab.copy_expression;
  copy_pattern               = compose bc.copy_pattern               ab.copy_pattern;
  copy_case                  = compose bc.copy_case                  ab.copy_case;
  copy_type_declaration      = compose bc.copy_type_declaration      ab.copy_type_declaration;
  copy_type_extension        = compose bc.copy_type_extension        ab.copy_type_extension;
  copy_extension_constructor = compose bc.copy_extension_constructor ab.copy_extension_constructor;
  copy_out_value             = compose bc.copy_out_value             ab.copy_out_value;
  copy_out_type              = compose bc.copy_out_type              ab.copy_out_type;
  copy_out_class_type        = compose bc.copy_out_class_type        ab.copy_out_class_type;
  copy_out_module_type       = compose bc.copy_out_module_type       ab.copy_out_module_type;
  copy_out_sig_item          = compose bc.copy_out_sig_item          ab.copy_out_sig_item;
  copy_out_type_extension    = compose bc.copy_out_type_extension    ab.copy_out_type_extension;
  copy_out_phrase            = compose bc.copy_out_phrase            ab.copy_out_phrase;
  copy_mapper                = compose bc.copy_mapper                ab.copy_mapper;
  (*$*)
}

type _ migration += Migration : 'from ocaml_version * ('from, 'to_) migration_functions * 'to_ ocaml_version -> 'from migration

module type Migrate_module = sig
  module From : Ast
  module To : Ast
  (*$ foreach_type (fun m s ->
        printf "val copy_%-21s: From.%s.%s -> To.%s.%s\n" s m s m s) *)
  val copy_structure            : From.Parsetree.structure -> To.Parsetree.structure
  val copy_signature            : From.Parsetree.signature -> To.Parsetree.signature
  val copy_toplevel_phrase      : From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase
  val copy_core_type            : From.Parsetree.core_type -> To.Parsetree.core_type
  val copy_expression           : From.Parsetree.expression -> To.Parsetree.expression
  val copy_pattern              : From.Parsetree.pattern -> To.Parsetree.pattern
  val copy_case                 : From.Parsetree.case -> To.Parsetree.case
  val copy_type_declaration     : From.Parsetree.type_declaration -> To.Parsetree.type_declaration
  val copy_type_extension       : From.Parsetree.type_extension -> To.Parsetree.type_extension
  val copy_extension_constructor: From.Parsetree.extension_constructor -> To.Parsetree.extension_constructor
  val copy_out_value            : From.Outcometree.out_value -> To.Outcometree.out_value
  val copy_out_type             : From.Outcometree.out_type -> To.Outcometree.out_type
  val copy_out_class_type       : From.Outcometree.out_class_type -> To.Outcometree.out_class_type
  val copy_out_module_type      : From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  val copy_out_sig_item         : From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item
  val copy_out_type_extension   : From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension
  val copy_out_phrase           : From.Outcometree.out_phrase -> To.Outcometree.out_phrase
  val copy_mapper               : From.Ast_mapper.mapper -> To.Ast_mapper.mapper
  (*$*)
end

module Migration_functions
    (A : OCaml_version) (B : OCaml_version)
    (A_to_B : Migrate_module with module From = A.Ast and module To = B.Ast)
=
struct
  let migration_functions : (A.types, B.types) migration_functions =
    let open A_to_B in
    {
      (*$ foreach_type (fun _ s -> printf "copy_%s;\n" s) *)
      copy_structure;
      copy_signature;
      copy_toplevel_phrase;
      copy_core_type;
      copy_expression;
      copy_pattern;
      copy_case;
      copy_type_declaration;
      copy_type_extension;
      copy_extension_constructor;
      copy_out_value;
      copy_out_type;
      copy_out_class_type;
      copy_out_module_type;
      copy_out_sig_item;
      copy_out_type_extension;
      copy_out_phrase;
      copy_mapper;
      (*$*)
    }
end

module Register_migration (A : OCaml_version) (B : OCaml_version)
    (A_to_B : Migrate_module with module From = A.Ast and module To = B.Ast)
    (B_to_A : Migrate_module with module From = B.Ast and module To = A.Ast)
=
struct
  let () = (
    let is_undefined : type a. a migration -> bool = function
      | Undefined -> true
      | _ -> false
    in
    assert (A.version < B.version);
    assert (is_undefined A.migration_info.next_version);
    assert (is_undefined B.migration_info.previous_version);
    let module A_to_B_fun = Migration_functions(A)(B)(A_to_B) in
    let module B_to_A_fun = Migration_functions(B)(A)(B_to_A) in
    A.migration_info.next_version <-
      Migration ((module A), A_to_B_fun.migration_functions, (module B));
    B.migration_info.previous_version <-
      Migration ((module B), B_to_A_fun.migration_functions, (module A));
  )
end

type 'from immediate_migration =
  | No_migration : 'from immediate_migration
  | Immediate_migration
    :  ('from, 'to_) migration_functions * 'to_ ocaml_version
    -> 'from immediate_migration

let immediate_migration
    (*$ foreach_type (fun _ s -> printf "(type %s)\n" s) *)
    (type structure)
    (type signature)
    (type toplevel_phrase)
    (type core_type)
    (type expression)
    (type pattern)
    (type case)
    (type type_declaration)
    (type type_extension)
    (type extension_constructor)
    (type out_value)
    (type out_type)
    (type out_class_type)
    (type out_module_type)
    (type out_sig_item)
    (type out_type_extension)
    (type out_phrase)
    (type mapper)
    (*$*)
    ((module A) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s;\n" s s) *)
     structure             : structure;
     signature             : signature;
     toplevel_phrase       : toplevel_phrase;
     core_type             : core_type;
     expression            : expression;
     pattern               : pattern;
     case                  : case;
     type_declaration      : type_declaration;
     type_extension        : type_extension;
     extension_constructor : extension_constructor;
     out_value             : out_value;
     out_type              : out_type;
     out_class_type        : out_class_type;
     out_module_type       : out_module_type;
     out_sig_item          : out_sig_item;
     out_type_extension    : out_type_extension;
     out_phrase            : out_phrase;
     mapper                : mapper;
     (*$*)
     > ocaml_version)
    direction
  =
  let version = match direction with
    | `Next -> A.migration_info.next_version
    | `Previous -> A.migration_info.previous_version
  in
  match version with
  | Undefined -> No_migration
  | Migration (_, funs, to_) -> Immediate_migration (funs, to_)
  | _ -> assert false

let migrate
    (*$ foreach_type (fun _ s -> printf "(type %s1) (type %s2)\n" s s) *)
    (type structure1) (type structure2)
    (type signature1) (type signature2)
    (type toplevel_phrase1) (type toplevel_phrase2)
    (type core_type1) (type core_type2)
    (type expression1) (type expression2)
    (type pattern1) (type pattern2)
    (type case1) (type case2)
    (type type_declaration1) (type type_declaration2)
    (type type_extension1) (type type_extension2)
    (type extension_constructor1) (type extension_constructor2)
    (type out_value1) (type out_value2)
    (type out_type1) (type out_type2)
    (type out_class_type1) (type out_class_type2)
    (type out_module_type1) (type out_module_type2)
    (type out_sig_item1) (type out_sig_item2)
    (type out_type_extension1) (type out_type_extension2)
    (type out_phrase1) (type out_phrase2)
    (type mapper1) (type mapper2)
    (*$*)
    ((module A) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s1;\n" s s) *)
     structure             : structure1;
     signature             : signature1;
     toplevel_phrase       : toplevel_phrase1;
     core_type             : core_type1;
     expression            : expression1;
     pattern               : pattern1;
     case                  : case1;
     type_declaration      : type_declaration1;
     type_extension        : type_extension1;
     extension_constructor : extension_constructor1;
     out_value             : out_value1;
     out_type              : out_type1;
     out_class_type        : out_class_type1;
     out_module_type       : out_module_type1;
     out_sig_item          : out_sig_item1;
     out_type_extension    : out_type_extension1;
     out_phrase            : out_phrase1;
     mapper                : mapper1;
     (*$*)
     > ocaml_version)
    ((module B) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s2;\n" s s) *)
     structure             : structure2;
     signature             : signature2;
     toplevel_phrase       : toplevel_phrase2;
     core_type             : core_type2;
     expression            : expression2;
     pattern               : pattern2;
     case                  : case2;
     type_declaration      : type_declaration2;
     type_extension        : type_extension2;
     extension_constructor : extension_constructor2;
     out_value             : out_value2;
     out_type              : out_type2;
     out_class_type        : out_class_type2;
     out_module_type       : out_module_type2;
     out_sig_item          : out_sig_item2;
     out_type_extension    : out_type_extension2;
     out_phrase            : out_phrase2;
     mapper                : mapper2;
     (*$*)
     > ocaml_version)
  : (A.types, B.types) migration_functions
  =
  match A.Version with
  | B.Version -> migration_identity
  | _ ->
    let direction = if A.version < B.version then `Next else `Previous in
    let rec migrate (m : A.types immediate_migration) : (A.types, B.types) migration_functions =
      match m with
      | No_migration -> assert false
      | Immediate_migration (f, (module To)) ->
        match To.Version with
        | B.Version -> f
        | _ ->
          match immediate_migration (module To) direction with
          | No_migration -> assert false
          | Immediate_migration (g, to2) ->
            migrate (Immediate_migration (migration_compose f g, to2))
    in
    migrate (immediate_migration (module A) direction)

module Convert (A : OCaml_version) (B : OCaml_version) = struct
  let {
    (*$ foreach_type (fun _ s -> printf "copy_%s;\n" s) *)
    copy_structure;
    copy_signature;
    copy_toplevel_phrase;
    copy_core_type;
    copy_expression;
    copy_pattern;
    copy_case;
    copy_type_declaration;
    copy_type_extension;
    copy_extension_constructor;
    copy_out_value;
    copy_out_type;
    copy_out_class_type;
    copy_out_module_type;
    copy_out_sig_item;
    copy_out_type_extension;
    copy_out_phrase;
    copy_mapper;
    (*$*)
  } : (A.types, B.types) migration_functions =
    migrate (module A) (module B)
end

(*$ foreach_version (fun suffix version ->
      printf "module OCaml_%s = struct\n" suffix;
      printf "  module Ast = Ast_%s\n" suffix;
      printf "  include Make_witness(Ast_%s)\n" suffix;
      printf "  let version = %s\n" suffix;
      printf "  let string_version = %S\n" version;
      printf "end\n";
      printf "let ocaml_%s : OCaml_%s.types ocaml_version = (module OCaml_%s)\n"
        suffix suffix suffix;
    )
*)
module OCaml_402 = struct
  module Ast = Ast_402
  include Make_witness(Ast_402)
  let version = 402
  let string_version = "4.02"
end
let ocaml_402 : OCaml_402.types ocaml_version = (module OCaml_402)
module OCaml_403 = struct
  module Ast = Ast_403
  include Make_witness(Ast_403)
  let version = 403
  let string_version = "4.03"
end
let ocaml_403 : OCaml_403.types ocaml_version = (module OCaml_403)
module OCaml_404 = struct
  module Ast = Ast_404
  include Make_witness(Ast_404)
  let version = 404
  let string_version = "4.04"
end
let ocaml_404 : OCaml_404.types ocaml_version = (module OCaml_404)
module OCaml_405 = struct
  module Ast = Ast_405
  include Make_witness(Ast_405)
  let version = 405
  let string_version = "4.05"
end
let ocaml_405 : OCaml_405.types ocaml_version = (module OCaml_405)
(*$*)

let all_versions : (module OCaml_version) list = [
  (*$foreach_version (fun suffix _ ->
       printf "(module OCaml_%s : OCaml_version);\n" suffix)*)
  (module OCaml_402 : OCaml_version);
  (module OCaml_403 : OCaml_version);
  (module OCaml_404 : OCaml_version);
  (module OCaml_405 : OCaml_version);
  (*$*)
]

(*$foreach_version_pair (fun a b ->
   printf "include Register_migration(OCaml_%s)(OCaml_%s)\n" a b;
   printf "  (Migrate_parsetree_%s_%s)(Migrate_parsetree_%s_%s)\n" a b b a
  )
*)
include Register_migration(OCaml_402)(OCaml_403)
    (Migrate_parsetree_402_403)(Migrate_parsetree_403_402)
include Register_migration(OCaml_403)(OCaml_404)
    (Migrate_parsetree_403_404)(Migrate_parsetree_404_403)
include Register_migration(OCaml_404)(OCaml_405)
    (Migrate_parsetree_404_405)(Migrate_parsetree_405_404)
(*$*)

module OCaml_current = OCaml_402          
let ocaml_current : OCaml_current.types ocaml_version = (module OCaml_current)

(* Make sure the preprocessing worked as expected *)
let _f (x : Parsetree.expression) : OCaml_current.Ast.Parsetree.expression = x

end
module Migrate_parsetree_ast_io : sig 
#1 "migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** A marshalled ast packs the ast with the corresponding version of the
    frontend *)
type ast =
  | Impl : (module Migrate_parsetree_versions.OCaml_version with
             type Ast.Parsetree.structure = 'concrete) * 'concrete -> ast
  | Intf : (module Migrate_parsetree_versions.OCaml_version with
             type Ast.Parsetree.signature = 'concrete) * 'concrete -> ast

(** A simple alias used for the filename of the source that produced an AST *)
type filename = string

type read_error =
  | Not_a_binary_ast of string
  (** The input doesn't contain a binary AST. The argument corresponds
      to the bytes from the input that were consumed. *)
  | Unknown_version of string
  (** The input contains a binary AST for an unknown version of OCaml.
      The argument is the unknown magic number. *)

(** Load a marshalled AST from a channel

    Any exception raised during unmarshalling (see [Marshal]) can escape.  *)
val from_channel : in_channel -> (filename * ast, read_error) result

(** Load a marshalled AST from a byte string.

    See [from_channel] description for exception that can be raised. *)
val from_bytes : bytes -> int -> (filename * ast, read_error) result

(** Marshal an AST to a channel *)
val to_channel : out_channel -> filename -> ast -> unit

(** Marshal an AST to a byte string *)
val to_bytes : filename -> ast -> bytes

end = struct
#1 "migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

type ast =
  | Impl : (module Migrate_parsetree_versions.OCaml_version with
             type Ast.Parsetree.structure = 'concrete) * 'concrete -> ast
  | Intf : (module Migrate_parsetree_versions.OCaml_version with
             type Ast.Parsetree.signature = 'concrete) * 'concrete -> ast

type filename = string

let magic_length = String.length Ast_402.Config.ast_impl_magic_number

let read_magic ic =
  let buf = Bytes.create magic_length in
  let len = input ic buf 0 magic_length in
  let s = Bytes.sub_string buf 0 len in
  if len = magic_length then
    Ok s
  else
    Error s

type read_error =
  | Not_a_binary_ast of string
  | Unknown_version of string

let find_magic magic =
  let rec loop = function
    | [] ->
        let prefix = String.sub magic 0 9 in
        if prefix = String.sub Ast_402.Config.ast_impl_magic_number 0 9 ||
           prefix = String.sub Ast_402.Config.ast_intf_magic_number 0 9 then
          Error (Unknown_version magic)
        else
          Error (Not_a_binary_ast magic)
    | (module Frontend : Migrate_parsetree_versions.OCaml_version) :: tail ->
        if Frontend.Ast.Config.ast_impl_magic_number = magic then
          Ok (fun x -> Impl ((module Frontend), Obj.obj x))
        else if Frontend.Ast.Config.ast_intf_magic_number = magic then
          Ok (fun x -> Intf ((module Frontend), Obj.obj x))
        else
          loop tail
  in
  loop Migrate_parsetree_versions.all_versions

let from_channel ic =
  match read_magic ic with
  | Error s -> Error (Not_a_binary_ast s)
  | Ok s ->
    match find_magic s with
    | Ok inj ->
      let filename : filename = input_value ic in
      let payload = inj (input_value ic) in
      Ok (filename, payload)
    | Error _ as e  -> e

let from_bytes bytes pos =
  if Bytes.length bytes - pos < magic_length then
    Error (Not_a_binary_ast "")
  else
    let magic = Bytes.to_string (Bytes.sub bytes pos magic_length) in
    match find_magic magic with
    | Ok inj ->
      let filename_pos = pos + magic_length in
      let filename : filename = Marshal.from_bytes bytes filename_pos in
      let payload_pos = filename_pos + Marshal.total_size bytes filename_pos in
      let payload = inj (Marshal.from_bytes bytes payload_pos) in
      Ok (filename, payload)
    | Error _ as e -> e

let decompose_ast = function
  | Impl ((module Frontend), tree) ->
      (Frontend.Ast.Config.ast_impl_magic_number, Obj.repr tree)
  | Intf ((module Frontend), tree) ->
      (Frontend.Ast.Config.ast_intf_magic_number, Obj.repr tree)

let to_channel oc (filename : filename) x =
  let magic_number, payload = decompose_ast x in
  output_string oc magic_number;
  output_value oc filename;
  output_value oc payload

let to_bytes (filename : filename) x =
  let magic_number, payload = decompose_ast x in
  Bytes.cat (
    Bytes.cat
      (Bytes.of_string magic_number)
      (Marshal.to_bytes filename [])
  ) (Marshal.to_bytes payload [])

end
module Migrate_parsetree_driver : sig 
#1 "migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
open Migrate_parsetree_versions

(** {1 State a rewriter can access} *)

type config = {
  tool_name       : string;
  include_dirs    : string list;
  load_path       : string list;
  debug           : bool;
  for_package     : string option;
}

type cookies

val get_cookie
  : cookies
  -> string
  -> 'types ocaml_version -> 'types get_expression option

val set_cookie
  : cookies
  -> string
  -> 'types ocaml_version -> 'types get_expression
  -> unit

(** {1 Registering rewriters} *)

type 'types rewriter = config -> cookies -> 'types get_mapper

val register
  :  name:string
  -> ?reset_args:(unit -> unit) -> ?args:(Arg.key * Arg.spec * Arg.doc) list
  -> 'types ocaml_version -> 'types rewriter
  -> unit

(** {1 Running registered rewriters} *)

val run_as_ast_mapper : string list -> Ast_mapper.mapper

val run_as_ppx_rewriter : unit -> 'a

val run_main : unit -> 'a

end = struct
#1 "migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
open Migrate_parsetree_versions
module Ast_io = Migrate_parsetree_ast_io

(** {1 State a rewriter can access} *)

type config = {
  tool_name: string;
  include_dirs : string list;
  load_path : string list;
  debug : bool;
  for_package : string option;
}

type cookie = Cookie : 'types ocaml_version * 'types get_expression -> cookie

type cookies = (string, cookie) Hashtbl.t

let get_cookie table name version =
  match
    match Hashtbl.find table name with
    | result -> Some result
    | exception Not_found ->
        match Ast_mapper.get_cookie name with
        | None -> None
        | Some expr -> Some (Cookie ((module OCaml_current), expr))
  with
  | None -> None
  | Some (Cookie (version', expr)) ->
    Some ((migrate version' version).copy_expression expr)

let set_cookie table name version expr =
  Hashtbl.replace table name (Cookie (version, expr))

let apply_cookies table =
  Hashtbl.iter (fun name (Cookie (version, expr)) ->
      Ast_mapper.set_cookie name
        ((migrate version (module OCaml_current)).copy_expression expr)
    ) table

let initial_state () : config * cookies =
  {
    tool_name = Ast_mapper.tool_name ();
    include_dirs = !Clflags.include_dirs;
    load_path = !Config.load_path;
    debug = !Clflags.debug;
    for_package = !Clflags.for_package
  }, Hashtbl.create 3

(** {1 Registering rewriters} *)

type 'types rewriter = config -> cookies -> 'types get_mapper

type rewriter_group =
    Rewriters : 'types ocaml_version * (string * 'types rewriter) list -> rewriter_group

let uniq_rewriter = Hashtbl.create 7
let registered_rewriters = ref []

let uniq_arg = Hashtbl.create 7
let registered_args_reset = ref []
let registered_args = ref []

type ('types, 'version, 'rewriter) is_rewriter =
  | Is_rewriter : ('types, 'types ocaml_version, 'types rewriter) is_rewriter

let add_rewriter
    (type types) (type version) (type rewriter)
    (Is_rewriter : (types, version, rewriter) is_rewriter)
    (version : version) name (rewriter : rewriter) =
  let rec add_rewriter = function
  | [] -> [Rewriters (version, [name, rewriter])]
  | (Rewriters (version', rewriters) as x) :: xs ->
      match compare_ocaml_version version version' with
      | Eq -> Rewriters (version', (name, rewriter) :: rewriters) :: xs
      | Lt -> Rewriters (version, [name, rewriter]) :: x :: xs
      | Gt -> x :: add_rewriter xs
  in
  add_rewriter

let register ~name ?reset_args ?(args=[]) version rewriter =
  (* Validate name *)
  if name = "" then
    invalid_arg "Migrate_parsetree_driver.register: name is empty";
  if Hashtbl.mem uniq_rewriter name then
    invalid_arg ("Migrate_parsetree_driver.register: rewriter " ^ name ^ " has already been registered")
  else Hashtbl.add uniq_rewriter name ();
  (* Validate arguments *)
  List.iter (fun (arg_name, _, _) ->
      match Hashtbl.find uniq_arg arg_name with
      | other_rewriter ->
          invalid_arg (Printf.sprintf
                         "Migrate_parsetree_driver.register: argument %s is used by %s and %s" arg_name name other_rewriter)
      | exception Not_found ->
          Hashtbl.add uniq_arg arg_name name
    ) args;
  (* Register *)
  begin match reset_args with
  | None -> ()
  | Some f -> registered_args_reset := f :: !registered_args_reset
  end;
  registered_args := List.rev_append args !registered_args;
  registered_rewriters :=
    add_rewriter Is_rewriter version name rewriter !registered_rewriters

(** {1 Accessing or running registered rewriters} *)

type ('types, 'version, 'tree) is_signature =
    Signature : ('types, 'types ocaml_version, 'types get_signature) is_signature

type ('types, 'version, 'tree) is_structure =
    Structure : ('types, 'types ocaml_version, 'types get_structure) is_structure

let rec rewrite_signature
  : type types version tree.
    config -> cookies ->
    (types, version, tree) is_signature -> version -> tree ->
    rewriter_group list -> Parsetree.signature
  = fun (type types) (type version) (type tree)
    config cookies
    (Signature : (types, version, tree) is_signature)
    (version : version)
    (tree : tree)
    -> function
      | [] -> (migrate version (module OCaml_current)).copy_signature tree
      | Rewriters (version', rewriters) :: rest ->
          let rewrite (_name, rewriter) tree =
            let (module Version) = version' in
            Version.Ast.map_signature (rewriter config cookies) tree
          in
          let tree = (migrate version version').copy_signature tree in
          let tree = List.fold_right rewrite rewriters tree in
          rewrite_signature config cookies Signature version' tree rest

let rec rewrite_structure
  : type types version tree.
    config -> cookies ->
    (types, version, tree) is_structure -> version -> tree ->
    rewriter_group list -> Parsetree.structure
  = fun (type types) (type version) (type tree)
    config cookies
    (Structure : (types, version, tree) is_structure)
    (version : version)
    (tree : tree)
    -> function
      | [] -> (migrate version (module OCaml_current)).copy_structure tree
      | Rewriters (version', rewriters) :: rest ->
          let rewriter (_name, rewriter) tree =
            let (module Version) = version' in
            Version.Ast.map_structure (rewriter config cookies) tree
          in
          let tree = (migrate version version').copy_structure tree in
          let tree = List.fold_right rewriter rewriters tree in
          rewrite_structure config cookies Structure version' tree rest

let run_as_ast_mapper args =
  let spec = List.rev !registered_args in
  let args, usage =
    let me = Filename.basename Sys.executable_name in
    let args = match args with "--as-ppx" :: args -> args | args -> args in
    (Array.of_list (me :: args),
     Printf.sprintf "%s [options] <input ast file> <output ast file>" me)
  in
  match
    Arg.parse_argv args spec
      (fun arg -> raise (Arg.Bad (Printf.sprintf "invalid argument %S" arg)))
      usage
  with
  | exception (Arg.Help msg) ->
      prerr_endline msg;
      exit 1
  | () ->
      OCaml_current.Ast.make_top_mapper
        ~signature:(fun sg ->
            let config, cookies = initial_state () in
            let sg = rewrite_signature config cookies
                Signature (module OCaml_current) sg !registered_rewriters in
            apply_cookies cookies;
            sg
          )
        ~structure:(fun str ->
            let config, cookies = initial_state () in
            let str = rewrite_structure config cookies
                Structure (module OCaml_current) str !registered_rewriters in
            apply_cookies cookies;
            str
          )

let protectx x ~finally ~f =
  match f x with
  | y -> finally x; y
  | exception e -> finally x; raise e

let with_file_in fn ~f =
  protectx (open_in_bin fn) ~finally:close_in ~f

let with_file_out fn ~f =
  protectx (open_out_bin fn) ~finally:close_out ~f

type ('a, 'b) intf_or_impl =
  | Intf of 'a
  | Impl of 'b

let guess_file_kind fn =
  if Filename.check_suffix fn ".ml" then
    Impl fn
  else if Filename.check_suffix fn ".mli" then
    Intf fn
  else
    Location.raise_errorf ~loc:(Location.in_file fn)
      "I can't decide whether %s is an implementation or interface file"
      fn

let check_kind fn ~expected ~got =
  let describe = function
    | Intf _ -> "interface"
    | Impl _ -> "implementation"
  in
  match expected, got with
  | Impl _, Impl _
  | Intf _, Intf _ -> ()
  | _ ->
    Location.raise_errorf ~loc:(Location.in_file fn)
      "Expected an %s got an %s instead"
      (describe expected)
      (describe got)

let load_file file =
  let fn =
    match file with
    | Intf fn -> fn
    | Impl fn -> fn
  in
  with_file_in fn ~f:(fun ic ->
    match Ast_io.from_channel ic with
    | Ok (fn, Ast_io.Intf ((module V), sg)) ->
      check_kind fn ~expected:file ~got:(Intf ());
      (* We need to convert to the current version in order to interpret the cookies using
         [Ast_mapper.drop_ppx_context_*] from the compiler *)
      (fn, Intf ((migrate (module V) (module OCaml_current)).copy_signature sg))
    | Ok (fn, Ast_io.Impl ((module V), st)) ->
      check_kind fn ~expected:file ~got:(Impl ());
      (fn, Impl ((migrate (module V) (module OCaml_current)).copy_structure st))
    | Error (Ast_io.Unknown_version _) ->
      Location.raise_errorf ~loc:(Location.in_file fn)
        "File is a binary ast for an unknown version of OCaml"
    | Error (Ast_io.Not_a_binary_ast prefix_read_from_file) ->
      (* To test if a file is a binary AST file, we have to read the first few bytes of
         the file.

         If it is not a binary AST, we have to parse these bytes and the rest of the file
         as source code. To do that, we prefill the lexbuf buffer with what we read from
         the file to do the test. *)
      let lexbuf = Lexing.from_channel ic in
      let len = String.length prefix_read_from_file in
      String.blit prefix_read_from_file 0 lexbuf.Lexing.lex_buffer 0 len;
      lexbuf.Lexing.lex_buffer_len <- len;
      lexbuf.Lexing.lex_curr_p <-
        { Lexing.
          pos_fname = fn
        ; pos_lnum  = 1
        ; pos_bol   = 0
        ; pos_cnum  = 0
        };
      Location.input_name := fn;
      if Filename.check_suffix fn ".ml" then
        (fn, Impl (Parse.implementation lexbuf))
      else if Filename.check_suffix fn ".mli" then
        (fn, Intf (Parse.interface lexbuf))
      else
        (* TODO: add support for -intf and -impl *)
        Location.raise_errorf ~loc:(Location.in_file fn)
          "I can't decide whether %s is an implementation or interface file"
          fn)

let with_output output ~f =
  match output with
  | None -> f stdout
  | Some fn -> with_file_out fn ~f

let process_file ~config ~output ~dump_ast file =
  let cookies = Hashtbl.create 3 in
  let fn, ast = load_file file in
  let ast =
    match ast with
    | Intf sg ->
      let sg = Ast_mapper.drop_ppx_context_sig ~restore:true sg in
      let sg =
        rewrite_signature config cookies Signature
          (module OCaml_current) sg !registered_rewriters
      in
      apply_cookies cookies;
      Intf (sg, Ast_mapper.add_ppx_context_sig ~tool_name:config.tool_name sg)
    | Impl st ->
      let st = Ast_mapper.drop_ppx_context_str ~restore:true st in
      let st =
        rewrite_structure config cookies Structure
          (module OCaml_current) st !registered_rewriters
      in
      apply_cookies cookies;
      Impl (st, Ast_mapper.add_ppx_context_str ~tool_name:config.tool_name st)
  in
  with_output output ~f:(fun oc ->
    if dump_ast then begin
      let ast =
        match ast with
        | Intf (_, sg) -> Ast_io.Intf ((module OCaml_current), sg)
        | Impl (_, st) -> Ast_io.Impl ((module OCaml_current), st)
      in
      Ast_io.to_channel oc fn ast
    end else begin
      let ppf = Format.formatter_of_out_channel oc in
      (match ast with
       | Intf (sg, _) -> Pprintast.signature ppf sg
       | Impl (st, _) -> Pprintast.structure ppf st);
      Format.pp_print_newline ppf ()
    end)

let run_as_standalone_driver () =
  let output = ref None in
  let dump_ast = ref false in
  let files = ref [] in
  let set_cookie s =
    match String.index s '=' with
    | exception _ ->
      raise (Arg.Bad "invalid cookie, must be of the form \"<name>=<expr>\"")
    | i ->
      let name = String.sub s 0 i in
      let value = String.sub s (i + 1) (String.length s - i - 1) in
      let input_name = "<command-line>" in
      Location.input_name := input_name;
      let lexbuf = Lexing.from_string value in
      lexbuf.Lexing.lex_curr_p <-
        { Lexing.
          pos_fname = input_name
        ; pos_lnum  = 1
        ; pos_bol   = 0
        ; pos_cnum  = 0
        };
      let expr = Parse.expression lexbuf in
      Ast_mapper.set_cookie name expr
  in
  let spec =
    let as_ppx () =
      raise (Arg.Bad "--as-ppx must be passed as first argument")
    in
    [ "--as-ppx", Arg.Unit as_ppx,
      " Act as a -ppx rewriter"
    ; "--dump-ast", Arg.Set dump_ast,
      " Output a binary AST instead of source code"
    ; "-o", Arg.String (fun o -> output := Some o),
      "FILE Output to this file instead of the standard output"
    ; "--intf", Arg.String (fun fn -> files := Intf fn :: !files),
      "FILE Treat FILE as a .mli file"
    ; "--impl", Arg.String (fun fn -> files := Impl fn :: !files),
      "FILE Treat FILE as a .ml file"
    ; "--cookie", Arg.String set_cookie,
      "NAME=EXPR Set the cookie NAME to EXPR"
    ]
  in
  let spec = Arg.align (spec @ List.rev !registered_args) in
  let me = Filename.basename Sys.executable_name in
  let usage = Printf.sprintf "%s [options] [<files>]" me in
  try
    Arg.parse spec (fun anon -> files := guess_file_kind anon :: !files) usage;
    let output = !output in
    let dump_ast = !dump_ast in
    let config =
      (* TODO: we could add -I, -L and -g options to populate these fields. *)
      { tool_name    = "migrate_driver"
      ; include_dirs = []
      ; load_path    = []
      ; debug        = false
      ; for_package  = None
      }
    in
    List.iter (process_file ~config ~output ~dump_ast) (List.rev !files)
  with exn ->
    Location.report_exception Format.err_formatter exn;
    exit 1

let run_as_ppx_rewriter () =
  let a = Sys.argv in
  let n = Array.length a in
  if n <= 2 then begin
    let me = Filename.basename Sys.executable_name in
    Arg.usage (List.rev !registered_args)
      (Printf.sprintf "%s [options] <input ast file> <output ast file>" me);
    exit 2
  end;
  match
    Ast_mapper.apply ~source:a.(n - 2) ~target:a.(n - 1)
      (run_as_ast_mapper (Array.to_list (Array.sub a 1 (n - 3))))
  with
  | () -> exit 0
  | exception (Arg.Bad help) ->
      prerr_endline help;
      exit 1
  | exception exn ->
      Location.report_exception Format.err_formatter exn;
      exit 1

let run_main () =
  if Array.length Sys.argv >= 2 && Sys.argv.(1) = "--as-ppx" then
    run_as_ppx_rewriter ()
  else
    run_as_standalone_driver ();
  exit 0

end
module Migrate_parsetree
= struct
#1 "migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                   Jérémie Dimino, Jane Street Europe                   *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Shared definitions.
   Mostly errors about features missing in older versions. *)
module Def = Migrate_parsetree_def

(* Copy of OCaml parsetrees *)
module Ast_402 = Ast_402
module Ast_403 = Ast_403
module Ast_404 = Ast_404
module Ast_405 = Ast_405

(* A module for marshalling/unmarshalling arbitrary versions of Asts *)
module Ast_io = Migrate_parsetree_ast_io

(* Manual migration between versions *)
module Migrate_402_403 = Migrate_parsetree_402_403
module Migrate_403_402 = Migrate_parsetree_403_402
module Migrate_403_404 = Migrate_parsetree_403_404
module Migrate_404_403 = Migrate_parsetree_404_403
module Migrate_404_405 = Migrate_parsetree_404_405
module Migrate_405_404 = Migrate_parsetree_405_404

(* An abstraction of OCaml compiler versions *)
module Versions = Migrate_parsetree_versions

(* All versions are compatible with this signature *)
module type OCaml_version = Versions.OCaml_version

module OCaml_402 = Versions.OCaml_402
module OCaml_403 = Versions.OCaml_403
module OCaml_404 = Versions.OCaml_404
module OCaml_405 = Versions.OCaml_405
module OCaml_current = Versions.OCaml_current

(* A Functor taking two OCaml versions and producing a module of functions
   migrating from one to the other. *)
module Convert = Versions.Convert

(* Entrypoints for registering rewriters and making a ppx binary *)
module Driver = Migrate_parsetree_driver

(* Aliases for compiler-libs modules that might be shadowed *)
module Compiler_libs = struct
  module Location = Location
  module Longident = Longident

  module type Asttypes = module type of struct include Asttypes end
  module rec Asttypes : Asttypes = Asttypes

  module type Parsetree = module type of struct include Parsetree end
  module rec Parsetree : Parsetree = Parsetree

  module Docstrings = Docstrings
  module Ast_helper = Ast_helper
  module Ast_mapper = Ast_mapper
end

end
module Easy_format : sig 
#1 "easy_format.mli"
(**
   Easy_format: indentation made easy.
*)

(**
  This module provides a functional, simplified layer over
  the Format module of the standard library.

  Input data must be first modelled as a tree using 3 kinds of nodes:
  - atoms
  - lists
  - labelled nodes

  Atoms represent any text that is guaranteed to be printed as-is.
  Lists can model any sequence of items such as arrays of data
  or lists of definitions that are labelled with something
  like "int main", "let x =" or "x:".
*)

type wrap =
    [ `Wrap_atoms
    | `Always_wrap
    | `Never_wrap
    | `Force_breaks
    | `Force_breaks_rec
    | `No_breaks ]
(** List wrapping conditions:
    - [`Wrap_atoms]: wrap if the list contains only atoms
    - [`Always_wrap]: always wrap when needed
    - [`Never_wrap]: never wrap,
      i.e. the list is either horizontal or vertical
    - [`Force_breaks]: align vertically,
      i.e. always break line between list items and
      align the left edge of each item.
    - [`Force_breaks_rec]: same as [`Force_breaks] but turns
      any wrappable ancestor node's wrap property ([`Wrap_atoms]
      or [`Always_wrap]) into [`Force_breaks].
    - [`No_breaks]: align horizontally,
      i.e. never break line between list items
*)

type label_break = [
  | `Auto
  | `Always
  | `Always_rec
  | `Never
]
(** When to break the line after a [Label]:
    - [Auto]: break after the label if there's not enough room
    - [Always]: always break after the label
    - [Always_rec]: always break after the label and force breaks in all parent
      lists and labels, similarly to [`Force_breaks_rec] for lists.
    - [Never]: never break after the label
*)

type style_name = string

type style = {
  tag_open : string;
  tag_close : string
}
    (** Pair of opening and closing tags that are inserted around
	text after pretty-printing. *)

type atom_param = {
  atom_style : style_name option; (** Default: [None] *)
}

val atom : atom_param


(** List-formatting parameters.
    Always derive a new set of parameters from an existing record.
    See {!Easy_format.list}.
*)
type list_param = {
  space_after_opening : bool; (** Whether there must be some whitespace
				  after the opening string.
				  Default: [true] *)
  space_after_separator : bool; (** Whether there must be some whitespace
				    after the item separators.
				    Default: [true] *)
  space_before_separator : bool; (** Whether there must be some whitespace
				     before the item separators.
				     Default: [false] *)
  separators_stick_left : bool; (** Whether the separators must
				    stick to the item on the left.
				    Default: [true] *)
  space_before_closing : bool; (** Whether there must be some whitespace
				   before the closing string.
				   Default: [true] *)
  stick_to_label : bool; (** Whether the opening string should be fused
			     with the preceding label.
			     Default: [true] *)
  align_closing : bool; (** Whether the beginning of the
			    closing string must be aligned
			    with the beginning of the opening string
			    (stick_to_label = false) or
			    with the beginning of the label if any
			    (stick_to_label = true).
			    Default: [true] *)
  wrap_body : wrap; (** Defines under which conditions the list body
			may be wrapped, i.e. allow several lines
			and several list items per line.
			Default: [`Wrap_atoms] *)
  indent_body : int; (** Extra indentation of the list body.
			 Default: [2] *)

  list_style : style_name option; (** Default: [None] *)
  opening_style : style_name option; (** Default: [None] *)
  body_style : style_name option; (** Default: [None] *)
  separator_style : style_name option; (** Default: [None] *)
  closing_style : style_name option; (** Default: [None] *)
}

val list : list_param
  (** Default list-formatting parameters, using the default values
      described in the type definition above.

      In order to make code compatible with future versions of the library,
      the record inheritance syntax should be used, e.g.
      [ { list with align_closing = false } ].
      If new record fields are added, the program would still compile
      and work as before.
  *)

(** Label-formatting parameters.
    Always derive a new set of parameters from an existing record.
    See {!Easy_format.label}.
*)
type label_param = {
  label_break: label_break;
    (** Whether to break the line after the label.
        Introduced in version 1.2.0.
        Default: [`Auto] *)

  space_after_label : bool;
    (** Whether there must be some whitespace after the label.
	Default: [true] *)

  indent_after_label : int;
    (** Extra indentation before the item that comes after a label.
	Default: [2]
    *)

  label_style : style_name option;
    (** Default: [None] *)
}

val label : label_param
  (** Default label-formatting parameters, using the default values
      described in the type definition above.

      In order to make code compatible with future versions of the library,
      the record inheritance syntax should be used, e.g.
      [ { label with indent_after_label = 0 } ].
      If new record fields are added, the program would still compile
      and work as before.
 *)



type t =
    Atom of string * atom_param (** Plain string normally
				    without line breaks. *)

  | List of
      (
	string    (* opening *)
	* string  (* separator *)
	* string  (* closing *)
	* list_param
      )
      * t list
	(** [List ((opening, separator, closing, param), nodes)] *)

  | Label of (t * label_param) * t
      (** [Label ((label, param), node)]: labelled node. *)

  | Custom of (Format.formatter -> unit)
      (** User-defined printing function that allows to use the
	  Format module directly if necessary. It is responsible
	  for leaving the formatter in a clean state. *)
(** The type of the tree to be pretty-printed. Each node contains
    its own formatting parameters.

    Detail of a list node
    [List ((opening, separator, closing, param), nodes)]:

    - [opening]: opening string such as ["\{"] ["\["] ["("] ["begin"] [""] etc.
    - [separator]: node separator such as [";"] [","] [""] ["+"] ["|"] etc.
    - [closing]: closing string such as ["\}"] ["\]"] [")"] ["end"] [""] etc.
    - [nodes]: elements of the list.

*)

type escape =
    [ `None
    | `Escape of
	((string -> int -> int -> unit) -> string -> int -> int -> unit)
    | `Escape_string of (string -> string) ]

type styles = (style_name * style) list

(** The regular pretty-printing functions *)
module Pretty :
sig
  val define_styles : Format.formatter -> escape -> styles -> unit
  val to_formatter : Format.formatter -> t -> unit

  val to_buffer : ?escape:escape -> ?styles:styles -> Buffer.t -> t -> unit
  val to_string : ?escape:escape -> ?styles:styles -> t -> string
  val to_channel : ?escape:escape -> ?styles:styles -> out_channel -> t -> unit
  val to_stdout : ?escape:escape -> ?styles:styles -> t -> unit
  val to_stderr : ?escape:escape -> ?styles:styles -> t -> unit
end

(** No spacing or newlines other than those in the input data
    or those produced by [Custom] printing. *)
module Compact :
sig
  val to_buffer : Buffer.t -> t -> unit
  val to_string : t -> string
  val to_channel : out_channel -> t -> unit
  val to_stdout : t -> unit
  val to_stderr : t -> unit
  val to_formatter : Format.formatter -> t -> unit
 end


(**/**)

(** Deprecated. Predefined sets of parameters *)
module Param :
sig
  val list_true : list_param
    (** Deprecated. All boolean fields set to true. indent_body = 2. *)

  val label_true : label_param
    (** Deprecated. All boolean fields set to true. indent_after_label = 2. *)

  val list_false : list_param
    (** Deprecated. All boolean fields set to false. indent_body = 2. *)

  val label_false : label_param
    (** Deprecated. All boolean fields set to false. indent_after_label = 2. *)
end


end = struct
#1 "easy_format.ml"
open Format

type wrap = [
  | `Wrap_atoms
  | `Always_wrap
  | `Never_wrap
  | `Force_breaks
  | `Force_breaks_rec
  | `No_breaks
]

type label_break = [
  | `Auto
  | `Always
  | `Always_rec
  | `Never
]

type style_name = string
type style = {
  tag_open : string;
  tag_close : string
}

type atom_param = {
  atom_style : style_name option;
}

let atom = {
  atom_style = None
}

type list_param = {
  space_after_opening : bool;
  space_after_separator : bool;
  space_before_separator : bool;
  separators_stick_left : bool;
  space_before_closing : bool;
  stick_to_label : bool;
  align_closing : bool;
  wrap_body : wrap;
  indent_body : int;
  list_style : style_name option;
  opening_style : style_name option;
  body_style : style_name option;
  separator_style : style_name option;
  closing_style : style_name option;
}

let list = {
  space_after_opening = true;
  space_after_separator = true;
  space_before_separator = false;
  separators_stick_left = true;
  space_before_closing = true;
  stick_to_label = true;
  align_closing = true;
  wrap_body = `Wrap_atoms;
  indent_body = 2;
  list_style = None;
  opening_style = None;
  body_style = None;
  separator_style = None;
  closing_style = None;
}

type label_param = {
  label_break: label_break;
  space_after_label : bool;
  indent_after_label : int;
  label_style : style_name option;
}

let label = {
  label_break = `Auto;
  space_after_label = true;
  indent_after_label = 2;
  label_style = None;
}

type t =
    Atom of string * atom_param
  | List of (string * string * string * list_param) * t list
  | Label of (t * label_param) * t
  | Custom of (formatter -> unit)

type escape =
    [ `None
    | `Escape of
        ((string -> int -> int -> unit) -> string -> int -> int -> unit)
    | `Escape_string of (string -> string) ]

type styles = (style_name * style) list

(*
   Transform a tree starting from the leaves, propagating and merging
   accumulators until reaching the root.
*)
let propagate_from_leaf_to_root
  ~init_acc  (* create initial accumulator for a leaf *)
  ~merge_acc (* merge two accumulators coming from child nodes *)
  ~map_node  (* (node, acc) -> (node, acc) *)
  x =

  let rec aux x =
    match x with
    | Atom _ ->
        let acc = init_acc x in
        map_node x acc
    | List (param, children) ->
        let new_children, accs = List.split (List.map aux children) in
        let acc = List.fold_left merge_acc (init_acc x) accs in
        map_node (List (param, new_children)) acc
    | Label ((x1, param), x2) ->
        let acc0 = init_acc x in
        let new_x1, acc1 = aux x1 in
        let new_x2, acc2 = aux x2 in
        let acc = merge_acc (merge_acc acc0 acc1) acc2 in
        map_node (Label ((new_x1, param), new_x2)) acc
    | Custom _ ->
        let acc = init_acc x in
        map_node x acc
  in
  aux x

(*
   Convert wrappable lists into vertical lists if any of their descendants
   has the attribute wrap_body = `Force_breaks_rec.
*)
let propagate_forced_breaks x =
  (* acc = whether to force breaks in wrappable lists or labels *)
  let init_acc = function
    | List ((_, _, _, { wrap_body = `Force_breaks_rec }), _)
    | Label ((_, { label_break = `Always_rec }), _) -> true
    | Atom _
    | Label _
    | Custom _
    | List _ -> false
  in
  let merge_acc force_breaks1 force_breaks2 =
    force_breaks1 || force_breaks2
  in
  let map_node x force_breaks =
    match x with
    | List ((_, _, _, { wrap_body = `Force_breaks_rec }), _) -> x, true
    | List ((_, _, _, { wrap_body = `Force_breaks }), _) -> x, force_breaks

    | List ((op, sep, cl, ({ wrap_body = (`Wrap_atoms
                                         | `Never_wrap
                                         | `Always_wrap) } as p)),
            children) ->
        if force_breaks then
          let p = { p with wrap_body = `Force_breaks } in
          List ((op, sep, cl, p), children), true
        else
          x, false

    | Label ((a, ({ label_break = `Auto } as lp)), b) ->
        if force_breaks then
          let lp = { lp with label_break = `Always } in
          Label ((a, lp), b), true
        else
          x, false

    | List ((_, _, _, { wrap_body = `No_breaks }), _)
    | Label ((_, { label_break = (`Always | `Always_rec | `Never) }), _)
    | Atom _
    | Custom _ -> x, force_breaks
  in
  let new_x, forced_breaks =
    propagate_from_leaf_to_root
      ~init_acc
      ~merge_acc
      ~map_node
      x
  in
  new_x

module Pretty =
struct
  (*
     Rewrite the tree to be printed.
     Currently, this is used only to handle `Force_breaks_rec.
  *)
  let rewrite x = propagate_forced_breaks x

  (*
    Relies on the fact that mark_open_tag and mark_close_tag
    are called exactly once before calling pp_output_string once.
    It's a reasonable assumption although not guaranteed by the
    documentation of the Format module.
  *)
  let set_escape fmt escape =
    let print0, flush0 = pp_get_formatter_output_functions fmt () in
    let tagf0 = pp_get_formatter_tag_functions fmt () in

    let is_tag = ref false in

    let mot tag =
      is_tag := true;
      tagf0.mark_open_tag tag
    in

    let mct tag =
      is_tag := true;
      tagf0.mark_close_tag tag
    in

    let print s p n =
      if !is_tag then
        (print0 s p n;
         is_tag := false)
      else
        escape print0 s p n
    in

    let tagf = {
      tagf0 with
        mark_open_tag = mot;
        mark_close_tag = mct
    }
    in
    pp_set_formatter_output_functions fmt print flush0;
    pp_set_formatter_tag_functions fmt tagf


  let set_escape_string fmt esc =
    let escape print s p n =
      let s0 = String.sub s p n in
      let s1 = esc s0 in
      print s1 0 (String.length s1)
    in
    set_escape fmt escape


  let define_styles fmt escape l =
    if l <> [] then (
      pp_set_tags fmt true;
      let tbl1 = Hashtbl.create (2 * List.length l) in
      let tbl2 = Hashtbl.create (2 * List.length l) in
      List.iter (
        fun (style_name, style) ->
          Hashtbl.add tbl1 style_name style.tag_open;
          Hashtbl.add tbl2 style_name style.tag_close
      ) l;
      let mark_open_tag style_name =
        try Hashtbl.find tbl1 style_name
        with Not_found -> ""
      in
      let mark_close_tag style_name =
        try Hashtbl.find tbl2 style_name
        with Not_found -> ""
      in

      let tagf = {
        (pp_get_formatter_tag_functions fmt ()) with
          mark_open_tag = mark_open_tag;
          mark_close_tag = mark_close_tag
      }
      in
      pp_set_formatter_tag_functions fmt tagf
    );

    (match escape with
         `None -> ()
       | `Escape esc -> set_escape fmt esc
       | `Escape_string esc -> set_escape_string fmt esc)


  let pp_open_xbox fmt p indent =
    match p.wrap_body with
	`Always_wrap
      | `Never_wrap
      | `Wrap_atoms -> pp_open_hvbox fmt indent
      | `Force_breaks
      | `Force_breaks_rec -> pp_open_vbox fmt indent
      | `No_breaks -> pp_open_hbox fmt ()

  let extra_box p l =
    let wrap =
      match p.wrap_body with
          `Always_wrap -> true
        | `Never_wrap
        | `Force_breaks
        | `Force_breaks_rec
        | `No_breaks -> false
        | `Wrap_atoms ->
            List.for_all (function Atom _ -> true | _ -> false) l
    in
    if wrap then
      ((fun fmt -> pp_open_hovbox fmt 0),
       (fun fmt -> pp_close_box fmt ()))
    else
      ((fun fmt -> ()),
       (fun fmt -> ()))


  let pp_open_nonaligned_box fmt p indent l =
    match p.wrap_body with
        `Always_wrap -> pp_open_hovbox fmt indent
      | `Never_wrap -> pp_open_hvbox fmt indent
      | `Wrap_atoms ->
          if List.for_all (function Atom _ -> true | _ -> false) l then
            pp_open_hovbox fmt indent
          else
            pp_open_hvbox fmt indent
      | `Force_breaks
      | `Force_breaks_rec -> pp_open_vbox fmt indent
      | `No_breaks -> pp_open_hbox fmt ()


  let open_tag fmt = function
      None -> ()
    | Some s -> pp_open_tag fmt s

  let close_tag fmt = function
      None -> ()
    | Some _ -> pp_close_tag fmt ()

  let tag_string fmt o s =
    match o with
        None -> pp_print_string fmt s
      | Some tag ->
          pp_open_tag fmt tag;
          pp_print_string fmt s;
          pp_close_tag fmt ()

  let rec fprint_t fmt = function
      Atom (s, p) ->
        tag_string fmt p.atom_style s;

    | List ((_, _, _, p) as param, l) ->
        open_tag fmt p.list_style;
        if p.align_closing then
          fprint_list fmt None param l
        else
          fprint_list2 fmt param l;
        close_tag fmt p.list_style

    | Label (label, x) -> fprint_pair fmt label x
    | Custom f -> f fmt

  and fprint_list_body_stick_left fmt p sep hd tl =
    open_tag fmt p.body_style;
    fprint_t fmt hd;
    List.iter (
      fun x ->
        if p.space_before_separator then
          pp_print_string fmt " ";
        tag_string fmt p.separator_style sep;
        if p.space_after_separator then
          pp_print_space fmt ()
        else
          pp_print_cut fmt ();
        fprint_t fmt x
    ) tl;
    close_tag fmt p.body_style

  and fprint_list_body_stick_right fmt p sep hd tl =
    open_tag fmt p.body_style;
    fprint_t fmt hd;
    List.iter (
      fun x ->
        if p.space_before_separator then
          pp_print_space fmt ()
        else
          pp_print_cut fmt ();
        tag_string fmt p.separator_style sep;
        if p.space_after_separator then
          pp_print_string fmt " ";
        fprint_t fmt x
    ) tl;
    close_tag fmt p.body_style

  and fprint_opt_label fmt = function
      None -> ()
    | Some (lab, lp) ->
        open_tag fmt lp.label_style;
        fprint_t fmt lab;
        close_tag fmt lp.label_style;
        if lp.space_after_label then
          pp_print_string fmt " "

  (* Either horizontal or vertical list *)
  and fprint_list fmt label ((op, sep, cl, p) as param) = function
      [] ->
        fprint_opt_label fmt label;
        tag_string fmt p.opening_style op;
        if p.space_after_opening || p.space_before_closing then
          pp_print_string fmt " ";
        tag_string fmt p.closing_style cl

    | hd :: tl as l ->

        if tl = [] || p.separators_stick_left then
          fprint_list_stick_left fmt label param hd tl l
        else
          fprint_list_stick_right fmt label param hd tl l


  and fprint_list_stick_left fmt label (op, sep, cl, p) hd tl l =
    let indent = p.indent_body in
    pp_open_xbox fmt p indent;
    fprint_opt_label fmt label;

    tag_string fmt p.opening_style op;

    if p.space_after_opening then
      pp_print_space fmt ()
    else
      pp_print_cut fmt ();

    let open_extra, close_extra = extra_box p l in
    open_extra fmt;
    fprint_list_body_stick_left fmt p sep hd tl;
    close_extra fmt;

    if p.space_before_closing then
      pp_print_break fmt 1 (-indent)
    else
      pp_print_break fmt 0 (-indent);
    tag_string fmt p.closing_style cl;
    pp_close_box fmt ()

  and fprint_list_stick_right fmt label (op, sep, cl, p) hd tl l =
    let base_indent = p.indent_body in
    let sep_indent =
      String.length sep + (if p.space_after_separator then 1 else 0)
    in
    let indent = base_indent + sep_indent in

    pp_open_xbox fmt p indent;
    fprint_opt_label fmt label;

    tag_string fmt p.opening_style op;

    if p.space_after_opening then
      pp_print_space fmt ()
    else
      pp_print_cut fmt ();

    let open_extra, close_extra = extra_box p l in
    open_extra fmt;

    fprint_t fmt hd;
    List.iter (
      fun x ->
        if p.space_before_separator then
          pp_print_break fmt 1 (-sep_indent)
        else
          pp_print_break fmt 0 (-sep_indent);
        tag_string fmt p.separator_style sep;
        if p.space_after_separator then
          pp_print_string fmt " ";
        fprint_t fmt x
    ) tl;

    close_extra fmt;

    if p.space_before_closing then
      pp_print_break fmt 1 (-indent)
    else
      pp_print_break fmt 0 (-indent);
    tag_string fmt p.closing_style cl;
    pp_close_box fmt ()



  (* align_closing = false *)
  and fprint_list2 fmt (op, sep, cl, p) = function
      [] ->
        tag_string fmt p.opening_style op;
        if p.space_after_opening || p.space_before_closing then
          pp_print_string fmt " ";
        tag_string fmt p.closing_style cl

    | hd :: tl as l ->
        tag_string fmt p.opening_style op;
        if p.space_after_opening then
          pp_print_string fmt " ";

        pp_open_nonaligned_box fmt p 0 l ;
        if p.separators_stick_left then
          fprint_list_body_stick_left fmt p sep hd tl
        else
          fprint_list_body_stick_right fmt p sep hd tl;
        pp_close_box fmt ();

        if p.space_before_closing then
          pp_print_string fmt " ";
        tag_string fmt p.closing_style cl


  (* Printing a label:value pair.

     The opening bracket stays on the same line as the key, no matter what,
     and the closing bracket is either on the same line
     or vertically aligned with the beginning of the key.
  *)
  and fprint_pair fmt ((lab, lp) as label) x =
    match x with
        List ((op, sep, cl, p), l) when p.stick_to_label && p.align_closing ->
          fprint_list fmt (Some label) (op, sep, cl, p) l

      | _ ->
          let indent = lp.indent_after_label in
          pp_open_hvbox fmt 0;

          open_tag fmt lp.label_style;
          fprint_t fmt lab;
          close_tag fmt lp.label_style;

          (match lp.label_break with
           | `Auto ->
               if lp.space_after_label then
                 pp_print_break fmt 1 indent
               else
                 pp_print_break fmt 0 indent
           | `Always
           | `Always_rec ->
               pp_force_newline fmt ();
               pp_print_string fmt (String.make indent ' ')
           | `Never ->
               if lp.space_after_label then
                 pp_print_char fmt ' '
               else
                 ()
          );
          fprint_t fmt x;
          pp_close_box fmt ()

  let to_formatter fmt x =
    let x = rewrite x in
    fprint_t fmt x;
    pp_print_flush fmt ()

  let to_buffer ?(escape = `None) ?(styles = []) buf x =
    let fmt = Format.formatter_of_buffer buf in
    define_styles fmt escape styles;
    to_formatter fmt x

  let to_string ?escape ?styles x =
    let buf = Buffer.create 500 in
    to_buffer ?escape ?styles buf x;
    Buffer.contents buf

  let to_channel ?(escape = `None) ?(styles = []) oc x =
    let fmt = formatter_of_out_channel oc in
    define_styles fmt escape styles;
    to_formatter fmt x

  let to_stdout ?escape ?styles x = to_channel ?escape ?styles stdout x
  let to_stderr ?escape ?styles x = to_channel ?escape ?styles stderr x

end




module Compact =
struct
  open Printf

  let rec fprint_t buf = function
      Atom (s, _) -> Buffer.add_string buf s
    | List (param, l) -> fprint_list buf param l
    | Label (label, x) -> fprint_pair buf label x
    | Custom f ->
        (* Will most likely not be compact *)
        let fmt = formatter_of_buffer buf in
        f fmt;
        pp_print_flush fmt ()

  and fprint_list buf (op, sep, cl, _) = function
      [] -> bprintf buf "%s%s" op cl
    | x :: tl ->
        Buffer.add_string buf op;
        fprint_t buf x;
        List.iter (
          fun x ->
            Buffer.add_string buf sep;
            fprint_t buf x
        ) tl;
        Buffer.add_string buf cl

  and fprint_pair buf (label, _) x =
    fprint_t buf label;
    fprint_t buf x


  let to_buffer buf x = fprint_t buf x

  let to_string x =
    let buf = Buffer.create 500 in
    to_buffer buf x;
    Buffer.contents buf

  let to_formatter fmt x =
    let s = to_string x in
    Format.fprintf fmt "%s" s;
    pp_print_flush fmt ()

  let to_channel oc x =
    let buf = Buffer.create 500 in
    to_buffer buf x;
    Buffer.output_buffer oc buf

  let to_stdout x = to_channel stdout x
  let to_stderr x = to_channel stderr x
end




(* Obsolete *)
module Param =
struct
  let list_true = {
    space_after_opening = true;
    space_after_separator = true;
    space_before_separator = true;
    separators_stick_left = true;
    space_before_closing = true;
    stick_to_label = true;
    align_closing = true;
    wrap_body = `Wrap_atoms;
    indent_body = 2;
    list_style = None;
    opening_style = None;
    body_style = None;
    separator_style = None;
    closing_style = None;
  }

  let list_false = {
    space_after_opening = false;
    space_after_separator = false;
    space_before_separator = false;
    separators_stick_left = false;
    space_before_closing = false;
    stick_to_label = false;
    align_closing = false;
    wrap_body = `Wrap_atoms;
    indent_body = 2;
    list_style = None;
    opening_style = None;
    body_style = None;
    separator_style = None;
    closing_style = None;
  }

  let label_true = {
    label_break = `Auto;
    space_after_label = true;
    indent_after_label = 2;
    label_style = None;
  }

  let label_false = {
    label_break = `Auto;
    space_after_label = false;
    indent_after_label = 2;
    label_style = None;
  }
end

end
module Syntax_util
= struct
#1 "syntax_util.ml"
open Ast_404

open Asttypes
open Ast_mapper
open Parsetree
open Longident

(** [is_prefixed prefix i str] checks if prefix is the prefix of str
  * starting from position i
  *)
let is_prefixed prefix str i =
  let len = String.length prefix in
  if i + len > String.length str then false else
  let rec loop j =
    if j >= len then true else
      if String.unsafe_get prefix j <> String.unsafe_get str (i + j) then false else loop (j + 1)
    in
  loop 0

(**
 * pick_while returns a tuple where first element is longest prefix (possibly empty) of the list of elements that satisfy p
 * and second element is the remainder of the list
 *)
let rec pick_while p = function
  | [] -> [], []
  | hd::tl when p hd ->
                  let (satisfied, not_satisfied) = pick_while p tl in
                  hd :: satisfied, not_satisfied
  | l -> ([], l)


let rec replace_string_ old_str new_str i str buffer =
  if i >= String.length str then
    ()
  else
    (* found match *)
    if is_prefixed old_str str i then
      (* split string *)
      let old_str_len = String.length old_str in
      Buffer.add_string buffer new_str;
      replace_string_ old_str new_str (i + old_str_len) str buffer
    else
      let start = String.sub str i 1 in
      Buffer.add_string buffer start;
      replace_string_ old_str new_str (i + 1) str buffer


(** [replace_string old_str new_str str] replaces old_str to new_str in str *)
let replace_string old_str new_str str =
  let buffer = Buffer.create (String.length old_str * 2) in
  replace_string_ old_str new_str 0 str buffer;
  Buffer.contents buffer

(* This is lifted from https://github.com/bloomberg/bucklescript/blob/14d94bb9c7536b4c5f1208c8e8cc715ca002853d/jscomp/ext/ext_string.ml#L32
  Thanks @bobzhang and @hhugo! *)
let split_by ?(keep_empty=false) is_delim str =
  let len = String.length str in
  let rec loop acc last_pos pos =
    if pos = -1 then
      if last_pos = 0 && not keep_empty then
        (*
           {[ split " test_unsafe_obj_ffi_ppx.cmi" ~keep_empty:false ' ']}
        *)
        acc
      else
        String.sub str 0 last_pos :: acc
    else
      if is_delim str.[pos] then
        let new_len = (last_pos - pos - 1) in
        if new_len <> 0 || keep_empty then
          let v = String.sub str (pos + 1) new_len in
          loop ( v :: acc)
            pos (pos - 1)
        else loop acc pos (pos - 1)
    else loop acc last_pos (pos - 1)
  in
  loop [] len (len - 1)

let rec trim_right_idx str idx =
  if idx = -1 then 0
  else
    match String.get str idx with
    | '\t' | ' ' | '\n' | '\r' -> trim_right_idx str (idx - 1)
    | _ -> idx + 1

let trim_right str =
  let length = String.length str in
  if length = 0 then ""
  else
    let index = trim_right_idx str (length - 1) in
    if index = 0 then ""
    else if index = length then str
    else String.sub str 0 index

let strip_trailing_whitespace str =
  split_by ~keep_empty:true (fun x -> x = '\n') str
  |> List.map trim_right
  |> String.concat "\n"
  |> String.trim

module StringMap = Map.Make (String)


(** Generate a suitable extension node for Merlin's consumption,
    for the purposes of reporting a syntax error - only used
    in recovery mode.
 *)
let syntax_error_extension_node loc message =
  let str = Location.mkloc "merlin.syntax-error" loc in
  let payload = PStr [{
    pstr_loc = Location.none;
    pstr_desc =
      Pstr_eval (
        {
          pexp_loc = Location.none;
          pexp_desc = Pexp_constant (Parsetree.Pconst_string (message, None));
          pexp_attributes = [];
        },
        []
      );
  }]
 in
 (str, payload)

let reason_to_ml_swapping_alist = [
  "===",  "==";
  "==",  "=";
  (* ===\/ and !==\/ are not representable in OCaml but
   * representable in Reason
   *)
  "\\!==", "!==";
  "\\===", "===";
  "!=", "<>";
  "!==", "!=";
  "match", "switch";
  "method", "pub";
  "private", "pri";
]

let swap_txt map txt =
  if StringMap.mem txt map then
    StringMap.find txt map
  else
    txt

(** identifier_mapper maps all identifiers in an AST with a mapping function f
  *)
let identifier_mapper f =
{ default_mapper with
  expr = begin fun mapper expr ->
    let expr =
      match expr with
        | {pexp_desc=Pexp_ident ({txt} as id);
           pexp_loc;
           pexp_attributes} ->
             let swapped = match txt with
               | Lident s -> Lident (f s)
               | Ldot(longPrefix, s) -> Ldot(longPrefix, f s)
               | Lapply (y,s) -> Lapply (y, s)
             in
             {expr with pexp_desc=Pexp_ident ({id with txt=swapped})}
        | _ -> expr
    in
    default_mapper.expr mapper expr
  end;
  pat = begin fun mapper pat ->
    let pat =
      match pat with
        | {ppat_desc=Ppat_var ({txt} as id);
           ppat_loc;
           ppat_attributes} ->
             {pat with ppat_desc=Ppat_var ({id with txt=(f txt)})}
        | _ -> pat
    in
    default_mapper.pat mapper pat
  end;
}

let create_auto_printer_mapper =
  let attach_str_printer = function
    | { pstr_desc=Pstr_type (_,type_decls) } as ty ->
        let str_of_type = Ppx_deriving_show.str_of_type ~options:[] ~path:[] in
        let printer = List.concat (List.map str_of_type type_decls) in
        (ty, Some (Ast_helper.Str.value Recursive printer))
    | ty -> (ty, None)
  in
  let attach_sig_printer = function
    | { psig_desc=Psig_type (_,type_decls) } as ty ->
        let sig_of_type = Ppx_deriving_show.sig_of_type ~options:[] ~path:[] in
        let printer = List.concat (List.map sig_of_type type_decls) in
        (ty, Some printer)
    | ty -> (ty, None)
  in
  { default_mapper with structure = begin fun mapper decls ->
    let decls =
      let maybe_concat acc = function
        | (s, None) -> s::acc
        | (s, Some x) -> x::s::acc
      in
      List.rev (List.fold_left maybe_concat [] (List.map attach_str_printer decls))
    in
    default_mapper.structure mapper decls
  end;
  signature = begin fun mapper decls ->
    let decls =
      let maybe_concat acc = function
        | (s, None) -> s::acc
        | (s, Some x) -> x @ (s::acc)
      in
      List.rev (List.fold_left maybe_concat [] (List.map attach_sig_printer decls))
    in
    default_mapper.signature mapper decls
  end }

(** unescape_stars_slashes_mapper unescapes all stars and slases in an AST
  *)
let unescape_stars_slashes_mapper =
  let unescape_stars_slashes str =
    let len = String.length str in
    if len < 2 then
      str
    else
      let ending = String.sub str 1 (len - 1) in
    String.sub str 0 1 ^
      replace_string "\\*" "*"
        (replace_string ("\\/") "/" ending)
  in
  identifier_mapper unescape_stars_slashes

(** escape_stars_slashes_mapper escapes all stars and slases in an AST
  *)
let escape_stars_slashes_mapper =
  let escape_stars_slashes str =
    let len = String.length str in
    if len < 2 then
      str
    else
      let ending = String.sub str 1 (len -1) in
      String.sub str 0 1 ^
        replace_string "*" "\\*"
          (replace_string "/" "\\/" ending)
  in
  identifier_mapper escape_stars_slashes

(**
 * swap_operator_mapper is a mapper that swaps two operators at parse/print time.
 * We need this since we want to transform operator such as "=" in Ocaml to "==" in Reason.
 * In this case, in the parser, everytime we see a token "==" in Reason, we transform it into "=";
 * Similarly, in the printer, everytime we see a token "=", we transform it into "==";
 *)
let swap_operator_mapper map = identifier_mapper (swap_txt map)

let reason_to_ml_swap_map = List.fold_left
                              (fun map (op1, op2) -> (StringMap.add op1 op2 map))
                              StringMap.empty
                              reason_to_ml_swapping_alist

let ml_to_reason_swap_map = List.fold_left
                              (fun map (op1, op2) -> (StringMap.add op2 op1 map))
                              StringMap.empty
                              reason_to_ml_swapping_alist

(* To be used in parser, transform a token into an ast node with different identifier
 *)
let reason_to_ml_swap_operator_mapper = swap_operator_mapper reason_to_ml_swap_map

(* To be used in printer, transform an ast node into a token with different identifier
 *)
let ml_to_reason_swap_operator_mapper = swap_operator_mapper ml_to_reason_swap_map

(* attribute_equals tests an attribute is txt
 *)
let attribute_equals to_compare = function
  | ({txt; _}, _) -> txt = to_compare

(* attribute_exists tests if an attribute exists in a list
 *)
let attribute_exists txt attributes = List.exists (attribute_equals txt) attributes

(* conflicted_attributes tests if both attribute1 and attribute2
 * exist
 *)
let attributes_conflicted attribute1 attribute2 attributes =
  attribute_exists attribute1 attributes &&
  attribute_exists attribute2 attributes

(* normalized_attributes removes attribute from a list of attributes
 *)
let normalized_attributes attribute attributes =
  List.filter (fun x -> not (attribute_equals attribute x)) attributes

(*
 * apply_mapper_chain family applies an ast_mapper_chain to an ast,
 * ordering from left to right.
 *)
let apply_mapper_chain_to_structure =
  List.fold_left (fun s mapper -> mapper.structure mapper s )
let apply_mapper_chain_to_signature =
  List.fold_left (fun s mapper -> mapper.signature mapper s )
let apply_mapper_chain_to_type =
  List.fold_left (fun s mapper -> mapper.typ mapper s )
let apply_mapper_chain_to_expr =
  List.fold_left (fun s mapper -> mapper.expr mapper s )
let apply_mapper_chain_to_pattern =
  List.fold_left (fun s mapper -> mapper.pat mapper s )

let apply_mapper_chain_to_toplevel_phrase toplevel_phrase chain =
  match toplevel_phrase with
  | Ptop_def x -> Ptop_def (apply_mapper_chain_to_structure x chain)
  | x -> x

let apply_mapper_chain_to_use_file use_file chain =
  List.map (fun x -> apply_mapper_chain_to_toplevel_phrase x chain) use_file

(* The following logic defines our own Error object
 * and register it with ocaml so it knows how to print it
 *)

type error = Syntax_error of string

exception Error of Location.t * error

let report_error ppf (Syntax_error err) =
  Format.(fprintf ppf "%s" err)

let () =
  Location.register_error_of_exn
    (function
     | Error (loc, err) ->
        Some (Location.error_of_printer loc report_error err)
     | _ ->
        None
     )


type menhirMessagesError = {
  msg: string;
  loc: Location.t;
}

type menhirError =
  | NoMenhirMessagesError
  | MenhirMessagesError of menhirMessagesError

let menhirMessagesError = ref [NoMenhirMessagesError]

let findMenhirErrorMessage loc =
    let rec find messages =
      match messages with
      | MenhirMessagesError err :: tail when err.loc = loc -> MenhirMessagesError err
      | _ :: tail -> find tail
      | [] -> NoMenhirMessagesError
    in find !menhirMessagesError

let add_error_message err =
  let msg = if err.msg = "<SYNTAX ERROR>\n" then
    [MenhirMessagesError {err with msg = "A syntax error occurred. Help to improve this message: https://github.com/facebook/reason/wiki/Add-a-Menhir-error-message"}]
  else
    [MenhirMessagesError err]
  in
  menhirMessagesError := !menhirMessagesError @ msg;

end
module Reason_pprint_ast
= struct
#1 "reason_pprint_ast.ml"
(*
 *  Copyright (c) 2015-present, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 *  Forked from OCaml, which is provided under the license below:
 *
 *  Xavier Leroy, projet Cristal, INRIA Rocquencourt
 *
 *  Copyright © 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Inria
 *
 *  Permission is hereby granted, free of charge, to the Licensee obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense
 *  under any license of the Licensee's choice, and/or sell copies of the
 *  Software, subject to the following conditions:
 *
 *  1.	Redistributions of source code must retain the above copyright notice
 *  and the following disclaimer.
 *  2.	Redistributions in binary form must reproduce the above copyright
 *  notice, the following disclaimer in the documentation and/or other
 *  materials provided with the distribution.
 *  3.	All advertising materials mentioning features or use of the Software
 *  must display the following acknowledgement: This product includes all or
 *  parts of the Caml system developed by Inria and its contributors.
 *  4.	Other than specified in clause 3, neither the name of Inria nor the
 *  names of its contributors may be used to endorse or promote products
 *  derived from the Software without specific prior written permission.
 *
 *  Disclaimer
 *
 *  This software is provided by Inria and contributors “as is” and any express
 *  or implied warranties, including, but not limited to, the implied
 *  warranties of merchantability and fitness for a particular purpose are
 *  disclaimed. in no event shall Inria or its contributors be liable for any
 *  direct, indirect, incidental, special, exemplary, or consequential damages
 *  (including, but not limited to, procurement of substitute goods or
 *  services; loss of use, data, or profits; or business interruption) however
 *  caused and on any theory of liability, whether in contract, strict
 *  liability, or tort (including negligence or otherwise) arising in any way
 *  out of the use of this software, even if advised of the possibility of such
 *  damage.
 *
 *)

(* TODO more fine-grained precedence pretty-printing *)

open Ast_404
open Asttypes
open Format
open Location
open Lexing
open Longident
open Parsetree
open Easy_format
open Syntax_util
open Ast_mapper


type commentCategory =
  | EndOfLine
  | SingleLine
  | Regular

(* (comment text, attachment_location, physical location) *)
type commentWithCategory = (String.t * commentCategory * Location.t) list

let print_easy easyFormatted =
  match easyFormatted with
  | Atom (s,_) -> s
  | List (_,_) -> "list"
  | Label (_,_) -> "label"
  | Custom _ -> "custom"

let (|>) = fun x f -> f x
let (<|) = fun f x -> f x

exception NotPossible of string

let case_not_implemented msg loc (file, line, column) =
  Format.fprintf Format.err_formatter
    "Not Implemented Yet %s %a (from: %s:%s:%s)@."
    msg
    Location.print_loc loc
    file
    (string_of_int line)
    (string_of_int column)

let exprDescrString x =
  x.pexp_loc.loc_start.Lexing.pos_fname ^
    "[" ^
    (string_of_int x.pexp_loc.loc_start.Lexing.pos_lnum) ^
    ", " ^
    (string_of_int x.pexp_loc.loc_end.Lexing.pos_lnum) ^
    "]"

type ruleInfoData = {
  reducePrecedence: precedence;
  shiftPrecedence: precedence;
}

and ruleCategory =
  (* Printing will be parsed with very high precedence, so not much need to
     worry about ensuring it will reduce correctly. In short, you can put
     `FunctionApplication` content anywhere around an infix identifier without
     wrapping in parens. For example `myFunc x y z` or `if x {y} else {z}`
     The layout is kept in list form only to allow for elegant wrapping rules
     to take into consideration the *number* of high precedence parsed items. *)
  | FunctionApplication of layoutNode list
  (* Care should be taken to ensure the rule that caused it to be parsed will
     reduce again on the printed output - context should carefully consider
     wrapping in parens according to the ruleInfoData. *)
  | SpecificInfixPrecedence of ruleInfoData * layoutNode
  (* Not safe to include anywhere between infix operators without wrapping in
     parens. This describes expressions like `fun x => x` which doesn't fit into
     our simplistic algorithm for printing function applications separated by infix.

     It might be possible to include these in between infix, but there are
     tricky rules to determining when these must be guarded by parens (it
     depends highly on context that is hard to reason about). It's so nuanced
     that it's easier just to always wrap them in parens.  *)
  | PotentiallyLowPrecedence of layoutNode
  | Simple of layoutNode

and associativity =
  | Right
  | Nonassoc
  | Left

and precedenceEntryType =
  | TokenPrecedence
  | CustomPrecedence

and precedence =
  | Token of string
  | Custom of string

(* Make a standard list *)
and whenToDoSomething =
  | Never
  | IfNeed
  | Always
  (* Always_rec not only will break, it will break recursively up to the root *)
  | Always_rec

(* Describes the "fixity" of a token, and stores its *printed* representation
   should it be rendered as infix/prefix (This rendering may be different than
   how it is stored in the AST). *)
and tokenFixity =
  (* Such as !simple_expr and ~!simple_expr. These function applications are
     considered *almost* "simple" because they may be allowed anywhere a simple
     expression is accepted, except for when on the left hand side of a
     dot/send. *)
  | AlmostSimplePrefix of string
  | UnaryPlusPrefix of string
  | UnaryMinusPrefix of string
  | Infix of string
  | Normal

and easyFormatLabelFormatter = Easy_format.t -> Easy_format.t -> Easy_format.t
and listConfig = {
  (* Newlines above items that do not have any comments immediately above it.
     Only really useful when used with break:Always/Always_rec *)
  newlinesAboveItems: int;
  (* Newlines above regular comments *)
  newlinesAboveComments: int;
  (* Newlines above doc comments *)
  newlinesAboveDocComments: int;
  (* If you are only grouping something for the sake of visual appearance, and
   * not forming an actual conceptual sequence of items, then this is often
   * useful. For example, if you're appending a semicolon etc. *)
  interleaveComments: bool;
  (* Whether or not to render the final separator *)
  renderFinalSep: bool;
  break: whenToDoSomething;
  (* Break setting that becomes activated if a comment becomes interleaved into
   * this list. Typically, if not specified, the behavior from [break] will be
   * used.
   *)
  wrap: string * string;
  inline: bool * bool;
  sep: string;
  indent: int;
  sepLeft: bool;
  preSpace: bool;
  postSpace: bool;
  pad: bool * bool;
  (* A function, because the system might rearrange your previous settings, and
   * a function allows you to not be locked into some configuration that is made
   * out of date by the formatting system (suppose it removes the separator
   * token etc.) Having a function allows you to instruct our formatter how to
   * extend the "freshest" notion of the list config when comments are
   * interleaved. *)
  listConfigIfCommentsInterleaved: (listConfig -> listConfig) option;

  (* Formatting to use if an item in a list had an end-of-line comment appended *)
  listConfigIfEolCommentsInterleaved: (listConfig -> listConfig) option;
}

(**
 * These represent "intent to format" the AST, with some parts being annotated
 * with original source location. The benefit of tracking this in an
 * intermediate structure, is that we can then interleave comments throughout
 * the tree before generating the final representation. That prevents the
 * formatting code from having to thread comments everywhere.
 *
 * The final representation is rendered using Easy_format.
 *)
and layoutNode =
  | SourceMap of Location.t * layoutNode (* a layout with location info *)
  | WithEOLComment of string * layoutNode (* a layout with comment attached *)
  | Sequence of listConfig * (layoutNode list)
  | Label of easyFormatLabelFormatter * layoutNode * layoutNode
  | Easy of Easy_format.t

let print_comment_type = function
  | Regular -> "Regular"
  | EndOfLine -> "End of Line"
  | SingleLine -> "SingleLine"

let rec print_comments = function
  | [] -> ()
  | ((s, t, loc)::tl) ->
       printf "%d (%d:%d)-%d (%d:%d) -- %s:||%s||\n"
              loc.loc_start.Lexing.pos_cnum
              loc.loc_start.Lexing.pos_lnum
              (loc.loc_start.Lexing.pos_cnum - loc.loc_start.Lexing.pos_bol)
              loc.loc_end.Lexing.pos_cnum
              loc.loc_end.Lexing.pos_lnum
              (loc.loc_end.Lexing.pos_cnum - loc.loc_end.Lexing.pos_bol)
              (print_comment_type t)
              s;
       print_comments tl;
       ()

let rec print_easy_rec ?(indent=0) easyFormatted =
  let space = Array.fold_left (^) "" (Array.make indent " ") in
  match easyFormatted with
  | Atom (s,_) ->
     printf "%s Atom:'%s'\n" space s
  | List ((opening, sep, closing, config), items) ->
     let break = (match config.wrap_body with
                  | `No_breaks -> "No_breaks"
                  | `Wrap_atoms -> "Wrap_atoms"
                  | `Never_wrap -> "Never_wrap"
                  | `Force_breaks -> "Force_breaks"
                  | `Force_breaks_rec -> "Force_breaks_rec"
                  | `Always_wrap -> "Always_wrap") in
     printf "%s List: open %s close %s sep %s break %s \n" space opening closing sep break;
     let _ = List.map (print_easy_rec ~indent:(indent+2)) items in
     ()
  | Label ((left, config), right) ->
     let break = match config.label_break with
     | `Never -> "Never"
     | `Always_rec -> "Always_rec"
     | `Auto -> "Auto"
     | `Always -> "Always" in
     printf "%s Label (break = %s): \n" space break;
     printf "  %s left \n" space;
     print_easy_rec ~indent:(indent+2) left;
     printf "  %s right \n" space;
     print_easy_rec ~indent:(indent+2) right;
  | Custom _ -> printf "custom \n"

let rec print_layout ?(indent=0) layout =
  let space = Array.fold_left (^) "" (Array.make indent " ") in
  match layout with
  | SourceMap (loc, layout) ->
     printf "%s [%d (%d:%d)-%d (%d:%d)]\n" space
            loc.loc_start.Lexing.pos_cnum
            loc.loc_start.Lexing.pos_lnum
            (loc.loc_start.Lexing.pos_cnum - loc.loc_start.Lexing.pos_bol)
            loc.loc_end.Lexing.pos_cnum
            loc.loc_end.Lexing.pos_lnum
            (loc.loc_end.Lexing.pos_cnum - loc.loc_end.Lexing.pos_bol);
     print_layout ~indent:(indent+2) layout
  | Sequence (config, layout_list) ->
     let break = match config.break with
       | Never  -> "Never"
       | IfNeed  -> "if need"
       | Always  -> "Always"
       | Always_rec  -> "Always_rec" in
     printf "%s Sequence of %d, sep: %s, finalSep: %s stick_to_left: %s break: %s\n" space (List.length layout_list) config.sep (string_of_bool config.renderFinalSep) (string_of_bool config.sepLeft) break;
     let _ = List.map (print_layout ~indent:(indent+2)) layout_list in
     ()
  | WithEOLComment (comment, layout) ->
     printf "%s WithEOLComment: \n" space;
     printf "  %s node \n" space;
     print_layout ~indent:(indent+2) layout;
     printf "  %s comments : \n" space;
     printf "  %s %s\n" space comment;
     printf "\n";
  | Label (_, left, right) ->
     printf "%s Label: \n" space;
     printf "  %s left \n" space;
     print_layout ~indent:(indent+2) left;
     printf "  %s right \n" space;
     print_layout ~indent:(indent+2) right;
  | Easy e ->
     printf "%s Easy: %s \n" space (print_easy e)

let rec longIdentSame = function
  | (Lident l1, Lident l2) -> String.compare l1 l2 == 0
  | (Ldot (path1, l1), Ldot (path2, l2)) ->
    longIdentSame (path1, path2) && String.compare l1 l2 == 0
  | (Lapply (l11, l12), Lapply (l21, l22)) ->
    longIdentSame (l11, l21) && longIdentSame (l12, l22)
  | _ -> false

let rec trueForEachPair l1 l2 tester = match (l1, l2) with
  | ([], []) -> true
  | ([], _::_) -> false
  | (_::_, []) -> false
  | (hd1::tl1, hd2::tl2) -> (tester hd1 hd2 && trueForEachPair tl1 tl2 tester)

(*
   Checks to see if two types are the same modulo the process of varification
   which turns abstract types into type variables of the same name.
   For example, [same_ast_modulo_varification] would consider (a => b) and ('a
   => 'b) to have the same ast. This is useful in recovering syntactic sugar
   for explicit polymorphic types with locally abstract types.

   Does not compare attributes, or extensions intentionally.

   TODO: This has one more issue: We need to compare only accepting t1's type
   variables, to be considered compatible with t2's type constructors - not the
   other way around.
 *)
let same_ast_modulo_varification_and_extensions t1 t2 =
  let rec loop t1 t2 = match (t1.ptyp_desc, t2.ptyp_desc) with
    (* Importantly, cover the case where type constructors (of the form [a])
       are converted to type vars of the form ['a].
     *)
    | (Ptyp_constr({txt=Lident s1}, []), Ptyp_var s2) -> String.compare s1 s2 == 0
    (* Now cover the case where type variables (of the form ['a]) are
       converted to type constructors of the form [a].
     *)
    | (Ptyp_var s1, Ptyp_constr({txt=Lident s2}, [])) -> String.compare s1 s2 == 0
    (* Now cover the typical case *)
    | (Ptyp_constr(longident1, lst1), Ptyp_constr(longident2, lst2))  ->
      longIdentSame (longident1.txt, longident2.txt) &&
      trueForEachPair lst1 lst2 loop
    | (Ptyp_any, Ptyp_any) -> true
    | (Ptyp_var x1, Ptyp_var x2) -> String.compare x1 x2 == 0
    | (Ptyp_arrow (label1, core_type1, core_type1'), Ptyp_arrow (label2, core_type2, core_type2')) ->
      begin
         match label1, label2 with
         | Nolabel, Nolabel -> true
         | Labelled s1, Labelled s2 -> String.compare s1 s2 == 0
         | Optional s1, Optional s2 -> String.compare s1 s2 == 0
         | _ -> false
      end &&
      loop core_type1 core_type2 &&
      loop core_type1' core_type2'
    | (Ptyp_tuple lst1, Ptyp_tuple lst2) -> trueForEachPair lst1 lst2 loop
    | (Ptyp_object (lst1, o1), Ptyp_object (lst2, o2)) ->
      let tester = fun (s1, attrs1, t1) (s2, attrs2, t2) ->
        String.compare s1 s2 == 0 &&
        loop t1 t2
      in
      trueForEachPair lst1 lst2 tester &&
      o1 == o2
    | (Ptyp_class (longident1, lst1), Ptyp_class (longident2, lst2)) ->
      longIdentSame (longident1.txt, longident2.txt) &&
      trueForEachPair lst1 lst2 loop
    | (Ptyp_alias(core_type1, string1), Ptyp_alias(core_type2, string2)) ->
      loop core_type1 core_type2 &&
      String.compare string1 string2 == 0
    | (Ptyp_variant(row_field_list1, flag1, lbl_lst_option1), Ptyp_variant(row_field_list2, flag2, lbl_lst_option2)) ->
      trueForEachPair row_field_list1 row_field_list2 rowFieldEqual &&
      flag1 == flag2 &&
      lbl_lst_option1 == lbl_lst_option2
    | (Ptyp_poly (string_lst1, core_type1), Ptyp_poly (string_lst2, core_type2))->
      trueForEachPair string_lst1 string_lst2 (fun s1 s2 -> String.compare s1 s2 == 0) &&
      loop core_type1 core_type2
    | (Ptyp_package(longident1, lst1), Ptyp_package (longident2, lst2)) ->
      longIdentSame (longident1.txt, longident2.txt) &&
      trueForEachPair lst1 lst2 testPackageType
    | (Ptyp_extension (s1, arg1), Ptyp_extension (s2, arg2)) ->
      String.compare s1.txt s2.txt == 0
    | _ -> false
  and testPackageType (lblLongIdent1, ct1) (lblLongIdent2, ct2) =
    longIdentSame (lblLongIdent1.txt, lblLongIdent2.txt) &&
    loop ct1 ct2
  and rowFieldEqual f1 f2 = match (f1, f2) with
    | ((Rtag(label1, attrs1, flag1, lst1)), (Rtag (label2, attrs2, flag2, lst2))) ->
      String.compare label1 label2 == 0 &&
      flag1 == flag2 &&
      trueForEachPair lst1 lst2 loop
    | (Rinherit t1, Rinherit t2) -> loop t1 t2
    | _ -> false
  in
  loop t1 t2

let wrapLayoutWithLoc loc layout =
  match loc with
  | None -> layout
  | Some loc -> SourceMap (loc, layout)

let expandLocation pos ~expand:(startPos, endPos) =
  { pos with
    loc_start = {
      pos.loc_start with
        Lexing.pos_cnum = pos.loc_start.Lexing.pos_cnum + startPos
    };
    loc_end = {
      pos.loc_end with
        Lexing.pos_cnum = pos.loc_end.Lexing.pos_cnum + endPos
    }
  }

(** Kinds of attributes *)
type attributesPartition = {
  arityAttrs : attributes;
  docAttrs : attributes;
  stdAttrs : attributes;
  jsxAttrs : attributes
}

(** Partition attributes into kinds *)
let rec partitionAttributes attrs : attributesPartition =
  match attrs with
    | [] ->
        {arityAttrs=[]; docAttrs=[]; stdAttrs=[]; jsxAttrs=[]}
    | (({txt="JSX"; loc}, _) as jsx)::atTl ->
        let partition = partitionAttributes atTl in
        {partition with jsxAttrs=jsx::partition.jsxAttrs}
    | (({txt="explicit_arity"; loc}, _) as arity_attr)::atTl
    | (({txt="implicit_arity"; loc}, _) as arity_attr)::atTl ->
        let partition = partitionAttributes atTl in
        {partition with arityAttrs=arity_attr::partition.arityAttrs}
    | (({txt="ocaml.text"; loc}, _) as doc)::atTl
    | (({txt="ocaml.doc"; loc}, _) as doc)::atTl ->
        let partition = partitionAttributes atTl in
        {partition with docAttrs=doc::partition.docAttrs}
    | atHd::atTl ->
        let partition = partitionAttributes atTl in
        {partition with stdAttrs=atHd::partition.stdAttrs}

let extractStdAttrs attrs =
  (partitionAttributes attrs).stdAttrs

let rec sequentialIfBlocks x =
  match x with
    | Some ({pexp_desc=Pexp_ifthenelse (e1, e2, els)}) -> (
       let (nestedIfs, finalExpression) = (sequentialIfBlocks els) in
       ((e1, e2)::nestedIfs, finalExpression)
      )
    | Some e -> ([], Some e)
    | None -> ([], None)


(*
  TODO: IDE integration beginning with Vim:

  - Create recovering version of parser that creates regions of "unknown"
    content in between let sequence bindings (anything between semicolons,
    really).
  - Use Easy_format's "style" features to tag each known node.
  - Turn those style annotations into editor highlight commands.
  - Editors have a set of keys that retrigger the parsing/rehighlighting
    process (typically newline/semi/close-brace).
  - On every parsing/rehighlighting, this pretty printer can be used to
    determine the highlighting of recovered regions, and the editor plugin can
    relegate highlighting of malformed regions to the editor which mostly does
    so based on token patterns.

*)

(*
     @avoidSingleTokenWrapping

  +-----------------------------+
  |+------+                     |     Another label
  || let ( \                    |
  ||    a  | Label              |
  ||    o  |                    |     The thing to the right of any label must be a
  ||    p _+ label RHS          |     list in order for it to wrap correctly. Lists
  ||  ): /   v                  |     will wrap if they need to/can. NON-lists will
  |+--+ sixteenTuple = echoTuple|(    wrap (indented) even though they're no lists!
  +---/ 0,\---------------------+     To prevent a single item from wrapping, make
        0,                            an unbreakable list via ensureSingleTokenSticksToLabel.
        0
      );                              In general, the best approach for indenting
                                      let bindings is to keep building up labels from
                                      the "let", always ensuring things that you want
                                      to wrap will either be lists or guarded in
                                      [ensureSingleTokenSticksToLabel].
                                      If you must join several lists together (via =)
                                      (or colon), ensure that joining is done via
                                      [makeList] (which won't break), and that new
                                      list is always appended to the left
                                      hand side of the label. (So that the right hand
                                      side may always be the untouched list that you want
                                      to wrap with aligned closing).
                                      Always make sure rhs of the label are the

                                      Creating nested labels will preserve the original
                                      indent location ("let" in this
                                      case) as long as that nesting is
                                      done on the left hand side of the labels.

*)

(*
    Table 2.1. Precedence and associativity.
    Precedence from highest to lowest: From RWOC, modified to include !=
    ---------------------------------------

    Operator prefix	Associativity
    !..., ?..., ~...	                              Prefix
    ., .(, .[	-
    function application, constructor, assert, lazy	Left associative
    -, -.                                           Prefix
    **..., lsl, lsr, asr                            Right associative
    *..., /..., %..., mod, land, lor, lxor          Left associative
    +..., -...                                      Left associative
    ::                                              Right associative
    @..., ^...                                      Right associative
---
    !=                                              Left associative (INFIXOP0 listed first in lexer)
    =..., <..., >..., |..., &..., $...              Left associative (INFIXOP0)
    =, <, >                                         Left associative (IN SAME row as INFIXOP0 listed after)
---
    &, &&                                           Right associative
    or, ||                                          Right associative
    ,                                               -
    :=, =                                         	Right associative
    if                                              -
    ;                                               Right associative


   Note: It would be much better if &... and |... were in separate precedence
   groups just as & and | are. This way, we could encourage custom infix
   operators to use one of the two precedences and no one would be confused as
   to precedence (leading &, | are intuitive). Two precedence classes for the
   majority of infix operators is totally sufficient.

   TODO: Free up the (&) operator from pervasives so it can be reused for
   something very common such as string concatenation or list appending.

   let x = tail & head;
 *)

(* "Almost Simple Prefix" function applications parse with the rule:

   `PREFIXOP simple_expr %prec below_DOT_AND_SHARP`, which in turn is almost
   considered a "simple expression" (it's acceptable anywhere a simple
   expression is except in a couple of edge cases.

   "Unary Prefix" function applications parse with the rule:

   `MINUS epxr %prec prec_unary_minus`, which in turn is considered an
   "expression" (not simple). All unary operators are mapped into an identifier
   beginning with "~".

   TODO: Migrate all "almost simple prefix" to "unsary prefix". When `!`
   becomes "not", then it will make more sense that !myFunc (arg) is parsed as
   !(myFunc arg) instead of (!myFunc) arg.

 *)
let almost_simple_prefix_symbols  = [ '!'; '?'; '~'] ;;
(* Subset of prefix symbols that have special "unary precedence" *)
let unary_minus_prefix_symbols  = [ "~-"; "~-."] ;;
let unary_plus_prefix_symbols  = ["~+"; "~+." ] ;;
let infix_symbols = [ '='; '<'; '>'; '@'; '^'; '|'; '&'; '+'; '-'; '*'; '/';
                      '$'; '%'; '\\'; '#' ]
let operator_chars = [ '!'; '$'; '%'; '&'; '*'; '+'; '-'; '.'; '/';
                       ':'; '<'; '='; '>'; '?'; '@'; '^'; '|'; '~' ]
let numeric_chars  = [ '0'; '1'; '2'; '3'; '4'; '5'; '6'; '7'; '8'; '9' ]

let special_infix_strings =
  ["asr"; "land"; "lor"; "lsl"; "lsr"; "lxor"; "mod"; "or"; ":="; "!="; "!=="]

let updateToken = "="
let requireIndentFor = [updateToken; ":="]

let infixTokenRequiresIndent printedIdent =
  if List.exists (fun i -> i = printedIdent) requireIndentFor then None else Some 0

let getPrintableUnaryIdent s =
  if List.mem s unary_minus_prefix_symbols || List.mem s unary_plus_prefix_symbols then
    String.sub s 1 (String.length s -1)
  else s


(* determines if the string is an infix string.
   checks backwards, first allowing a renaming postfix ("_102") which
   may have resulted from Pexp -> Texp -> Pexp translation, then checking
   if all the characters in the beginning of the string are valid infix
   characters. *)
let printedStringAndFixity  = function
  | s when List.mem s special_infix_strings -> Infix s
  | s when List.mem s.[0] infix_symbols -> Infix s
  (* Correctness under assumption that unary operators are stored in AST with
     leading "~" *)
  | s when List.mem s.[0] almost_simple_prefix_symbols &&
           not (List.mem s special_infix_strings) &&
           not (s = "?")-> (
      (* What *kind* of prefix fixity? *)
      if List.mem s unary_plus_prefix_symbols then
        UnaryPlusPrefix (getPrintableUnaryIdent s)
      else if List.mem s unary_minus_prefix_symbols then
        UnaryMinusPrefix (getPrintableUnaryIdent s)
      else
        AlmostSimplePrefix s
  )
  | _ -> Normal


(* Also, this doesn't account for != and !== being infixop!!! *)
let isSimplePrefixToken s = match printedStringAndFixity s with
  | AlmostSimplePrefix _ -> true
  | _ -> false


(* Convenient bank of information that represents the parser's precedence
   rankings.  Each instance describes a precedence table entry. The function
   tests either a token string encountered by the parser, or (in the case of
   `CustomPrecedence`) the string name of a custom rule precedence declared
   using %prec *)
let rules = [
  [
    (TokenPrecedence, (fun s -> (Nonassoc, isSimplePrefixToken s)));
  ];
  [
    (CustomPrecedence, (fun s -> (Nonassoc, s = "prec_unary_minus")));
    (CustomPrecedence, (fun s -> (Nonassoc, s = "prec_unary_plus")));
  ];
  (* Note the special case for "*\*", BARBAR, and LESSMINUS, AMPERSAND(s) *)
  [
    (TokenPrecedence, (fun s -> (Right, String.length s > 1 && s.[0] == '*' && s.[1] == '\\' && s.[2] == '*')));
    (TokenPrecedence, (fun s -> (Right, s = "lsl")));
    (TokenPrecedence, (fun s -> (Right, s = "lsr")));
    (TokenPrecedence, (fun s -> (Right, s = "asr")));
  ];
  [
    (TokenPrecedence, (fun s -> (Left, s.[0] == '*' && (String.length s == 1 || s != "*\\*"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '/')));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '%' )));
    (TokenPrecedence, (fun s -> (Left, s = "mod" )));
    (TokenPrecedence, (fun s -> (Left, s = "land" )));
    (TokenPrecedence, (fun s -> (Left, s = "lor" )));
    (TokenPrecedence, (fun s -> (Left, s = "lxor" )));
  ];
  [
    (* Even though these use the same *tokens* as unary plus/minus at parse
       time, when unparsing infix -/+, the CustomPrecedence rule would be
       incorrect to use, and instead we need a rule that models what infix
       parsing would use - just the regular token precedence without a custom
       precedence. *)
    (TokenPrecedence, (fun s -> (Left, s.[0] == '+' )));
    (TokenPrecedence ,(fun s -> (Left, s.[0] == '-' )));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = "::")));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s.[0] == '@')));
    (TokenPrecedence, (fun s -> (Right, s.[0] == '^')));
  ];
  [
    (TokenPrecedence, (fun s -> (Left, s.[0] == '=' && not (s = "=") && not (s = "=>"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '<' && not (s = "<"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '>' && not (s = ">"))));
    (TokenPrecedence, (fun s -> (Left, s = "!=")));  (* Not preset in the RWO table! *)
    (TokenPrecedence, (fun s -> (Left, s = "!==")));  (* Not preset in the RWO table! *)
    (TokenPrecedence, (fun s -> (Left, s = "==")));
    (TokenPrecedence, (fun s -> (Left, s = "===")));
    (TokenPrecedence, (fun s -> (Left, s = "<")));
    (TokenPrecedence, (fun s -> (Left, s = ">")));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '|' && not (s = "||"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '&' && not (s = "&") && not (s = "&&"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '$')));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = "&")));
    (TokenPrecedence, (fun s -> (Right, s = "&&")));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = "or")));
    (TokenPrecedence, (fun s -> (Right, s = "||")));
  ];
  [
    (* The Left shouldn't ever matter in practice. Should never get in a
       situation with two consecutive infix ? - the colon saves us. *)
    (TokenPrecedence, (fun s -> (Left, s = "?")));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = ":=")));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = updateToken)));
  ];
  (* It's important to account for ternary ":" being lower precedence than "?" *)
  [
    (TokenPrecedence, (fun s -> (Right, s = ":")))
  ];
  [
    (TokenPrecedence, (fun s -> (Nonassoc, s = "=>")));
  ];
]

(* remove all prefixing backslashes, e.g. \=== becomes === *)
let rec without_prefixed_backslashes str =
  if str = "" then str
  else if String.get str 0 = '\\' then String.sub str 1 (String.length str - 1)
  else str

let indexOfFirstMatch ~prec lst =
  let rec indexOfFirstMatchN ~prec lst n = match lst with
    | [] -> None
    | []::tl -> indexOfFirstMatchN ~prec tl (n + 1)
    | (hdHd::hdTl)::tl -> (
      let (kind, tester) = hdHd in
      match (prec, kind) with
      | (Token str, TokenPrecedence)
      | (Custom str, CustomPrecedence) ->
        let (associativity, foundMatch) = tester str in
        if foundMatch then
          Some (associativity, n)
        else
          indexOfFirstMatchN ~prec (hdTl::tl) (n)
      | _ -> indexOfFirstMatchN ~prec (hdTl::tl) (n)
    )
  in
  indexOfFirstMatchN ~prec lst 0

(* Assuming it's an infix function application. *)
let precedenceInfo ~prec =
  (* Removes prefixed backslashes in order to do proper conversion *)
  let normalizedCheck =
    match prec with
      | Token str -> Token (without_prefixed_backslashes str)
      | Custom str -> prec
  in
  indexOfFirstMatch ~prec:normalizedCheck rules

let isLeftAssociative ~prec = match precedenceInfo ~prec with
  | None -> false
  | Some (Left, _) -> true
  | Some (Right, _) -> false
  | Some (Nonassoc, _) -> false

let isRightAssociative ~prec = match precedenceInfo ~prec with
  | None -> false
  | Some (Right, _) -> true
  | Some (Left, _) -> false
  | Some (Nonassoc, _) -> false

let higherPrecedenceThan c1 c2 = match ((precedenceInfo c1), (precedenceInfo c2)) with
  | (_, None)
  | (None, _) ->
    let (str1, str2) = match (c1, c2) with
      | (Token s1, Token s2) -> ("Token " ^ s1, "Token " ^ s2)
      | (Token s1, Custom s2) -> ("Token " ^ s1, "Custom " ^ s2)
      | (Custom s1, Token s2) -> ("Custom " ^ s1, "Token " ^ s2)
      | (Custom s1, Custom s2) -> ("Custom " ^ s1, "Custom " ^ s2)
    in
    raise (NotPossible ("Cannot determine precedence of two checks " ^ str1 ^ " vs. " ^ str2))
  | (Some (_, p1), Some (_, p2)) -> p1 < p2


let printedStringAndFixityExpr = function
  | {pexp_desc = Pexp_ident {txt=Lident l}} -> printedStringAndFixity l
  | _ -> Normal

let is_predef_option = function
  | (Ldot (Lident "*predef*","option")) -> true
  | _ -> false

(* which identifiers are in fact operators needing parentheses *)
let needs_parens txt =
  match printedStringAndFixity txt with
    | Infix _ -> true
    | UnaryPlusPrefix _ -> true
    | UnaryMinusPrefix _ -> true
    | AlmostSimplePrefix _ -> true
    | Normal -> false

(* some infixes need spaces around parens to avoid clashes with comment
   syntax. This isn't needed for comment syntax /* */ *)
let needs_spaces txt =
  txt.[0]='*' || txt.[String.length txt - 1] = '*'

(* add parentheses to binders when they are in fact infix or prefix operators *)
let protect_ident ppf txt =
  let format : (_, _, _) format =
    if not (needs_parens txt) then "%s"
    else if needs_spaces txt then "(@;%s@;)"
    else "(%s)"
  in fprintf ppf format txt

let protect_longident ppf print_longident longprefix txt =
  let format : (_, _, _) format =
    if not (needs_parens txt) then "%a.%s"
    else if needs_spaces txt then  "(@;%a.%s@;)"
    else "(%a.%s)" in
  fprintf ppf format print_longident longprefix txt

let rec longident f = function
  | Lident s -> protect_ident f s
  | Ldot(y,s) -> protect_longident f longident y s
  | Lapply (y,s) ->
      fprintf f "%a(%a)" longident y longident s

let rec orList = function (* only consider ((A|B)|C)*)
  | {ppat_desc = Ppat_or (p1, p2)} -> (orList p1) @ (orList p2)
  | x -> [x]

type space_formatter = (unit, Format.formatter, unit) format

let override = function
  | Override -> "!"
  | Fresh -> ""

(* variance encoding: need to sync up with the [parser.mly] *)
let type_variance = function
  | Invariant -> ""
  | Covariant -> "+"
  | Contravariant -> "-"

type construct =
  [ `cons of expression list
  | `list of expression list
  | `nil
  | `normal
  | `simple of Longident.t
  | `tuple ]

let view_expr x =
  match x.pexp_desc with
    | Pexp_construct ( {txt= Lident "()"; _},_) -> `tuple
    | Pexp_construct ( {txt= Lident "[]"},_) -> `nil
    | Pexp_construct ( {txt= Lident"::"},Some _) ->
        let rec loop exp acc = match exp with
          | {pexp_desc=Pexp_construct ({txt=Lident "[]"},_)} ->
              (List.rev acc,true)
          | {pexp_desc=
               Pexp_construct ({txt=Lident "::"},
                 Some ({pexp_desc= Pexp_tuple([e1;e2])}))} ->
              loop e2 (e1::acc)
          | e -> (List.rev (e::acc),false) in
        let (ls,b) = loop x []  in
        if b then
          `list ls
        else `cons ls
    | Pexp_construct (x,None) -> `simple (x.txt)
    | _ -> `normal

let is_simple_construct :construct -> bool = function
  | `nil | `tuple | `list _ | `simple _ | `cons _  -> true
  | `normal -> false

let pp = fprintf

type funcReturnStyle =
  | ReturnValOnSameLine

let detectTernary l = match l with
  | [{
      pc_lhs={ppat_desc=Ppat_construct ({txt=Lident "true"}, _)};
      pc_guard=None;
      pc_rhs=ifTrue
    };
    {
      pc_lhs={ppat_desc=Ppat_construct ({txt=Lident "false"}, _)};
      pc_guard=None;
      pc_rhs=ifFalse
    }] -> Some (ifTrue, ifFalse)
  | _ -> None
type funcApplicationLabelStyle =
  (* No attaching to the label, but if the entire application fits on one line,
     the entire application will appear next to the label as you 'd expect. *)
  | NeverWrapFinalItem
  (* Attach the first term if there are exactly two terms involved in the
     application.

     let x = firstTerm (secondTerm_1 secondTerm_2) thirdTerm;

     Ideally, we'd be able to attach all but the last argument into the label any
     time all but the last term will fit - and *not* when (attaching all but
     the last term isn't enough to prevent a wrap) - But there's no way to tell
     ahead of time if it would prevent a wrap.

     However, the number two is somewhat convenient. This models the
     indentation that you'd prefer in non-curried syntax languages like
     JavaScript, where application only ever has two terms.
  *)
  | WrapFinalListyItemIfFewerThan of int

(*
    space=2, indentWrappedPatternArgs=1, funcReturnStyle=ReturnValOnSameLine
    ------------------------------------------------------------------------
    (* When [ReturnValOnSameLine], [indentWrappedPatternArgs] has no effect! *)
    let myFunc
        (wrappedArgOne:int)
        (wrappedArgTwo:int) => {
      valOne: 10,
      valTwo: 20
    };

    space=2, indentWrappedPatternArgs=2, funcReturnStyle=ReturnValOnSameLine
    ------------------------------------------------------------------------
    (* When [ReturnValOnSameLine], [indentWrappedPatternArgs] has no effect! *)
    let myFunc
        (wrappedArgOne:int)
        (wrappedArgTwo:int) => {
      valOne: 10,
      valTwo: 20
    };

*)

type formatSettings = {
  (* Whether or not to expect that the original parser that generated the AST
     would have annotated constructor argument tuples with explicit arity to
     indicate that they are multiple arguments. (True if parsed in original
     OCaml AST, false if using Reason parser).
  *)
  constructorTupleImplicitArity: bool;
  space: int;
  (* Whether or not to begin a curried function's return expression immediately
     after the [=>] without a newline.
  *)
  returnStyle: funcReturnStyle;

  (* For curried arguments in function *definitions* only: Number of [space]s
     to offset beyond the [let] keyword. Default 1.
  *)
  listsRecordsIndent: int;

  (* When [funcReturnStyle] = [ReturnValOnSameLine],
     [indentWrappedPatternArgs] is not adjustable - wrapped arguments will
     always be aligned with the function name. *)
  indentWrappedPatternArgs: int;

  indentMatchCases: int;

  (* Amount to indent in label-like constructs such as wrapped function
     applications, etc - or even record fields. This is not the same concept as an
     indented curried argument list. *)
  indentAfterLabels: int;

  (* Amount to indent after the opening brace of switch/try.
     Here's an example of what it would look like w/ [trySwitchIndent = 2]:
     Sticks the expression to the last item in a sequence in several [X | Y | Z
     => expr], and forces X, Y, Z to be split onto several lines. (Otherwise,
     sticking to Z would result in hanging expressions).  TODO: In the first case,
     it's clear that we want patterns to have an "extra" indentation with matching
     in a "match". Create extra config param to pass to [self#pattern] for extra
     indentation in this one case.

      switch x {
      | TwoCombos
          (HeresTwoConstructorArguments x y)
          (HeresTwoConstructorArguments a b) =>
          ((a + b) + x) + y;
      | Short
      | AlsoHasARecord a b {x, y} => (
          retOne,
          retTwo
        )
      | AlsoHasARecord a b {x, y} =>
        callMyFunction
          withArg
          withArg
          withArg
          withArg;
      }
  *)
  trySwitchIndent: int;


  (* In the case of two term function application (when flattened), the first
     term should become part of the label, and the second term should be able to wrap
     This doesn't effect n != 2.

       [true]
       let x = reallyShort allFitsOnOneLine;
       let x = someFunction {
         reallyLongObject: true,
         thatWouldntFitOnThe: true,
         firstLine: true
       };

       [false]
       let x = reallyShort allFitsOnOneLine;
       let x =
        someFunction
          {
            reallyLongObject: true,
            thatWouldntFitOnThe: true,
            firstLine: true
          };
  *)
  funcApplicationLabelStyle: funcApplicationLabelStyle;

  funcCurriedPatternStyle: funcApplicationLabelStyle;

  width: int;

  assumeExplicitArity: bool;

  constructorLists: string list;
}

let defaultSettings = {
  constructorTupleImplicitArity = false;
  space = 1;
  returnStyle = ReturnValOnSameLine;
  listsRecordsIndent = 2;
  indentWrappedPatternArgs = 2;
  indentMatchCases = 2;
  indentAfterLabels = 2;
  trySwitchIndent = 0;
  funcApplicationLabelStyle = WrapFinalListyItemIfFewerThan 3;
  (* WrapFinalListyItemIfFewerThan is currently a bad idea for curried
     arguments: It looks great in some cases:

        let myFun (a:int) :(
          int,
          string
        ) => (a, "this is a");

     But horrible in others:

        let myFun
            {
              myField,
              yourField
            } :someReturnType => myField + yourField;

        let myFun
            {            // Curried arg wraps
              myField,
              yourField
            } : (       // But the last is "listy" so it docks
          int,          // To the [let].
          int,
          int
        ) => myField + yourField;

     We probably want some special listy label docking/wrapping mode for
     curried function bindings.

  *)
  funcCurriedPatternStyle = NeverWrapFinalItem;
  width = 90;
  assumeExplicitArity = false;
  constructorLists = [];
}
let configuredSettings = ref defaultSettings

let configure ~width ~assumeExplicitArity ~constructorLists = (
  configuredSettings := {defaultSettings with width; assumeExplicitArity; constructorLists}
)

let string_of_formatter f x =
  Format.asprintf "%a" f x

let createFormatter () =
let module Formatter = struct

let settings = !configuredSettings


(* How do we make
   this a label?

   /---------------------\
   let myVal = (oneThing, {
   field: [],
   anotherField: blah
   });

   But in this case, this wider region a label?
   /------------------------------------------------------\
   let myVal = callSomeFunc (oneThing, {field: [], anotherField: blah}, {
   boo: 'hi'
   });

   This is difficult. You must form a label from the preorder traversal of every
   node - except the last encountered in the traversal. An easier heuristic is:

   - The last argument to a functor application is expanded.

   React.CreateClass SomeThing {
   let render {props} => {
   };
   }

   - The last argument to a function application is expanded on the same line.
   - Only if it's not curried with another invocation.
   -- Optionally: "only if everything else is an atom"
   -- Optionally: "only if there are no other args"

   React.createClass someThing {
   render: fn x => y,
   }

   !!! NOT THIS
   React.createClass someThing {
   render: fn x => y,
   }
   somethingElse
*)

let isArityClear attrs =
  (!configuredSettings).assumeExplicitArity ||
  List.exists
    (function
      | ({txt="explicit_arity"; loc}, _) -> true
      | _ -> false
    )
    attrs


let list_settings = {
  Easy_format.space_after_opening = false;
  space_after_separator = false;
  space_before_separator = false;
  separators_stick_left = true;
  space_before_closing = false;
  stick_to_label = true;
  align_closing = true;
  wrap_body = `No_breaks;
  indent_body = settings.listsRecordsIndent * settings.space;
  list_style = Some "list";
  opening_style = None;
  body_style = None;
  separator_style = None;
  closing_style = None;
}

let nullStyle = { Easy_format.atom_style = Some "null" }
let boolStyle = { Easy_format.atom_style = Some "bool" }
let intStyle = { Easy_format.atom_style = Some "int" }
let stringStyle = { Easy_format.atom_style = Some "string" }
let labelStringStyle = { Easy_format.atom_style = Some "atomClss" }
let colonStyle = { Easy_format.atom_style = Some "punct" }

let simplifiedApplicationSettings = {
  list_settings with
    align_closing = true; (* So the semicolon sticks to end of application *)
    (* This must be true to support this case:

        let oneNestedInvocationThatWraps = outerFunc (
          nestedFuncToInvokeThatCausesWrapping
          []
        );

       Otherwise, we would get:
        let oneNestedInvocationThatWraps = outerFunc
          (nestedFuncToInvokeThatCausesWrapping []);
    *)
    stick_to_label = true; (* I don't believe this has a purpose *)
    space_after_separator = true;
    wrap_body = `Never_wrap
}

let easyListSettingsFromListConfig listConfig =
  let {
    break;
    wrap;
    inline;
    indent;
    sepLeft;
    preSpace;
    postSpace;
    pad;
    sep;
  } = listConfig in
  let (opn, cls) = wrap in
  let (padOpn, padCls) = pad in
  let (inlineStart, inlineEnd) = inline in
  (opn, sep, cls, {
    list_settings with
      wrap_body = (
        match break with
          | Never -> `No_breaks
          (* Yes, `Never_wrap is a horrible name - really means "if needed". *)
          | IfNeed -> `Never_wrap
          | Always -> `Force_breaks
          | Always_rec -> `Force_breaks_rec
      );
      indent_body = indent;
      space_after_separator = postSpace;
      space_before_separator = preSpace;
      space_after_opening = padOpn;
      space_before_closing = padCls;
      stick_to_label = inlineStart;
      align_closing = not inlineEnd;
  })

let makeListConfig
    ?(newlinesAboveItems=0)
    ?(newlinesAboveComments=0)
    ?(newlinesAboveDocComments=0)
    ?(interleaveComments=true)
    ?listConfigIfCommentsInterleaved
    ?(listConfigIfEolCommentsInterleaved)
    ?(renderFinalSep=false)
    ?(break=Never)
    ?(wrap=("", ""))
    ?(inline=(true, false))
    ?(sep="")
    ?(indent=list_settings.indent_body)
    ?(sepLeft=true)
    ?(preSpace=false)
    ?(postSpace=false)
    ?(pad=(false,false))
    () =
  {
    newlinesAboveItems;
    newlinesAboveComments;
    newlinesAboveDocComments;
    interleaveComments;
    listConfigIfCommentsInterleaved;
    listConfigIfEolCommentsInterleaved;
    renderFinalSep;
    break;
    wrap;
    inline;
    sep;
    indent;
    sepLeft;
    preSpace;
    postSpace;
    pad;
  }

let easyListWithConfig listConfig easyListItems =
  let (opn, sep, cls, settings) =
    easyListSettingsFromListConfig listConfig in
  Easy_format.List ((opn, sep, cls, settings), easyListItems)

let makeEasyList
    ?(newlinesAboveItems=0)
    ?(newlinesAboveComments=0)
    ?(newlinesAboveDocComments=0)
    ?(interleaveComments=true)
    ?(renderFinalSep=false)
    ?(break=Never)
    ?(wrap=("", ""))
    ?(inline=(true, false))
    ?(sep="")
    ?(indent=list_settings.indent_body)
    ?(sepLeft=true)
    ?(preSpace=false)
    ?(postSpace=false)
    ?(pad=(false,false)) easyListItems =
  let listConfig =
    makeListConfig
      ~newlinesAboveItems
      ~newlinesAboveComments
      ~newlinesAboveDocComments
      ~interleaveComments
      (* This is unused at this point - separators are handled by our pretty printer,
         not Easy_format (so that we can interleave comments intelligently) *)
      ~renderFinalSep
      ~break
      ~wrap
      ~inline
      ~sep
      ~indent
      ~sepLeft
      ~preSpace
      ~postSpace
      ~pad
      ()
  in
  let (opn, sep, cls, listSettings) = easyListSettingsFromListConfig listConfig in
  Easy_format.List ((opn, sep, cls, listSettings), easyListItems)

let makeList
    (* Allows a fallback in the event that comments were interleaved with the
     * list *)
    ?(newlinesAboveItems=0)
    ?(newlinesAboveComments=0)
    ?(newlinesAboveDocComments=0)
    ?(interleaveComments=true)
    ?listConfigIfCommentsInterleaved
    ?listConfigIfEolCommentsInterleaved
    ?(renderFinalSep=false)
    ?(break=Never)
    ?(wrap=("", ""))
    ?(inline=(true, false))
    ?(sep="")
    ?(indent=list_settings.indent_body)
    ?(sepLeft=true)
    ?(preSpace=false)
    ?(postSpace=false)
    ?(pad=(false,false)) lst =
  let config =
    makeListConfig
      ~newlinesAboveItems
      ~newlinesAboveComments
      ~newlinesAboveDocComments
      ~interleaveComments
      ?listConfigIfCommentsInterleaved
      ?listConfigIfEolCommentsInterleaved
      ~renderFinalSep
      ~break
      ~wrap
      ~inline
      ~sep
      ~indent
      ~sepLeft
      ~preSpace
      ~postSpace
      ~pad
      ()
  in
  Sequence (config, lst)

let makeAppList l =
  match l with
  | hd::[] -> hd
  | _ -> makeList ~inline:(true, true) ~postSpace:true ~break:IfNeed l

let ensureSingleTokenSticksToLabel x =
  makeList
    ~interleaveComments:true
    ~listConfigIfCommentsInterleaved: (
      fun currentConfig -> {currentConfig with break=Always_rec; postSpace=true; indent=0; inline=(true, true)}
    )
    [x]

let unbreakLabelFormatter formatter =
  let newFormatter labelTerm term =
    match formatter labelTerm term with
    | Easy_format.Label ((labelTerm, settings), term) ->
       Easy_format.Label ((labelTerm,
                           {settings with label_break = `Never}),
                          term)
    | _ -> failwith "not a label"
  in newFormatter

let inlineLabel labelTerm term =
  let settings = {
    label_break = `Never;
    space_after_label = true;
    indent_after_label = 0;
    label_style = Some "inlineLabel";
  } in
  Easy_format.Label ((labelTerm, settings), term)

(* Just for debugging: Set debugWithHtml = true *)
let debugWithHtml = ref false

let html_escape_string s =
  let buf = Buffer.create (2 * String.length s) in
  for i = 0 to String.length s - 1 do
    match s.[i] with
        '&' -> Buffer.add_string buf "&amp;"
      | '<' -> Buffer.add_string buf "&lt;"
      | '>' -> Buffer.add_string buf "&gt;"
      | c -> Buffer.add_char buf c
  done;
  Buffer.contents buf

let html_escape = `Escape_string html_escape_string
let html_style = [
  "atom", { Easy_format.tag_open = "<a>"; tag_close = "</a>" };
  "body", { tag_open = "<lb>"; tag_close = "</lb>" };
  "list", { tag_open = "<l>"; tag_close = "</l>" };
  "op", { tag_open = "<op>"; tag_close = "</op>" };
  "cl", { tag_open = "<cl>"; tag_close = "</cl>" };
  "sep", { tag_open = "<sep>"; tag_close = "</sep>" };
  "label", { tag_open = "<la>"; tag_close = "</la>" };
]


let easyLabel ?(break=`Auto) ?(space=false) ?(indent=settings.indentAfterLabels) labelTerm term =
  let settings = {
    label_break = break;
    space_after_label = space;
    indent_after_label = indent;
    label_style = Some "label";
  } in
  Easy_format.Label ((labelTerm, settings), term)

let label ?(break=`Auto) ?(space=false) ?(indent=settings.indentAfterLabels) (labelTerm:layoutNode) (term:layoutNode) =
  Label (
    (fun x y -> easyLabel ~break ~indent ~space x y),
    labelTerm,
    term
  )

let labelSpace l r = label ~space:true l r

let atom ?loc str =
  let layout = Easy (Easy_format.Atom(str, labelStringStyle)) in
  wrapLayoutWithLoc loc layout

let easyAtom str = Easy_format.Atom(str, labelStringStyle)

(** Take x,y,z and n and generate [x, y, z, ...n] *)
let makeES6List lst last =
  let last_dots = makeList [atom "..."; last] in
  makeList ~wrap:("[", "]") ~break:IfNeed ~postSpace:true ~sep:"," (lst @ [last_dots])

let makeNonIndentedBreakingList lst =
    (* No align closing: So that semis stick to the ends of every break *)
  makeList ~break:Always_rec ~indent:0 ~inline:(true, true) lst

let break =
    (* No align closing: So that semis stick to the ends of every break *)
  makeListConfig ~break:Always_rec ~indent:0 ~inline:(true, true) ()

let makeBreakableList lst = makeList ~break:IfNeed ~inline:(true, true) lst

let makeNonIndentedBreakableEasyList lst = makeEasyList ~break:IfNeed ~inline:(true, true) ~indent:0 lst

(* Like a <span> could place with other breakableInline lists without upsetting final semicolons *)
let makeSpacedBreakableInlineList lst =
  makeList ~break:IfNeed ~inline:(true, true) ~postSpace:true lst

let makeCommaBreakableList lst = makeList ~break:IfNeed ~postSpace:true lst

let makeCommaBreakableListSurround opn cls lst =
  makeList ~break:IfNeed ~postSpace:true ~sep:"," ~wrap:(opn, cls) lst

(* TODO: Allow configuration of spacing around colon symbol *)

let formatPrecedence ?loc formattedTerm =
  let withParens = makeList ~wrap:("(", ")") ~break:IfNeed [formattedTerm] in
  match loc with
    | None -> withParens
    | Some l -> SourceMap (l, withParens)

(* What to do when a comment wasn't interleaved in a list - default is to attach and break. *)
let fallbackCommentListConfig = break


let eolCommentListConfig = makeListConfig ~break:Never ~postSpace:true ~inline:(true, true) ()

let isListy = function
  | Easy_format.List _ -> true
  | _ -> false

let easyFormatToFormatter f x =
  let buf = Buffer.create 1000 in
  let fauxmatter = Format.formatter_of_buffer buf in
  let _ = Format.pp_set_margin fauxmatter settings.width in
  if debugWithHtml.contents then
    Easy_format.Pretty.define_styles fauxmatter html_escape html_style;
  let _ = Easy_format.Pretty.to_formatter fauxmatter x in
  let trimmed = Syntax_util.strip_trailing_whitespace (Buffer.contents buf) in
  Format.fprintf f "%s\n" trimmed;
  pp_print_flush f ()

let wrap fn = fun term ->
  ignore (flush_str_formatter ());
  let f = str_formatter in
  (fn f term; atom (flush_str_formatter ()))


(** Either an ItemComment  (not eol) designates if it's a doc comment (which
    have extra leading stars).  Or an Item which might include its eol
    comments. *)
type commentOrItem =
  | ItemComment of Easy_format.t * bool
  (* The item, and a list of "end of line" comments to render *)
  | Item of (Easy_format.t * Easy_format.t list)


(**
 * Invokes the supplied partitioning function with normalized location
 * positions. AST nodes and comments' locations have endpoints that are not one
 * beyond the actual end. [extractComments] normalizes this and provides
 * the exact first/last character position. The function should return true iff
 * an item with that exact location is to be included in the left partition.
 *
 * The callback is invoked with both normalized physical location, as well as
 * the "attachment" location. The attachment location makes note of where
 * the comment was relative to indentation or the beginning of a line.
 *
 * Attachment location: What portion of text is the comment annotating
 * (including the comment text itself)?
 * Physical location: Where in the file was the comment? Usually a subset of
 * attachment location.
 *)
let rec extractComments comments tester =
  let open Lexing in
  (* There might be an issue here - we shouldn't have to split "up to and including".
     Up to should be sufficient. Comments' end position might be off by one (too large) *)
  comments |> List.partition (fun (str, attLoc, physLoc) ->
    let oneGreaterThanAttachmentLocEnd = attLoc.loc_end.pos_cnum in
    let attachmentLocLastChar = oneGreaterThanAttachmentLocEnd - 1 in
    let oneGreaterThanPhysLocEnd = physLoc.loc_end.pos_cnum in
    let physLastChar = oneGreaterThanPhysLocEnd - 1 in
    tester attLoc.loc_start.pos_cnum attachmentLocLastChar physLoc.loc_start.pos_cnum physLastChar
  )

(* Don't use `trim` since it kills line return too? *)
let rec beginsWithStar_ line length idx =
  if idx = length then false
  else
    let ch = String.get line idx in
    if ch = '*' then true
    else if ch = '\t' || ch = ' ' then beginsWithStar_ line length (idx + 1)
    else false

let beginsWithStar line = beginsWithStar_ line (String.length line) 0

let rec numLeadingSpace_ line length idx accum =
  if idx = length then accum
  else
    let ch = String.get line idx in
    if ch = '\t' || ch = ' ' then numLeadingSpace_ line length (idx + 1) (accum + 1)
    else accum

let numLeadingSpace line = numLeadingSpace_ line (String.length line) 0 0

(* Computes the smallest leading spaces for non-empty lines *)
let smallestLeadingSpaces strs =
  let rec smallestLeadingSpaces curMin strs = match strs with
    | [] -> curMin
    | hd::tl ->
      if hd = "" then
        smallestLeadingSpaces curMin tl
      else
        let leadingSpace = numLeadingSpace hd in
        let nextMin = min curMin leadingSpace in
        smallestLeadingSpaces nextMin tl
  in
  smallestLeadingSpaces 99999 strs

let convertIsListyToIsSequencey isListyImpl =
  let rec isSequencey layoutNode = match layoutNode with
    | SourceMap (_, subLayoutNode) -> isSequencey subLayoutNode
    | Sequence _ -> true
    | WithEOLComment (_, sub) -> isSequencey sub
    | Label (_, _, _) -> false
    | Easy easy -> isListyImpl easy
  in
  isSequencey

let isSequencey = convertIsListyToIsSequencey isListy

let inline ?(preSpace=false) ?(postSpace=false) labelTerm term =
  makeList ~inline:(true, true) ~postSpace ~preSpace ~indent:0 ~break:Never [labelTerm; term]

let breakline labelTerm term =
  makeList ~inline:(true, true) ~indent:0 ~break:Always_rec [labelTerm; term]

let insertBlankLines n term =
  if n = 0 then
    term
  else
    makeList ~inline:(true, true) ~indent:0 ~break:Always_rec (Array.to_list (Array.make n (atom "")) @ [term])

let string_after s n = String.sub s n (String.length s - n)

let wrapComment txt =
  ("/*" ^ txt ^ "*/")

(* This is a special-purpose functions only used by `formatComment_`. Notice we
skip a char below during usage because we know the comment starts with `/*` *)
let rec lineZeroMeaningfulContent_ line length idx accum =
  if idx = length then None
  else
    let ch = String.get line idx in
    if ch = '\t' || ch = ' ' || ch = '*' then
      lineZeroMeaningfulContent_ line length (idx + 1) (accum + 1)
    else Some accum

let lineZeroMeaningfulContent line = lineZeroMeaningfulContent_ line (String.length line) 1 0

let formatComment_ txt =
  let commLines = Syntax_util.split_by ~keep_empty:true (fun x -> x = '\n') (wrapComment txt) in
  match commLines with
  | [] -> atom ""
  | [hd] ->
    makeList ~inline:(true, true) ~postSpace:true ~preSpace:true ~indent:0 ~break:IfNeed [atom hd]
  | zero::one::tl ->
    let attemptRemoveCount = (smallestLeadingSpaces (one::tl)) in
    let leftPad =
      if beginsWithStar one then 1
      else match lineZeroMeaningfulContent zero with
      | None -> 1
      | Some num -> num + 1
    in
    let padNonOpeningLine s =
      let numLeadingSpaceForThisLine = numLeadingSpace s in
      if String.length s == 0 then ""
      else (String.make leftPad ' ') ^
            (string_after s (min attemptRemoveCount numLeadingSpaceForThisLine)) in
    let lines = zero :: List.map padNonOpeningLine (one::tl) in
    makeList ~inline:(true, true) ~indent:0 ~break:Always_rec (List.map atom lines)

let formatComment ?locOpt txt =
  let list = formatComment_ txt in
  match locOpt with
  | None ->
     list
  | Some loc ->
     SourceMap (loc, list)

(** [hasComment layout] checks if a layout has comment attached to it *)
let rec hasComment = function
  | WithEOLComment (_, _) -> true
  | SourceMap (_, sub) -> hasComment sub
  | _ -> false

let rec append ?(space=false) txt = function
  | SourceMap (loc, sub) -> SourceMap (loc, append ~space txt sub)
  | Sequence (config, l) when snd config.wrap <> "" ->
     let sep = if space then " " else "" in
     Sequence ({config with wrap=(fst config.wrap, snd config.wrap ^ sep ^ txt)}, l)
  | Sequence (config, l) when List.length l = 0 ->
     Sequence (config, [atom txt])
  | Sequence (config, l) when config.sep = "" ->
     let sub = List.mapi (fun i layout ->
                   (* append to the end of the list *)
                   if i + 1 = List.length l then
                     append ~space txt layout
                   else
                     layout
                 ) l in
     Sequence (config, sub)
  | Label (formatter, left, right) ->
     Label (formatter, left, append ~space txt right)
  | layout ->
     inline ~postSpace:space layout (atom txt)

let appendSep spaceBeforeSep sep layout =
  let sep = if spaceBeforeSep then
              " " ^ sep
            else
              sep in
  append sep layout

let rec flattenCommentAndSep ?spaceBeforeSep:(spaceBeforeSep=false) ?sep = function
  | WithEOLComment (txt, sub) ->
     begin
       match sep with
       | None -> append ~space:true (wrapComment txt) sub
       | Some sep -> append ~space:true (wrapComment txt)
                                   (appendSep spaceBeforeSep sep sub)
     end
  | Sequence (listConfig, [hd]) when hasComment hd ->
    Sequence (listConfig, [flattenCommentAndSep ~spaceBeforeSep ?sep hd])
  | SourceMap (loc, sub) ->
     SourceMap (loc, flattenCommentAndSep ~spaceBeforeSep ?sep sub)
  | layout ->
     begin
       match sep with
       | None -> layout
       | Some sep -> appendSep spaceBeforeSep sep layout
     end

let rec preOrderWalk f layout =
  match f layout with
  | Sequence (listConfig, sublayouts) ->
     let newSublayouts = List.map (preOrderWalk f) sublayouts in
     (Sequence (listConfig, newSublayouts))
  | Label (formatter, left, right) ->
     let newLeftLayout = preOrderWalk f left in
     let newRightLayout = preOrderWalk f right in
     Label (formatter, newLeftLayout, newRightLayout)
  | SourceMap (loc, sub) ->
     let newSub = preOrderWalk f sub in
     SourceMap (loc, newSub)
  | WithEOLComment (c, sub) ->
     let newSub = preOrderWalk f sub in
     WithEOLComment (c, newSub)
  | _ -> layout

(** Recursively unbreaks a layout to make sure they stay within the same line *)
let unbreaklayout = preOrderWalk (function
  | Sequence (listConfig, sublayouts) ->
    Sequence ({listConfig with break=Never}, sublayouts)
  | Label (formatter, left, right) ->
    Label (unbreakLabelFormatter formatter, left, right)
  | layout -> layout
)

(** [consolidateSeparator layout] walks the [layout], extract separators out of each
 *  list and insert them into PrintTree as separated items
 *)
let consolidateSeparator = preOrderWalk (function
  | Sequence (listConfig, sublayouts)
       when listConfig.sep <> ""
         && listConfig.sepLeft
    ->
     let layoutsWithSepAndComment =
       List.mapi (fun i layout ->
           (* Do not render the final separator *)
           if not listConfig.renderFinalSep && i + 1 = List.length sublayouts then
             flattenCommentAndSep ~spaceBeforeSep:listConfig.preSpace layout
           else
             flattenCommentAndSep ~spaceBeforeSep:listConfig.preSpace ~sep:listConfig.sep layout) sublayouts in
     let break = if List.exists hasComment sublayouts then
                   Always_rec
                 else
                   listConfig.break in
     let sep = "" in
     let preSpace = false in
     Sequence ({listConfig with sep; break; preSpace}, layoutsWithSepAndComment)
  | WithEOLComment _ as layout ->
     makeList ~inline:(true, true) ~postSpace:false ~preSpace:true ~indent:0
              ~break:Always_rec [flattenCommentAndSep layout]
  | layout -> layout
)

(** [insertLinesAboveItems layout] walkts the [layout] and insert empty lines
 *  based on the configuration of newlinesAboveItems
 *)
let insertLinesAboveItems = preOrderWalk (function
  | Sequence (listConfig, sublayouts)
       when listConfig.newlinesAboveItems <> 0
    ->
     let layoutsWithLinesInjected =
       List.map (insertBlankLines listConfig.newlinesAboveItems) sublayouts in
     Sequence ({listConfig with newlinesAboveItems=0}, layoutsWithLinesInjected)
  | layout -> layout
)

(** Union of two locations *)
let unionLoc loc1 loc2 =
  match (loc1, loc2) with
  | None, _ -> loc2
  | _, None -> loc1
  | Some loc1, Some loc2  -> Some {loc1 with loc_end = loc2.loc_end}

(** [getLocFromLayout] recursively takes the unioned location of its children,
 *  and returns the max one
 *)
let rec getLocFromLayout = function
  | Sequence (listConfig, subLayouts) ->
     let locs = List.map getLocFromLayout subLayouts in
     List.fold_left unionLoc None locs
  | Label (formatter, left, right) ->
     let leftLoc = getLocFromLayout left in
     let rightLoc = getLocFromLayout right in
     unionLoc leftLoc rightLoc
  | SourceMap (loc, _) ->
     Some loc
  | WithEOLComment (_, sub) ->
     getLocFromLayout sub
  | _ -> None

(**
 * Returns true if loc1 contains loc2
 *)
let containLoc loc1 loc2 =
  loc1.loc_start.Lexing.pos_cnum <= loc2.loc_start.Lexing.pos_cnum &&
  loc1.loc_end.Lexing.pos_cnum >= loc2.loc_end.Lexing.pos_cnum

(**
 * Returns true if loc1 is before loc2
 *)
let beforeLoc loc1 loc2 =
  loc1.loc_end.Lexing.pos_cnum <= loc2.loc_start.Lexing.pos_cnum

let attachEOLComment layout txt =
  WithEOLComment (txt, layout)


(**
 * Returns true if the layout's location contains loc
 *)
let layoutContainsLoc loc layout =
  match getLocFromLayout layout with
  | None -> false
  | Some subLoc -> containLoc subLoc loc


(**
 * Returns true if any of the subLayout's location contains loc
 *)
let anySublayoutContainLocation loc =
  List.exists (layoutContainsLoc loc)

let isDocComment (c, _, _) = String.length c > 0 && c.[0] == '*'

(**
 * prependSingleLineComment inserts a single line comment right above layout
 *)
let rec prependSingleLineComment ?newlinesAboveDocComments:(newlinesAboveDocComments=0) comment layout =
  let (txt, _, loc) = comment in
  match layout with
  | WithEOLComment (c, sub) ->
     WithEOLComment (c, prependSingleLineComment ~newlinesAboveDocComments comment sub)
  | SourceMap (loc, sub) ->
     SourceMap (loc, prependSingleLineComment ~newlinesAboveDocComments comment sub)
  | Sequence (config, hd::tl) when config.break = Always_rec->
     Sequence(config, (prependSingleLineComment ~newlinesAboveDocComments comment hd)::tl)
  | layout ->
     let withComment = breakline (formatComment ~locOpt:loc txt) layout in
     if isDocComment comment then
       insertBlankLines newlinesAboveDocComments withComment
     else
       withComment

(**
 * [looselyAttachComment layout comment] preorderly walks the layout and
 * find a place where the comment can be loosely attached to
 *)
let rec looselyAttachComment layout ((txt, _, commentLoc) as comment) =
  match layout with
  | SourceMap (loc, sub) ->
     SourceMap (loc, looselyAttachComment sub comment)
  | WithEOLComment (c, sub) ->
     WithEOLComment (c, looselyAttachComment sub comment)
  | Easy e ->
     inline ~postSpace:true layout (formatComment txt)
  | Sequence (listConfig, subLayouts) when anySublayoutContainLocation commentLoc subLayouts ->
     (* If any of the subLayout strictly contains this comment, recurse into to it *)
     let subLayouts = List.map (fun layout ->
                          if layoutContainsLoc commentLoc layout then
                            looselyAttachComment layout comment
                          else
                            layout
                        ) subLayouts in
     Sequence (listConfig, subLayouts)
  | Sequence (listConfig, subLayouts) when subLayouts == [] ->
    (* If there are no subLayouts (empty body), create a Sequence of just the comment *)
    Sequence (listConfig, [formatComment txt])
  | Sequence (listConfig, subLayouts) ->
     let (beforeComment, afterComment) = Syntax_util.pick_while (fun layout ->
                                             match getLocFromLayout layout with
                                             | None -> true
                                             | Some loc -> beforeLoc loc commentLoc
                                           ) subLayouts in
     let newSubLayout = match List.rev beforeComment with
       | [] ->
          prependSingleLineComment comment (List.hd afterComment) :: (List.tl afterComment)
       | hd::tl -> (attachEOLComment hd txt :: tl |> List.rev) @ afterComment
     in
     Sequence (listConfig, newSubLayout)
  | Label (formatter, left, right) ->
     let leftLoc = getLocFromLayout left in
     let rightLoc = getLocFromLayout right in
     let newLeft, newRight = match (leftLoc, rightLoc) with
       | (None, None) ->
          (left, looselyAttachComment right comment)
       | (_, Some loc2) when containLoc loc2 commentLoc ->
          (left, looselyAttachComment right comment)
       | (Some loc1, _) when containLoc loc1 commentLoc ->
          (looselyAttachComment left comment, right)
       | (Some loc1, Some loc2) when beforeLoc commentLoc loc1 ->
          (prependSingleLineComment comment left, right)
       | (Some loc1, Some loc2) when beforeLoc commentLoc loc2 ->
          (left, prependSingleLineComment comment right)
       | _ -> (left, attachEOLComment right txt)
     in
     Label (formatter, newLeft, newRight)

(**
 * [insertSingleLineComment layout comment] preorderly walks the layout and
 * find a place where the SingleLineComment can be fit into
 *)
let rec insertSingleLineComment layout comment =
  let (txt, _, commentLoc) = comment in
      match layout with
      | SourceMap (loc, sub) ->
         SourceMap (loc, insertSingleLineComment sub comment)
      | WithEOLComment (c, sub) ->
         WithEOLComment (c, insertSingleLineComment sub comment)
      | Easy e ->
         prependSingleLineComment comment layout
      | Sequence (listConfig, subLayouts) when subLayouts == [] ->
        (* If there are no subLayouts (empty body), create a Sequence of just the comment *)
        Sequence (listConfig, [formatComment txt])
      | Sequence (listConfig, subLayouts) ->
         let newlinesAboveDocComments = listConfig.newlinesAboveDocComments in
         let (beforeComment, afterComment) = Syntax_util.pick_while (fun layout ->
                                                 match getLocFromLayout layout with
                                                 | None -> true
                                                 | Some loc -> beforeLoc loc commentLoc
                                               ) subLayouts in
         begin
           match afterComment with
           | (* Nothing in the list is after comment, attach comment to the statement before the comment *)
           [] -> let revBeforeComment = List.rev beforeComment in
                 let lastItemBeforeComment = List.hd revBeforeComment in
                 Sequence (listConfig,  (List.rev
                                           (breakline lastItemBeforeComment (formatComment ~locOpt:commentLoc txt) :: (List.tl revBeforeComment))))
           | hd::tl ->
              let afterComment =
                match getLocFromLayout hd with
                | Some loc when containLoc loc commentLoc ->
                   insertSingleLineComment hd comment :: tl
                | Some loc ->
                   SourceMap (loc, (prependSingleLineComment ~newlinesAboveDocComments comment hd)) :: tl
                | _ ->
                   prependSingleLineComment ~newlinesAboveDocComments comment hd :: tl
              in
              Sequence (listConfig, beforeComment @ afterComment)
         end
      | Label (formatter, left, right) ->
         let leftLoc = getLocFromLayout left in
         let rightLoc = getLocFromLayout right in
         let newLeft, newRight = match (leftLoc, rightLoc) with
           | (None, None) ->
              (left, insertSingleLineComment right comment)
           | (_, Some loc2) when containLoc loc2 commentLoc ->
              (left, insertSingleLineComment right comment)
           | (Some loc1, _) when containLoc loc1 commentLoc ->
              (insertSingleLineComment left comment, right)
           | (Some loc1, Some loc2) when beforeLoc commentLoc loc1 ->
              (prependSingleLineComment comment left, right)
           | (Some loc1, Some loc2) when beforeLoc commentLoc loc2 ->
              (left, prependSingleLineComment comment right)
           | _ -> (left, breakline right (formatComment ~locOpt:commentLoc txt))
         in
         Label (formatter, newLeft, newRight)

let rec attachCommentToNodeRight layout ((txt, t, loc) as comment) =
  match layout with
  | Sequence (config, sub) when snd config.wrap <> "" ->
     Sequence ({config with wrap=(fst config.wrap, snd config.wrap ^ " " ^ (wrapComment txt))}, sub)
  | SourceMap (loc, sub) ->
     SourceMap (loc, attachCommentToNodeRight sub comment)
  | layout ->
     begin
       match t with
       | EndOfLine ->
          WithEOLComment (txt, layout)
       | _ ->
          inline ~postSpace:true layout (formatComment txt)
     end

let rec attachCommentToNodeLeft ((txt, _, loc) as comment) layout =
  match layout with
  | Sequence (config, sub) when snd config.wrap <> "" ->
     Sequence ({config with wrap=(wrapComment txt ^ " " ^ (fst config.wrap), snd config.wrap)}, sub)
  | SourceMap (loc, sub) ->
     SourceMap (loc, attachCommentToNodeLeft comment sub )
  | layout ->
     Label (inlineLabel, (formatComment txt), layout)

let isNone opt =
  match opt with
  | None -> true | _ -> false


(** [tryPerfectlyAttachComment layout comment] postorderly walk the [layout] and tries
 *  to perfectly attach a comment with a layout node.
 *
 *  Perfectly attach here means a comment's start location is equal to the node's end location
 *  and vice versa.
 *
 *  If the comment can be perfectly attached to any layout node, returns (newLayout, None),
 *  meaning the comment is consumed. Otherwise returns the (unchangedLayout, Some comment),
 *  meaning the comment is not consumed.
 *)
let rec tryPerfectlyAttachComment layout comment =
  match comment with
  | None -> layout, comment
  | Some ((s, t, commLoc) as c)  -> begin
     match layout with
     | Sequence (listConfig, subLayouts) ->
        let distributeCommentIntoSubLayouts (i, processed, newComment) layout =
          let (layout, newComment) = tryPerfectlyAttachComment layout newComment in
          i + 1, layout::processed, newComment
        in
        let (_, processed, consumed) = List.fold_left distributeCommentIntoSubLayouts
                                                      (0, [], comment) (List.rev subLayouts) in
        Sequence (listConfig, processed), consumed
     | Label (labelFormatter, left, right) ->
        let (newRight, comment) = tryPerfectlyAttachComment right comment in
        let (newLeft, comment) = tryPerfectlyAttachComment left comment in
        Label (labelFormatter, newLeft, newRight), comment
     | SourceMap (loc, subLayout) ->
        if loc.loc_end.Lexing.pos_lnum = loc.loc_start.Lexing.pos_lnum &&
             commLoc.loc_start.Lexing.pos_cnum = loc.loc_end.Lexing.pos_cnum then
          SourceMap (loc, makeList ~inline:(true, true) ~break:Always
                                   [unbreaklayout (attachCommentToNodeRight subLayout c)]), None
        else
          let (layout, comment) = tryPerfectlyAttachComment subLayout comment in
          begin
            match comment with
            | None -> (SourceMap (loc, layout), None)
            | Some ((s, t, commLoc) as comment)->
               if commLoc.loc_end.Lexing.pos_cnum = loc.loc_start.Lexing.pos_cnum  then
                 SourceMap (loc, attachCommentToNodeLeft comment layout), None
               else if commLoc.loc_start.Lexing.pos_cnum = loc.loc_end.Lexing.pos_cnum then
                 SourceMap (loc, attachCommentToNodeRight layout comment), None
               else
                 SourceMap (loc, layout), Some comment
          end
     | WithEOLComment (c, sub) ->
        let (processed, consumed) = tryPerfectlyAttachComment sub comment in
        WithEOLComment (c, processed), consumed
     | _ -> layout, comment
     end

(** [insertComment layout comment] inserts comment into layout*)
let insertComment layout comment =
  (* print_layout layout; *)
  let (txt, t, loc) = comment in
  let layout = match t with
  | Regular
  | EndOfLine ->
     let (layout, c) = tryPerfectlyAttachComment layout (Some comment) in
     begin
     match c with
     | None -> layout
     | Some _ -> looselyAttachComment layout comment
     end
  | SingleLine -> insertSingleLineComment layout comment
  in
  (* print_comments [comment]; *)
  (* print_layout layout; *)
  layout

(** [insertComments layout comments] inserts comments into layout*)
let insertComments = List.fold_left insertComment

(** [isSingleLineComment comment] checks if a comment is singleline comment*)
let isSingleLineComment (_, t, _) =
  match t with
  | SingleLine -> true | _ -> false

let rec layoutToEasyFormat_ = function
  | Sequence (listConfig, subLayouts) ->
     easyListWithConfig listConfig (List.map layoutToEasyFormat_ subLayouts)
  | Label (labelFormatter, left, right) ->
     labelFormatter (layoutToEasyFormat_ left) (layoutToEasyFormat_ right)
  | SourceMap (_, subLayout) ->
     layoutToEasyFormat_ subLayout
  | WithEOLComment (_, sub) ->
     layoutToEasyFormat_ sub
  | Easy e -> e

let layoutToEasyFormatNoComments layoutNode =
  layoutToEasyFormat_ layoutNode


let layoutToEasyFormat layoutNode comments =
  (* print_layout layoutNode; *)
  let layout = layoutNode in
  let revComments = List.rev comments in
  let (singleLineComments, nonSingleLineComments) = (List.partition isSingleLineComment revComments) in
  let layout = insertComments layout nonSingleLineComments in
  let layout = consolidateSeparator layout in
  let layout = insertComments layout singleLineComments in
  let layout = insertLinesAboveItems layout in
  let easyFormat= layoutToEasyFormat_ layout in
  (* print_easy_rec easyFormat; *)
  makeEasyList ~break:Always_rec ~indent:0 ~inline:(true, true) [easyFormat]

let partitionFinalWrapping listTester wrapFinalItemSetting x =
  let rev = List.rev x in
  match (rev, wrapFinalItemSetting) with
    | ([], _) -> raise (NotPossible "shouldnt be partitioning 0 label attachments")
    | (_, NeverWrapFinalItem) -> None
    | (last::revEverythingButLast, WrapFinalListyItemIfFewerThan max) ->
        if not (listTester last) || (List.length x) >= max then
          None
        else
          Some (List.rev revEverythingButLast, last)

let semiTerminated term = makeList ~interleaveComments:false [term; atom ";"]


(* postSpace is so that when comments are interleaved, we still use spacing rules. *)
let makeLetSequence letItems =
  makeList
    ~break:Always_rec
    ~inline:(true, false)
    ~wrap:("{", "}")
    ~newlinesAboveComments:0
    ~newlinesAboveItems:0
    ~newlinesAboveDocComments:1
    ~renderFinalSep:false
    ~postSpace:true
    ~sep:";"
    letItems

let makeLetSequenceSingleLine letItems =
  makeList
    ~break:IfNeed
    ~inline:(true, false)
    ~wrap:("{", "}")
    ~newlinesAboveComments:0
    ~newlinesAboveItems:0
    ~newlinesAboveDocComments:1
    ~renderFinalSep:false
    ~preSpace:true
    ~postSpace:true
    ~sep:";"
    letItems

let f = Format.std_formatter

(* postSpace is so that when comments are interleaved, we still use spacing rules. *)
let makeUnguardedLetSequence letItems =
  makeList
    ~break:Always_rec
    ~inline:(true, true)
    ~wrap:("", "")
    ~newlinesAboveComments:0
    ~indent:0
    ~newlinesAboveItems:0
    ~newlinesAboveDocComments:1
    ~renderFinalSep:false
    ~postSpace:true
    ~sep:";"
    letItems

let formatSimpleAttributed x y =
  makeList
    ~wrap:("(", ")")
    ~break:IfNeed
    ~indent:0
    ~postSpace:true
    [x; y;]

let formatAttributed x y =
  makeList
    ~break:IfNeed
    ~inline:(true, true)
    ~indent:0
    ~postSpace:true
    [x; y]

(* For when the type constraint should be treated as a separate breakable line item itself
   not docked to some value/pattern label.
   fun x
       y
       : retType => blah;
 *)
let formatJustTheTypeConstraint =
  (fun typ ->
     (makeList ~postSpace:false [atom ":"; typ]))

let formatTypeConstraint =
  (fun one two ->
    label ~space:true (makeList ~postSpace:false [one; atom ":"]) two)

let formatLabeledArgument =
  (fun lbl lblSuffix term ->
    if lbl = "" then
      (*
       * This logic helps avoid a line break to be added after "::"
       * ```
       * let f
       *   ::
       *     superLonglonglongnameArg => ...
       * ```
       * Instead, it prints it to
       * ```
       * let f
       *   :: superLonglonglongnameArg => ...
       * ```
       *
       *)
      makeList [atom lbl; atom ("::" ^ lblSuffix); term]
    else
      label ~space:false (makeList [atom lbl; atom ("::" ^ lblSuffix)]) term)

let formatCoerce expr optType coerced =
  match optType with
    | None ->
      label ~space:true (makeList ~postSpace:true [expr; atom ":>"]) coerced
    | Some typ ->
      label ~space:true (makeList ~postSpace:true [formatTypeConstraint expr typ; atom ":>"]) coerced


(* Standard function application style indentation - no special wrapping
 * behavior.
 *
 * Formats like this:
 *
 *   let result =
 *     someFunc
 *       (10, 20);
 *
 *
 * Instead of this:
 *
 *   let result =
 *     someFunc (
 *       10,
 *       20
 *     );
 *
 * The outer list wrapping fixes #566: format should break the whole
 * application before breaking arguments.
 *)
let formatIndentedApplication headApplicationItem argApplicationItems =
  makeList ~inline:(true, true) ~postSpace:true ~break:IfNeed [
    label
      ~space:true
      headApplicationItem
      (makeAppList argApplicationItems)
  ]


(* The loc, is an optional location or the returned app terms *)
let formatAttachmentApplication finalWrapping (attachTo: (bool * layoutNode) option) (appTermItems, loc) =
  let partitioning = finalWrapping appTermItems in
  let maybeSourceMap maybeLoc x =
    match maybeLoc with
      | None -> x
      | Some loc -> SourceMap (loc, x)
  in
  match partitioning with
    | None -> (
        match (appTermItems, attachTo) with
          | ([], _) -> raise (NotPossible "No app terms")
          | ([hd], None) -> maybeSourceMap loc hd
          | ([hd], (Some (useSpace, toThis))) -> label ~space:useSpace toThis (maybeSourceMap loc hd)
          | (hd::tl, None) ->
            maybeSourceMap loc (formatIndentedApplication hd tl)
          | (hd::tl, (Some (useSpace, toThis))) ->
            label
              ~space:useSpace
              toThis
              (maybeSourceMap loc (formatIndentedApplication hd tl))
      )
    | Some (attachedList, wrappedListy) -> (
        match (attachedList, attachTo) with
          | ([], Some (useSpace, toThis)) -> label ~space:useSpace toThis (maybeSourceMap loc wrappedListy)
          | ([], None) ->
            (* Not Sure when this would happen *)
            maybeSourceMap loc wrappedListy
          | (hd::tl, Some (useSpace, toThis)) ->
            (* TODO: Can't attach location to this - maybe rewrite anyways *)
            let attachedArgs = makeAppList attachedList in
              (label ~space:useSpace toThis (label
              ~space:true attachedArgs wrappedListy))

          | (hd::tl, None) ->
            (* Args that are "attached to nothing" *)
            let appList = makeAppList attachedList in
            maybeSourceMap loc (label ~space:true appList wrappedListy)
      )

(*
  Preprocesses an expression term for the sake of label attachments ([letx =
  expr]or record [field: expr]). Function application should have special
  treatment when placed next to a label. (The invoked function term should
  "stick" to the label in some cases). In others, the invoked function term
  should become a new label for the remaining items to be indented under.
 *)
let applicationFinalWrapping x =
  partitionFinalWrapping isSequencey settings.funcApplicationLabelStyle x

let curriedFunctionFinalWrapping x =
  partitionFinalWrapping isSequencey settings.funcCurriedPatternStyle x

let typeApplicationFinalWrapping typeApplicationItems =
  partitionFinalWrapping isSequencey settings.funcApplicationLabelStyle typeApplicationItems


(* add parentheses to binders when they are in fact infix or prefix operators *)
let protectIdentifier txt =
  if not (needs_parens txt) then atom txt
  else if needs_spaces txt then makeList ~interleaveComments:false ~wrap:("(", ")") ~pad:(true, true) [atom txt]
  else atom ("(" ^ txt ^ ")")

let protectLongIdentifier longPrefix txt =
  makeList ~interleaveComments:false [longPrefix; atom "."; protectIdentifier txt]

let paren: 'a . ?first:space_formatter -> ?last:space_formatter ->
  bool -> (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a -> unit
  = fun  ?(first=("": _ format6)) ?(last=("": _ format6)) b fu f x ->
    if b then (pp f "("; pp f first; fu f x; pp f last; pp f ")")
    else fu f x
let constant_string f s = pp f "%S" s
let tyvar f str = pp f "'%s" str
let constant f = function
  | Pconst_char i -> pp f "%C"  i
  | Pconst_string (i, None) -> pp f "%S" i
  | Pconst_string (i, Some delim) -> pp f "{%s|%s|%s}" delim i delim
  | Pconst_integer (i, None) -> paren (i.[0]='-') (fun f -> pp f "%s") f i
  | Pconst_integer (i, Some m) ->
    paren (i.[0]='-') (fun f (i, m) -> pp f "%s%c" i m) f (i,m)
  | Pconst_float (i, None) -> paren (i.[0]='-') (fun f -> pp f "%s") f i
  | Pconst_float (i, Some m) -> paren (i.[0]='-') (fun f (i,m) ->
      pp f "%s%c" i m) f (i,m)


let pun_labelled_expression e lbl =
  (match e with
    | { pexp_desc = (Pexp_ident { txt; _ }); _ } when txt = (Longident.parse lbl) -> ""
    | _ -> lbl )

let pun_labelled_pattern e lbl =
  (match e with
    | { ppat_desc = (Ppat_var { txt; _ }) } when txt = lbl -> ""
    | _ -> lbl )

let isLongIdentWithDot = function
  | Ldot _ -> true
  | _ -> false

let recordRowIsPunned pld =
      let name = pld.pld_name.txt in
      (match pld.pld_type with
        | { ptyp_desc = (Ptyp_constr ({ txt; _ }, args)); _}
            when
            (Longident.last txt = name
              (* Don't pun types from other modules, e.g. type bar = {foo: Baz.foo}; *)
              && isLongIdentWithDot txt == false
              (* don't pun parameterized types, e.g. {tag: tag 'props} *)
              && List.length args == 0) -> true
        | _ -> false)

class printer  ()= object(self:'self)
  val pipe = false
  val semi = false
  (* The test and first branch of ternaries must be guarded *)
  method under_pipe = {<pipe=true>}
  method under_semi = {<semi=true>}
  method reset_semi = {<semi=false>}
  method reset_pipe = {<pipe=false>}
  method reset = {<pipe=false;semi=false>}


  method longident = function
    | Lident s -> (protectIdentifier s)
    | Ldot(longPrefix, s) ->
        (protectLongIdentifier (self#longident longPrefix) s)
    | Lapply (y,s) -> makeList ~interleaveComments:false [self#longident y; atom "("; self#longident s; atom ")";]

  (* This form allows applicative functors. *)
  method longident_class_or_type_loc x = self#longident x.txt
  (* TODO: Fail if observing applicative functors for this form. *)
  method longident_loc (x:Longident.t Location.loc) = SourceMap (x.loc, self#longident (x.txt))
  method constant = wrap constant

  method constant_string = wrap constant_string
  method tyvar = wrap tyvar

  (* c ['a,'b] *)
  method class_params_def = function
    | [] -> atom ""
    | l ->
      makeList ~postSpace:true (List.map self#type_param l)

  (* This will fall through to the simple version. *)
  method non_arrowed_core_type x = self#non_arrowed_non_simple_core_type x

  method core_type2 x =
    let {stdAttrs} = partitionAttributes x.ptyp_attributes in
    if stdAttrs <> [] then
      formatAttributed
        (self#non_arrowed_simple_core_type {x with ptyp_attributes=[]})
        (self#attributes stdAttrs)
    else
      let rec allArrowSegments xx = match xx.ptyp_desc with
        | Ptyp_arrow (l, ct1, ct2) ->
            (self#type_with_label (l,ct1))::(allArrowSegments ct2)
        | _ -> [self#core_type2 xx]
      in
      match (x.ptyp_desc) with
        | (Ptyp_arrow (l, ct1, ct2)) ->
            let normalized =
              makeList ~break:IfNeed ~sep:"=>" ~preSpace:true ~postSpace:true ~inline:(true, true) (allArrowSegments x)
            in
            SourceMap (x.ptyp_loc, normalized)
        | Ptyp_poly (sl, ct) ->
            let poly =
              makeList ~break:IfNeed [
                makeList ~postSpace:true [
                  makeList ~postSpace:true (List.map (fun x -> self#tyvar x) sl);
                  atom ".";
                ];
                self#core_type ct;
              ]
            in SourceMap (x.ptyp_loc, poly)
        | _ -> self#non_arrowed_core_type x

  (* Same as core_type2 but can be aliased *)
  method core_type x =
    let {stdAttrs} = partitionAttributes x.ptyp_attributes in
    if stdAttrs <> [] then
      formatAttributed
        (self#non_arrowed_simple_core_type {x with ptyp_attributes=[]})
        (self#attributes stdAttrs)
    else match (x.ptyp_desc) with
      | (Ptyp_alias (ct, s)) ->
        SourceMap (
          x.ptyp_loc,
          (label
            ~space:true
            (self#core_type ct)
            (makeList ~postSpace:true [atom "as"; atom ("'" ^ s)])
          )
        )
      | _ -> self#core_type2 x

  method type_with_label (label, ({ptyp_desc} as c)) =
    match label with
    | Nolabel ->  self#non_arrowed_non_simple_core_type c (* otherwise parenthesize *)
    | Labelled s -> formatLabeledArgument s "" (self#non_arrowed_non_simple_core_type c)
    | Optional lbl ->
       let everythingButQuestion =
         formatLabeledArgument
           lbl
           ""
           (makeList
              ~postSpace:true
              ~break:IfNeed
              ~inline:(true, true)
              (* I don't think you'll have more than one l here. *)
              [self#non_arrowed_non_simple_core_type c]
            )
       in makeList [everythingButQuestion; atom "?"]

  method type_param (ct, a) =
    makeList [atom (type_variance a); self#core_type ct]

  (* According to the parse rule [type_declaration], the "type declaration"'s
   * physical location (as indicated by [td.ptype_loc]) begins with the
   * identifier and includes the constraints. *)
  method formatOneTypeDef prepend name assignToken ({ptype_params; ptype_kind; ptype_manifest; ptype_loc} as td) =
    let (equalInitiatedSegments, constraints) = (self#type_declaration_binding_segments td) in
    let formattedTypeParams = List.map self#type_param ptype_params in
    let binding = makeList ~postSpace:true (prepend::name::[]) in
    (*
        /-----------everythingButConstraints--------------  | -constraints--\
       /-innerL---| ------innerR--------------------------\
      /binding\     /typeparams\ /--equalInitiatedSegments-\
      type name      'v1    'v1  =  foo = private bar        constraint a = b
    *)

    let labelWithParams = match formattedTypeParams with
        [] -> binding
      | phd::ptl -> label ~space:true binding (makeList ~postSpace:true ~break:IfNeed ~inline:(true, true) (phd::ptl)) in
    let everythingButConstraints =
      let nameParamsEquals = makeList ~postSpace:true [labelWithParams; assignToken] in
      match equalInitiatedSegments with
        | [] -> labelWithParams
        | hd::hd2::hd3::tl -> raise (NotPossible "More than two type segments.")
        | hd::[] ->
            formatAttachmentApplication
              typeApplicationFinalWrapping
              (Some (true, nameParamsEquals))
              (hd, None)
        | hd::hd2::[] ->
            let first = makeList ~postSpace:true ~break:IfNeed ~inline:(true, true) (hd @ [atom "="]) in
            (*
             * Because we want a record as a label with the opening brace on the same line
             * and the closing brace indented at the beginning, we can't wrap it in a list here
             * Example:
             * type doubleEqualsRecord =
             *  myRecordWithReallyLongName = {   <- opening brace on the same line
             *    xx: int,
             *    yy: int
             *  };                               <- closing brace indentation
             *)
            let second = match ptype_kind with
              | Ptype_record _ -> List.hd hd2
              | _ -> makeList ~postSpace:true ~break:IfNeed ~inline:(true, true) hd2
            in
            label ~space:true nameParamsEquals (
              label ~space:true first second
            )
    in
    let everything =
      match constraints with
        | [] -> everythingButConstraints
        | hd::tl -> makeList ~break:IfNeed ~postSpace:true ~indent:0 ~inline:(true, true) (everythingButConstraints::hd::tl)
    in
    (SourceMap (ptype_loc, everything))

  method formatOneTypeExt prepend name assignToken te =
    let privateAtom = (atom "pri") in
    let privatize scope lst = match scope with
      | Public -> lst
      | Private -> privateAtom::lst in
    let equalInitiatedSegments =
      let segments = List.map self#type_extension_binding_segments te.ptyext_constructors in
      let privatized_segments = privatize te.ptyext_private segments in
      [makeList ~break:Always_rec ~postSpace:true ~inline:(true, true) privatized_segments] in
    let formattedTypeParams = List.map self#type_param te.ptyext_params in
    let binding = makeList ~postSpace:true (prepend::name::[]) in
    let labelWithParams = match formattedTypeParams with
        [] -> binding
      | phd::ptl -> label ~space:true binding (makeList ~postSpace:true ~break:IfNeed ~inline:(true, true) (phd::ptl)) in
    let everything =
      let nameParamsEquals = makeList ~postSpace:true [labelWithParams; assignToken] in
      formatAttachmentApplication
             typeApplicationFinalWrapping
             (Some (true, nameParamsEquals))
             (equalInitiatedSegments, None)
    in
    SourceMap (te.ptyext_path.loc, everything)

  method type_extension_binding_segments {pext_kind; pext_loc; pext_attributes; pext_name} =
    let normalize lst = match lst with
        | [] -> raise (NotPossible "should not be called")
        | [hd] -> hd
        | _::_ -> makeList ~break:Never ~postSpace:true lst
      in
      let add_bar name args =
        let lbl = label ~space:true name args in
        makeList ~postSpace:true [atom "|"; lbl]
      in
    let sourceMappedName = SourceMap (pext_name.loc, atom pext_name.txt) in
    let nameOf = makeList ~postSpace:true [sourceMappedName] in
    let barName = makeList ~postSpace:true [atom "|"; sourceMappedName] in
    let resolved = match pext_kind with
      | Pext_decl (ctor_args, gadt) ->
        let formattedArgs = match ctor_args with
          | Pcstr_tuple args -> List.map self#non_arrowed_simple_core_type args
          | Pcstr_record r -> [self#record_declaration r]
        in
        let formattedGadt = match gadt with
        | None -> None
        | Some x -> Some (
            makeList [
              formatJustTheTypeConstraint (self#core_type x)
            ]
          )
        in
        (formattedArgs, formattedGadt)
      (* type bar += Foo = Attr.Foo *)
      | Pext_rebind rebind ->
        let r = self#longident_loc rebind in
        let prepend = (atom "=") in
        ([makeList ~postSpace:true [prepend; r]], None)
    in
      (**
        The first element of the tuple represents constructor arguments,
        the second an optional formatted gadt.

        Case 1: No constructor arguments, neither a gadt
          type attr = ..;
          type attr += | Str

        Case 2: No constructor arguments, is a gadt
          type attr = ..;
          type attr += | Str :attr

        Case 3: Has Constructor args, not a gadt
          type attr  = ..;
          type attr += | Str string;
          type attr += | Point int int;

        Case 4: Has Constructor args & is a gadt
          type attr  = ..;
          type attr += | Point int int :attr;
      *)
    let everything = match resolved with
      | ([], None) -> barName
      | ([], Some gadt) -> add_bar sourceMappedName gadt
      | (ctorArgs, None) -> add_bar nameOf (normalize ctorArgs)
      | (ctorArgs, Some gadt) -> add_bar nameOf (normalize (ctorArgs@[gadt]))
    in
    (SourceMap (pext_loc, self#attach_std_attrs pext_attributes everything))

  (* shared by [Pstr_type,Psig_type]*)
  method type_def_list (rf, l) =
    (* As oposed to used in type substitution. *)
    let formatOneTypeDefStandard prepend td =
      let itm =
        self#formatOneTypeDef
          prepend
          (SourceMap (td.ptype_name.loc, (atom td.ptype_name.txt)))
          (atom "=")
          td
      in
      self#attach_std_item_attrs td.ptype_attributes itm
    in

    match l with
      | [] -> raise (NotPossible "asking for type list of nothing")
      | hd::tl ->
          let first =
            match rf with
            | Recursive -> formatOneTypeDefStandard (atom "type") hd
            | Nonrecursive ->
                formatOneTypeDefStandard (atom "type nonrec") hd
          in
          match tl with
            (* Exactly one type *)
            | [] -> first
            | tlhd::tltl -> makeList ~indent:0 ~inline:(true, true) ~break:Always_rec (
                first::(List.map (formatOneTypeDefStandard (atom "and")) (tlhd::tltl))
              )

  method type_variant_leaf ?opt_ampersand:(a=false) ?polymorphic:(p=false) = self#type_variant_leaf1 a p true
  method type_variant_leaf_nobar ?opt_ampersand:(a=false) ?polymorphic:(p=false) = self#type_variant_leaf1 a p false

  (* TODOATTRIBUTES: Attributes on the entire variant leaf are likely
   * not parsed or printed correctly. *)
  method type_variant_leaf1 opt_ampersand polymorphic print_bar x =
    let {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} = x in
    let {stdAttrs} = partitionAttributes pcd_attributes in
    let prefix = if polymorphic then "`" else "" in
    let sourceMappedName = SourceMap (pcd_name.loc, atom (prefix ^ pcd_name.txt)) in
    let nameOf = makeList ~postSpace:true [sourceMappedName] in
    let barName =
      let lst = if print_bar then [atom "|"; sourceMappedName] else [sourceMappedName] in
      makeList ~postSpace:true lst in
    let ampersand_helper i arg =
      let ct = self#non_arrowed_simple_core_type arg in
      let add_ampersand = label (atom "&") in
      if polymorphic then
        if i == 0 && not opt_ampersand then
          ct
        else
          add_ampersand ct
      else
        ct
    in
    let args = match pcd_args with
      | Pcstr_record r -> [self#record_declaration r]
      | Pcstr_tuple l -> List.mapi ampersand_helper l
    in
    let gadtRes = match pcd_res with
      | None -> None
      | Some x -> Some (
          makeList ~inline:(true, true) ~break:IfNeed [ (* Single row just so the entire return type breaks onto its own line *)
            formatJustTheTypeConstraint (self#core_type x)
          ]
      )
    in
    let normalize lst = match lst with
      | [] -> raise (NotPossible "should not be called")
      | [hd] -> hd
      | _::_ -> makeList ~inline:(true, true) ~break:IfNeed ~postSpace:true lst
    in
    (* In some cases (e.g. inline records) we want the label with bar & the gadt resolution
     * as a list.
     *   | If {
     *       pred: expr bool,
     *       true_branch: expr 'a,
     *       false_branch: expr 'a
     *     }                           ==> end of label
     *     :expr 'a;                   ==> gadt res
     * The label & the gadt res form two separate units combined into a list.
     * This is necessary to properly align the closing '}' on the same height as the 'If'.
     *)
    let add_bar ?gadt name args =
      let lbl = label ~space:true name args in
      let fullLbl = match gadt with
        | Some g -> makeList ~inline:(true, true) ~break:IfNeed ~postSpace:true [lbl; g]
        | None -> lbl
      in
      makeList ~postSpace:true (if print_bar then [atom "|"; fullLbl] else [fullLbl])
    in
    let everything = match (args, gadtRes) with
      | ([], None) -> barName
      | ([], Some gadt) -> add_bar sourceMappedName gadt
      | (_::_, None) -> add_bar nameOf (normalize args)
      | (_::_, Some gadt) ->
          (match pcd_args with
            | Pcstr_record _ -> add_bar ~gadt nameOf (normalize args)
            | _ -> add_bar nameOf (normalize (args@[gadt])))
    in
    let everythingWithAttrs =
      if stdAttrs <> [] then
        formatAttributed everything (self#attributes stdAttrs)
      else
        everything
    in
    (SourceMap (pcd_loc, everythingWithAttrs))

  method record_declaration ?assumeRecordLoc lbls =
    let recordRow pld =
      let hasPunning = recordRowIsPunned pld in
      let name = if hasPunning then
          SourceMap (pld.pld_name.loc, makeList [atom pld.pld_name.txt;])
        else
          SourceMap (pld.pld_name.loc, makeList [atom pld.pld_name.txt; atom ":"])
      in
      let withMutable =
        match pld.pld_mutable with
        | Immutable -> name
        | Mutable -> makeList ~postSpace:true [atom "mutable"; name]
      in
      let recordRow = if hasPunning then
          label withMutable (atom "")
        else
          label ~space:true withMutable (self#core_type pld.pld_type)
      in
      SourceMap (pld.pld_loc, recordRow)
    in
    let rows = List.map recordRow lbls in
    (* if a record has more than 2 rows, always break *)
    let break = if List.length rows >= 2 then Always_rec else IfNeed in
    let rowList = makeList ~wrap:("{", "}") ~sep:"," ~postSpace:true ~break rows in
    match assumeRecordLoc with
    | None -> rowList
    | Some loc -> SourceMap(loc, rowList)

  (* Returns the type declaration partitioned into three segments - one
     suitable for appending to a label, the actual type manifest
     and the list of constraints. *)
  method type_declaration_binding_segments x =
    (* Segments of the type binding (occuring after the type keyword) that
       should begin with "=". Zero to two total sections.
       This is just a straightforward reverse mapping from the original parser:
        type_kind:
            /*empty*/
              { (Ptype_abstract, Public, None) }
          | EQUAL core_type
              { (Ptype_abstract, Public, Some $2) }
          | EQUAL PRIVATE core_type
              { (Ptype_abstract, Private, Some $3) }
          | EQUAL constructor_declarations
              { (Ptype_variant(List.rev $2), Public, None) }
          | EQUAL PRIVATE constructor_declarations
              { (Ptype_variant(List.rev $3), Private, None) }
          | EQUAL private_flag BAR constructor_declarations
              { (Ptype_variant(List.rev $4), $2, None) }
          | EQUAL DOTDOT
              { (Ptype_open, Public, None) }
          | EQUAL private_flag LBRACE label_declarations opt_comma RBRACE
              { (Ptype_record(List.rev $4), $2, None) }
          | EQUAL core_type EQUAL private_flag opt_bar constructor_declarations
              { (Ptype_variant(List.rev $6), $4, Some $2) }
          | EQUAL core_type EQUAL DOTDOT
              { (Ptype_open, Public, Some $2) }
          | EQUAL core_type EQUAL private_flag LBRACE label_declarations opt_comma RBRACE
              { (Ptype_record(List.rev $6), $4, Some $2) }
    *)
    let privateAtom = (atom "pri") in
    let privatize scope lst = match scope with
      | Public -> lst
      | Private -> privateAtom::lst in

    let estimateRecordOpenBracePoint () =
      match x.ptype_params with
        | [] -> x.ptype_name.loc.loc_end
        | hd::tl ->
          (fst (List.nth x.ptype_params (List.length x.ptype_params - 1))).ptyp_loc.loc_end
    in

    let equalInitiatedSegments = match (x.ptype_kind, x.ptype_private, x.ptype_manifest) with
      (* /*empty*/ {(Ptype_abstract, Public, None)} *)
      | (Ptype_abstract, Public, None) -> [

        ]
      (* EQUAL core_type {(Ptype_abstract, Public, Some _)} *)
      | (Ptype_abstract, Public, Some y) -> [
          [self#core_type y]
        ]
      (* EQUAL PRIVATE core_type {(Ptype_abstract, Private, Some $3)} *)
      | (Ptype_abstract, Private, Some y) -> [
          [privateAtom; self#core_type y]
        ]
      (* EQUAL constructor_declarations {(Ptype_variant _., Public, None)} *)
      (* This case is redundant *)
      (* | (Ptype_variant lst, Public, None) -> [ *)
      (*     [makeSpacedBreakableInlineList (List.map type_variant_leaf lst)] *)
      (*   ] *)
      (* EQUAL PRIVATE constructor_declarations {(Ptype_variant _, Private, None)} *)
      | (Ptype_variant lst, Private, None) -> [
          [privateAtom; makeList ~break:IfNeed ~postSpace:true ~inline:(true, true) (List.map self#type_variant_leaf lst)]
        ]
      (* EQUAL private_flag BAR constructor_declarations {(Ptype_variant _, $2, None)} *)
      | (Ptype_variant lst, scope, None) ->  [
          privatize scope [makeList ~break:Always_rec ~postSpace:true ~inline:(true, true) (List.map self#type_variant_leaf lst)]
        ]
      (* EQUAL DOTDOT {(Ptype_open, Public, None)} *)
      | (Ptype_open, Public, None) -> [
          [atom ".."]
        ]
      (* Super confusing how record/variants' manifest is not actually the
         description of the structure. What's in the manifest in that case is
         the *second* EQUALS asignment. *)

      (* EQUAL private_flag LBRACE label_declarations opt_comma RBRACE {(Ptype_record _, $2, None)} *)
      | (Ptype_record lst, scope, None) ->
          let assumeRecordLoc = {loc_start = estimateRecordOpenBracePoint(); loc_end = x.ptype_loc.loc_end; loc_ghost = false} in
          [privatize scope [self#record_declaration ~assumeRecordLoc lst]]
      (* And now all of the forms involving *TWO* equals *)
      (* Again, super confusing how manifests of variants/records represent the
         structure after the second equals. *)
      (* ================================================*)


      (* EQUAL core_type EQUAL private_flag opt_bar constructor_declarations {
         (Ptype_variant _, _, Some _)} *)
      | (Ptype_variant lst, scope, Some mani) -> [
          [self#core_type mani];
          let variant = makeList ~break:IfNeed ~postSpace:true ~inline:(true, true) (List.map self#type_variant_leaf lst) in
          privatize scope [variant];
        ]

      (* EQUAL core_type EQUAL DOTDOT {(Ptype_open, Public, Some $2)} *)
      | (Ptype_open, Public, Some mani) -> [
          [atom ".."];
          [self#core_type mani];
        ]
      (* EQUAL core_type EQUAL private_flag LBRACE label_declarations opt_comma RBRACE
           {(Ptype_record _, $4, Some $2)} *)
      | (Ptype_record lst, scope, Some mani) ->
          let declaration = self#record_declaration lst in
          let record = match scope with
            | Public -> [declaration]
            | Private -> [label ~space:true privateAtom declaration]
          in
          [ [self#core_type mani]; record ]

      (* Everything else is impossible *)
      (* ================================================*)

      | (_, _, _ ) ->  raise (NotPossible "Encountered impossible type specification")
    in

    let makeConstraint (ct1, ct2, _) =
      let constraintEq = makeList ~postSpace:true [
        atom "constraint";
        self#core_type ct1;
        atom "=";
      ] in
      label ~space:true constraintEq (self#core_type ct2) in
    let constraints = List.map makeConstraint x.ptype_cstrs in
    (equalInitiatedSegments, constraints)

  method non_arrowed_non_simple_core_type x =
    let {stdAttrs} = partitionAttributes x.ptyp_attributes in
    if stdAttrs <> [] then
      formatAttributed
        (self#non_arrowed_simple_core_type {x with ptyp_attributes=[]})
        (self#attributes stdAttrs)
    else
      match x.ptyp_desc with
    (* This significantly differs from the standard OCaml printer/parser:
       Type constructors are no longer simple *)
    | Ptyp_constr (li, l) ->

      (*
         The single identifier has to be wrapped in a [ensureSingleTokenSticksToLabel] to
         avoid (@see @avoidSingleTokenWrapping):
      *)
      let constr = match l with
        (* [ensureSingleTokenSticksToLabel] loses location information which is important
           when you are embedded inside a list and comments are to be interleaved around you.
           Therefore, we wrap the result in the correct [SourceMap].
         *)
        | [] -> SourceMap (li.loc, ensureSingleTokenSticksToLabel (self#longident_loc li))
        | hd::tl ->
            let sourceMappedIdent = SourceMap (li.loc, self#longident_loc li) in

            let typeList = match tl with
              | [] -> self#non_arrowed_simple_core_type hd
              | _ ->
                 let simpleTypeList = (List.map (self#non_arrowed_simple_core_type) (hd::tl)) in
                 (makeList ~inline:(true, true) ~postSpace:true ~break:IfNeed simpleTypeList)
            in
            (label ~space:true sourceMappedIdent typeList)
      in
      (* It's actually better without this source mapped *)
      constr
    | _ -> self#non_arrowed_simple_core_type x

  method non_arrowed_simple_core_type x =
    let {stdAttrs} = partitionAttributes x.ptyp_attributes in
    if stdAttrs <> [] then
      formatSimpleAttributed
        (self#non_arrowed_simple_core_type {x with ptyp_attributes=[]})
        (self#attributes stdAttrs)
    else
      let result =
        match x.ptyp_desc with
        (*   LPAREN core_type_comma_list RPAREN %prec below_NEWDOT *)
        (*       { match $2 with *)
        (*         | [] -> raise Parse_error *)
        (*         | one::[] -> one *)
        (*         | moreThanOne -> mktyp(Ptyp_tuple(List.rev moreThanOne)) } *)
        | Ptyp_tuple l ->
            makeList ~wrap:("(",")") ~sep:"," ~postSpace:true ~break:IfNeed (List.map (self#core_type) l)
        | Ptyp_object (l, o) ->
          let core_field_type (s, attrs, ct) =
            let l = extractStdAttrs attrs in
            (match l with
              | [] -> label ~space:true
                      (label ~space:true (atom s) (atom ":"))
                      (self#core_type ct)
              | _::_ ->
                makeList
                  ~postSpace:true
                  ~break:IfNeed
                  [atom s; (self#attributes attrs); atom ":"; self#core_type ct]
            )
          in
          let openness = match o with
            | Closed -> [atom "."]
            | Open -> [atom ".."]
          in
          let rows = List.map core_field_type l in
          makeList ~break:IfNeed ~preSpace:(List.length rows > 0) ~wrap:("{", "}") (openness @ [makeList ~break:IfNeed ~inline:(true, (List.length rows > 0)) ~postSpace:true ~sep:"," rows])
        | Ptyp_package (lid, cstrs) ->
          let typeConstraint (s, ct) =
            label
              (makeList ~break:IfNeed ~postSpace:true [atom "type"; self#longident_loc s; atom "="])
              (self#core_type ct)
          in
          (
            match cstrs with
              | [] ->
                makeList ~wrap:("(", ")") [
                  (makeList ~postSpace:true [atom "module"; self#longident_loc lid])
                ]
              | _ ->
                makeList ~wrap:("(", ")") [
                  label ~space:true
                    (makeList ~postSpace:true [atom "module"; self#longident_loc lid])
                    (makeList
                      ~break:IfNeed
                      ~sep:" and"
                      ~wrap:("with", "")
                      ~pad:(true, false)
                      (List.map typeConstraint cstrs))
                ]
          )
        (*   | QUOTE ident *)
        (*       { mktyp(Ptyp_var $2) } *)
        | Ptyp_var s -> ensureSingleTokenSticksToLabel (self#tyvar s)
        (*   | UNDERSCORE *)
        (*       { mktyp(Ptyp_any) } *)
        | Ptyp_any -> ensureSingleTokenSticksToLabel (atom "_")
        (*   | type_longident *)
        (*       { mktyp(Ptyp_constr(mkrhs $1 1, [])) } *)
        | Ptyp_constr (li, []) ->
            (* Only simple if zero type paramaters *)
            ensureSingleTokenSticksToLabel (self#longident_loc li)
        | Ptyp_variant (l, closed, low) ->
          let pcd_loc = x.ptyp_loc in
          let pcd_attributes = x.ptyp_attributes in
          let pcd_res = None in
          let variant_helper rf =
            match rf with
              | Rtag (label, attrs, opt_ampersand, ctl) ->
                let pcd_name = {
                  txt = label;
                  loc = pcd_loc;
                } in
                let pcd_args = Pcstr_tuple ctl in
                let all_attrs = List.concat [pcd_attributes; attrs] in
                self#type_variant_leaf ~opt_ampersand ~polymorphic:true {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes = all_attrs}
              | Rinherit ct -> self#core_type ct in
          let (designator, tl) =
            match (closed,low) with
              | (Closed,None) -> ("", [])
              | (Closed,Some tl) -> ("<", tl)
              | (Open,_) -> (">", []) in
          let node_list = List.map variant_helper l in
          let ll = (List.map (fun t -> atom ("`" ^ t)) tl) in
          let tag_list = makeList ~postSpace:true ~break:IfNeed ((atom ">")::ll) in
          let type_list = if List.length tl != 0 then node_list@[tag_list] else node_list in
          makeList ~wrap:("[" ^ designator,"]") ~pad:(true, false) ~postSpace:true ~break:IfNeed type_list
        | Ptyp_class (li, l) ->
          (match l with
            | [] -> makeList [atom "#"; self#longident_loc li]
            | _::_ ->
              label
                ~space:true
                (makeList [atom "#"; self#longident_loc li])
                (makeList ~postSpace:true ~inline:(true, false) (List.map self#core_type l))
          )
        | Ptyp_extension e -> self#extension e
        | Ptyp_constr (_, _::_)
        | Ptyp_arrow (_, _, _)
        | Ptyp_alias (_, _)
        | Ptyp_poly (_, _) ->
            makeList ~wrap:("(",")") ~break:IfNeed [self#core_type x]
      in
      SourceMap (x.ptyp_loc, result)
  (* TODO: ensure that we have a form of desugaring that protects *)
  (* when final argument of curried pattern is a type constraint: *)
  (* | COLON non_arrowed_core_type EQUALGREATER expr
      { mkexp_constraint $4 (Some $2, None) }         *)
  (*                         \----/   \--/
                             constraint coerce

                             Creates a ghost expression:
                             mkexp_constraint | Some t, None -> ghexp(Pexp_constraint(e, t))
  *)

  method pattern_list_split_cons acc = function
    | {
      ppat_desc = Ppat_construct (
        { txt = Lident("::"); loc=consLoc },
        Some {ppat_desc = Ppat_tuple ([pat1; pat2])}
      )
    } ->
        self#pattern_list_split_cons (pat1::acc) pat2
    | p -> (List.rev acc), p

  (*
   * Adds parens to the right sub-tree when it is not a single node:
   *
   * A | B                   is formatted as    A | B
   * A | (B | C)             is formatted as    A | (B | C)
   *
   * Also, adds parens to both sub-trees when both of them
   * are not a single node:
   * (A | B) | (C | D)       is formatted as    A | B | (C | D)
   * A | B | (C | D)         is formatted as    A | B | (C | D)
   * (A | B) | C             is formatted as    A | B | C
   * A | B | C               is formatted as    A | B | C
   *
   *)
  method or_pattern p1 p2 =
    let (p1_raw, p2_raw) = (self#pattern p1, self#pattern p2) in
    let (left, right) =
      match p2.ppat_desc with
        | Ppat_or _ -> (p1_raw, formatPrecedence p2_raw)
        | _ -> (p1_raw, p2_raw)
    in
    makeList
      ~break:IfNeed
      ~inline:(true, true)
      ~sep:"|"
      ~postSpace:true
      ~preSpace:true
      [left; right]

  method pattern_without_or x =
    let patternSourceMap pt layout = (SourceMap (pt.ppat_loc, layout)) in
    (* TODOATTRIBUTES: Handle the stdAttrs here *)
    let {arityAttrs} = partitionAttributes x.ppat_attributes in
    match x.ppat_desc with
      | Ppat_alias (p, s) ->
          let raw_pattern = (self#pattern p) in
          let pattern_with_precedence = match p.ppat_desc with
            | Ppat_or (p1, p2) -> formatPrecedence (self#or_pattern p1 p2)
            | _ -> raw_pattern
          in
          label ~space:true
            (patternSourceMap p pattern_with_precedence)
            (makeList ~postSpace:true [
              atom "as";
              (SourceMap (s.loc, (protectIdentifier s.txt)))
            ]) (* RA*)
      | Ppat_variant (l, Some p) ->
          if arityAttrs != [] then
            raise (NotPossible "Should never see embedded attributes on poly variant")
          else
            let layout = (self#constructor_pattern ~polyVariant:true ~arityIsClear:true (atom ("`" ^ l)) p) in
            SourceMap (x.ppat_loc, layout)
      | Ppat_lazy p -> label ~space:true (atom "lazy") (self#simple_pattern p)
      | Ppat_construct (({txt} as li), po) when not (txt = Lident "::")-> (* FIXME The third field always false *)
          let liSourceMapped = SourceMap (li.loc, (self#longident_loc li)) in
          let formattedConstruction = match po with
            (* TODO: Check the explicit_arity field on the pattern/constructor
               attributes to determine if should desugar to an *actual* tuple. *)
            (* | Some ({ *)
            (*   ppat_desc=Ppat_tuple l; *)
            (*   ppat_attributes=[{txt="explicit_arity"; loc}] *)
            (* }) -> *)
            (*   label ~space:true (self#longident_loc li) (makeSpacedBreakableInlineList (List.map self#simple_pattern l)) *)
            | Some xx ->
                let arityIsClear = isArityClear arityAttrs in
                self#constructor_pattern ~arityIsClear liSourceMapped xx
            | None ->
                liSourceMapped

          in
            SourceMap (x.ppat_loc, formattedConstruction)
      | _ -> self#simple_pattern x

  method pattern x =
    let {arityAttrs; stdAttrs} = partitionAttributes x.ppat_attributes in
    if stdAttrs <> [] then
      formatAttributed
        (* Doesn't need to be simple_pattern because attributes are parse as
         * appyling to the entire "function application style" syntax preceeding them *)
        (self#pattern {x with ppat_attributes=arityAttrs})
        (self#attributes stdAttrs)
    else match x.ppat_desc with
      | Ppat_or (p1, p2) ->
        self#or_pattern p1 p2
      | _ -> self#pattern_without_or x

  method pattern_list_helper pat =
    let pat_list, pat_last = self#pattern_list_split_cons [] pat in
    match pat_last with
    | {ppat_desc = Ppat_construct ({txt=Lident "[]"},_)} -> (* [x,y,z] *)
        makeList ~break:IfNeed ~wrap:("[", "]") ~sep:"," ~postSpace:true (List.map self#pattern pat_list)
    | _ -> (* x::y *)
        makeES6List (List.map self#pattern pat_list) (self#pattern pat_last)

  method potentiallyConstrainedPattern1 x = match x.ppat_desc with
    | Ppat_constraint (p, ct) ->
        formatTypeConstraint (self#pattern p) (self#core_type ct)
    | _  -> self#pattern x

  method simple_pattern x =
    let {arityAttrs; stdAttrs} = partitionAttributes x.ppat_attributes in
    if stdAttrs <> [] then
      formatSimpleAttributed
        (self#simple_pattern {x with ppat_attributes=arityAttrs})
        (self#attributes stdAttrs)
    else
      let itm =
        match x.ppat_desc with
          | Ppat_construct (({loc; txt=Lident ("()"|"[]" as x)}), _) ->
              (* Patterns' locations might include a leading bar depending on the
               * context it was parsed in. Therefore, we need to include further
               * information about the contents of the pattern such as tokens etc,
               * in order to get comments to be distributed correctly.*)

              SourceMap (loc, (atom x))
          | Ppat_construct (({txt=Lident "::"}), po) ->
                self#pattern_list_helper x (* LIST PATTERN *)
          | Ppat_construct (({txt} as li), None) ->
              let liSourceMapped = SourceMap (li.loc, (self#longident_loc li)) in
              SourceMap (x.ppat_loc, liSourceMapped)
          | Ppat_any -> atom "_"
          | Ppat_var ({loc; txt = txt}) ->
            (*
               To prevent this:

                 let oneArgShouldWrapToAlignWith
                   theFunctionNameBinding => theFunctionNameBinding;

               And instead do:

                 let oneArgShouldWrapToAlignWith
                     theFunctionNameBinding => theFunctionNameBinding;

               We have to do something to the non "listy" patterns. Non listy
               patterns don't indent the same amount as listy patterns when docked
               to a label.

               If wrapping the non-listy pattern in [ensureSingleTokenSticksToLabel]
               you'll get the following (even though it should wrap)

                 let oneArgShouldWrapToAlignWith theFunctionNameBinding => theFunctionNameBinding;

             *)
              SourceMap (loc, (protectIdentifier txt))
          | Ppat_array l ->
              makeList ~wrap:("[|", "|]") ~break:IfNeed ~postSpace:true ~sep:"," (List.map self#pattern l)
          | Ppat_unpack (s) ->
              makeList ~wrap:("(", ")") ~break:IfNeed ~postSpace:true [atom "module"; atom s.txt]
          | Ppat_type li ->
              makeList [atom "#"; self#longident_loc li]
          | Ppat_record (l, closed) ->
              let longident_x_pattern (li, p) =
                match (li, p.ppat_desc) with
                  | ({txt=Lident s}, Ppat_var {txt}) when s = txt ->
                      self#longident_loc li
                  | _ ->
                      label ~space:true (makeList [self#longident_loc li; atom ":"]) (self#pattern p)
              in
              let rows = (List.map longident_x_pattern l)@(
                match closed with
                  | Closed -> []
                  | _ -> [atom "_"]
              ) in
              makeList ~wrap:("{", "}") ~break:IfNeed ~sep:"," ~postSpace:true rows
          | Ppat_tuple l ->
              makeList ~wrap:("(", ")") ~sep:"," ~postSpace:true ~break:IfNeed (List.map (self#potentiallyConstrainedPattern1) l)
          | Ppat_constant (c) -> (self#constant c)
          | Ppat_interval (c1, c2) -> makeList [self#constant c1; atom ".."; self#constant c2]
          | Ppat_variant (l, None) -> makeList[atom "`"; atom l]
          | Ppat_constraint (p, ct) ->
              formatPrecedence (formatTypeConstraint (self#pattern p) (self#core_type ct))
          | Ppat_lazy p ->formatPrecedence (label ~space:true (atom "lazy") (self#simple_pattern p))
          | Ppat_extension e -> self#extension e
          | Ppat_exception p ->
              (*
                An exception pattern with an alias should be wrapped in (...)
                The rules for what goes to the right of the exception are a little (too) nuanced.
                It accepts "non simple" parameters, except in the case of `as`.
                Here we consistently apply "simplification" to the exception argument.
                Example:
                  | exception (Sys_error _ as exc) => raise exc
                 parses correctly while
                  | Sys_error _ as exc => raise exc
                 results in incorrect parsing with type error otherwise.
              *)
               makeList ~postSpace:true [atom "exception"; self#simple_pattern p]
          | _ -> formatPrecedence (self#pattern x) (* May have a redundant sourcemap *)
        in
        SourceMap (x.ppat_loc, itm)

  method label_exp (l,opt,p) =
    match l with
    | Nolabel -> self#simple_pattern p (*single case pattern parens needed here *)
    | Optional lbl ->
        let lbl = pun_labelled_pattern p lbl in
        (formatLabeledArgument
           lbl ""
           (label
             (makeList [(self#simple_pattern p); atom "="])
             (match opt with None -> (atom "?") | Some o -> (self#simplifyUnparseExpr o))))
    | Labelled l ->
        let lbl = pun_labelled_pattern p l in
        formatLabeledArgument lbl "" (self#simple_pattern p)

  method access op cls e1 e2 = makeList ~interleaveComments:false [
    (* Important that this be not breaking - at least to preserve same
       behavior as stock desugarer. It might even be required (double check
       in parser.mly) *)
    e1;
    atom ".";
    atom op;
    e2;
    atom cls;
  ]

  method simple_get_application x =
    let {stdAttrs; jsxAttrs} = partitionAttributes x.pexp_attributes in
    match (x.pexp_desc, stdAttrs, jsxAttrs) with
    | (_, attrHd::attrTl, []) -> None (* Has some printed attributes - not simple *)
    | (Pexp_apply ({pexp_desc=Pexp_ident loc}, l), [], _jsx::_) -> (
      (* TODO: Soon, we will allow the final argument to be an identifier which
         represents the entire list. This would be written as
         `<tag>...list</tag>`. If you imagine there being an implicit [] inside
         the tag, then it would be consistent with array spread:
         [...list] evaluates to the thing as list.
      *)
      let hasLabelledChildrenListLiteral = List.exists (function
        | (Labelled "children", {pexp_desc = Pexp_construct ({txt = Lident "::" | Lident "[]"}, _)}) -> true
        | _ -> false
      ) l in
      let rec hasSingleNonLabelledUnitAndIsAtTheEnd l = match l with
      | [] -> false
      | (Nolabel, {pexp_desc = Pexp_construct ({txt = Lident "()"}, _)}) :: [] -> true
      | (Nolabel, _) :: rest -> false
      | _ :: rest -> hasSingleNonLabelledUnitAndIsAtTheEnd rest
      in
      if hasLabelledChildrenListLiteral && hasSingleNonLabelledUnitAndIsAtTheEnd l then
        let moduleNameList = List.rev (List.tl (List.rev (Longident.flatten loc.txt))) in
        if List.length moduleNameList > 0 then
          if Longident.last loc.txt = "createElement" then
            Some (self#formatJSXComponent (String.concat "." moduleNameList) l)
          else None
        else Some (self#formatJSXComponent (Longident.last loc.txt) l)
      else None
    )
    | (Pexp_apply (eFun, ls), [], []) -> (
      match (printedStringAndFixityExpr eFun, ls) with
      (* We must take care not to print two subsequent prefix operators without
         spaces between them (`! !` could become `!!` which is totally
         different).  *)
      | (AlmostSimplePrefix prefixStr, [(Nolabel, rightExpr)]) ->
        let forceSpace = match rightExpr.pexp_desc with
          | Pexp_apply (ee, lsls) ->
            (match printedStringAndFixityExpr ee with | AlmostSimplePrefix _ -> true | _ -> false)
          | _ -> false
        in
        let rightItm = self#simplifyUnparseExpr rightExpr in
        Some (label ~space:forceSpace (atom prefixStr) rightItm)
      | (Infix infixStr, [(_, leftExpr); (_, rightExpr)]) when infixStr.[0] = '#' ->
        (* Little hack. We check the right expression to see if it's also a SHARPOP, if it is
           we call `formatPrecedence` on the result of `simplifyUnparseExpr` to add the appropriate
           parens. This is done because `unparseExpr` doesn't seem to be able to handle
           high enough precedence things. Using the normal precedence handling, something like

              ret #= (Some 10)

            gets pretty printed to

              ret #= Some 10

            Which seems to indicate that the pretty printer doesn't think `#=` is of
            high enough precedence for the parens to be worth adding back. *)
        let rightItm = (
          match rightExpr.pexp_desc with
          | Pexp_apply (eFun, ls) -> (
            match (printedStringAndFixityExpr eFun, ls) with
              | (Infix infixStr, [(_, _); (_, _)]) when infixStr.[0] = '#' -> formatPrecedence (self#simplifyUnparseExpr rightExpr)
              | _ -> self#simplifyUnparseExpr rightExpr
          )
          | _ -> self#simplifyUnparseExpr rightExpr
        ) in
        Some (makeList [self#simple_enough_to_be_lhs_dot_send leftExpr; atom infixStr; rightItm])
      | (_, _) -> (
        match (eFun, ls) with
        | ({pexp_desc = Pexp_ident {txt = Ldot (Lident ("String"),"get")}}, [(_,e1);(_,e2)]) ->
          Some (self#access "[" "]" (self#simple_enough_to_be_lhs_dot_send e1) (self#unparseExpr e2))
        | ({pexp_desc = Pexp_ident {txt = Ldot (Lident ("Array"),"get")}}, [(_,e1);(_,e2)]) ->
          Some (self#access "(" ")" (self#simple_enough_to_be_lhs_dot_send e1) (self#unparseExpr e2))
        | (
            {pexp_desc= Pexp_ident {txt=Ldot (Ldot (Lident "Bigarray", "Genarray" ), "get")}},
            [(_,a); (_,{pexp_desc=Pexp_array ls})]
          ) ->
          let formattedList = List.map self#simplifyUnparseExpr ls in
          Some (self#access "{" "}" (self#simple_enough_to_be_lhs_dot_send a) (makeCommaBreakableList formattedList))
        | ({pexp_desc= Pexp_ident {txt=Ldot (Ldot (Lident "Bigarray", ("Array1"|"Array2"|"Array3")), "get")}}, (_,a)::rest) ->
          let formattedList = List.map self#simplifyUnparseExpr (List.map snd rest) in
          Some (self#access "{" "}" (self#simple_enough_to_be_lhs_dot_send a) (makeCommaBreakableList formattedList))
        | _ -> None
      )
    )
    | _ ->  None

  (** Detects "sugar expressions" (sugar for array/string setters) and returns their separate
      parts.  *)
  method sugar_set_expr_parts e =
    if e.pexp_attributes <> [] then None
    (* should also check attributes underneath *)
    else match e.pexp_desc with
      | Pexp_apply ({pexp_desc=Pexp_ident{txt=Ldot (Lident ("Array"), "set")}}, [(_,e1);(_,e2);(_,e3)]) ->
        Some (self#access "(" ")" (self#simple_enough_to_be_lhs_dot_send e1) (self#unparseExpr e2), e3)
      | Pexp_apply ({pexp_desc=Pexp_ident {txt=Ldot (Lident "String", "set")}}, [(_,e1);(_,e2);(_,e3)]) ->
        Some ((self#access "[" "]" (self#simple_enough_to_be_lhs_dot_send e1) (self#unparseExpr e2)), e3)
      | Pexp_apply (
        {pexp_desc=Pexp_ident {txt = Ldot (Ldot (Lident "Bigarray", array), "set")}},
        label_exprs
      ) -> (
        match array with
          | "Genarray" -> (
            match label_exprs with
            | [(_,a);(_,{pexp_desc=Pexp_array ls});(_,c)] ->
              let formattedList = List.map self#simplifyUnparseExpr ls in
              Some (self#access "{" "}" (self#simple_enough_to_be_lhs_dot_send a) (makeCommaBreakableList formattedList), c)
            | _ -> None
          )
          | ("Array1"|"Array2"|"Array3") -> (
            match label_exprs with
            | (_,a)::rest -> (
              match List.rev rest with
              | (_,v)::rest ->
                let args = List.map snd (List.rev rest) in
                let formattedList = List.map self#simplifyUnparseExpr args in
                Some (self#access "{" "}" (self#simple_enough_to_be_lhs_dot_send a) (makeCommaBreakableList formattedList), v)
              | _ -> assert false
            )
            | _ -> assert false
          )
          | _ -> None
        )
      | _ -> None

  (*

     How would we know not to print the sequence without { }; protecting the let a?

                            let a
                             |
                           sequence
                          /        \
                    let a           print a
                    alert a
     let res = {
       let a = something();
       {                     \
         alert(a);           | portion to be parsed as a sequence()
         let a = 20;         | The final ; print(a) causes the entire
         alert(a);           | portion to be parsed as a sequence()
       };                    |
       print (a);            /
     }

     ******************************************************************
     Any time the First expression of a sequence is another sequence, or (as in
     this case) a let, wrapping the first sequence expression in { } is
     required.
     ******************************************************************
  *)

  (**
     TODO: Configure the optional ability to print the *minimum* number of
     parens. It's simply a matter of changing [higherPrecedenceThan] to
     [higherOrEqualPrecedenceThan].
   *)

  (* Ensures a rule doesn't reduce until *after* `reducesAfterRight` gets a chance
     to reduce. Example: The addtion rule which has precedence of rightmost
     token "+", in `x + a * b` should not reduce until after the a * b gets
     a chance to reduce. This function would determine the minimum parens to
     ensure that. *)
  method ensureContainingRule ~withPrecedence ~reducesAfterRight =
    match self#unparseExprRecurse reducesAfterRight with
    | (SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, rightRecurse)) ->
      if higherPrecedenceThan shiftPrecedence withPrecedence then rightRecurse
      else if (higherPrecedenceThan withPrecedence shiftPrecedence) then
        formatPrecedence ~loc:reducesAfterRight.pexp_loc rightRecurse
      else (
        if isRightAssociative withPrecedence then
          rightRecurse
        else
          formatPrecedence ~loc:reducesAfterRight.pexp_loc rightRecurse
      )
    | FunctionApplication itms ->
      formatAttachmentApplication applicationFinalWrapping None (itms, Some reducesAfterRight.pexp_loc)
    | PotentiallyLowPrecedence itm -> formatPrecedence ~loc:reducesAfterRight.pexp_loc itm
    | Simple itm -> itm

  method ensureExpression expr ~reducesOnToken =
    match self#unparseExprRecurse expr with
    | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, leftRecurse) ->
      if higherPrecedenceThan reducePrecedence reducesOnToken then leftRecurse
      else if higherPrecedenceThan reducesOnToken reducePrecedence then
        formatPrecedence ~loc:expr.pexp_loc leftRecurse
      else (
        if isLeftAssociative reducesOnToken then
          leftRecurse
        else
          formatPrecedence ~loc:expr.pexp_loc leftRecurse
      )
    | FunctionApplication itms -> formatAttachmentApplication applicationFinalWrapping None (itms, Some expr.pexp_loc)
    | PotentiallyLowPrecedence itm -> formatPrecedence ~loc:expr.pexp_loc itm
    | Simple itm -> itm


  (** Attempts to unparse: The beginning of a more general printing algorithm,
      that determines how to print based on precedence of tokens and rules.
      The end goal is that this should be completely auto-generated from the
      Menhir parsing tables. We could move more and more into this function.

      You could always just call self#expression, but `unparseExpr` will render
      infix/prefix/unary/terary fixities in their beautiful forms while
      minimizing parenthesis.
  *)
  method unparseExpr x =
    match self#unparseExprRecurse x with
    | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, itm) -> itm
    | FunctionApplication itms -> formatAttachmentApplication applicationFinalWrapping None (itms, Some x.pexp_loc)
    | PotentiallyLowPrecedence itm -> itm
    | Simple itm -> itm

  method simplifyUnparseExpr x =
    match self#unparseExprRecurse x with
    | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, itm) -> formatPrecedence ~loc:x.pexp_loc itm
    | FunctionApplication itms ->
      formatPrecedence ~loc:x.pexp_loc (formatAttachmentApplication applicationFinalWrapping None (itms, Some x.pexp_loc))
    | PotentiallyLowPrecedence itm -> formatPrecedence ~loc:x.pexp_loc itm
    | Simple itm -> itm

  method unparseExprApplicationItems x =
    match self#unparseExprRecurse x with
    | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, itm) -> ([itm], Some x.pexp_loc)
    | FunctionApplication itms -> (itms, Some x.pexp_loc)
    | PotentiallyLowPrecedence itm -> ([itm], Some x.pexp_loc)
    | Simple itm -> ([itm], Some x.pexp_loc)

  method unparseExprRecurse x =
    (* If there are any attributes, render unary like `(~-) x [@ppx]`, and infix like `(+) x y [@attr]` *)
    let {arityAttrs; stdAttrs; jsxAttrs} = partitionAttributes x.pexp_attributes in
    (* If there's any attributes, recurse without them, then apply them to
       the ends of functions, or simplify infix printings then append. *)
    if stdAttrs <> [] then
      let withoutVisibleAttrs = {x with pexp_attributes=(arityAttrs @ jsxAttrs)} in
      let attributesAsList = (List.map self#attribute stdAttrs) in
      let itms = match self#unparseExprRecurse withoutVisibleAttrs with
        | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, itm) -> [formatPrecedence ~loc:x.pexp_loc itm]
        | FunctionApplication itms -> itms
        | PotentiallyLowPrecedence itm -> [formatPrecedence ~loc:x.pexp_loc itm]
        | Simple itm -> [itm]
      in
      FunctionApplication [
        makeList
          ~break:IfNeed
          ~inline:(true, true)
          ~indent:0
          ~postSpace:true
          (List.concat [itms; attributesAsList])
      ]
    else
    match self#simplest_expression x with
    | Some se -> Simple se
    | None ->
    match x.pexp_desc with
    | Pexp_apply (e, ls) -> (
      match (self#sugar_set_expr_parts x) with
      (* Returns None if there's attributes - would render as regular function *)
      (* Format as if it were an infix function application with identifier "=" *)
      | Some (simplyFormatedLeftItm, rightExpr) -> (
        let tokenPrec = Token updateToken in
        let rightItm = self#ensureContainingRule ~withPrecedence:tokenPrec ~reducesAfterRight:rightExpr in
        let leftWithOp = makeList ~postSpace:true [simplyFormatedLeftItm; atom updateToken] in
        let expr = label ~space:true leftWithOp rightItm in
        SpecificInfixPrecedence ({reducePrecedence=tokenPrec; shiftPrecedence=tokenPrec}, expr)
      )
      | None -> (
        match (printedStringAndFixityExpr e, ls) with
        | (Infix printedIdent, [(Nolabel, leftExpr); (Nolabel, rightExpr)]) ->
          let infixToken = Token printedIdent in
          let rightItm = self#ensureContainingRule ~withPrecedence:infixToken ~reducesAfterRight:rightExpr in
          let leftItm = self#ensureExpression leftExpr ~reducesOnToken:infixToken in
          let leftWithOp = makeList ~postSpace:true [leftItm; atom printedIdent] in
          let indent = infixTokenRequiresIndent printedIdent in
          let expr = label ~space:true ?indent leftWithOp rightItm in
          SpecificInfixPrecedence ({reducePrecedence=infixToken; shiftPrecedence=infixToken}, expr)
        (* Will be rendered as `(+) a b c` which is parsed with higher precedence than all
           the other forms unparsed here.*)
        | (UnaryPlusPrefix printedIdent, [(Nolabel, rightExpr)]) ->
          let prec = Custom "prec_unary_plus" in
          let rightItm = self#ensureContainingRule ~withPrecedence:prec ~reducesAfterRight:rightExpr in
          let expr = label ~space:true (atom printedIdent) rightItm in
          SpecificInfixPrecedence ({reducePrecedence=prec; shiftPrecedence=Token printedIdent}, expr)
        | (UnaryMinusPrefix printedIdent, [(Nolabel, rightExpr)]) ->
          let prec = Custom "prec_unary_minus" in
          let rightItm = self#ensureContainingRule ~withPrecedence:prec ~reducesAfterRight:rightExpr in
          let expr = label ~space:true (atom printedIdent) rightItm in
          SpecificInfixPrecedence ({reducePrecedence=prec; shiftPrecedence=Token printedIdent}, expr)
        (* Will need to be rendered in self#expression as (~-) x y z. *)
        | (_, _) ->
        (* This case will happen when there is something like

             Bar.createElement a::1 b::2 [] [@bla] [@JSX]

           At this point the bla will be stripped (because it's a visible
           attribute) but the JSX will still be there.
         *)
        (* If there was a JSX attribute BUT JSX component wasn't detected,
           that JSX attribute needs to be pretty printed so it doesn't get
           lost
         *)
        let maybeJSXAttr = (match jsxAttrs with
          | [] -> []
          | jsx -> (List.map self#attribute jsx)
        ) in
        let theFunc = SourceMap (e.pexp_loc, (self#simplifyUnparseExpr e)) in
        (*reset here only because [function,match,try,sequence] are lower priority*)
        let theArgs = List.map self#reset#label_x_expression_param ls in
        FunctionApplication (theFunc::theArgs @ maybeJSXAttr)
      )
    )
    | Pexp_construct (li, Some eo) when not (is_simple_construct (view_expr x)) -> (
        match view_expr x with
        (* TODO: Explicit arity *)
        | `normal ->
            let arityIsClear = isArityClear arityAttrs in
            FunctionApplication [self#constructor_expression ~arityIsClear stdAttrs (self#longident_loc li) eo]
        | _ -> assert false
      )
    | Pexp_variant (l, Some eo) ->
        if arityAttrs != [] then
          raise (NotPossible "Should never see embedded attributes on poly variant")
        else
          FunctionApplication [self#constructor_expression ~polyVariant:true ~arityIsClear:true stdAttrs (atom ("`" ^ l)) eo]
    (* TODO: Should protect this identifier *)
    | Pexp_setinstvar (s, rightExpr) ->
      let rightItm = self#ensureContainingRule ~withPrecedence:(Token updateToken) ~reducesAfterRight:rightExpr in
      let expr = label ~space:true (makeList ~postSpace:true [(protectIdentifier s.txt); atom updateToken]) rightItm in
      SpecificInfixPrecedence ({reducePrecedence=(Token updateToken); shiftPrecedence=(Token updateToken)}, expr)
    | Pexp_setfield (leftExpr, li, rightExpr) ->
      let rightItm = self#ensureContainingRule ~withPrecedence:(Token updateToken) ~reducesAfterRight:rightExpr in
      let leftItm =
        label
          (makeList ~interleaveComments:false [self#simple_enough_to_be_lhs_dot_send leftExpr; atom "."])
          (self#longident_loc li) in
      let expr = label ~space:true (makeList ~postSpace:true [leftItm; atom updateToken]) rightItm in
      SpecificInfixPrecedence ({reducePrecedence=(Token updateToken); shiftPrecedence=(Token updateToken)}, expr)
    | Pexp_match (e, l) when detectTernary l != None -> (
      match detectTernary l with
      | None -> raise (Invalid_argument "Impossible")
      | Some (tt, ff) ->
        let ifTrue = self#unparseExpr tt in
        let testItm = self#ensureExpression e ~reducesOnToken:(Token "?") in
        let ifFalse = self#ensureContainingRule ~withPrecedence:(Token ":") ~reducesAfterRight:ff in
        let withQuestion = SourceMap (e.pexp_loc, makeList ~postSpace:true [testItm; atom "?"]) in
        let trueFalseBranches =
          makeList ~inline:(true, true) ~break:IfNeed ~sep:":" ~postSpace:true ~preSpace:true [ifTrue; ifFalse]
        in
        let expr = label ~space:true withQuestion trueFalseBranches in
        SpecificInfixPrecedence ({reducePrecedence=Token ":"; shiftPrecedence=Token "?"}, expr)
    )
    | _ -> (
      match self#expression_requiring_parens_in_infix x with
      | Some e -> PotentiallyLowPrecedence e
      | None -> raise (Invalid_argument "No match for unparsing expression")
    )

  (*
     It's not enough to only check if precedence of an infix left/right is
     greater than the infix itself. We also should likely pay attention to
     left/right associativity. So how do we render the minimum number of
     parenthesis?

     The intuition is that sequential right associative operators will
     naturally build up deep trees on the right side (left builds up left-deep
     trees). So by default, we add parens to model the tree structure that
     we're rendering except when the parser will *naturally* parse the tree
     structure that the parens assert.

     Sequential identical infix operators:
     ------------------------------------
     So if we see a nested infix operator of precedence Y, as one side of
     another infix operator that has the same precedence (Y), that is S
     associative on the S side of the function application, we don't need to
     wrap in parens. In more detail:

     -Add parens around infix binary function application
       Exception 1: Unless we are a left-assoc operator of precedence X in the left branch of an operator w/ precedence X.
       Exception 2: Unless we are a right-assoc operator of precedence X in the right branch of an operator w/ precedence X.
       Exception 3: Unless we are a _any_-assoc X operator in the _any_ branch of an Y operator where X has greater precedence than Y.

     Note that the exceptions do not specify any special cases for mixing
     left/right associativity. Precedence is what determines necessity of
     parens for operators with non-identical precedences. Associativity
     only determines necessity of parens for identically precedented operators.

     PLUS is left assoc:
     - So this one *shouldn't* expand into two consecutive infix +:


            [Pexp_apply]
              /      \
         first +   [Pexp_apply]
                      /   \
                  second + third


     - This one *should*:

                    [Pexp_apply]
                      /      \
           [  Pexp_apply  ] + third
              /     \
           first +  second



     COLONCOLON is right assoc, so
     - This one *should* expand into two consecutive infix ::  :

            [Pexp_apply]
              /      \
         first ::   [Pexp_apply]
                      /   \
                  second :: third


     - This one *shouldn't*:

                    [Pexp_apply]
                      /      \
           [  Pexp_apply  ] :: third
              /     \
           first ::  second




     Sequential differing infix operators:
     ------------------------------------

     Neither of the following require paren grouping because of rule 3.


            [Pexp_apply]
              /      \
         first  +  [Pexp_apply]
                      /   \
                  second * third


                    [Pexp_apply]
                      /      \
            [Pexp_apply  +  third
              /     \
           first *  second

      The previous has nothing to do with the fact that + and * have the same
      associativity. Exception 3 applies to the following where :: is right assoc
      and + is left. + has higher precedence than ::

      - so parens aren't required to group + when it is in a branch of a
        lower precedence ::

            [Pexp_apply]
              /      \
         first ::   [Pexp_apply]
                      /   \
                  second + third


      - Whereas there is no Exception that applies in this case (Exception 3
        doesn't apply) so parens are required around the :: in this case.

                    [Pexp_apply]
                      /      \
           [  Pexp_apply  ] + third
              /     \
           first ::  second

  *)

  method classExpressionToFormattedApplicationItems x =
    let itms =
      match x.pcl_desc with
        | Pcl_apply (ce, l) ->
          (self#simple_class_expr ce)::
          (List.map self#label_x_expression_param l)
        | _ -> [self#class_expr x]
    in
    (itms, None)


  (**
        How JSX is formatted/wrapped. We want the attributes to wrap independently
        of children.

        <xxx
          attr1=blah
          attr2=foo>
          child
          child
          child
        </x>

      +-------------------------------+
      |  left   right (list of attrs) |
      |   / \   /   \                 |
      |   <tag                        |
      |     attr1=blah                |
      |     attr2=foo                 |
      +-------------------------------+
       |
       |
       |
       |      left       right  list of children with
       |   /       \    /  \     open,close = > </tag>
       |  +---------+
       +--|         |    >
          +---------+

          </tag>           *)
  method formatJSXComponent componentName args =
    let rec processArguments arguments processedAttrs children =
      match arguments with
      | (Labelled "children", {pexp_desc = Pexp_construct (_, None)}) :: tail ->
        processArguments tail processedAttrs None
      | (Labelled "children", {pexp_desc = Pexp_construct ({txt = Lident"::"}, Some {pexp_desc = Pexp_tuple(components)} )}) :: tail ->
        processArguments tail processedAttrs (self#formatChildren components [])
      | (Optional lbl, expression) :: tail ->
        let nextAttr = makeList ([atom lbl; atom "=?"; self#simplifyUnparseExpr expression]) in
        processArguments tail (nextAttr :: processedAttrs) children

      | (Labelled lbl, expression) :: tail ->
         let nextAttr =
           match expression.pexp_desc with
           | Pexp_ident (ident) when (not (isLongIdentWithDot ident.txt)
                                        && (Longident.last ident.txt) = lbl) -> atom lbl
           | Pexp_record _
           | Pexp_construct _
           | Pexp_array _
           | Pexp_tuple _
           | Pexp_match _
           | Pexp_extension _
           | Pexp_fun _
           | Pexp_apply _ -> label (makeList [atom lbl; atom "="]) (self#simplifyUnparseExpr expression)
           | _ -> makeList ([atom lbl; atom "="; self#simplifyUnparseExpr expression])
         in
         processArguments tail (nextAttr :: processedAttrs) children
      | [] -> (processedAttrs, children)
      | _ :: tail -> processArguments tail processedAttrs children
    in
    let (reversedAttributes, children) = processArguments args [] None in
    match children with
    | None ->
      makeList
        ~break:IfNeed
        ~wrap:("<" ^ componentName, "/>")
        ~pad:(true, true)
        ~inline:(false, false)
        ~postSpace:true
        (List.rev reversedAttributes)
    | Some renderedChildren ->
      let openTagAndAttrs =
        match reversedAttributes with
        | [] -> (atom ("<" ^ componentName ^ ">"))
        | revAttrHd::revAttrTl ->
          let finalAttrList = (List.rev (makeList ~break:Never [revAttrHd; atom ">"] :: revAttrTl)) in
          let renderedAttrList = (makeList ~inline:(true, true) ~break:IfNeed ~pad:(false, false) ~preSpace:true finalAttrList) in
          label
            ~space:true
            (atom ("<" ^ componentName))
            renderedAttrList
      in
      label
        openTagAndAttrs
        (makeList
          ~wrap:("", "</" ^ componentName ^ ">")
          ~inline:(true, false)
          ~break:IfNeed
          ~pad:(true, true)
          ~postSpace:true
          renderedChildren)


  (* Creates a list of simple module expressions corresponding to module
     expression or functor application. *)
  method moduleExpressionToFormattedApplicationItems x =
    let rec functorApplicationList xx = match xx.pmod_desc with
      | Pmod_apply (me1, me2) ->
          SourceMap (me2.pmod_loc, (self#simple_module_expr me2))::
            (functorApplicationList me1)
      | _ -> SourceMap (xx.pmod_loc, (self#module_expr xx))::[]
    in
    (List.rev (functorApplicationList x), None)


  (*

     Watch out, if you see something like below (sixteenTuple getting put on a
     newline), yet a paren-wrapped list wouldn't have had an extra newlin, you
     might need to wrap the single token (sixteenTuple) in [ensureSingleTokenSticksToLabel].
     let (
        axx,
        oxx,
        pxx
      ):
        sixteenTuple = echoTuple (
        0,
        0,
        0
      );
  *)

  method formatSimplePatternBinding labelOpener layoutPattern typeConstraint appTerms =
    let letPattern = label ~break:`Never ~space:true (atom labelOpener) layoutPattern in
    let upUntilEqual =
      match typeConstraint with
        | None -> letPattern
        | Some tc -> formatTypeConstraint letPattern tc
    in
    let includingEqual = makeList ~postSpace:true [upUntilEqual; atom "="] in
    formatAttachmentApplication applicationFinalWrapping (Some (true, includingEqual)) appTerms

  (* Only formats a type annotation for a value binding. *)
  method formatSimpleSignatureBinding labelOpener bindingPattern typeConstraint =
    let letPattern = (label ~space:true (atom labelOpener) bindingPattern) in
    (formatTypeConstraint letPattern typeConstraint)


  (*
     The [bindingLabel] is either the function name (if let binding) or first
     arg (if lambda).

     For defining layout of the following form:

         lbl one
             two
             constraint => {
           ...
         }

     If using "=" as the arrow, can also be used for:

         met private
             myMethod
             constraint = fun ...

   *)
  method wrapCurriedFunctionBinding
         ?(attachTo)
         ?(arrow="=>")
         prefixText
         bindingLabel
         patternList
         returnedAppTerms =
    let allPatterns = bindingLabel::patternList in
    let partitioning = curriedFunctionFinalWrapping allPatterns in
    let everythingButReturnVal = match settings.returnStyle with
        (*
         Because align_closing is set to false, you get:

         (Brackets[] inserted to show boundaries between open/close of pattern list)
         let[firstThing
             secondThing
             thirdThing]

         It only wraps to indent four by coincidence: If the "opening" token was
         longer, you'd get:

         letReallyLong[firstThing
                       secondThing
                       thirdThing]

         For curried let bindings, we stick the arrow in the *last* pattern:
         let[firstThing
             secondThing
             thirdThing =>]

         But it could have just as easily been the "closing" token corresponding to
         "let". This works because we have [align_closing = false]. The benefit of
         shoving it in the last pattern, is that we can turn [align_closing = true]
         and still have the arrow stuck to the last pattern (which is usually what we
         want) (See modeTwo below).
      *)
      | ReturnValOnSameLine -> (
          match partitioning with
            | None ->
                (* We want the binding label to break *with* the arguments. Again,
                   there's no apparent way to add additional indenting for the
                   args with this setting. *)

                (**
                   Formats lambdas by treating the first pattern as the
                   "bindingLabel" which is kind of strange in some cases (when
                   you only have one arg that wraps)...

                      echoTheEchoer (
                        fun (
                              a,
                              p
                            ) => (
                          a,
                          b
                        )

                   But it makes sense in others (where you have multiple args):

                      echoTheEchoer (
                        fun (
                              a,
                              p
                            )
                            mySecondArg
                            myThirdArg => (
                          a,
                          b
                        )

                   Try any other convention for wrapping that first arg and it
                   won't look as balanced when adding multiple args.

                *)
              makeList
                ~pad:(true, true)
                ~wrap:(prefixText, arrow)
                ~indent:(settings.space * settings.indentWrappedPatternArgs)
                ~postSpace:true
                ~inline:(true, true)
                ~break:IfNeed
                allPatterns
            | Some (attachedList, wrappedListy) ->
                (* To get *only* the final argument to "break", while not
                   necessarily breaking the prior arguments, we dock everything
                   but the last item to a created label *)
              label
                ~space:true
                (
                  makeList
                    ~pad:(true, true)
                    ~wrap:(prefixText, arrow)
                    ~indent:(settings.space * settings.indentWrappedPatternArgs)
                    ~postSpace:true
                    ~inline:(true, true)
                    ~break:IfNeed
                    attachedList
                )
                wrappedListy
        )
    in

    let everythingButAppTerms = match attachTo with
      | None -> everythingButReturnVal
      | Some toThis -> label ~space:true toThis everythingButReturnVal
    in
    formatAttachmentApplication
      applicationFinalWrapping
      (Some (true, everythingButAppTerms))
      returnedAppTerms

  method leadingCurriedAbstractTypes x =
    let rec argsAndReturn xx =
      match xx.pexp_desc with
        | Pexp_newtype (str,e) ->
            let (nextArgs, return) = argsAndReturn e in
            (str::nextArgs, return)
        | _ -> ([], xx.pexp_desc)
    in argsAndReturn x

  method curriedConstructorPatternsAndReturnVal cl =
    let rec argsAndReturn xx =
      if xx.pcl_attributes <> [] then ([], xx)
      else match xx.pcl_desc with
      | Pcl_fun (label, eo, p, e) ->
        let (nextArgs, return) = argsAndReturn e in
        if label=Nolabel then
          let args = SourceMap (p.ppat_loc, (self#simple_pattern p))::nextArgs in
          (args, return)
        else
          let args = SourceMap (p.ppat_loc, (self#label_exp (label, eo, p)))::nextArgs in
          (args, return)
      | _ -> ([], xx)
    in argsAndReturn cl


  (*
    Returns the arguments list (if any, that occur before the =>), and the
    final expression (that is either returned from the function (after =>) or
    that is bound to the value (if there are no arguments, and this is just a
    let pattern binding)).
  *)
  method curriedPatternsAndReturnVal x =
    let rec argsAndReturn xx =
      if xx.pexp_attributes <> [] then ([], xx)
      else match xx.pexp_desc with
        (* label * expression option * pattern * expression *)
        | Pexp_fun (label, eo, p, e) ->
            let (nextArgs, return) = argsAndReturn e in
            if label=Nolabel then
              let args = SourceMap (p.ppat_loc, (self#simple_pattern p))::nextArgs in
              (args, return)
            else
              let args = SourceMap (p.ppat_loc, (self#label_exp (label, eo, p)))::nextArgs in
              (args, return)
        | Pexp_newtype (newtype,e) -> newtypesAndReturn [newtype] e
        | _ -> ([], xx)
    and newtypesAndReturn newtypes xx =
      match xx.pexp_desc with
        | Pexp_newtype (newtype,e) when xx.pexp_attributes = [] ->
          newtypesAndReturn (newtype :: newtypes) e
        | _ ->
          let typeParamLayout =
            atom ("(type " ^ String.concat " " (List.rev newtypes) ^ ")") in
          let (nextArgs, return) = argsAndReturn xx in
          (typeParamLayout::nextArgs, return)
    in argsAndReturn x

  (* Returns the (curriedModule, returnStructure) for a functor *)
  method curriedFunctorPatternsAndReturnStruct me = match me.pmod_desc with
    (* string loc * module_type option * module_expr *)
    | Pmod_functor(s, mt, me2) ->
        let firstOne =
          match mt with
            | None -> atom "()"
            | Some mt' -> makeList ~wrap:("(",")") ~break:IfNeed [formatTypeConstraint (atom s.txt) (self#module_type mt')]
        in
        let (functorArgsRecurse, returnStructure) = (self#curriedFunctorPatternsAndReturnStruct me2) in
        (firstOne::functorArgsRecurse, returnStructure)
    | _ -> ([], me)

  method isRenderableAsPolymorphicAbstractTypes
         typeVars
         polyType
         leadingAbstractVars
         nonVarifiedType =
      same_ast_modulo_varification_and_extensions polyType nonVarifiedType &&
      trueForEachPair typeVars leadingAbstractVars (fun x y -> String.compare x y == 0)
  (* Reinterpret this as a pattern constraint since we don't currently have a
     way to disambiguate. There is currently a way to disambiguate a parsing
     from Ppat_constraint vs.  Pexp_constraint. Currently (and consistent with
     OCaml standard parser):

       let (x: typ) = blah;
         Becomes Ppat_constraint
       let x:poly . type = blah;
         Becomes Ppat_constraint
       let x:typ = blah;
         Becomes Pexp_constraint(ghost)
       let x = (blah:typ);
         Becomes Pexp_constraint(ghost)

     How are double constraints represented?
     let (x:typ) = (blah:typ);
     If currently both constraints are parsed into a single Pexp_constraint,
     then something must be lost, and how could you fail type checking on:
     let x:int = (10:string) ?? Answer: It probably parses into a nested
     Pexp_constraint.

     Proposal:

       let (x: typ) = blah;
         Becomes Ppat_constraint   (still)
       let x:poly . type = blah;
         Becomes Ppat_constraint   (still)
       let x:typ = blah;
         Becomes Ppat_constraint
       let x = blah:typ;
         Becomes Pexp_constraint


     Reasoning: Allows parsing of any of the currently valid ML forms, but
     combines the two most similar into one form. The only lossyness is the
     unnecessary parens, which there is already precedence for dropping in
     expressions. In the existing approach, preserving a paren-constrained
     expression is *impossible* because it becomes pretty printed as
     let x:t =.... In the proposal, it is not impossible - it is only
     impossible to preserve unnecessary parenthesis around the let binding.

     The one downside is that integrating with existing code that uses [let x =
     (blah:typ)] in standard OCaml will be parsed as a Pexp_constraint. There
     might be some lossiness (beyond parens) that occurs in the original OCaml
     parser.
  *)

  method locallyAbstractPolymorphicFunctionBinding prefixText layoutPattern funWithNewTypes absVars bodyType =
    let appTerms = self#unparseExprApplicationItems funWithNewTypes in
    let locallyAbstractTypes = (List.map atom absVars) in
    let typeLayout =
      SourceMap (bodyType.ptyp_loc, (self#core_type bodyType)) in
    let polyType =
      label
        ~space:true
        (* TODO: This isn't a correct use of sep! It ruins how
         * comments are interleaved. *)
        (makeList [makeList ~sep:" " (atom "type"::locallyAbstractTypes); atom "."])
        typeLayout
      in
    self#formatSimplePatternBinding
      prefixText
      layoutPattern
      (Some polyType)
      appTerms

  (**
      Intelligently switches between:
      Curried function binding w/ constraint on return expr:
         lbl patt
             pattAux
             arg
             :constraint => {
           ...
         }

      Constrained:
         lbl patt
             pattAux...
             :constraint = {
           ...
         }
   *)
  method wrappedBinding prefixText pattern patternAux expr =
    let (argsList, return) = self#curriedPatternsAndReturnVal expr in
    let patternList =
      match patternAux with
        | [] -> pattern
        | _::_ -> makeList ~postSpace:true ~inline:(true, true) ~break:IfNeed (pattern::patternAux)
    in
    match (argsList, return.pexp_desc) with
      | ([], Pexp_constraint (e, ct)) ->
          let typeLayout = SourceMap (ct.ptyp_loc, (self#core_type ct)) in
          let appTerms = self#unparseExprApplicationItems e in
          self#formatSimplePatternBinding prefixText patternList (Some typeLayout) appTerms
      | ([], _) ->
          let appTerms = self#unparseExprApplicationItems expr  in
          self#formatSimplePatternBinding prefixText patternList None appTerms
      | (_::_, _) ->
          let (argsWithConstraint, actualReturn) = self#normalizeFunctionArgsConstraint argsList return in
          let fauxArgs =
            List.concat [patternAux; argsWithConstraint] in
          let returnedAppTerms = self#unparseExprApplicationItems actualReturn in
          self#wrapCurriedFunctionBinding prefixText pattern fauxArgs returnedAppTerms

  (* Similar to the above method. *)
  method wrappedClassBinding prefixText pattern patternAux expr =
    let (argsList, return) = self#curriedConstructorPatternsAndReturnVal expr in
    let patternList =
      match patternAux with
        | [] -> pattern
        | _::_ -> makeList ~postSpace:true ~inline:(true, true) ~break:IfNeed (pattern::patternAux)
    in
    match (argsList, return.pcl_desc) with
      | ([], Pcl_constraint (e, ct)) ->
          let typeLayout = SourceMap (ct.pcty_loc, (self#class_constructor_type ct)) in
          let appTerms = self#classExpressionToFormattedApplicationItems e in
          self#formatSimplePatternBinding prefixText patternList (Some typeLayout) appTerms
      | ([], _) ->
          let appTerms = self#classExpressionToFormattedApplicationItems expr in
          self#formatSimplePatternBinding prefixText patternList None appTerms
      | (_::_, _) ->
          let (argsWithConstraint, actualReturn) =
            self#normalizeConstructorArgsConstraint argsList return in
          let returnedAppTerms = self#classExpressionToFormattedApplicationItems actualReturn in
          let fauxArgs =
            List.concat [patternAux; argsWithConstraint] in
          self#wrapCurriedFunctionBinding prefixText pattern fauxArgs returnedAppTerms

  method binding {pvb_pat; pvb_expr=x} prefixText = (* TODO: print attributes *)
    match (pvb_pat.ppat_desc) with
      | (Ppat_var {txt}) ->
          let pattern = SourceMap (pvb_pat.ppat_loc, self#simple_pattern pvb_pat) in
          self#wrappedBinding prefixText pattern [] x
      (*
         Ppat_constraint is used in bindings of the form

            let (inParenVar:typ) = ...

         And in the case of let bindings for explicitly polymorphic type
         annotations (see parser for more details).

         See reason_parser.mly for explanation of how we encode the two primary
         forms of explicit polymorphic annotations in the parse tree, and how
         we must recover them here.
       *)
      | (Ppat_constraint(p, ty)) -> (
          (* Locally abstract forall types are *seriously* mangled by the parsing
             stage, and we have to be very smart about how to recover it.

              let df_locallyAbstractFuncAnnotated:
                type a b.
                  a =>
                  b =>
                  (inputEchoRecord a, inputEchoRecord b) =
                fun (input: a) (input2: b) => (
                  {inputIs: input},
                  {inputIs: input2}
                );

             becomes:

               let df_locallyAbstractFuncAnnotatedTwo:
                 'a 'b .
                 'a => 'b => (inputEchoRecord 'a, inputEchoRecord 'b)
                =
                 fun (type a) (type b) => (
                   fun (input: a) (input2: b) => ({inputIs: input}, {inputIs:input2}):
                     a => b => (inputEchoRecord a, inputEchoRecord b)
                 );
          *)
          let layoutPattern =
            SourceMap (pvb_pat.ppat_loc, (self#simple_pattern p)) in
          let leadingAbsTypesAndExpr = self#leadingCurriedAbstractTypes x in
          match (p.ppat_desc, ty.ptyp_desc, leadingAbsTypesAndExpr) with
            | (
                Ppat_var s,
                Ptyp_poly (typeVars, varifiedPolyType),
                (_::_ as absVars, Pexp_constraint(funWithNewTypes, nonVarifiedExprType))
              )
              when self#isRenderableAsPolymorphicAbstractTypes
                  typeVars
                  (* If even artificially varified - don't know until returns*)
                  varifiedPolyType
                  absVars
                  nonVarifiedExprType ->
              (*
                 We assume was the case whenever we see this pattern in the
                 AST, it was because the parser parsed the polymorphic locally
                 abstract type sugar.

                 Ppat_var..Ptyp_poly...Pexp_constraint:

                    let x: 'a 'b . 'a => 'b => 'b =
                      fun (type a) (type b) =>
                         (fun aVal bVal => bVal : a => b => b);

                 We need to be careful not to accidentally detect similar
                 forms, that cannot be printed as sugar.

                    let x: 'a 'b . 'a => 'b => 'b =
                      fun (type a) (type b) =>
                         (fun aVal bVal => bVal : int => int => int);

                 Should *NOT* be formatted as:

                    let x: type a b. int => int => int = fun aVal bVal => bVal;

                 The helper function
                 [same_ast_modulo_varification_and_extensions] was created to
                 help compare the varified constraint pattern body, and the
                 non-varified expression constraint type.

                 The second requirement that we check before assuming that the
                 sugar form is correct, is to make sure the list of type vars
                 corresponds to a leading prefix of the Pexp_newtype variables.
              *)
              self#locallyAbstractPolymorphicFunctionBinding
                prefixText
                layoutPattern
                funWithNewTypes
                absVars
                nonVarifiedExprType
            | _ ->
              let typeLayout = SourceMap (ty.ptyp_loc, (self#core_type ty)) in
              let appTerms = self#unparseExprApplicationItems x in
              self#formatSimplePatternBinding
                prefixText
                layoutPattern
                (Some typeLayout)
                appTerms
        )
      | (_) ->
          let layoutPattern =
            SourceMap (pvb_pat.ppat_loc, (self#pattern pvb_pat)) in
          let appTerms = self#unparseExprApplicationItems x in
          self#formatSimplePatternBinding prefixText layoutPattern None appTerms


  (* Ensures that the constraint is formatted properly for sake of function
     binding (formatted without arrows)
     let x y z : no_unguarded_arrows_allowed_here => ret;
   *)
  method normalizeFunctionArgsConstraint argsList return =
    match return.pexp_desc with
      | Pexp_constraint (e, ct) ->
        let typeLayout = SourceMap (ct.ptyp_loc, (self#non_arrowed_non_simple_core_type ct)) in
        (argsList@[formatJustTheTypeConstraint typeLayout], e)
      | _ -> (argsList, return)

  method normalizeConstructorArgsConstraint argsList return =
    match return.pcl_desc with
      | Pcl_constraint (e, ct) when return.pcl_attributes = [] ->
        let typeLayout = SourceMap (ct.pcty_loc, (self#non_arrowed_class_constructor_type ct)) in
        (argsList@[formatJustTheTypeConstraint typeLayout], e)
      | _ -> (argsList, return)

  method bindingsLocationRange l =
    let len = List.length l in
    let fstLoc = (List.nth l 0).pvb_loc in
    let lstLoc = (List.nth l (len - 1)).pvb_loc in
    {
      loc_start = fstLoc.loc_start;
      loc_end = lstLoc.loc_end;
      loc_ghost = false
    }

  method bindings (rf, l) =
    let firstLine = (
      match l with
        | [] -> raise (NotPossible "no bindings supplied")
        | x::[]
        | x::_ ->
          let label = match rf with
            | Nonrecursive -> "let"
            | Recursive -> "let rec" in
          SourceMap (x.pvb_loc, (self#binding x label))

    ) in
    let forEachRemaining = fun t -> SourceMap (t.pvb_loc, (self#binding t "and")) in
    let remainingBindings = (
      match l with
        | [] -> []
        | x::[] -> []
        | x::x2::xtl -> List.map forEachRemaining (x2::xtl)
    ) in
    match remainingBindings with
    | [] -> firstLine
    | _ ->
    makeList
      ~postSpace:true
      ~break:Always
      ~indent:0
      ~inline:(true, true)
      (firstLine::remainingBindings)

  method letList exprTerm =
    match (exprTerm.pexp_attributes, exprTerm.pexp_desc) with
      | ([], Pexp_let (rf, l, e)) ->
        (* For "letList" bindings, the start/end isn't as simple as with
         * module value bindings. For "let lists", the sequences were formed
         * within braces {}. The parser relocates the first let binding to the
         * first brace. *)
         let bindingsLayout = (self#bindings (rf, l)) in
         let bindingsLoc = self#bindingsLocationRange l in
         let bindingsSourceMapped = SourceMap (bindingsLoc, bindingsLayout) in
         bindingsSourceMapped::(self#letList e)
      | ([], Pexp_open (ovf, lid, e)) ->
        let listItems = (self#letList e) in
        if (List.length listItems == 1) && ovf == Fresh then
            (* The following logic is a syntax sugar
             * for an 'open' expression that has only one let item.
             *
             * Instead of printing:
             * let result =  {
             *   open Fmt;
             *   strf
             *     "-pkgs %a"
             *     (list sep::(unit ",") string)
             * }
             *
             * We format as:
             *
             * let result = Fmt.(strf "-pkgs %a" (list sep::(unit ",") string))
             *
             * (Also see https://github.com/facebook/Reason/issues/114)
             *)
            let expression = match e.pexp_desc with
                (* syntax sugar for M.{x:1} *)
                | Pexp_record _
                (* syntax sugar for M.(a, b) *)
                | Pexp_tuple _
                (* syntax sugar for M.{} *)
                | Pexp_object {pcstr_fields = []}
                (* syntax sugar for M.[x,y] *)
                | Pexp_construct ( {txt= Lident"::"},Some _) ->
                    (self#simplifyUnparseExpr e)
                (* syntax sugar for the rest, wrap with parens to avoid ambiguity.
                 * E.g., avoid M.(M2.v) being printed as M.M2.v
                 *)
                | _ ->
                    (makeList ~wrap:("(",")") ~break:IfNeed listItems)
            in
            let openLayout = label
              (label (self#longident_loc lid) (atom (".")))
              expression
            in [openLayout]
         else
            let overrideStr = match ovf with | Override -> "!" | Fresh -> "" in
            let openLayout = label ~space:true
              (atom ("open" ^ overrideStr))
              (self#longident_loc lid)
            in
            (* Just like the bindings, have to synthesize a location since the
             * Pexp location is parsed (potentially) beginning with the open
             * brace {} in the let sequence. *)
            let openSourceMapped = SourceMap (lid.loc, openLayout) in
            openSourceMapped::listItems
      | ([], Pexp_letmodule (s, me, e)) ->
          let prefixText = "module" in
          let bindingName = atom ~loc:s.loc s.txt in
          let moduleExpr = me in
          let letModuleLayout =
            (self#let_module_binding prefixText bindingName moduleExpr) in
          let letModuleLoc = {
            loc_start = s.loc.loc_start;
            loc_end = me.pmod_loc.loc_end;
            loc_ghost = false
          } in
          (* Just like the bindings, have to synthesize a location since the
           * Pexp location is parsed (potentially) beginning with the open
           * brace {} in the let sequence. *)
          let letModuleSourceMapped = SourceMap (letModuleLoc, letModuleLayout) in
           letModuleSourceMapped::(self#letList e)
      | ([], Pexp_sequence (({pexp_desc=Pexp_sequence _ }) as e1, e2))
      | ([], Pexp_sequence (({pexp_desc=Pexp_let _      }) as e1, e2))
      | ([], Pexp_sequence (({pexp_desc=Pexp_open _     }) as e1, e2))
      | ([], Pexp_sequence (({pexp_desc=Pexp_letmodule _}) as e1, e2))
      | ([], Pexp_sequence (e1, e2)) ->
          let e1Layout = (self#unparseExpr e1) in
          (* It's kind of difficult to synthesize a location here in the case
           * where this is the first expression in the braces. We could consider
           * deeply inspecting the leftmost token/term in the expression. *)
          let e1SourceMapped = SourceMap (e1.pexp_loc, e1Layout) in
          e1SourceMapped::(self#letList e2)
      | _ ->
          let exprTermLayout = (self#unparseExpr exprTerm) in
          let exprTermSourceMapped = SourceMap (exprTerm.pexp_loc, exprTermLayout) in
          (* Should really do something to prevent infinite loops here. Never
             allowing a top level call into letList to recurse back to
             self#unparseExpr- top level calls into letList *must* be one of the
             special forms above whereas lower level recursive calls may be of
             any form. *)
          [exprTermSourceMapped]

  method constructor_expression ?(polyVariant=false) ~arityIsClear stdAttrs ctor eo =
    let (implicit_arity, arguments) =
      match eo.pexp_desc with
        | Pexp_tuple l when not polyVariant -> (
            let exprs = match (List.map self#simplifyUnparseExpr l) with
              | [] -> raise (NotPossible "no tuple items")
              | hd::[] -> hd
              | hd::tl as all -> makeSpacedBreakableInlineList all
            in
            (* There is no ambiguity when the number of tuple components is 1.
               We don't need put implicit_arity in that case *)
            (List.length l > 1 && not arityIsClear, exprs)
          )
        | _ -> (false, self#simplifyUnparseExpr eo)
    in
    let construction =
      label ~space:true
        ctor
        (if isSequencey arguments then arguments else (ensureSingleTokenSticksToLabel arguments))
    in
    let attrs =
      if implicit_arity && (not polyVariant) then
        ({txt="implicit_arity"; loc=eo.pexp_loc}, PStr []) :: stdAttrs
      else
        stdAttrs
    in
    match attrs with
      | [] -> construction
      | _::_ -> formatAttributed construction (self#attributes attrs)

  (* TODOATTRIBUTES: Handle stdAttrs here (merge with implicit_arity) *)
  method constructor_pattern ?(polyVariant=false) ~arityIsClear ctor po =
    let (implicit_arity, arguments) =
      match po.ppat_desc with
        | Ppat_tuple l when not polyVariant ->
            let exprs = match (List.map self#simple_pattern l) with
              | [] -> raise (NotPossible "no tuple items")
              | [hd] -> hd
              | hd::tl as all -> makeSpacedBreakableInlineList all
            in
              (* There is no ambiguity when the number of tuple components is 1.
               We don't need put implicit_arity in that case *)
            (List.length l > 1 && not arityIsClear, exprs)
        | _ -> (false, self#simple_pattern po)
    in
    let construction = label ~space:true
      ctor
      (if isSequencey arguments then arguments else (ensureSingleTokenSticksToLabel arguments)) in
    if implicit_arity && (not polyVariant) then
      formatAttributed construction (self#attributes [({txt="implicit_arity"; loc=po.ppat_loc}, PStr [])])
    else
      construction

  method patternFunction loc l =
    let estimatedFunLocation = {
        loc_start = loc.loc_start;
        loc_end = {loc.loc_start with pos_cnum = loc.loc_start.Lexing.pos_cnum + 3};
        loc_ghost = false;
    } in
    makeList
      ~postSpace:true
      ~break:IfNeed
      ~inline:(true, true)
      ~pad:(false, false)
      ((atom ~loc:estimatedFunLocation "fun") :: (self#case_list l))

  (* Expressions requiring parens, in most contexts such as separated by infix *)
  method expression_requiring_parens_in_infix x =
    let {stdAttrs} = partitionAttributes x.pexp_attributes in
    assert (stdAttrs == []);
    match x.pexp_desc with
      (* The only reason Pexp_fun must also be wrapped in parens when under
         pipe, is that its => token will be confused with the match token.
         Simple expression will also invoke `#reset`. *)
      | Pexp_function _ when pipe || semi -> None (* Would be rendered as simplest_expression  *)
      | Pexp_function l -> Some (self#patternFunction x.pexp_loc l)
      | _ ->
        (* The Pexp_function cases above don't use location because comment printing
          breaks for them. *)
        let itm = match x.pexp_desc with
          | Pexp_fun _
          | Pexp_newtype _ ->
            let (args, ret) = self#curriedPatternsAndReturnVal x in
            (match args with
            | [] -> raise (NotPossible ("no arrow args in unparse "))
            | firstArg::tl ->
              (* Suboptimal printing of parens:

                    something >>= fun x => x + 1;

                 Will be printed as:

                    something >>= (fun x => x + 1);

                 Because the arrow has lower precedence than >>=, but it wasn't
                 needed because

                    (something >>= fun x) => x + 1;

                 Is not a valid parse. Parens around the `=>` weren't needed to
                 prevent reducing instead of shifting. To optimize this part, we need
                 a much deeper encoding of the parse rules to print parens only when
                 needed, testing which rules will be reduced. It really should be
                 integrated deeply with Menhir.

                 One question is, if it's this difficult to describe when parens are
                 needed, should we even print them with the minimum amount?  We can
                 instead model everything as "infix" with ranked precedences.  *)
              let retValUnparsed = self#unparseExprApplicationItems ret in
              Some (self#wrapCurriedFunctionBinding "fun" firstArg tl retValUnparsed)
            )
          | Pexp_try (e, l) ->
            let estimatedBracePoint = {
              loc_start = e.pexp_loc.loc_end;
              loc_end = x.pexp_loc.loc_end;
              loc_ghost = false;
            }
            in
            let cases = (self#case_list ~allowUnguardedSequenceBodies:true l) in
            let switchWith = label ~space:true (atom "try") (self#reset#simplifyUnparseExpr e) in
            Some (
              label
                ~space:true
                switchWith
                (SourceMap (estimatedBracePoint, (makeList ~indent:settings.trySwitchIndent ~wrap:("{", "}") ~break:Always_rec ~postSpace:true cases)))
            )
          (* These should have already been handled and we should never havgotten this far. *)
          | Pexp_setinstvar (s, e) -> raise (Invalid_argument "Cannot handle setinstvar here - call unparseExpr")
          | Pexp_setfield (_, _, _) -> raise (Invalid_argument "Cannot handle setfield here - call unparseExpr")
          | Pexp_apply (e, l) -> raise (Invalid_argument "Cannot handle apply here - call unparseExpr")
          | Pexp_match (e, l) ->
             let estimatedBracePoint = {
               loc_start = e.pexp_loc.loc_end;
               loc_end = x.pexp_loc.loc_end;
               loc_ghost = false;
             }
             in
             let cases = (self#case_list ~allowUnguardedSequenceBodies:true l) in
             let switchWith = label ~space:true (atom "switch") (self#reset#simplifyUnparseExpr e) in
             let lbl =
               label
                 ~space:true
                 switchWith
                 (SourceMap (estimatedBracePoint, (makeList ~indent:settings.trySwitchIndent ~wrap:("{", "}") ~break:Always_rec ~postSpace:true cases)))
             in
             Some lbl
          | Pexp_ifthenelse (e1, e2, eo) ->
            let (blocks, finalExpression) = sequentialIfBlocks eo in
            let rec singleExpression exp =
              match exp.pexp_desc with
              | Pexp_ident _ -> true
              | Pexp_constant _ -> true
              | Pexp_construct (_, arg) ->
                (match arg with
                | None -> true
                | Some x -> singleExpression x)
              | _ -> false
            in
            let singleLineIf =
              (singleExpression e1) &&
              (singleExpression e2) &&
              (match eo with
               | Some expr -> singleExpression expr
               | None -> true
              )
            in
            let makeLetSequence =
              if singleLineIf then
                makeLetSequenceSingleLine
              else
                makeLetSequence
            in
            let rec sequence soFar remaining = (
              match (remaining, finalExpression) with
                | ([], None) -> soFar
                | ([], Some e) ->
                  let soFarWithElseAppended = makeList ~postSpace:true [soFar; atom "else"] in
                  label ~space:true soFarWithElseAppended (makeLetSequence (self#letList e))
                | (hd::tl, _) ->
                  let (e1, e2) = hd in
                  let soFarWithElseIfAppended =
                    label
                      ~space:true
                      (makeList ~postSpace:true [soFar; atom "else if"])
                      (self#simplifyUnparseExpr e1)
                  in
                  let nextSoFar =
                    label ~space:true soFarWithElseIfAppended (makeLetSequence (self#letList e2)) in
                  sequence nextSoFar tl
            ) in
            let init =
              label
                ~space:true
                (SourceMap (e1.pexp_loc, (label ~space:true (atom "if") (self#simplifyUnparseExpr e1))))
                (makeLetSequence (self#letList e2)) in
            Some (sequence init blocks)
          | Pexp_while (e1, e2) ->
            let lbl =
              label
                ~space:true
                (label ~space:true (atom "while") (self#simplifyUnparseExpr e1))
                (makeLetSequence (self#letList e2)) in
            Some lbl
          | Pexp_for (s, e1, e2, df, e3) ->
            (*
             *  for longIdentifier in
             *      (longInit expr) to
             *      (longEnd expr) {
             *    print_int longIdentifier;
             *  };
             *)
            let identifierIn = (makeList ~postSpace:true [self#pattern s; atom "in";]) in
            let dockedToFor =
                (makeList
                  ~break:IfNeed
                  ~postSpace:true
                  ~inline:(true, true)
                  [
                    identifierIn;
                    makeList ~postSpace:true [self#simplifyUnparseExpr e1; self#direction_flag df];
                    (self#simplifyUnparseExpr e2);
                  ]
                )
            in
            let upToBody = makeList ~inline:(true, true) ~postSpace:true [atom "for"; dockedToFor] in
            Some (label ~space:true upToBody (makeLetSequence (self#letList e3)))
          | Pexp_new (li) ->
            Some (label ~space:true (atom "new") (self#longident_class_or_type_loc li))
          | Pexp_assert e ->
            Some (
              label ~space:true
                (atom "assert")
                (self#reset#simplifyUnparseExpr e);
            )
          | Pexp_lazy (e) ->
              Some (label ~space:true (atom "lazy") (self#simplifyUnparseExpr e))
          | Pexp_poly _ ->
            failwith (
              "This version of the pretty printer assumes it is impossible to " ^
              "construct a Pexp_poly outside of a method definition - yet it sees one."
            )
          | _ -> None
        in
        match itm with
          | None -> None
          | Some i -> Some (SourceMap (x.pexp_loc, i))

  method potentiallyConstrainedExpr x =
    match x.pexp_desc with
      | Pexp_constraint (e, ct) ->
          formatTypeConstraint (self#unparseExpr e) (self#core_type ct)
      | _ -> self#unparseExpr x


  (*
   * Because the rule BANG simple_expr was given %prec below_DOT_AND_SHARP,
   * !x.y.z will parse as !(x.y.z) and not (!x).y.z.
   *
   *     !x.y.z == !((x.y).z)
   *     !x#y#z == !((x#y)#z)
   *
   * So the intuition is: In general, any simple expression can exist to the
   * left of a `.`, except `BANG simple_expr`, which has special precedence,
   * and must be guarded in this one case.
   *
   * TODO: Instead of special casing this here, we should continue to extend
   * unparseExpr to also unparse simple expressions, (by encoding the
   * rules precedence below_DOT_AND_SHARP).
   *
   * TODO:
   *  Some would even have the prefix application be parsed with lower
   *  precedence function *application*. In the case of !, where ! means not,
   *  it makes a lot of sense because (!identifier)(arg) would be meaningless.
   *
   *  !callTheFunction(1, 2, 3)(andEvenCurriedArgs)
   *
   * Only problem is that it could then not appear anywhere simple expressions
   * would appear.
   *
   * We could make a special case for ! followed by one simple expression, and
   * consider the result simple.
   *
   * Alternatively, we can figure out a way to not require simple expressions
   * in the most common locations such as if/while tests. This is really hard
   * (impossible w/ grammars Menhir supports?)
   *
   * if ! myFunc argOne argTwo {
   *
   * } else {
   *
   * };
   *
   *)
  method simple_enough_to_be_lhs_dot_send x = match x.pexp_desc with
    | (Pexp_apply (eFun, _)) -> (
      match printedStringAndFixityExpr eFun with
        | AlmostSimplePrefix _ ->
          SourceMap (x.pexp_loc, formatPrecedence (self#simplifyUnparseExpr x))
        | UnaryPlusPrefix _
        | UnaryMinusPrefix _
        | Infix _
        | Normal -> self#simplifyUnparseExpr x
    )
    | _ -> self#simplifyUnparseExpr x

  method unparseRecord ?withStringKeys:(withStringKeys=false) ?allowPunning:(allowPunning=true) l eo =
    let quote = (atom "\"") in
    let maybeQuoteFirstElem fst rest =
        if withStringKeys then (match fst.txt with
          | Lident s -> quote::(atom s)::quote::rest
          | Ldot _  | Lapply _ -> assert false
          )
        else
          (self#longident_loc fst)::rest
    in
    let makeRow (li, e) appendComma shouldPun =
      let comma = atom "," in
      let totalRowLoc = {
        loc_start = li.Asttypes.loc.loc_start;
        loc_end = e.pexp_loc.loc_end;
        loc_ghost = false;
      } in
      let theRow =
        match e.pexp_desc with
          (* Punning *)
          |  Pexp_ident {txt} when li.txt = txt && shouldPun && allowPunning ->
              makeList (maybeQuoteFirstElem li (if appendComma then [comma] else []))
          | _ ->
             let (argsList, return) = self#curriedPatternsAndReturnVal e in (
               match (argsList, return.pexp_desc) with
                 | ([], _) ->
                   let appTerms = self#unparseExprApplicationItems e in
                   let upToColon = makeList (maybeQuoteFirstElem li [atom ":"]) in
                   let labelExpr =
                     formatAttachmentApplication
                       applicationFinalWrapping
                       (Some (true, upToColon))
                       appTerms in
                   if appendComma then
                     makeList [labelExpr; comma;]
                   else
                     labelExpr
                 | (firstArg::tl, _) ->
                   let upToColon = makeList (maybeQuoteFirstElem li [atom ":"]) in
                   let returnedAppTerms = self#unparseExprApplicationItems return in
                   let labelExpr =
                       (self#wrapCurriedFunctionBinding ~attachTo:upToColon "fun" firstArg tl returnedAppTerms) in
                   if appendComma then makeList [labelExpr; comma;] else labelExpr
             )
      in SourceMap (totalRowLoc, theRow)
    in
    let rec getRows l =
      match l with
        | [] -> []
        | hd::[] -> [makeRow hd false true]
        | hd::hd2::tl -> (makeRow hd true true)::(getRows (hd2::tl))
    in

    let allRows = match eo with
      | None -> (
        match l with
          (* No punning (or comma) for records with only a single field. *)
          (* See comment in parser.mly for lbl_expr_list_with_at_least_one_non_punned_field *)
          | [hd] -> [makeRow hd false false]
          | _ -> getRows l
        )
      | Some withRecord ->
        let firstRow = (
          (* Unclear why "sugar_expr" was special cased here. *)
          let appTerms = self#unparseExprApplicationItems withRecord in
          let firstRowContents =
            formatAttachmentApplication applicationFinalWrapping (Some (false, (atom "..."))) appTerms in
          if l == [] then firstRowContents else makeList [firstRowContents; atom ","]
        ) in
        SourceMap (withRecord.pexp_loc, firstRow)::(getRows l)
    in
    makeList ~wrap:("{", "}") ~break:IfNeed ~preSpace:true allRows

  method simplest_expression x =
    let {stdAttrs; jsxAttrs} = partitionAttributes x.pexp_attributes in
    if stdAttrs <> [] then
      None
    else
      let item = match x.pexp_desc with
        (* The only reason Pexp_fun must also be wrapped in parens is that its =>
           token will be confused with the match token. *)
        | Pexp_fun _ when pipe || semi -> Some (self#reset#simplifyUnparseExpr x)
        | Pexp_function l when pipe || semi -> Some (formatPrecedence ~loc:x.pexp_loc (self#reset#patternFunction x.pexp_loc l))
        | Pexp_apply (e, l) -> (
          match self#simple_get_application x with
          (* If it's the simple form of application. *)
          | Some simpleGet -> Some simpleGet
          | None -> None
        )
        | Pexp_object cs ->
          let obj =
            makeList
              ~sep:";"
              ~wrap:("{", "}")
              ~break:IfNeed
              ~postSpace:true
              ~inline:(true, false)
              (self#class_self_pattern_and_structure cs) in
          Some obj
        | Pexp_override l -> (* FIXME *)
          let string_x_expression (s, e) =
            label ~space:true (atom (s.txt ^ ":")) (self#unparseExpr e)
          in
          Some (
            makeList
              ~postSpace:true
              ~wrap:("{<", ">}")
              ~sep:","
              (List.map string_x_expression l)
          )
        | Pexp_construct _  when is_simple_construct (view_expr x) ->
            let hasJsxAttribute = jsxAttrs != [] in
            Some (
              match view_expr x with
              | `nil -> if hasJsxAttribute then atom "<> </>" else atom "[]"
              | `tuple -> atom "()"
              | `list xs -> (* LIST EXPRESSION *)
                if hasJsxAttribute then
                  let actualChildren =
                    match self#formatChildren xs [] with
                    | None -> []
                    | Some ch -> ch
                  in
                    makeList
                      ~break:IfNeed
                      ~inline:(false, false)
                      ~postSpace:true
                      ~wrap:("<>", "</>")
                      ~pad:(true, true)
                      actualChildren
                else
                  makeList ~break:IfNeed ~wrap:("[", "]") ~sep:"," ~postSpace:true (List.map self#unparseExpr xs)
              | `cons xs ->
                let seq, ext = match List.rev xs with
                  | ext :: seq_rev -> (List.rev seq_rev, ext)
                  | [] -> assert false in
                 makeES6List (List.map self#unparseExpr seq) (self#unparseExpr ext)
              | `simple x -> self#longident x
              | _ -> assert false
            )
        | Pexp_ident li ->
            (* Lone identifiers shouldn't break when to the right of a label *)
            Some (ensureSingleTokenSticksToLabel (self#longident_loc li))
        | Pexp_constant c ->
            (* Constants shouldn't break when to the right of a label *)
            Some (ensureSingleTokenSticksToLabel (self#constant c))
        | Pexp_pack me ->
          Some (
            makeList
              ~break:IfNeed
              ~postSpace:true
              ~wrap:("(", ")")
              ~inline:(true, true)
              [atom "module"; self#module_expr me;]
          )
        | Pexp_tuple l ->
            (* TODO: These may be simple, non-simple, or type constrained
               non-simple expressions *)
          Some (
            makeList
              ~wrap:("(", ")")
              ~sep:","
              ~break:IfNeed
              ~postSpace:true
              (List.map self#potentiallyConstrainedExpr l)
          )
        | Pexp_constraint (e, ct) ->
          Some (
            makeList
              ~break:IfNeed
              ~wrap:("(", ")")
              [formatTypeConstraint (self#unparseExpr e) (self#core_type ct)]
          )
        | Pexp_coerce (e, cto1, ct) ->
            let optFormattedType = match cto1 with
              | None -> None
              | Some typ -> Some (self#core_type typ) in
            Some (
              makeList
                ~break:IfNeed
                ~wrap:("(", ")")
                [formatCoerce (self#unparseExpr e) optFormattedType (self#core_type ct)]
            )
        | Pexp_variant (l, None) ->
            Some (ensureSingleTokenSticksToLabel (atom ("`" ^ l)))
        | Pexp_record (l, eo) -> Some (self#unparseRecord l eo)
        | Pexp_array (l) ->
          Some (
            makeList
              ~break:IfNeed
              ~sep:","
              ~postSpace:true
              ~wrap:("[|", "|]")
              (List.map self#unparseExpr l)
          )
        | Pexp_let (rf, l, e) ->
            Some (makeLetSequence (self#letList x))
        | Pexp_letmodule (s, me, e) ->
            Some (makeLetSequence (self#letList x))
        | Pexp_open (ovf, lid, e) ->
            let letItems = (self#letList x) in
            (match letItems with
                (* if an open expression has only one letItem in the list,
                 * we don't wrap it in "{}" so it becomes something like:
                 *
                 * let a = Fmt.(strf "-pkgs %a" (list sep::(unit ",") string))
                 *
                 * instead of:
                 *
                 * let a = {
                 *   Fmt.(strf "-pkgs %a" (list sep::(unit ",") string))
                 * }
                 *)
                | [item] -> Some item
                | _ -> Some (makeLetSequence letItems)
             )
        | Pexp_sequence _ ->
            Some (makeLetSequence (self#letList x))
        | Pexp_field (e, li) ->
          Some (label (makeList [self#simple_enough_to_be_lhs_dot_send e; atom "."]) (self#longident_loc li))
        | Pexp_send (e, s) ->
          Some (label (makeList [self#simple_enough_to_be_lhs_dot_send e; atom "#";]) (atom s))
        | Pexp_extension e -> Some (self#extension e)
        | _ -> None
      in
      match item with
        | None -> None
        | Some i -> Some (SourceMap (x.pexp_loc, i))

  method formatChildren children processedRev =
    match children with
    | {pexp_desc = Pexp_constant (constant)} :: remaining ->
      self#formatChildren remaining (self#constant constant :: processedRev)
    | {pexp_desc = Pexp_construct ({txt = Lident "::"}, Some {pexp_desc = Pexp_tuple(children)} )} :: remaining ->
      self#formatChildren (remaining @ children) processedRev
    | {pexp_desc = Pexp_apply(expr, l); pexp_attributes} :: remaining ->
      self#formatChildren remaining (self#simplifyUnparseExpr (List.hd children) :: processedRev)
    | {pexp_desc = Pexp_ident li} :: remaining ->
      self#formatChildren remaining (self#longident_loc li :: processedRev)
    | {pexp_desc = Pexp_construct ({txt = Lident "[]"}, None)} :: remaining -> self#formatChildren remaining processedRev
    | head :: remaining -> self#formatChildren remaining (self#simplifyUnparseExpr head :: processedRev)
    | [] -> match processedRev with
        | [] -> None
        | _::_ -> Some (List.rev processedRev)
  method direction_flag = function
    | Upto -> atom "to"
    | Downto -> atom "downto"

  method payload ppxToken ppxId e =
    let wrap = ("[" ^ ppxToken ^ ppxId.txt, "]") in
    let break = IfNeed in
    let pad = (true, false) in
    let postSpace = true in
    let sep = ";" in
    match e with
      | PStr [] -> atom ("[" ^ ppxToken  ^ ppxId.txt  ^ "]")
      | PStr [itm] -> makeList ~break ~wrap ~pad [self#structure_item itm]
      | PStr (_::_ as items) ->
        let rows = (List.map (self#structure_item) items) in
        makeList ~wrap ~break ~pad ~postSpace ~sep rows
      | PTyp x ->
        makeList ~wrap ~break ~pad [label ~space:true (atom ":") (self#core_type x)]
      (* Signatures in attributes were added recently *)
      | PSig x -> makeList [atom ":"; self#signature x]
      | PPat (x, None) ->
        makeList ~wrap ~break ~pad [label ~space:true (atom "?") (self#pattern x)]
      | PPat (x, Some e) ->
        makeList ~wrap ~break ~pad ~postSpace [
          label ~space:true (atom "?") (self#pattern x);
          label ~space:true (atom "when") (self#unparseExpr e)
        ]

  method extension (s, e) =
    match (s.txt) with
    (* We special case "bs.obj" for now to allow for a nicer interop with
     * BuckleScript. We might be able to generalize to any kind of record
     * looking thing with struct keys. *)
    | "bs.obj" -> (
      match e with
      | PStr [itm] -> (
        match itm with
        | {pstr_desc = Pstr_eval ({ pexp_desc = Pexp_record (l, eo) }, []) } ->
          self#unparseRecord ~withStringKeys:true ~allowPunning:false l eo
        | _ -> assert false
      )
      | _ -> assert false
    )
    | _ -> (self#payload "%" s e)

  method item_extension (s, e) = (self#payload "%%" s e)


  (* [@ ...] Simple attributes *)
  method attribute (s, e) = (self#payload "@" s e)

  (* [@@ ... ] Attributes that occur after a major item in a structure/class *)
  method item_attribute (s, e) = (self#payload "@@" s e)

  (* [@@@ ...] Attributes that occur not *after* an item in some structure/class/sig, but
     rather as their own standalone item. Note that syntactic distinction
     between item_attribute and floating_attribute is no longer necessary with
     Reason. Thank you semicolons. *)
  method floating_attribute (s, e) = (self#payload "@@@" s e)


  method attributes l =
	    makeList ~break:IfNeed ~postSpace:true (List.map self#attribute l)

  method attach_std_attrs l toThis =
    let l = extractStdAttrs l in
    match l with
      | [] -> toThis
      | _::_ -> makeList ~postSpace:true [toThis; (self#attributes l)]

  method attach_std_item_attrs l toThis =
    let l = extractStdAttrs l in
    match l with
      | [] -> toThis
      | _::_ ->
        makeList ~postSpace:true ~indent:0 ~break:IfNeed ~inline:(true, true) [
          toThis;
          makeList ~break:IfNeed ~postSpace:true (List.map self#item_attribute l);
        ]

  method exception_declaration ed =
    let pcd_name = ed.pext_name in
    let pcd_loc = ed.pext_loc in
    let pcd_attributes = ed.pext_attributes in
    let exn_arg = match ed.pext_kind with
      | Pext_decl (args, type_opt) ->
          let pcd_args, pcd_res = args, type_opt in
          [self#type_variant_leaf_nobar {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes}]
      | Pext_rebind id ->
          [atom pcd_name.txt; atom "="; (self#longident_loc id)] in
    makeList ~postSpace:true ((atom "exception")::exn_arg)

  (*
    Note: that override doesn't appear in class_sig_field, but does occur in
    class/object expressions.
    TODO: TODOATTRIBUTES
   *)
  method method_sig_flags_for s = function
    | Virtual -> [atom "virtual"; atom s]
    | Concrete ->  [atom s]

  method value_type_flags_for s = function
    | (Virtual, Mutable) -> [atom "virtual"; atom "mutable"; atom s]
    | (Virtual, Immutable) -> [atom "virtual"; atom s]
    | (Concrete, Mutable) -> [atom "mutable"; atom s]
    | (Concrete, Immutable) -> [atom s]

  method class_sig_field x =
    match x.pctf_desc with
    | Pctf_inherit (ct) ->
      label ~space:true (atom "inherit") (self#class_constructor_type ct)
    | Pctf_val (s, mf, vf, ct) ->
      let valueFlags = self#value_type_flags_for (s ^ ":") (vf, mf) in
      label
        ~space:true
        (
          label ~space:true
            (atom "val")
            (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed valueFlags)
        )
        (self#core_type ct)
    | Pctf_method (s, pf, vf, ct) ->
      let methodFlags = self#method_sig_flags_for (s ^ ":") vf
      in
      let pubOrPrivate =
        match pf with
        | Private -> "pri"
        | Public -> "pub"
      in
      let m = label
        ~space:true
        (label ~space:true
            (atom pubOrPrivate)
            (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed methodFlags)
        )
        (self#core_type ct)
      in
      (self#attach_std_item_attrs x.pctf_attributes m)
    | Pctf_constraint (ct1, ct2) ->
      label
        (atom "constraint")
        (label ~space:true
            (makeList ~postSpace:true [self#core_type ct1; atom "="])
            (self#core_type ct2)
        )
    | Pctf_attribute a -> self#floating_attribute a
    | Pctf_extension e -> self#item_extension e


  (* The type of something returned from a constructor. Formerly [class_signature]  *)
  method shouldDisplayClassInstTypeItem x = match x.pctf_desc with
    | Pctf_attribute (s, _) -> (not (s.txt = "ocaml.text") && not (s.txt = "ocaml.doc"))
    | _ -> true

  method shouldDisplayClassField x = match x.pcf_desc with
    | Pcf_attribute (s, _) -> (not (s.txt = "ocaml.text") && not (s.txt = "ocaml.doc"))
    | _ -> true

  method shouldDisplaySigItem x = match x.psig_desc with
    | Psig_attribute (s, _) -> (not (s.txt = "ocaml.text") && not (s.txt = "ocaml.doc"))
    | _ -> true

  method shouldDisplayStructureItem x = match x.pstr_desc with
    | Pstr_attribute (s, _) -> (not (s.txt = "ocaml.text") && not (s.txt = "ocaml.doc"))
    | _ -> true

  (*
    external render : reactElement => element => unit =   (* frstHalf *)
      "render" [@@bs.val] [@@bs.module "react-dom"];      (* sndHalf *)

    To improve the formatting with breaking & indentation:
      * consider the part before the '=' as a label
      * combine that label with '=' in a list
      * consider the part after the '=' as a list
      * combine both parts as a label
  *)
  method primitive_declaration vd =
    let attrs = List.map (fun x -> self#item_attribute x) vd.pval_attributes in
    let lblBefore =
      label ~space:true
        (makeList ~postSpace:true
          [atom "external"; protectIdentifier vd.pval_name.txt; atom ":"])
        (self#core_type vd.pval_type)
    in
    let frstHalf = makeList ~postSpace:true [lblBefore; atom "="] in
    let string_literals = makeSpacedBreakableInlineList (List.map self#constant_string vd.pval_prim) in
    let sndHalf =
      if (List.length attrs) == 0 then
        string_literals
      else
        makeSpacedBreakableInlineList [
          string_literals;
          makeSpacedBreakableInlineList attrs
        ]
    in
    label ~space:true frstHalf sndHalf

  method class_instance_type x = match x.pcty_desc with
    | Pcty_signature cs ->
        let {pcsig_self = ct; pcsig_fields = l} = cs in
        let instTypeFields =
          List.map self#class_sig_field (List.filter self#shouldDisplayClassInstTypeItem l) in
        let allItems = match ct.ptyp_desc with
          | Ptyp_any -> instTypeFields
          | _ ->
            label ~space:true (atom "as") (self#core_type ct) ::
            instTypeFields
        in
        makeList
          ~wrap:("{", "}")
          ~postSpace:true
          ~break:Always_rec
          ~sep:";"
          allItems
    | Pcty_constr (li, l) -> (
        match l with
          | [] -> self#longident_loc li
          | _::_ ->
            label
              ~space:true
              (makeList ~wrap:("(", ")") ~sep:"," (List.map self#core_type l))
              (self#longident_loc li)
      )
    | Pcty_extension e -> self#extension e
    | Pcty_arrow _ -> failwith "class_instance_type should not be printed with Pcty_arrow"

  method class_declaration_list l =
    let class_declaration ?(class_keyword=false)
        ({pci_params=ls; pci_name={txt}; pci_virt; pci_expr={pcl_desc}; pci_loc} as x) =
      let (firstToken, pattern, patternAux) = self#class_opening class_keyword txt pci_virt ls in
      let classBinding = self#wrappedClassBinding firstToken pattern patternAux x.pci_expr in
      let itm = self#attach_std_item_attrs x.pci_attributes classBinding in
      SourceMap (pci_loc, itm)
    in
    (match l with
      | [] -> raise (NotPossible "Class definitions will have at least one item.")
      | x::rest ->
        makeNonIndentedBreakingList (
          class_declaration ~class_keyword:true x ::
          List.map class_declaration rest
        )
    )
  (* For use with [class type a = class_instance_type]. Class type
     declarations/definitions declare the types of instances generated by class
     constructors.
     We have to call self#class_instance_type because self#class_constructor_type
     would add a "new" before the type.
     TODO: TODOATTRIBUTES:
  *)
  method class_type_declaration_list l =
    let class_type_declaration kwd ({pci_params=ls;pci_name={txt};pci_attributes} as x) =
      let opener = match x.pci_virt with
        | Virtual -> kwd ^ " " ^ "virtual"
        | Concrete -> kwd
      in

      let upToName =
        if ls == [] then
          label ~space:true (atom opener) (atom txt)
        else
          label
            ~space:true
            (label ~space:true (atom opener) (atom txt))
            (self#class_params_def ls)
      in
      let includingEqual = makeList ~postSpace:true [upToName; atom "="] in
      let itm = label ~space:true includingEqual (self#class_instance_type x.pci_expr) in
      let itmWithAttrs = self#attach_std_attrs x.pci_expr.pcty_attributes itm in
      self#attach_std_item_attrs pci_attributes itmWithAttrs
    in
    match l with
    | [] -> failwith "Should not call class_type_declaration with no classes"
    | [x] -> class_type_declaration "class type" x
    | x :: xs ->
      makeList
        ~break:Always_rec
        ~indent:0
        ~inline:(true, true)
        (
          (class_type_declaration "class type" x)::
          List.map (class_type_declaration "and") xs
        )

  (*
     Formerly the [class_type]
     Notice how class_constructor_type doesn't have any type attributes -
     class_instance_type does.
     TODO: Divide into class_constructor_types that allow arrows and ones
     that don't.
   *)
  method class_constructor_type x =
    match x.pcty_desc with
    | Pcty_arrow (l, co, cl) ->
      let rec allArrowSegments xx = match xx.pcty_desc with
        | Pcty_arrow (l, ct1, ct2) ->
            (self#type_with_label (l, ct1))::(allArrowSegments ct2)
        (* This "new" is unfortunate. See reason_parser.mly for details. *)
        | _ -> [self#class_constructor_type xx]
      in
      let normalized =
        makeList
          ~break:IfNeed
          ~sep:"=>"
          ~preSpace:true
          ~postSpace:true
          ~inline:(true, true)
          (allArrowSegments x)
      in
      SourceMap (x.pcty_loc, normalized)
    | _ ->
      (* Unfortunately, we have to have final components of a class_constructor_type
         be prefixed with the `new` keyword.  Hopefully this is temporary. *)
      label ~space:true (atom "new") (self#class_instance_type x)

  method non_arrowed_class_constructor_type x =
    match x.pcty_desc with
    | Pcty_arrow (l, co, cl) ->
      let normalized = formatPrecedence (self#class_constructor_type x) in
      SourceMap (x.pcty_loc, normalized)
    | _ -> self#class_instance_type x

  (* TODO: TODOATTRIBUTES. *)
  method class_field x =
    let itm =
      match x.pcf_desc with
      | Pcf_inherit (ovf, ce, so) ->
        let inheritText = ("inherit" ^ override ovf) in
        let inheritExp = self#class_expr ce in
        label
          ~space:true
          (atom inheritText)
          (
            match so with
            | None -> inheritExp;
            | Some (s) -> label ~space:true inheritExp (atom ("as " ^ s))
          )
      | Pcf_val (s, mf, Cfk_concrete (ovf, e)) ->
        let opening = match mf with
          | Mutable ->
            let mutableName = [atom "mutable"; atom s.txt] in
            label
              ~space:true
              (atom ("val" ^ override ovf))
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed mutableName)
          | Immutable -> label ~space:true (atom ("val" ^ override ovf)) (atom s.txt)
        in
        let valExprAndConstraint = match e.pexp_desc with
          | Pexp_constraint (ex, ct) ->
            let openingWithTypeConstraint = formatTypeConstraint opening (self#core_type ct) in
            label
              ~space:true
              (makeList ~postSpace:true [openingWithTypeConstraint; atom "="])
              (self#unparseExpr ex)
          | _ ->
            label ~space:true (makeList ~postSpace:true [opening; atom "="]) (self#unparseExpr e)
        in
        valExprAndConstraint
      | Pcf_val (s, mf, Cfk_virtual ct) ->
        let opening = match mf with
          | Mutable ->
            let mutableVirtualName = [atom "mutable"; atom "virtual"; atom s.txt] in
            let openingTokens =
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed mutableVirtualName) in
            label ~space:true (atom "val") openingTokens
          | Immutable ->
            let virtualName = [atom "virtual"; atom s.txt] in
            let openingTokens =
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed virtualName) in
            label ~space:true (atom "val") openingTokens
        in
        formatTypeConstraint opening (self#core_type ct)
      | Pcf_method (s, pf, Cfk_virtual ct) ->
        let opening = match pf with
          | Private ->
            let privateVirtualName = [atom "virtual"; atom s.txt] in
            let openingTokens =
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed privateVirtualName) in
            label ~space:true (atom "pri") openingTokens
          | Public ->
            let virtualName = [atom "virtual"; atom s.txt] in
            let openingTokens =
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed virtualName) in
            label ~space:true (atom "pub") openingTokens
        in
        formatTypeConstraint opening (self#core_type ct)
      | Pcf_method (s, pf, Cfk_concrete (ovf, e)) ->
        let methodText =
           let postFix = if ovf == Override then "!" else "" in
           (
           match pf with
           | Private -> "pri" ^ postFix
           | Public -> "pub" ^ postFix
           ) in
        (* Should refactor the binding logic so faking out the AST isn't needed,
           currently, it includes a ton of nuanced logic around recovering explicitly
           polymorphic type definitions, and that furthermore, that representation...
           Actually, let's do it.

           For some reason, concrete methods are only ever parsed as Pexp_poly.
           If there *is* no polymorphic function for the method, then the return
           value of the function is wrapped in a ghost Pexp_poly with [None] for
           the type vars.*)
        (match e.pexp_desc with
          | (Pexp_poly
              ({pexp_desc=Pexp_constraint (methodFunWithNewtypes, nonVarifiedExprType)},
                Some ({ptyp_desc=Ptyp_poly (typeVars, varifiedPolyType)})
              )
            ) when (
              let (leadingAbstractVars, nonVarified) =
                self#leadingCurriedAbstractTypes methodFunWithNewtypes in
              self#isRenderableAsPolymorphicAbstractTypes
                typeVars
                (* If even artificially varified. Don't know until this returns*)
                varifiedPolyType
                leadingAbstractVars
                nonVarifiedExprType
          ) ->
            let (leadingAbstractVars, nonVarified) =
              self#leadingCurriedAbstractTypes methodFunWithNewtypes in
            self#locallyAbstractPolymorphicFunctionBinding
              methodText
              (atom s.txt)
              methodFunWithNewtypes
              leadingAbstractVars
              nonVarifiedExprType
          | Pexp_poly (e, Some ct) ->
            let typeLayout = SourceMap (ct.ptyp_loc, (self#core_type ct)) in
            let appTerms = self#unparseExprApplicationItems e in
            self#formatSimplePatternBinding methodText (atom s.txt) (Some typeLayout) appTerms
          (* This form means that there is no type constraint - it's a strange node name.*)
          | Pexp_poly (e, None) ->
            self#wrappedBinding methodText (atom s.txt) [] e
          | _ -> failwith "Concrete methods should only ever have Pexp_poly."
        )
      | Pcf_constraint (ct1, ct2) ->
        label
          ~space:true
          (atom "constraint")
          (
            makeList ~postSpace:true ~inline:(true, false) [
              makeList ~postSpace:true [self#core_type ct1; atom "="];
              self#core_type ct2
            ]
          )
      | Pcf_initializer (e) ->
        label
          ~space:true
          (atom "initializer =>")
          (self#unparseExpr e)
      | Pcf_attribute a -> self#floating_attribute a
      | Pcf_extension e ->
        (* And don't forget, we still need to print post_item_attributes even for
           this case *)
        self#item_extension e
    in
    SourceMap (x.pcf_loc, itm)

  method class_self_pattern_and_structure {pcstr_self = p; pcstr_fields = l} =
    let fields = (List.map self#class_field (List.filter self#shouldDisplayClassField l)) in
    (* Recall that by default self is bound to "this" at parse time. You'd
       have to go out of your way to bind it to "_". *)
    match (p.ppat_attributes, p.ppat_desc) with
      | ([], Ppat_var ({loc; txt = "this"})) -> fields
      | _ ->
        SourceMap (p.ppat_loc, (label ~space:true (atom "as") (self#pattern p)))
        ::fields

  method simple_class_expr x =
    let {stdAttrs} = partitionAttributes x.pcl_attributes in
    if stdAttrs <> [] then
      formatSimpleAttributed
        (self#simple_class_expr {x with pcl_attributes=[]})
        (self#attributes stdAttrs)
    else
      let itm =
        match x.pcl_desc with
        | Pcl_constraint (ce, ct) ->
          formatTypeConstraint (self#class_expr ce) (self#class_constructor_type ct)
        (* In OCaml,
          - In the most recent version of OCaml, when in the top level of a
            module, let _ = ... is a PStr_eval.
          - When in a function, it is a Pexp_let PPat_any
          - When in class pre-member let bindings it is a Pcl_let PPat_any

           Reason normalizes all of these to be simple imperative expressions
           with trailing semicolons, *except* in the case of classes because it
           will likely introduce a conflict with some proposed syntaxes for
           objects.
        *)
        | Pcl_let _
        | Pcl_structure _ ->
          let rows = (self#classExprLetsAndRest x) in
          makeList ~wrap:("{", "}") ~inline:(true, false) ~postSpace:true ~break:Always_rec (List.map semiTerminated rows)
        | Pcl_extension e -> self#extension e
        | _ -> formatPrecedence (self#class_expr x)
     in SourceMap (x.pcl_loc, itm)

  method classExprLetsAndRest x =
    match x.pcl_desc with
      | Pcl_structure cs -> self#class_self_pattern_and_structure cs
      | Pcl_let (rf, l, ce) ->
        (* For "letList" bindings, the start/end isn't as simple as with
         * module value bindings. For "let lists", the sequences were formed
         * within braces {}. The parser relocates the first let binding to the
         * first brace. *)
         let bindingsLayout = (self#bindings (rf, l)) in
         let bindingsLoc = self#bindingsLocationRange l in
         let bindingsSourceMapped = SourceMap (bindingsLoc, bindingsLayout) in
         bindingsSourceMapped::(self#classExprLetsAndRest ce)
      | _ -> [self#class_expr x]

  method class_expr x =
    let {stdAttrs} = partitionAttributes x.pcl_attributes in
    (* We cannot handle the attributes here. Must handle them in each item *)
    if stdAttrs <> [] then
      (* Do not need a "simple" attributes precedence wrapper. *)
      formatAttributed
        (self#simple_class_expr {x with pcl_attributes=[]})
        (self#attributes stdAttrs)
    else
      match x.pcl_desc with
      | Pcl_fun (l, eo, p, e) ->
          label
            ~space:true
            (makeList ~postSpace:true [
               (label ~space:true (atom "fun") (self#label_exp (l, eo, p)));
              (atom "=>");
            ])
            (self#class_expr e);
      | Pcl_apply (ce, l) ->
        let applicationItems = self#classExpressionToFormattedApplicationItems x in
        formatAttachmentApplication applicationFinalWrapping None applicationItems
      | Pcl_constr (li, l) ->
          (* TODO: Allow classes to use the same syntax as every other type
             application. *)
        (match l with
          | [] -> label ~space:true (atom "class") (self#longident_loc li)
          | ll ->
            let typeParameters =
              makeList
                ~break:IfNeed
                ~postSpace:true
                ~inline:(true, true)
                (List.map self#non_arrowed_simple_core_type l)
            in
            label
              ~space:true
              (makeList ~postSpace:true [atom "class"; self#longident_loc li])
              typeParameters
        )
      | Pcl_constraint _
      | Pcl_extension _
      | Pcl_let _
      | Pcl_structure _ -> self#simple_class_expr x;

  method signature signatureItems =
    let signatureItems = List.filter self#shouldDisplaySigItem signatureItems in
    if List.length signatureItems == 0 then
      atom ""
    else
      let signatureItems = List.filter self#shouldDisplaySigItem signatureItems in
      let first = List.nth signatureItems 0 in
      let last = List.nth signatureItems (List.length signatureItems - 1) in
      SourceMap (
        {loc_start=first.psig_loc.loc_start; loc_end=last.psig_loc.loc_end; loc_ghost=false},
        makeList
          ~newlinesAboveComments:1
          ~newlinesAboveItems:1
          ~newlinesAboveDocComments:1
          ~renderFinalSep:true
          ~postSpace:true
          ~break:Always_rec
          ~indent:0
          ~inline:(true, false)
          ~sep:";"
          (List.map self#signature_item signatureItems)
      )

  method value_description x =
    let vd = self#core_type x.pval_type in
    self#attach_std_item_attrs x.pval_attributes vd

  method signature_item x :layoutNode =
    let item: layoutNode =
      match x.psig_desc with
        | Psig_type (rf, l) ->
            self#type_def_list (rf, l)
        | Psig_value vd ->
            if vd.pval_prim <> [] then
              self#primitive_declaration vd
            else
              let intro = atom "let" in
              (formatTypeConstraint
                 (label ~space:true intro (wrapLayoutWithLoc (Some (vd.pval_name.loc)) (protectIdentifier vd.pval_name.txt)))
                 (self#value_description vd))

        | Psig_typext te ->
            self#type_extension te
        | Psig_exception ed ->
            self#exception_declaration ed
        | Psig_class l ->
            let class_description
                ?(class_keyword=false)
                ({pci_params=ls; pci_name={txt}; pci_loc} as x) =
              let (firstToken, pattern, patternAux) = self#class_opening class_keyword txt x.pci_virt ls in
              let withColon = self#wrapCurriedFunctionBinding
                ~arrow:":"
                firstToken
                pattern
                patternAux
                ([(self#class_constructor_type x.pci_expr)], None)
              in
              let itm = self#attach_std_item_attrs x.pci_attributes withColon in
              SourceMap (pci_loc, itm)
            in
            makeNonIndentedBreakingList (
              match l with
              | [] -> raise (NotPossible "No recursive class bindings")
              | [x] -> [class_description ~class_keyword:true x]
              | x :: xs ->
                 (class_description ~class_keyword:true x)::
                 (List.map class_description xs)
            )
        | Psig_module {pmd_name; pmd_type={pmty_desc=Pmty_alias alias}} ->
            label ~space:true
              (makeList ~postSpace:true [
                 atom "module";
                 atom pmd_name.txt;
                 atom "="
               ])
              (self#longident_loc alias)
        | Psig_module pmd ->
            self#formatSimpleSignatureBinding
              "module"
              (atom pmd.pmd_name.txt)
              (self#module_type pmd.pmd_type);
        | Psig_open od ->
            label ~space:true
              (atom ("open" ^ (override od.popen_override)))
              (self#longident_loc od.popen_lid)
        | Psig_include incl ->
            label ~space:true
              (atom "include")
              (self#module_type incl.pincl_mod)
        | Psig_modtype {pmtd_name=s; pmtd_type=md} -> (
            match md with
              | None -> makeList ~postSpace:true [atom "module type"; atom s.txt]
              | Some mt ->
                  label ~space:true
                    (makeList ~postSpace:true [atom "module type"; atom s.txt; atom "="])
                    (self#module_type mt)
          )
        | Psig_class_type l -> self#class_type_declaration_list l
        | Psig_recmodule decls ->
            let first xx =
              self#formatSimpleSignatureBinding
                "module rec"
                (atom xx.pmd_name.txt)
                (self#module_type xx.pmd_type)
            in
            let notFirst xx =
              self#formatSimpleSignatureBinding
                "and"
                (atom xx.pmd_name.txt)
                (self#module_type xx.pmd_type)
            in

            let moduleBindings = match decls with
              | [] -> raise (NotPossible "No recursive module bindings")
              | hd::tl -> (first hd)::(List.map notFirst tl)
            in
            makeNonIndentedBreakingList moduleBindings
        | Psig_attribute a -> self#floating_attribute a
        | Psig_extension (e, a) ->
          self#attach_std_item_attrs a (self#item_extension e)
    in
    SourceMap (x.psig_loc, item)

  method non_arrowed_module_type x =
    match x.pmty_desc with
      | Pmty_alias li ->
          formatPrecedence (label ~space:true (atom "module") (self#longident_loc li))
      | Pmty_typeof me ->
          label ~space:true
            (atom "module type of")
            (self#module_expr me)
      | _ -> self#simple_module_type x

  method simple_module_type x =
    match x.pmty_desc with
      | Pmty_ident li ->
          self#longident_loc li;
      | Pmty_signature s ->
          makeList
            ~break:IfNeed
            ~inline:(true, false)
            ~wrap:("{", "}")
            ~newlinesAboveComments:0
            ~newlinesAboveItems:0
            ~newlinesAboveDocComments:1
            ~renderFinalSep:true
            ~postSpace:true
            ~sep:";"
            (List.map self#signature_item (List.filter self#shouldDisplaySigItem s))
      | Pmty_extension (s, e) -> self#payload "%" s e
      | _ -> makeList ~break:IfNeed ~wrap:("(", ")") [self#module_type x]

  method module_type x =
    (* The segments that should be separated by arrows. *)
    let rec functorTypeArgs xx = match xx.pmty_desc with
      | Pmty_functor (_, None, mt2) -> (atom "()")::(functorTypeArgs mt2)
      | Pmty_functor (s, Some mt1, mt2) ->
          if s.txt = "_" then
            (self#non_arrowed_module_type mt1)::(functorTypeArgs mt2)
          else
            let cur =
              makeList ~wrap:("(",")") [
                formatTypeConstraint
                  (atom s.txt)
                  (self#module_type mt1)
              ] in
            cur::(functorTypeArgs mt2)
      | _ -> [self#module_type xx]
    in

    let pmty = match x.pmty_desc with
      | Pmty_functor _ ->
          let functorArgs = functorTypeArgs x in
          makeList ~break:IfNeed ~sep:"=>" ~preSpace:true ~postSpace:true ~inline:(true, true) functorArgs

      (* See comments in sugar_parser.mly about why WITH constraints aren't "non
       * arrowed" *)
      | Pmty_with (mt, l) ->
          let modSub atm li2 token = makeList ~postSpace:true [
            atom "module";
            atm;
            atom token;
            self#longident_loc li2
          ] in
          let typeAtom = atom "type" in
          let eqAtom = atom "=" in
          let destrAtom = atom ":=" in
          let with_constraint = function
            | Pwith_type (li, ({ptype_params} as td)) ->
                self#formatOneTypeDef
                  typeAtom
                  (SourceMap (li.loc, (self#longident_loc li)))
                  eqAtom
                  td
            | Pwith_module (li, li2) ->
                modSub (self#longident_loc li) li2 "="
            | Pwith_typesubst ({ptype_params} as td) ->
                self#formatOneTypeDef
                  typeAtom
                  (SourceMap (td.ptype_name.loc, (atom td.ptype_name.txt)))
                  destrAtom
                  td
            | Pwith_modsubst (s, li2) -> modSub (atom s.txt) li2 ":="
          in
          (match l with
            | [] -> self#module_type mt
            | _ ->
                label ~space:true
                  (makeList ~postSpace:true [self#module_type mt; atom "with"])
                  (makeList
                     ~break:IfNeed
                     ~inline:(true, true)
                     ~sep:"and"
                     ~postSpace:true
                     ~preSpace:true
                     (List.map with_constraint l));
          )
        (* Seems like an infinite loop just waiting to happen. *)
        | _ -> self#non_arrowed_module_type x
    in
    SourceMap (x.pmty_loc, pmty)

  method simple_module_expr x = match x.pmod_desc with
    | Pmod_unpack e ->
        formatPrecedence (makeList ~postSpace:true [atom "val"; self#unparseExpr e])
    | Pmod_ident (li) ->
        ensureSingleTokenSticksToLabel (self#longident_loc li)
    | Pmod_constraint (unconstrainedRet, mt) ->
        formatPrecedence (
          formatTypeConstraint
            (self#module_expr unconstrainedRet)
            (self#module_type mt)
        )
    | Pmod_structure (s) ->
      makeList
        ~break:Always_rec
        ~inline:(true, false)
        ~wrap:("{", "}")
        ~newlinesAboveComments:0
        ~newlinesAboveItems:0
        ~newlinesAboveDocComments:1
        ~renderFinalSep:true
        ~postSpace:true
        ~sep:";"
        (List.map self#structure_item (List.filter self#shouldDisplayStructureItem s))

    | _ ->
        (* For example, functor application will be wrapped. *)
        formatPrecedence (self#module_expr x)

  method module_expr x =
    match x.pmod_desc with
      | Pmod_functor _ ->
          let (argsList, return) = self#curriedFunctorPatternsAndReturnStruct x in (
            match (argsList, return.pmod_desc) with
              | ([], _) -> raise (NotPossible "functor must have some arg")
              | (firstArg::restArgs, _) ->
                (* See #19/20 in syntax.mls - cannot annotate return type at
                   the moment. *)
                let returnedAppTerms = self#moduleExpressionToFormattedApplicationItems return in
                self#wrapCurriedFunctionBinding "fun" firstArg restArgs returnedAppTerms
          )
      | Pmod_apply (me1, me2) ->
          let appTerms = self#moduleExpressionToFormattedApplicationItems x in
          (match appTerms with
            | ([], _) -> raise (NotPossible "no functor application terms")
            | ([hd], _) -> raise (NotPossible "one functor application terms")
            | (hd::tl, _) -> formatIndentedApplication hd tl
          )
      | Pmod_extension (s, e) -> self#payload "%" s e
      | Pmod_unpack _
      | Pmod_ident _
      | Pmod_constraint _
      | Pmod_structure _ -> self#simple_module_expr x


  method structure structureItems =
    if List.length structureItems == 0 then
      atom ""
    else
      let structureItems = List.filter self#shouldDisplayStructureItem structureItems in
      let first = List.nth structureItems 0 in
      let last = List.nth structureItems (List.length structureItems - 1) in
      SourceMap (
        {loc_start=first.pstr_loc.loc_start; loc_end=last.pstr_loc.loc_end; loc_ghost=false},
        makeList
          ~newlinesAboveComments:1
          ~newlinesAboveItems:1
          ~newlinesAboveDocComments:1
          ~renderFinalSep:true
          ~postSpace:true
          ~break:Always_rec
          ~indent:0
          ~inline:(true, false)
          ~sep:";"
          (List.map self#structure_item structureItems)
      )


  (*
     How do modules become parsed?
     let module (X: sig) = blah;
       Will not parse! (Should just make it parse to let [X:sig =]).
     let module X: sig = blah;
       Becomes Pmod_constraint
     let module X: sig = (blah:sig);
       Becomes Pmod_constraint .. Pmod_constraint
     let module X = blah:typ;
       Becomes Pmod_constraint
     let module X (Y:y) (Z:z):r => Q
       Becomes Pmod_functor...=> Pmod_constraint

     let module X (Y:y) (Z:z):r => (Q:r2)
       Probably becomes Pmod_functor...=> (Pmod_constraint..
       Pmod_constraint)

    let (module X) =
      Is a *completely* different thing (unpacking/packing first class modules).
      We should make sure this is very well distinguished.
      - Just replace all "let module" with a new three letter keyword (mod)?
      - Reserve let (module X) for unpacking first class modules.

    See the notes about how Ppat_constraint become parsed and attempt to unify
    those as well.
  *)

  method let_module_binding prefixText bindingName moduleExpr =
    let (argsList, return) = self#curriedFunctorPatternsAndReturnStruct moduleExpr in (
      match (argsList, return.pmod_desc) with
        (* Simple module with type constraint, no functor args. *)
        | ([], Pmod_constraint (unconstrainedRetTerm, ct)) ->
            let appTerms = self#moduleExpressionToFormattedApplicationItems unconstrainedRetTerm in
            self#formatSimplePatternBinding prefixText bindingName (Some (self#module_type ct)) appTerms
        (* Simple module with type no constraint, no functor args. *)
        | ([], _) ->
            let appTerms = self#moduleExpressionToFormattedApplicationItems return in
            self#formatSimplePatternBinding prefixText bindingName None appTerms
        | (_, _) ->
            (* A functor *)
            let (argsWithConstraint, actualReturn) = (
              match return.pmod_desc with
                (* A functor with constrained return type:
                 *
                 * let module X = (A) (B) : Ret => ...
                 * *)
                | Pmod_constraint (me, ct) -> (argsList@[formatJustTheTypeConstraint (self#non_arrowed_module_type ct)], me)
                | _ -> (argsList, return)
            ) in
            let returnedAppTerms = self#moduleExpressionToFormattedApplicationItems actualReturn in
            self#wrapCurriedFunctionBinding prefixText bindingName argsWithConstraint returnedAppTerms
    )

    method class_opening class_keyword name pci_virt ls =
      let firstToken = if class_keyword then "class" else "and" in
      match (pci_virt, ls) with
        (* When no class params, it's a very simple formatting for the
           opener - no breaking. *)
        | (Virtual, []) ->
          (firstToken, atom "virtual", [atom name])
        | (Concrete, []) ->
          (firstToken, atom name, [])
        | (Virtual, _::_) ->
          (firstToken, atom "virtual", [atom name; self#class_params_def ls])
        | (Concrete, _::_) ->
          (firstToken, atom name, [self#class_params_def ls])


  (* TODO: TODOATTRIBUTES: Structure items don't have attributes, but each
     pstr_desc *)
  method structure_item term =
    let item = (
      match term.pstr_desc with
        | Pstr_eval (e, _attrs) -> self#unparseExpr e
        | Pstr_type (_, []) -> assert false
        | Pstr_type (rf, l)  -> (self#type_def_list (rf, l))
        | Pstr_value (rf, l) -> (self#bindings (rf, l))
        | Pstr_typext te -> (self#type_extension te)
        | Pstr_exception ed -> (self#exception_declaration ed)
        | Pstr_module x ->
            let prefixText = "module" in
            let bindingName = atom ~loc:x.pmb_name.loc x.pmb_name.txt in
            let moduleExpr = x.pmb_expr in
            self#let_module_binding prefixText bindingName moduleExpr
        | Pstr_open od -> (
            makeList ~postSpace:true [
              atom ("open" ^ (override od.popen_override));
              self#longident_loc od.popen_lid;
            ]
        )
        | Pstr_modtype {pmtd_name=s; pmtd_type=md} -> (
            match md with
              | None -> makeList ~postSpace:true [atom "module type";atom s.txt]
              | Some mt ->
                  label ~space:true
                    (makeList ~postSpace:true [atom "module type";atom s.txt; atom "="])
                    (self#module_type mt)
          )
        | Pstr_class l -> self#class_declaration_list l
        | Pstr_class_type (l) -> self#class_type_declaration_list l
        | Pstr_primitive vd -> self#primitive_declaration vd
        | Pstr_include incl ->
            (* Kind of a hack *)
            let moduleExpr = incl.pincl_mod in
            let returnedAppTerms = self#moduleExpressionToFormattedApplicationItems moduleExpr in
            formatAttachmentApplication
              applicationFinalWrapping
              (Some (true, atom "include"))
              returnedAppTerms

        | Pstr_recmodule decls -> (* 3.07 *)
            let first xx =
              let prefixText = "module rec" in
              self#let_module_binding prefixText (atom xx.pmb_name.txt) xx.pmb_expr in
            let notFirst xx =
              let prefixText = "and" in
              self#let_module_binding prefixText (atom xx.pmb_name.txt) xx.pmb_expr in

            let moduleBindings = match decls with
              | [] -> raise (NotPossible "No recursive module bindings")
              | hd::tl -> (first hd)::(List.map notFirst tl)
            in
            (makeNonIndentedBreakingList moduleBindings)
        | Pstr_attribute a -> self#floating_attribute a
        | Pstr_extension (e, a) ->
          (* Notice how extensions have attributes - but not every structure
             item does. *)
          self#item_extension e
    ) in
    SourceMap(term.pstr_loc, item)

  method type_extension te =
    let formatOneTypeExtStandard prepend ({ptyext_path} as te) =
      let name = self#longident_loc ptyext_path in
      let item = self#formatOneTypeExt prepend name (atom "+=") te in
      self#attach_std_item_attrs te.ptyext_attributes item
    in
    formatOneTypeExtStandard (atom "type") te

  (* [allowUnguardedSequenceBodies] allows sequence expressions {} to the right of `=>` to not
     be guarded in `{}` braces. *)
  method case_list ?(allowUnguardedSequenceBodies=false) l =
    let rec appendLabelToLast items rhs =
      match items with
        | hd::[] -> (label ~indent:0 ~space:true hd rhs)::[]
        | hd::tl -> hd::(appendLabelToLast tl rhs)
        | [] -> raise (NotPossible "Cannot append to last of nothing")
    in

    let case_row {pc_lhs; pc_guard; pc_rhs} =
      let theOrs = orList pc_lhs in

      (* match x with *)
      (* | AnotherReallyLongVariantName (_, _, _)   *)
      (* | AnotherReallyLongVariantName2 (_, _, _)
           when true => {                           *)

      (*   }                                        *)

      (*<sbi><X>match x with</X>   *)
      (*     <Y>everythingElse</Y> *)
      (*</sbi>                     *)



      (*     ............................................................
             :    each or segment has a spaced list <> that ties its    :
             : bar "|" to its pattern                                   :
             ...:..........................................................:.....
             :  :  each or-patterned match is grouped in SpacedBreakableInline  :
             :  :                                                          :    :
             v  v                                                          v    v
             <sbi><>|<lb><A><>     FirstThingStandalone t =></A></><B>t</B></lb></></sbi>
             <sbi><>|<C>           AnotherReallyLongVariantName (_, _, _)</C></>
             ^    <>|<lb><><lb><D>AnotherReallyLongVariantNam2 (_, _, _)</D>             (label the last in or ptn for or and label it again for arrow)
             :        ^  ^   ^     <E>when true<E></lb> =></><F>{
             :        :  :   :    </F>}</lb></sbi> ^       ^
             :        :  :   :            ^     ^   :      :
             :        :  :   :            :     :   :      :
             :        :  :   :If there is :a WHERE  :      :
             :        :  :   :an extra    :label is :      :
             :        :  :   :inserted bef:ore the  :      :
             :        :  :   :arrow.      :     :   :      :
             :        :  :   :............:.....:...:      :
             :        :  :                :     :          :
             :        :  :                :     :          :
             :        :  :                :     :          :
             :        :  :The left side of:this final label:
             :        :  :uses a list to  :append the arrow:
             :        :  :................:.....:..........:
             :        :                   :     :
             :        :                   :     :
             :        :                   :     :
             :        :Final or segment is:     :
             :        :wrapped in lbl that:     :
             :        :partitions pattern :     :
             :        :and arrow from     :     :
             :        :expression.        :     :
             :        :                   :     :
             :        :...................:     :
             :     [orsWithWhereAndArrowOnLast] :
             :                                  :
             :..................................:
                         [row]

      *)
      let bar xx = makeList ~postSpace:true [atom "|"; xx] in
      let appendWhereAndArrow p = match pc_guard with
          | None -> makeList ~interleaveComments:false ~postSpace:true [p; atom "=>"]
          | Some g ->
            (* when x should break as a whole - extra list added around it to make it break as one *)
            let withWhen = label ~space:true p (makeList ~break:Never ~inline:(true, true) ~postSpace:true [label ~space:true (atom "when") (self#unparseExpr g)]) in
            makeList ~interleaveComments:false ~inline:(true, true) ~postSpace:true [withWhen; atom "=>"]
      in

      let rec appendWhereAndArrowToLastOr = function
        | [] -> []
        | hd::tl -> (
          let formattedHd = match tl with
            | [] -> appendWhereAndArrow (self#pattern hd)
            | tl::tlTl -> (self#pattern hd)
          in
          formattedHd::(appendWhereAndArrowToLastOr tl)
        )
      in
      let orsWithWhereAndArrowOnLast = appendWhereAndArrowToLastOr theOrs in
      let rhs =
        if allowUnguardedSequenceBodies then
          match (self#under_pipe#letList pc_rhs) with
            (* TODO: Still render a list with located information here so that
               comments (eol) are interleaved *)
            | [hd] -> hd
            (* In this case, we don't need any additional indentation, because there aren't
               wrapping {} which would cause zero indentation to look strange. *)
            | lst -> makeUnguardedLetSequence lst
        else self#under_pipe#unparseExpr pc_rhs in
      let row =
        let withoutBars = appendLabelToLast orsWithWhereAndArrowOnLast rhs in
        makeList ~break:Always_rec ~inline:(true, true) (List.map bar withoutBars)
      in
        SourceMap (
          (* Fake shift the location to accomodate for the bar, to make sure
           * the wrong comments don't make their way past the next bar. *)
          expandLocation ~expand:(0, 0) {
            loc_start = pc_lhs.ppat_loc.loc_start;
            loc_end = pc_rhs.pexp_loc.loc_end;
            loc_ghost = false;
          },
          row
        )

    in
    (List.map case_row l)

  method label_x_expression_param (l, e) =
    let param =
      match l with
      | Nolabel -> self#simplifyUnparseExpr e; (* level 2*)
      | Labelled lbl ->
        let lbl = pun_labelled_expression e lbl in
        formatLabeledArgument lbl "" (self#simplifyUnparseExpr e)
      | Optional str ->
        let lbl = pun_labelled_expression e str in
        formatLabeledArgument lbl "?" (self#simplifyUnparseExpr e)
    in
    SourceMap (e.pexp_loc, param)


end;;


let easy = new printer ()

let toplevel_phrase f x =
  match x with
    | Ptop_def (s) ->
      easyFormatToFormatter f (layoutToEasyFormatNoComments (easy#structure s))
    | Ptop_dir (s, da) -> print_string "(* top directives not supported *)"

let case_list f x =
  let l = easy#case_list x in
  (List.iter (fun x -> easyFormatToFormatter f (layoutToEasyFormatNoComments x)) l)

let top_phrase f x =
  pp_print_newline f () ;
  toplevel_phrase f x;
  pp f ";;" ;
  pp_print_newline f ();;

(* Convert a Longident to a list of strings.
   E.g. M.Constructor will be ["Constructor"; "M.Constructor"]
   Also support ".Constructor" to specify access without a path.
 *)
let longident_for_arity lid =
  let rec toplevel = function
    | Lident s ->
        [s]
    | Ldot (lid, s) ->
        let append_s x = x ^ "." ^ s in
        s :: (List.map append_s (toplevel lid))
    | Lapply (y,s) ->
        toplevel s in
   match lid with
    | Lident s ->
        ("." ^ s) :: toplevel lid
    | _ ->
        toplevel lid

(* add expilcit_arity to a list of attributes
 *)
let add_explicit_arity loc attributes =
  ({txt="explicit_arity"; loc}, PStr []) ::
  normalized_attributes "explicit_arity" attributes

(* explicit_arity_exists check if expilcit_arity exists
 *)
let explicit_arity_not_exists attributes =
  not (attribute_exists "explicit_arity" attributes)

(* wrap_expr_with_tuple wraps an expression
 * with tuple as a sole argument.
 *)
let wrap_expr_with_tuple exp =
  {exp with pexp_desc = Pexp_tuple [exp]}

(* wrap_pat_with_tuple wraps an pattern
 * with tuple as a sole argument.
 *)
let wrap_pat_with_tuple pat =
  {pat with ppat_desc = Ppat_tuple [pat]}



(* explicit_arity_constructors is a set of constructors that are known to have
 * multiple arguments
 *
 *)

module StringSet = Set.Make(String);;

let built_in_explicit_arity_constructors = ["Some"; "Assert_failure"; "Match_failure"]

let explicit_arity_constructors = StringSet.of_list(built_in_explicit_arity_constructors @ (!configuredSettings).constructorLists)

let add_explicit_arity_mapper =
{ default_mapper with
  expr = begin fun mapper expr ->
    let expr =
      match expr with
        | {pexp_desc=Pexp_construct(lid, Some sp);
           pexp_loc;
           pexp_attributes} when
             List.exists
                (fun c -> StringSet.mem c explicit_arity_constructors)
                (longident_for_arity lid.txt) &&
             explicit_arity_not_exists pexp_attributes ->
           {pexp_desc=Pexp_construct(lid, Some (wrap_expr_with_tuple sp));
            pexp_loc;
            pexp_attributes=add_explicit_arity pexp_loc pexp_attributes}
        | x -> x
    in
    default_mapper.expr mapper expr
  end;
  pat = begin fun mapper pat ->
    let pat =
      match pat with
        | {ppat_desc=Ppat_construct(lid, Some sp);
           ppat_loc;
           ppat_attributes} when
              List.exists
                  (fun c -> StringSet.mem c explicit_arity_constructors)
                  (longident_for_arity lid.txt) &&
              explicit_arity_not_exists ppat_attributes ->
           {ppat_desc=Ppat_construct(lid, Some (wrap_pat_with_tuple sp));
            ppat_loc;
            ppat_attributes=add_explicit_arity ppat_loc ppat_attributes}
        | x -> x
    in
    default_mapper.pat mapper pat
  end;
}

let preprocessing_chain = [add_explicit_arity_mapper; escape_stars_slashes_mapper; ml_to_reason_swap_operator_mapper]

let core_type f x =
  easyFormatToFormatter f (layoutToEasyFormatNoComments (easy#core_type (apply_mapper_chain_to_type x preprocessing_chain)))
let pattern f x =
  easyFormatToFormatter f (layoutToEasyFormatNoComments (easy#pattern (apply_mapper_chain_to_pattern x preprocessing_chain)))
let signature (comments : commentWithCategory) f x =
  easyFormatToFormatter f (layoutToEasyFormat (easy#signature (apply_mapper_chain_to_signature x preprocessing_chain)) comments)
let structure (comments : commentWithCategory) f x =
  easyFormatToFormatter f (layoutToEasyFormat (easy#structure (apply_mapper_chain_to_structure x preprocessing_chain)) comments)
let expression f x =
  easyFormatToFormatter f (layoutToEasyFormatNoComments (easy#unparseExpr (apply_mapper_chain_to_expr x preprocessing_chain)))
let case_list = case_list
end
in
object
  method core_type = Formatter.core_type
  method pattern = Formatter.pattern
  method signature = Formatter.signature
  method structure = Formatter.structure
  (* For merlin-destruct *)
  method toplevel_phrase = Formatter.toplevel_phrase
  method expression = Formatter.expression
  method case_list = Formatter.case_list
end

let defaultSettings = defaultSettings

end
module Printer_maker
= struct
#1 "printer_maker.ml"
open Migrate_parsetree
open Ast_404

type parse_itype = [ `ML | `Reason | `Binary | `BinaryReason | `Auto ]
type print_itype = [ `ML | `Reason | `Binary | `BinaryReason | `AST | `None ]

exception Invalid_config of string

module type PRINTER =
    sig
        type q
        type t = q list

        val parse : add_runtime:bool ->
                    use_stdin:bool ->
                    parse_itype ->
                    string ->
                    ((t * Reason_pprint_ast.commentWithCategory) * bool)

        val ppx_deriving_runtime : q

        val print : print_itype ->
                    string ->
                    bool ->
                    out_channel ->
                    Format.formatter ->
                    ((t * Reason_pprint_ast.commentWithCategory) -> unit)
    end

let err s = raise (Invalid_config s)

let prepare_output_file = function
    | Some name -> open_out_bin name
    | None -> set_binary_mode_out stdout true; stdout

let close_output_file output_file output_chan =
    match output_file with
    | Some _ -> close_out output_chan
    | None -> ()

let ocamlBinaryParser use_stdin filename =
  let chan =
    match use_stdin with
      | true -> stdin
      | false ->
          let file_chan = open_in filename in
          seek_in file_chan 0;
          file_chan
  in
  match Ast_io.from_channel chan with
  | Result.Error err -> assert false
  | Result.Ok (_, Ast_io.Impl ((module Version), ast)) ->
    let module Convert = Convert(Version)(OCaml_404) in
    ((Obj.magic (Convert.copy_structure ast), []), true, false)
  | Result.Ok (_, Ast_io.Intf ((module Version), ast)) ->
    let module Convert = Convert(Version)(OCaml_404) in
    ((Obj.magic (Convert.copy_signature ast), []), true, true)

let reasonBinaryParser use_stdin filename =
  let chan =
    match use_stdin with
      | true -> stdin
      | false ->
          let file_chan = open_in filename in
          seek_in file_chan 0;
          file_chan
  in
  let (magic_number, filename, ast, comments, parsedAsML, parsedAsInterface) = input_value chan in
  ((ast, comments), parsedAsML, parsedAsInterface)

end
module Reason_config
= struct
#1 "reason_config.ml"
(**
 * Copyright (c) 2015-present, Facebook, Inc. All rights reserved.
 *)

let recoverable = ref false
let add_printers = ref false

let configure ~r ~ap = (
  recoverable := r;
  add_printers := ap
)

end
module MenhirLib : sig 
#1 "menhirLib.mli"
module General : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This module offers general-purpose functions on lists and streams. *)

(* As of 2017/03/31, this module is DEPRECATED. It might be removed in
   the future. *)

(* --------------------------------------------------------------------------- *)

(* Lists. *)

(* [take n xs] returns the [n] first elements of the list [xs]. It is
   acceptable  for the list [xs] to have length less than [n], in
   which case [xs] itself is returned. *)

val take: int -> 'a list -> 'a list

(* [drop n xs] returns the list [xs], deprived of its [n] first elements.
   It is acceptable for the list [xs] to have length less than [n], in
   which case an empty list is returned. *)

val drop: int -> 'a list -> 'a list

(* [uniq cmp xs] assumes that the list [xs] is sorted according to the
   ordering [cmp] and returns the list [xs] deprived of any duplicate
   elements. *)

val uniq: ('a -> 'a -> int) -> 'a list -> 'a list

(* [weed cmp xs] returns the list [xs] deprived of any duplicate elements. *)

val weed: ('a -> 'a -> int) -> 'a list -> 'a list

(* --------------------------------------------------------------------------- *)

(* A stream is a list whose elements are produced on demand. *)

type 'a stream =
    'a head Lazy.t

and 'a head =
  | Nil
  | Cons of 'a * 'a stream

(* The length of a stream. *)

val length: 'a stream -> int

(* Folding over a stream. *)

val foldr: ('a -> 'b -> 'b) -> 'a stream -> 'b -> 'b
end
module Convert : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* An ocamlyacc-style, or Menhir-style, parser requires access to
   the lexer, which must be parameterized with a lexing buffer, and
   to the lexing buffer itself, where it reads position information. *)

(* This traditional API is convenient when used with ocamllex, but
   inelegant when used with other lexer generators. *)

type ('token, 'semantic_value) traditional =
    (Lexing.lexbuf -> 'token) -> Lexing.lexbuf -> 'semantic_value

(* This revised API is independent of any lexer generator. Here, the
   parser only requires access to the lexer, and the lexer takes no
   parameters. The tokens returned by the lexer may contain position
   information. *)

type ('token, 'semantic_value) revised =
    (unit -> 'token) -> 'semantic_value

(* --------------------------------------------------------------------------- *)

(* Converting a traditional parser, produced by ocamlyacc or Menhir,
   into a revised parser. *)

(* A token of the revised lexer is essentially a triple of a token
   of the traditional lexer (or raw token), a start position, and
   and end position. The three [get] functions are accessors. *)

(* We do not require the type ['token] to actually be a triple type.
   This enables complex applications where it is a record type with
   more than three fields. It also enables simple applications where
   positions are of no interest, so ['token] is just ['raw_token]
   and [get_startp] and [get_endp] return dummy positions. *)

val traditional2revised:
  ('token -> 'raw_token) ->
  ('token -> Lexing.position) ->
  ('token -> Lexing.position) ->
  ('raw_token, 'semantic_value) traditional ->
  ('token, 'semantic_value) revised

(* --------------------------------------------------------------------------- *)

(* Converting a revised parser back to a traditional parser. *)

val revised2traditional:
  ('raw_token -> Lexing.position -> Lexing.position -> 'token) ->
  ('token, 'semantic_value) revised ->
  ('raw_token, 'semantic_value) traditional

(* --------------------------------------------------------------------------- *)

(* Simplified versions of the above, where concrete triples are used. *)

module Simplified : sig

  val traditional2revised:
    ('token, 'semantic_value) traditional ->
    ('token * Lexing.position * Lexing.position, 'semantic_value) revised

  val revised2traditional:
    ('token * Lexing.position * Lexing.position, 'semantic_value) revised ->
    ('token, 'semantic_value) traditional

end
end
module IncrementalEngine : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

type position = Lexing.position

open General

(* This signature describes the incremental LR engine. *)

(* In this mode, the user controls the lexer, and the parser suspends
   itself when it needs to read a new token. *)

module type INCREMENTAL_ENGINE = sig

  type token

  (* A value of type [production] is (an index for) a production. The start
     productions (which do not exist in an \mly file, but are constructed by
     Menhir internally) are not part of this type. *)

  type production

  (* The type ['a checkpoint] represents an intermediate or final state of the
     parser. An intermediate checkpoint is a suspension: it records the parser's
     current state, and allows parsing to be resumed. The parameter ['a] is
     the type of the semantic value that will eventually be produced if the
     parser succeeds. *)

  (* [Accepted] and [Rejected] are final checkpoints. [Accepted] carries a
     semantic value. *)

  (* [InputNeeded] is an intermediate checkpoint. It means that the parser wishes
     to read one token before continuing. *)

  (* [Shifting] is an intermediate checkpoint. It means that the parser is taking
     a shift transition. It exposes the state of the parser before and after
     the transition. The Boolean parameter tells whether the parser intends to
     request a new token after this transition. (It always does, except when
     it is about to accept.) *)

  (* [AboutToReduce] is an intermediate checkpoint. It means that the parser is
     about to perform a reduction step. It exposes the parser's current
     state as well as the production that is about to be reduced. *)

  (* [HandlingError] is an intermediate checkpoint. It means that the parser has
     detected an error and is currently handling it, in several steps. *)

  (* A value of type ['a env] represents a configuration of the automaton:
     current state, stack, lookahead token, etc. The parameter ['a] is the
     type of the semantic value that will eventually be produced if the parser
     succeeds. *)

  (* In normal operation, the parser works with checkpoints: see the functions
     [offer] and [resume]. However, it is also possible to work directly with
     environments (see the functions [pop], [force_reduction], and [feed]) and
     to reconstruct a checkpoint out of an environment (see [input_needed]).
     This is considered advanced functionality; its purpose is to allow error
     recovery strategies to be programmed by the user. *)

  type 'a env

  type 'a checkpoint = private
    | InputNeeded of 'a env
    | Shifting of 'a env * 'a env * bool
    | AboutToReduce of 'a env * production
    | HandlingError of 'a env
    | Accepted of 'a
    | Rejected

  (* [offer] allows the user to resume the parser after it has suspended
     itself with a checkpoint of the form [InputNeeded env]. [offer] expects the
     old checkpoint as well as a new token and produces a new checkpoint. It does not
     raise any exception. *)

  val offer:
    'a checkpoint ->
    token * position * position ->
    'a checkpoint

  (* [resume] allows the user to resume the parser after it has suspended
     itself with a checkpoint of the form [AboutToReduce (env, prod)] or
     [HandlingError env]. [resume] expects the old checkpoint and produces a new
     checkpoint. It does not raise any exception. *)

  val resume:
    'a checkpoint ->
    'a checkpoint

  (* A token supplier is a function of no arguments which delivers a new token
     (together with its start and end positions) every time it is called. *)

  type supplier =
    unit -> token * position * position

  (* A pair of a lexer and a lexing buffer can be easily turned into a supplier. *)

  val lexer_lexbuf_to_supplier:
    (Lexing.lexbuf -> token) ->
    Lexing.lexbuf ->
    supplier

  (* The functions [offer] and [resume] are sufficient to write a parser loop.
     One can imagine many variations (which is why we expose these functions
     in the first place!). Here, we expose a few variations of the main loop,
     ready for use. *)

  (* [loop supplier checkpoint] begins parsing from [checkpoint], reading
     tokens from [supplier]. It continues parsing until it reaches a
     checkpoint of the form [Accepted v] or [Rejected]. In the former case, it
     returns [v]. In the latter case, it raises the exception [Error]. *)

  val loop: supplier -> 'a checkpoint -> 'a

  (* [loop_handle succeed fail supplier checkpoint] begins parsing from
     [checkpoint], reading tokens from [supplier]. It continues parsing until
     it reaches a checkpoint of the form [Accepted v] or [HandlingError env]
     (or [Rejected], but that should not happen, as [HandlingError _] will be
     observed first). In the former case, it calls [succeed v]. In the latter
     case, it calls [fail] with this checkpoint. It cannot raise [Error].

     This means that Menhir's traditional error-handling procedure (which pops
     the stack until a state that can act on the [error] token is found) does
     not get a chance to run. Instead, the user can implement her own error
     handling code, in the [fail] continuation. *)

  val loop_handle:
    ('a -> 'answer) ->
    ('a checkpoint -> 'answer) ->
    supplier -> 'a checkpoint -> 'answer

  (* [loop_handle_undo] is analogous to [loop_handle], except it passes a pair
     of checkpoints to the failure continuation.

     The first (and oldest) checkpoint is the last [InputNeeded] checkpoint that
     was encountered before the error was detected. The second (and newest)
     checkpoint is where the error was detected, as in [loop_handle]. Going back
     to the first checkpoint can be thought of as undoing any reductions that
     were performed after seeing the problematic token. (These reductions must
     be default reductions or spurious reductions.)

     [loop_handle_undo] must initially be applied to an [InputNeeded] checkpoint.
     The parser's initial checkpoints satisfy this constraint. *)

  val loop_handle_undo:
    ('a -> 'answer) ->
    ('a checkpoint -> 'a checkpoint -> 'answer) ->
    supplier -> 'a checkpoint -> 'answer

  (* [shifts checkpoint] assumes that [checkpoint] has been obtained by
     submitting a token to the parser. It runs the parser from [checkpoint],
     through an arbitrary number of reductions, until the parser either
     accepts this token (i.e., shifts) or rejects it (i.e., signals an error).
     If the parser decides to shift, then [Some env] is returned, where [env]
     is the parser's state just before shifting. Otherwise, [None] is
     returned. *)

  (* It is desirable that the semantic actions be side-effect free, or that
     their side-effects be harmless (replayable). *)

  val shifts: 'a checkpoint -> 'a env option

  (* The function [acceptable] allows testing, after an error has been
     detected, which tokens would have been accepted at this point. It is
     implemented using [shifts]. Its argument should be an [InputNeeded]
     checkpoint. *)

  (* For completeness, one must undo any spurious reductions before carrying out
     this test -- that is, one must apply [acceptable] to the FIRST checkpoint
     that is passed by [loop_handle_undo] to its failure continuation. *)

  (* This test causes some semantic actions to be run! The semantic actions
     should be side-effect free, or their side-effects should be harmless. *)

  (* The position [pos] is used as the start and end positions of the
     hypothetical token, and may be picked up by the semantic actions. We
     suggest using the position where the error was detected. *)

  val acceptable: 'a checkpoint -> token -> position -> bool

  (* The abstract type ['a lr1state] describes the non-initial states of the
     LR(1) automaton. The index ['a] represents the type of the semantic value
     associated with this state's incoming symbol. *)

  type 'a lr1state

  (* The states of the LR(1) automaton are numbered (from 0 and up). *)

  val number: _ lr1state -> int

  (* Productions are numbered. *)

  (* [find_production i] requires the index [i] to be valid. Use with care. *)

  val production_index: production -> int
  val find_production: int -> production

  (* An element is a pair of a non-initial state [s] and a semantic value [v]
     associated with the incoming symbol of this state. The idea is, the value
     [v] was pushed onto the stack just before the state [s] was entered. Thus,
     for some type ['a], the state [s] has type ['a lr1state] and the value [v]
     has type ['a]. In other words, the type [element] is an existential type. *)

  type element =
    | Element: 'a lr1state * 'a * position * position -> element

  (* The parser's stack is (or, more precisely, can be viewed as) a stream of
     elements. The type [stream] is defined by the module [General]. *)

  (* As of 2017/03/31, the types [stream] and [stack] and the function [stack]
     are DEPRECATED. They might be removed in the future. An alternative way
     of inspecting the stack is via the functions [top] and [pop]. *)

  type stack = (* DEPRECATED *)
    element stream

  (* This is the parser's stack, a stream of elements. This stream is empty if
     the parser is in an initial state; otherwise, it is non-empty.  The LR(1)
     automaton's current state is the one found in the top element of the
     stack. *)

  val stack: 'a env -> stack (* DEPRECATED *)

  (* [top env] returns the parser's top stack element. The state contained in
     this stack element is the current state of the automaton. If the stack is
     empty, [None] is returned. In that case, the current state of the
     automaton must be an initial state. *)

  val top: 'a env -> element option

  (* [pop_many i env] pops [i] cells off the automaton's stack. This is done
     via [i] successive invocations of [pop]. Thus, [pop_many 1] is [pop]. The
     index [i] must be nonnegative. The time complexity is O(i). *)

  val pop_many: int -> 'a env -> 'a env option

  (* [get i env] returns the parser's [i]-th stack element. The index [i] is
     0-based: thus, [get 0] is [top]. If [i] is greater than or equal to the
     number of elements in the stack, [None] is returned. The time complexity
     is O(i). *)

  val get: int -> 'a env -> element option

  (* [current_state_number env] is (the integer number of) the automaton's
     current state. This works even if the automaton's stack is empty, in
     which case the current state is an initial state. This number can be
     passed as an argument to a [message] function generated by [menhir
     --compile-errors]. *)

  val current_state_number: 'a env -> int

  (* [equal env1 env2] tells whether the parser configurations [env1] and
     [env2] are equal in the sense that the automaton's current state is the
     same in [env1] and [env2] and the stack is *physically* the same in
     [env1] and [env2]. If [equal env1 env2] is [true], then the sequence of
     the stack elements, as observed via [pop] and [top], must be the same in
     [env1] and [env2]. Also, if [equal env1 env2] holds, then the checkpoints
     [input_needed env1] and [input_needed env2] must be equivalent. The
     function [equal] has time complexity O(1). *)

  val equal: 'a env -> 'a env -> bool

  (* These are the start and end positions of the current lookahead token. If
     invoked in an initial state, this function returns a pair of twice the
     initial position. *)

  val positions: 'a env -> position * position

  (* When applied to an environment taken from a checkpoint of the form
     [AboutToReduce (env, prod)], the function [env_has_default_reduction]
     tells whether the reduction that is about to take place is a default
     reduction. *)

  val env_has_default_reduction: 'a env -> bool

  (* [state_has_default_reduction s] tells whether the state [s] has a default
     reduction. This includes the case where [s] is an accepting state. *)

  val state_has_default_reduction: _ lr1state -> bool

  (* [pop env] returns a new environment, where the parser's top stack cell
     has been popped off. (If the stack is empty, [None] is returned.) This
     amounts to pretending that the (terminal or nonterminal) symbol that
     corresponds to this stack cell has not been read. *)

  val pop: 'a env -> 'a env option

  (* [force_reduction prod env] should be called only if in the state [env]
     the parser is capable of reducing the production [prod]. If this
     condition is satisfied, then this production is reduced, which means that
     its semantic action is executed (this can have side effects!) and the
     automaton makes a goto (nonterminal) transition. If this condition is not
     satisfied, [Invalid_argument _] is raised. *)

  val force_reduction: production -> 'a env -> 'a env

  (* [input_needed env] returns [InputNeeded env]. That is, out of an [env]
     that might have been obtained via a series of calls to the functions
     [pop], [force_reduction], [feed], etc., it produces a checkpoint, which
     can be used to resume normal parsing, by supplying this checkpoint as an
     argument to [offer]. *)

  (* This function should be used with some care. It could "mess up the
     lookahead" in the sense that it allows parsing to resume in an arbitrary
     state [s] with an arbitrary lookahead symbol [t], even though Menhir's
     reachability analysis (menhir --list-errors) might well think that it is
     impossible to reach this particular configuration. If one is using
     Menhir's new error reporting facility, this could cause the parser to
     reach an error state for which no error message has been prepared. *)

  val input_needed: 'a env -> 'a checkpoint

end

(* This signature is a fragment of the inspection API that is made available
   to the user when [--inspection] is used. This fragment contains type
   definitions for symbols. *)

module type SYMBOLS = sig

  (* The type ['a terminal] represents a terminal symbol. The type ['a
     nonterminal] represents a nonterminal symbol. In both cases, the index
     ['a] represents the type of the semantic values associated with this
     symbol. The concrete definitions of these types are generated. *)

  type 'a terminal
  type 'a nonterminal

  (* The type ['a symbol] represents a terminal or nonterminal symbol. It is
     the disjoint union of the types ['a terminal] and ['a nonterminal]. *)

  type 'a symbol =
    | T : 'a terminal -> 'a symbol
    | N : 'a nonterminal -> 'a symbol

  (* The type [xsymbol] is an existentially quantified version of the type
     ['a symbol]. This type is useful in situations where the index ['a]
     is not statically known. *)

  type xsymbol =
    | X : 'a symbol -> xsymbol

end

(* This signature describes the inspection API that is made available to the
   user when [--inspection] is used. *)

module type INSPECTION = sig

  (* The types of symbols are described above. *)

  include SYMBOLS

  (* The type ['a lr1state] is meant to be the same as in [INCREMENTAL_ENGINE]. *)

  type 'a lr1state

  (* The type [production] is meant to be the same as in [INCREMENTAL_ENGINE].
     It represents a production of the grammar. A production can be examined
     via the functions [lhs] and [rhs] below. *)

  type production

  (* An LR(0) item is a pair of a production [prod] and a valid index [i] into
     this production. That is, if the length of [rhs prod] is [n], then [i] is
     comprised between 0 and [n], inclusive. *)

  type item =
      production * int

  (* Ordering functions. *)

  val compare_terminals: _ terminal -> _ terminal -> int
  val compare_nonterminals: _ nonterminal -> _ nonterminal -> int
  val compare_symbols: xsymbol -> xsymbol -> int
  val compare_productions: production -> production -> int
  val compare_items: item -> item -> int

  (* [incoming_symbol s] is the incoming symbol of the state [s], that is,
     the symbol that the parser must recognize before (has recognized when)
     it enters the state [s]. This function gives access to the semantic
     value [v] stored in a stack element [Element (s, v, _, _)]. Indeed,
     by case analysis on the symbol [incoming_symbol s], one discovers the
     type ['a] of the value [v]. *)

  val incoming_symbol: 'a lr1state -> 'a symbol

  (* [items s] is the set of the LR(0) items in the LR(0) core of the LR(1)
     state [s]. This set is not epsilon-closed. This set is presented as a
     list, in an arbitrary order. *)

  val items: _ lr1state -> item list

  (* [lhs prod] is the left-hand side of the production [prod]. This is
     always a non-terminal symbol. *)

  val lhs: production -> xsymbol

  (* [rhs prod] is the right-hand side of the production [prod]. This is
     a (possibly empty) sequence of (terminal or nonterminal) symbols. *)

  val rhs: production -> xsymbol list

  (* [nullable nt] tells whether the non-terminal symbol [nt] is nullable.
     That is, it is true if and only if this symbol produces the empty
     word [epsilon]. *)

  val nullable: _ nonterminal -> bool

  (* [first nt t] tells whether the FIRST set of the nonterminal symbol [nt]
     contains the terminal symbol [t]. That is, it is true if and only if
     [nt] produces a word that begins with [t]. *)

  val first: _ nonterminal -> _ terminal -> bool

  (* [xfirst] is analogous to [first], but expects a first argument of type
     [xsymbol] instead of [_ terminal]. *)

  val xfirst: xsymbol -> _ terminal -> bool

  (* [foreach_terminal] enumerates the terminal symbols, including [error].
     [foreach_terminal_but_error] enumerates the terminal symbols, excluding
     [error]. *)

  val foreach_terminal:           (xsymbol -> 'a -> 'a) -> 'a -> 'a
  val foreach_terminal_but_error: (xsymbol -> 'a -> 'a) -> 'a -> 'a

  (* The type [env] is meant to be the same as in [INCREMENTAL_ENGINE]. *)

  type 'a env

  (* [feed symbol startp semv endp env] causes the parser to consume the
     (terminal or nonterminal) symbol [symbol], accompanied with the semantic
     value [semv] and with the start and end positions [startp] and [endp].
     Thus, the automaton makes a transition, and reaches a new state. The
     stack grows by one cell. This operation is permitted only if the current
     state (as determined by [env]) has an outgoing transition labeled with
     [symbol]. Otherwise, [Invalid_argument _] is raised. *)

  val feed: 'a symbol -> position -> 'a -> position -> 'b env -> 'b env

end

(* This signature combines the incremental API and the inspection API. *)

module type EVERYTHING = sig

  include INCREMENTAL_ENGINE

  include INSPECTION
    with type 'a lr1state := 'a lr1state
    with type production := production
    with type 'a env := 'a env

end
end
module EngineTypes : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This file defines several types and module types that are used in the
   specification of module [Engine]. *)

(* --------------------------------------------------------------------------- *)

(* It would be nice if we could keep the structure of stacks and environments
   hidden. However, stacks and environments must be accessible to semantic
   actions, so the following data structure definitions must be public. *)

(* --------------------------------------------------------------------------- *)

(* A stack is a linked list of cells. A sentinel cell -- which is its own
   successor -- is used to mark the bottom of the stack. The sentinel cell
   itself is not significant -- it contains dummy values. *)

type ('state, 'semantic_value) stack = {

  (* The state that we should go back to if we pop this stack cell. *)

  (* This convention means that the state contained in the top stack cell is
     not the current state [env.current]. It also means that the state found
     within the sentinel is a dummy -- it is never consulted. This convention
     is the same as that adopted by the code-based back-end. *)

  state: 'state;

  (* The semantic value associated with the chunk of input that this cell
     represents. *)

  semv: 'semantic_value;

  (* The start and end positions of the chunk of input that this cell
     represents. *)

  startp: Lexing.position;
  endp: Lexing.position;

  (* The next cell down in the stack. If this is a self-pointer, then this
     cell is the sentinel, and the stack is conceptually empty. *)

  next: ('state, 'semantic_value) stack;

}

(* --------------------------------------------------------------------------- *)

(* A parsing environment contains all of the parser's state (except for the
   current program point). *)

type ('state, 'semantic_value, 'token) env = {

  (* If this flag is true, then the first component of [env.triple] should
     be ignored, as it has been logically overwritten with the [error]
     pseudo-token. *)

  error: bool;

  (* The last token that was obtained from the lexer, together with its start
     and end positions. Warning: before the first call to the lexer has taken
     place, a dummy (and possibly invalid) token is stored here. *)

  triple: 'token * Lexing.position * Lexing.position;

  (* The stack. In [CodeBackend], it is passed around on its own,
     whereas, here, it is accessed via the environment. *)

  stack: ('state, 'semantic_value) stack;

  (* The current state. In [CodeBackend], it is passed around on its
     own, whereas, here, it is accessed via the environment. *)

  current: 'state;

}

(* --------------------------------------------------------------------------- *)

(* This signature describes the parameters that must be supplied to the LR
   engine. *)

module type TABLE = sig

  (* The type of automaton states. *)

  type state

  (* States are numbered. *)

  val number: state -> int

  (* The type of tokens. These can be thought of as real tokens, that is,
     tokens returned by the lexer. They carry a semantic value. This type
     does not include the [error] pseudo-token. *)

  type token

  (* The type of terminal symbols. These can be thought of as integer codes.
     They do not carry a semantic value. This type does include the [error]
     pseudo-token. *)

  type terminal

  (* The type of nonterminal symbols. *)

  type nonterminal

  (* The type of semantic values. *)

  type semantic_value

  (* A token is conceptually a pair of a (non-[error]) terminal symbol and
     a semantic value. The following two functions are the pair projections. *)

  val token2terminal: token -> terminal
  val token2value: token -> semantic_value

  (* Even though the [error] pseudo-token is not a real token, it is a
     terminal symbol. Furthermore, for regularity, it must have a semantic
     value. *)

  val error_terminal: terminal
  val error_value: semantic_value

  (* [foreach_terminal] allows iterating over all terminal symbols. *)

  val foreach_terminal: (terminal -> 'a -> 'a) -> 'a -> 'a

  (* The type of productions. *)

  type production

  val production_index: production -> int
  val find_production: int -> production

  (* If a state [s] has a default reduction on production [prod], then, upon
     entering [s], the automaton should reduce [prod] without consulting the
     lookahead token. The following function allows determining which states
     have default reductions. *)

  (* Instead of returning a value of a sum type -- either [DefRed prod], or
     [NoDefRed] -- it accepts two continuations, and invokes just one of
     them. This mechanism allows avoiding a memory allocation. *)

  val default_reduction:
    state ->
    ('env -> production -> 'answer) ->
    ('env -> 'answer) ->
    'env -> 'answer

  (* An LR automaton can normally take three kinds of actions: shift, reduce,
     or fail. (Acceptance is a particular case of reduction: it consists in
     reducing a start production.) *)

  (* There are two variants of the shift action. [shift/discard s] instructs
     the automaton to discard the current token, request a new one from the
     lexer, and move to state [s]. [shift/nodiscard s] instructs it to move to
     state [s] without requesting a new token. This instruction should be used
     when [s] has a default reduction on [#]. See [CodeBackend.gettoken] for
     details. *)

  (* This is the automaton's action table. It maps a pair of a state and a
     terminal symbol to an action. *)

  (* Instead of returning a value of a sum type -- one of shift/discard,
     shift/nodiscard, reduce, or fail -- this function accepts three
     continuations, and invokes just one them. This mechanism allows avoiding
     a memory allocation. *)

  (* In summary, the parameters to [action] are as follows:

     - the first two parameters, a state and a terminal symbol, are used to
       look up the action table;

     - the next parameter is the semantic value associated with the above
       terminal symbol; it is not used, only passed along to the shift
       continuation, as explained below;

     - the shift continuation expects an environment; a flag that tells
       whether to discard the current token; the terminal symbol that
       is being shifted; its semantic value; and the target state of
       the transition;

     - the reduce continuation expects an environment and a production;

     - the fail continuation expects an environment;

     - the last parameter is the environment; it is not used, only passed
       along to the selected continuation. *)

  val action:
    state ->
    terminal ->
    semantic_value ->
    ('env -> bool -> terminal -> semantic_value -> state -> 'answer) ->
    ('env -> production -> 'answer) ->
    ('env -> 'answer) ->
    'env -> 'answer

  (* This is the automaton's goto table. This table maps a pair of a state
     and a nonterminal symbol to a new state. By extension, it also maps a
     pair of a state and a production to a new state. *)

  (* The function [goto_nt] can be applied to [s] and [nt] ONLY if the state
     [s] has an outgoing transition labeled [nt]. Otherwise, its result is
     undefined. Similarly, the call [goto_prod prod s] is permitted ONLY if
     the state [s] has an outgoing transition labeled with the nonterminal
     symbol [lhs prod]. The function [maybe_goto_nt] involves an additional
     dynamic check and CAN be called even if there is no outgoing transition. *)

  val       goto_nt  : state -> nonterminal -> state
  val       goto_prod: state -> production  -> state
  val maybe_goto_nt:   state -> nonterminal -> state option

  (* [is_start prod] tells whether the production [prod] is a start production. *)

  val is_start: production -> bool

  (* By convention, a semantic action is responsible for:

     1. fetching whatever semantic values and positions it needs off the stack;

     2. popping an appropriate number of cells off the stack, as dictated
        by the length of the right-hand side of the production;

     3. computing a new semantic value, as well as new start and end positions;

     4. pushing a new stack cell, which contains the three values
        computed in step 3;

     5. returning the new stack computed in steps 2 and 4.

     Point 1 is essentially forced upon us: if semantic values were fetched
     off the stack by this interpreter, then the calling convention for
     semantic actions would be variadic: not all semantic actions would have
     the same number of arguments. The rest follows rather naturally. *)

  (* Semantic actions are allowed to raise [Error]. *)

  exception Error

  type semantic_action =
      (state, semantic_value, token) env -> (state, semantic_value) stack

  val semantic_action: production -> semantic_action

  (* [may_reduce state prod] tests whether the state [state] is capable of
     reducing the production [prod]. This function is currently costly and
     is not used by the core LR engine. It is used in the implementation
     of certain functions, such as [force_reduction], which allow the engine
     to be driven programmatically. *)

  val may_reduce: state -> production -> bool

  (* The LR engine requires a number of hooks, which are used for logging. *)

  (* The comments below indicate the conventional messages that correspond
     to these hooks in the code-based back-end; see [CodeBackend]. *)

  (* If the flag [log] is false, then the logging functions are not called.
     If it is [true], then they are called. *)

  val log : bool

  module Log : sig

    (* State %d: *)

    val state: state -> unit

    (* Shifting (<terminal>) to state <state> *)

    val shift: terminal -> state -> unit

    (* Reducing a production should be logged either as a reduction
       event (for regular productions) or as an acceptance event (for
       start productions). *)

    (* Reducing production <production> / Accepting *)

    val reduce_or_accept: production -> unit

    (* Lookahead token is now <terminal> (<pos>-<pos>) *)

    val lookahead_token: terminal -> Lexing.position -> Lexing.position -> unit

    (* Initiating error handling *)

    val initiating_error_handling: unit -> unit

    (* Resuming error handling *)

    val resuming_error_handling: unit -> unit

    (* Handling error in state <state> *)

    val handling_error: state -> unit

  end

end

(* --------------------------------------------------------------------------- *)

(* This signature describes the monolithic (traditional) LR engine. *)

(* In this interface, the parser controls the lexer. *)

module type MONOLITHIC_ENGINE = sig

  type state

  type token

  type semantic_value

  (* An entry point to the engine requires a start state, a lexer, and a lexing
     buffer. It either succeeds and produces a semantic value, or fails and
     raises [Error]. *)

  exception Error

  val entry:
    state ->
    (Lexing.lexbuf -> token) ->
    Lexing.lexbuf ->
    semantic_value

end

(* --------------------------------------------------------------------------- *)

(* The following signatures describe the incremental LR engine. *)

(* First, see [INCREMENTAL_ENGINE] in the file [IncrementalEngine.ml]. *)

(* The [start] function is set apart because we do not wish to publish
   it as part of the generated [parser.mli] file. Instead, the table
   back-end will publish specialized versions of it, with a suitable
   type cast. *)

module type INCREMENTAL_ENGINE_START = sig

  (* [start] is an entry point. It requires a start state and a start position
     and begins the parsing process. If the lexer is based on an OCaml lexing
     buffer, the start position should be [lexbuf.lex_curr_p]. [start] produces
     a checkpoint, which usually will be an [InputNeeded] checkpoint. (It could
     be [Accepted] if this starting state accepts only the empty word. It could
     be [Rejected] if this starting state accepts no word at all.) It does not
     raise any exception. *)

  (* [start s pos] should really produce a checkpoint of type ['a checkpoint],
     for a fixed ['a] that depends on the state [s]. We cannot express this, so
     we use [semantic_value checkpoint], which is safe. The table back-end uses
     [Obj.magic] to produce safe specialized versions of [start]. *)

  type state
  type semantic_value
  type 'a checkpoint

  val start:
    state ->
    Lexing.position ->
    semantic_value checkpoint

end

(* --------------------------------------------------------------------------- *)

(* This signature describes the LR engine, which combines the monolithic
   and incremental interfaces. *)

module type ENGINE = sig

  include MONOLITHIC_ENGINE

  include IncrementalEngine.INCREMENTAL_ENGINE
    with type token := token
     and type 'a lr1state = state (* useful for us; hidden from the end user *)

  include INCREMENTAL_ENGINE_START
    with type state := state
     and type semantic_value := semantic_value
     and type 'a checkpoint := 'a checkpoint

end
end
module Engine : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

open EngineTypes

(* The LR parsing engine. *)

module Make (T : TABLE)
: ENGINE
  with type state = T.state
   and type token = T.token
   and type semantic_value = T.semantic_value
   and type production = T.production
   and type 'a env = (T.state, T.semantic_value, T.token) EngineTypes.env

(* We would prefer not to expose the definition of the type [env].
   However, it must be exposed because some of the code in the
   inspection API needs access to the engine's internals; see
   [InspectionTableInterpreter]. Everything would be simpler if
   --inspection was always ON, but that would lead to bigger parse
   tables for everybody. *)
end
module ErrorReports : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* -------------------------------------------------------------------------- *)

(* The following functions help keep track of the start and end positions of
   the last two tokens in a two-place buffer. This is used to nicely display
   where a syntax error took place. *)

type 'a buffer

(* [wrap lexer] returns a pair of a new (initially empty) buffer and a lexer
   which internally relies on [lexer] and updates [buffer] on the fly whenever
   a token is demanded. *)

open Lexing

val wrap:
  (lexbuf -> 'token) ->
  (position * position) buffer * (lexbuf -> 'token)

(* [show f buffer] prints the contents of the buffer, producing a string that
   is typically of the form "after '%s' and before '%s'". The function [f] is
   used to print an element. The buffer MUST be nonempty. *)

val show: ('a -> string) -> 'a buffer -> string

(* [last buffer] returns the last element of the buffer. The buffer MUST be
   nonempty. *)

val last: 'a buffer -> 'a

(* -------------------------------------------------------------------------- *)
end
module Printers : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This module is part of MenhirLib. *)

module Make

  (I : IncrementalEngine.EVERYTHING)

  (User : sig

    (* [print s] is supposed to send the string [s] to some output channel. *)

    val print: string -> unit

    (* [print_symbol s] is supposed to print a representation of the symbol [s]. *)

    val print_symbol: I.xsymbol -> unit

    (* [print_element e] is supposed to print a representation of the element [e].
       This function is optional; if it is not provided, [print_element_as_symbol]
       (defined below) is used instead. *)

    val print_element: (I.element -> unit) option

  end)

: sig

  open I

  (* Printing a list of symbols. *)

  val print_symbols: xsymbol list -> unit

  (* Printing an element as a symbol. This prints just the symbol
     that this element represents; nothing more. *)

  val print_element_as_symbol: element -> unit

  (* Printing a stack as a list of elements. This function needs an element
     printer. It uses [print_element] if provided by the user; otherwise
     it uses [print_element_as_symbol]. (Ending with a newline.) *)

  val print_stack: 'a env -> unit

  (* Printing an item. (Ending with a newline.) *)

  val print_item: item -> unit

  (* Printing a production. (Ending with a newline.) *)

  val print_production: production -> unit

  (* Printing the current LR(1) state. The current state is first displayed
     as a number; then the list of its LR(0) items is printed. (Ending with
     a newline.) *)

  val print_current_state: 'a env -> unit

  (* Printing a summary of the stack and current state. This function just
     calls [print_stack] and [print_current_state] in succession. *)

  val print_env: 'a env -> unit

end
end
module InfiniteArray : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(** This module implements infinite arrays. **)
type 'a t

(** [make x] creates an infinite array, where every slot contains [x]. **)
val make: 'a -> 'a t

(** [get a i] returns the element contained at offset [i] in the array [a].
   Slots are numbered 0 and up. **)
val get: 'a t -> int -> 'a

(** [set a i x] sets the element contained at offset [i] in the array
    [a] to [x]. Slots are numbered 0 and up. **)
val set: 'a t -> int -> 'a -> unit

(** [extent a] is the length of an initial segment of the array [a]
    that is sufficiently large to contain all [set] operations ever
    performed. In other words, all elements beyond that segment have
    the default value. *)
val extent: 'a t -> int

(** [domain a] is a fresh copy of an initial segment of the array [a]
    whose length is [extent a]. *)
val domain: 'a t -> 'a array
end
module PackedIntArray : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* A packed integer array is represented as a pair of an integer [k] and
   a string [s]. The integer [k] is the number of bits per integer that we
   use. The string [s] is just an array of bits, which is read in 8-bit
   chunks. *)

(* The ocaml programming language treats string literals and array literals
   in slightly different ways: the former are statically allocated, while
   the latter are dynamically allocated. (This is rather arbitrary.) In the
   context of Menhir's table-based back-end, where compact, immutable
   integer arrays are needed, ocaml strings are preferable to ocaml arrays. *)

type t =
  int * string

(* [pack a] turns an array of integers into a packed integer array. *)

(* Because the sign bit is the most significant bit, the magnitude of
   any negative number is the word size. In other words, [pack] does
   not achieve any space savings as soon as [a] contains any negative
   numbers, even if they are ``small''. *)

val pack: int array -> t

(* [get t i] returns the integer stored in the packed array [t] at index [i]. *)

(* Together, [pack] and [get] satisfy the following property: if the index [i]
   is within bounds, then [get (pack a) i] equals [a.(i)]. *)

val get: t -> int -> int

(* [get1 t i] returns the integer stored in the packed array [t] at index [i].
   It assumes (and does not check) that the array's bit width is [1]. The
   parameter [t] is just a string. *)

val get1: string -> int -> int

(* [unflatten1 (n, data) i j] accesses the two-dimensional bitmap
   represented by [(n, data)] at indices [i] and [j]. The integer
   [n] is the width of the bitmap; the string [data] is the second
   component of the packed array obtained by encoding the table as
   a one-dimensional array. *)

val unflatten1: int * string -> int -> int -> int

end
module RowDisplacement : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This module compresses a two-dimensional table, where some values
   are considered insignificant, via row displacement. *)

(* A compressed table is represented as a pair of arrays. The
   displacement array is an array of offsets into the data array. *)

type 'a table =
    int array * (* displacement *)
     'a array   (* data *)

(* [compress equal insignificant dummy m n t] turns the two-dimensional table
   [t] into a compressed table. The parameter [equal] is equality of data
   values. The parameter [wildcard] tells which data values are insignificant,
   and can thus be overwritten with other values. The parameter [dummy] is
   used to fill holes in the data array. [m] and [n] are the integer
   dimensions of the table [t]. *)

val compress:
  ('a -> 'a -> bool) ->
  ('a -> bool) ->
  'a ->
  int -> int ->
  'a array array ->
  'a table

(* [get ct i j] returns the value found at indices [i] and [j] in the
   compressed table [ct]. This function call is permitted only if the
   value found at indices [i] and [j] in the original table is
   significant -- otherwise, it could fail abruptly. *)

(* Together, [compress] and [get] have the property that, if the value
   found at indices [i] and [j] in an uncompressed table [t] is
   significant, then [get (compress t) i j] is equal to that value. *)

val get:
  'a table ->
  int -> int ->
  'a

(* [getget] is a variant of [get] which only requires read access,
   via accessors, to the two components of the table. *)

val getget:
  ('displacement -> int -> int) ->
  ('data -> int -> 'a) ->
  'displacement * 'data ->
  int -> int ->
  'a

end
module LinearizedArray : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* An array of arrays (of possibly different lengths!) can be ``linearized'',
   i.e., encoded as a data array (by concatenating all of the little arrays)
   and an entry array (which contains offsets into the data array). *)

type 'a t =
  (* data: *)   'a array *
  (* entry: *) int array

(* [make a] turns the array of arrays [a] into a linearized array. *)

val make: 'a array array -> 'a t

(* [read la i j] reads the linearized array [la] at indices [i] and [j].
   Thus, [read (make a) i j] is equivalent to [a.(i).(j)]. *)

val read: 'a t -> int -> int -> 'a

(* [write la i j v] writes the value [v] into the linearized array [la]
   at indices [i] and [j]. *)

val write: 'a t -> int -> int -> 'a -> unit

(* [length la] is the number of rows of the array [la]. Thus, [length (make
   a)] is equivalent to [Array.length a]. *)

val length: 'a t -> int

(* [row_length la i] is the length of the row at index [i] in the linearized
   array [la]. Thus, [row_length (make a) i] is equivalent to [Array.length
   a.(i)]. *)

val row_length: 'a t -> int -> int

(* [read_row la i] reads the row at index [i], producing a list. Thus,
   [read_row (make a) i] is equivalent to [Array.to_list a.(i)]. *)

val read_row: 'a t -> int -> 'a list

(* The following variants read the linearized array via accessors
   [get_data : int -> 'a] and [get_entry : int -> int]. *)

val row_length_via:
  (* get_entry: *) (int -> int) ->
  (* i: *)         int ->
                   int

val read_via:
  (* get_data: *)  (int -> 'a) ->
  (* get_entry: *) (int -> int) ->
  (* i: *)         int ->
  (* j: *)         int ->
                   'a

val read_row_via:
  (* get_data: *)  (int -> 'a) ->
  (* get_entry: *) (int -> int) ->
  (* i: *)         int ->
                   'a list

end
module TableFormat : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This signature defines the format of the parse tables. It is used as
   an argument to [TableInterpreter.Make]. *)

module type TABLES = sig

  (* This is the parser's type of tokens. *)

  type token

  (* This maps a token to its internal (generation-time) integer code. *)

  val token2terminal: token -> int

  (* This is the integer code for the error pseudo-token. *)

  val error_terminal: int

  (* This maps a token to its semantic value. *)

  val token2value: token -> Obj.t

  (* Traditionally, an LR automaton is described by two tables, namely, an
     action table and a goto table. See, for instance, the Dragon book.

     The action table is a two-dimensional matrix that maps a state and a
     lookahead token to an action. An action is one of: shift to a certain
     state, reduce a certain production, accept, or fail.

     The goto table is a two-dimensional matrix that maps a state and a
     non-terminal symbol to either a state or undefined. By construction, this
     table is sparse: its undefined entries are never looked up. A compression
     technique is free to overlap them with other entries.

     In Menhir, things are slightly different. If a state has a default
     reduction on token [#], then that reduction must be performed without
     consulting the lookahead token. As a result, we must first determine
     whether that is the case, before we can obtain a lookahead token and use it
     as an index in the action table.

     Thus, Menhir's tables are as follows.

     A one-dimensional default reduction table maps a state to either ``no
     default reduction'' (encoded as: 0) or ``by default, reduce prod''
     (encoded as: 1 + prod). The action table is looked up only when there
     is no default reduction. *)

  val default_reduction: PackedIntArray.t

  (* Menhir follows Dencker, Dürre and Heuft, who point out that, although the
     action table is not sparse by nature (i.e., the error entries are
     significant), it can be made sparse by first factoring out a binary error
     matrix, then replacing the error entries in the action table with undefined
     entries. Thus:

     A two-dimensional error bitmap maps a state and a terminal to either
     ``fail'' (encoded as: 0) or ``do not fail'' (encoded as: 1). The action
     table, which is now sparse, is looked up only in the latter case. *)

  (* The error bitmap is flattened into a one-dimensional table; its width is
     recorded so as to allow indexing. The table is then compressed via
     [PackedIntArray]. The bit width of the resulting packed array must be
     [1], so it is not explicitly recorded. *)

  (* The error bitmap does not contain a column for the [#] pseudo-terminal.
     Thus, its width is [Terminal.n - 1]. We exploit the fact that the integer
     code assigned to [#] is greatest: the fact that the right-most column
     in the bitmap is missing does not affect the code for accessing it. *)

  val error: int (* width of the bitmap *) * string (* second component of [PackedIntArray.t] *)

  (* A two-dimensional action table maps a state and a terminal to one of
     ``shift to state s and discard the current token'' (encoded as: s | 10),
     ``shift to state s without discarding the current token'' (encoded as: s |
     11), or ``reduce prod'' (encoded as: prod | 01). *)

  (* The action table is first compressed via [RowDisplacement], then packed
     via [PackedIntArray]. *)

  (* Like the error bitmap, the action table does not contain a column for the
     [#] pseudo-terminal. *)

  val action: PackedIntArray.t * PackedIntArray.t

  (* A one-dimensional lhs table maps a production to its left-hand side (a
     non-terminal symbol). *)

  val lhs: PackedIntArray.t

  (* A two-dimensional goto table maps a state and a non-terminal symbol to
     either undefined (encoded as: 0) or a new state s (encoded as: 1 + s). *)

  (* The goto table is first compressed via [RowDisplacement], then packed
     via [PackedIntArray]. *)

  val goto: PackedIntArray.t * PackedIntArray.t

  (* The number of start productions. A production [prod] is a start
     production if and only if [prod < start] holds. This is also the
     number of start symbols. A nonterminal symbol [nt] is a start
     symbol if and only if [nt < start] holds. *)

  val start: int

  (* A one-dimensional semantic action table maps productions to semantic
     actions. The calling convention for semantic actions is described in
     [EngineTypes]. This table contains ONLY NON-START PRODUCTIONS, so the
     indexing is off by [start]. Be careful. *)

  val semantic_action: ((int, Obj.t, token) EngineTypes.env ->
                        (int, Obj.t)        EngineTypes.stack) array

  (* The parser defines its own [Error] exception. This exception can be
     raised by semantic actions and caught by the engine, and raised by the
     engine towards the final user. *)

  exception Error

  (* The parser indicates whether to generate a trace. Generating a
     trace requires two extra tables, which respectively map a
     terminal symbol and a production to a string. *)

  val trace: (string array * string array) option

end
end
module InspectionTableFormat : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This signature defines the format of the tables that are produced (in
   addition to the tables described in [TableFormat]) when the command line
   switch [--inspection] is enabled. It is used as an argument to
   [InspectionTableInterpreter.Make]. *)

module type TABLES = sig

  (* The types of symbols. *)

  include IncrementalEngine.SYMBOLS

  (* The type ['a lr1state] describes an LR(1) state. The generated parser defines
     it internally as [int]. *)

  type 'a lr1state

  (* Some of the tables that follow use encodings of (terminal and
     nonterminal) symbols as integers. So, we need functions that
     map the integer encoding of a symbol to its algebraic encoding. *)

  val    terminal: int -> xsymbol
  val nonterminal: int -> xsymbol

  (* The left-hand side of every production already appears in the
     signature [TableFormat.TABLES], so we need not repeat it here. *)

  (* The right-hand side of every production. This a linearized array
     of arrays of integers, whose [data] and [entry] components have
     been packed. The encoding of symbols as integers in described in
     [TableBackend]. *)

  val rhs: PackedIntArray.t * PackedIntArray.t

  (* A mapping of every (non-initial) state to its LR(0) core. *)

  val lr0_core: PackedIntArray.t

  (* A mapping of every LR(0) state to its set of LR(0) items. Each item is
     represented in its packed form (see [Item]) as an integer. Thus the
     mapping is an array of arrays of integers, which is linearized and
     packed, like [rhs]. *)

  val lr0_items: PackedIntArray.t * PackedIntArray.t

  (* A mapping of every LR(0) state to its incoming symbol, if it has one. *)

  val lr0_incoming: PackedIntArray.t

  (* A table that tells which non-terminal symbols are nullable. *)

  val nullable: string
    (* This is a packed int array of bit width 1. It can be read
       using [PackedIntArray.get1]. *)

  (* A two-table dimensional table, indexed by a nonterminal symbol and
     by a terminal symbol (other than [#]), encodes the FIRST sets. *)

  val first: int (* width of the bitmap *) * string (* second component of [PackedIntArray.t] *)

end

end
module InspectionTableInterpreter : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This functor is invoked inside the generated parser, in [--table] mode. It
   produces no code! It simply constructs the types [symbol] and [xsymbol] on
   top of the generated types [terminal] and [nonterminal]. *)

module Symbols (T : sig

  type 'a terminal
  type 'a nonterminal

end)

: IncrementalEngine.SYMBOLS
  with type 'a terminal := 'a T.terminal
   and type 'a nonterminal := 'a T.nonterminal

(* This functor is invoked inside the generated parser, in [--table] mode. It
   constructs the inspection API on top of the inspection tables described in
   [InspectionTableFormat]. *)

module Make
  (TT : TableFormat.TABLES)
  (IT : InspectionTableFormat.TABLES
        with type 'a lr1state = int)
  (ET : EngineTypes.TABLE
        with type terminal = int
         and type nonterminal = int
         and type semantic_value = Obj.t)
  (E : sig
     type 'a env = (ET.state, ET.semantic_value, ET.token) EngineTypes.env
   end)

: IncrementalEngine.INSPECTION
  with type 'a terminal := 'a IT.terminal
   and type 'a nonterminal := 'a IT.nonterminal
   and type 'a lr1state := 'a IT.lr1state
   and type production := int
   and type 'a env := 'a E.env
end
module TableInterpreter : sig
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This module provides a thin decoding layer for the generated tables, thus
   providing an API that is suitable for use by [Engine.Make]. It is part of
   [MenhirLib]. *)

(* The exception [Error] is declared within the generated parser. This is
   preferable to pre-declaring it here, as it ensures that each parser gets
   its own, distinct [Error] exception. This is consistent with the code-based
   back-end. *)

(* This functor is invoked by the generated parser. *)

module MakeEngineTable
  (T : TableFormat.TABLES)
: EngineTypes.TABLE
    with type state = int
     and type token = T.token
     and type semantic_value = Obj.t
     and type production = int
     and type terminal = int
     and type nonterminal = int
end
module StaticVersion : sig
val require_20170418 : unit
end

end = struct
#1 "menhirLib.ml"
module General = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* --------------------------------------------------------------------------- *)

(* Lists. *)

let rec take n xs =
  match n, xs with
  | 0, _
  | _, [] ->
      []
  | _, (x :: xs as input) ->
     let xs' = take (n - 1) xs in
     if xs == xs' then
       input
     else
       x :: xs'

let rec drop n xs =
  match n, xs with
  | 0, _ ->
      xs
  | _, [] ->
      []
  | _, _ :: xs ->
      drop (n - 1) xs

let rec uniq1 cmp x ys =
  match ys with
  | [] ->
      []
  | y :: ys ->
      if cmp x y = 0 then
        uniq1 compare x ys
      else
        y :: uniq1 cmp y ys

let uniq cmp xs =
  match xs with
  | [] ->
      []
  | x :: xs ->
      x :: uniq1 cmp x xs

let weed cmp xs =
  uniq cmp (List.sort cmp xs)

(* --------------------------------------------------------------------------- *)

(* Streams. *)

type 'a stream =
    'a head Lazy.t

and 'a head =
  | Nil
  | Cons of 'a * 'a stream

(* The length of a stream. *)

let rec length xs =
  match Lazy.force xs with
  | Nil ->
      0
  | Cons (_, xs) ->
      1 + length xs

(* Folding over a stream. *)

let rec foldr f xs accu =
  match Lazy.force xs with
  | Nil ->
      accu
  | Cons (x, xs) ->
      f x (foldr f xs accu)

end
module Convert = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* An ocamlyacc-style, or Menhir-style, parser requires access to
   the lexer, which must be parameterized with a lexing buffer, and
   to the lexing buffer itself, where it reads position information. *)

(* This traditional API is convenient when used with ocamllex, but
   inelegant when used with other lexer generators. *)

type ('token, 'semantic_value) traditional =
    (Lexing.lexbuf -> 'token) -> Lexing.lexbuf -> 'semantic_value

(* This revised API is independent of any lexer generator. Here, the
   parser only requires access to the lexer, and the lexer takes no
   parameters. The tokens returned by the lexer may contain position
   information. *)

type ('token, 'semantic_value) revised =
    (unit -> 'token) -> 'semantic_value

(* --------------------------------------------------------------------------- *)

(* Converting a traditional parser, produced by ocamlyacc or Menhir,
   into a revised parser. *)

(* A token of the revised lexer is essentially a triple of a token
   of the traditional lexer (or raw token), a start position, and
   and end position. The three [get] functions are accessors. *)

(* We do not require the type ['token] to actually be a triple type.
   This enables complex applications where it is a record type with
   more than three fields. It also enables simple applications where
   positions are of no interest, so ['token] is just ['raw_token]
   and [get_startp] and [get_endp] return dummy positions. *)

let traditional2revised
  (get_raw_token : 'token -> 'raw_token)
  (get_startp    : 'token -> Lexing.position)
  (get_endp      : 'token -> Lexing.position)
  (parser : ('raw_token, 'semantic_value) traditional)
: ('token, 'semantic_value) revised =

  (* Accept a revised lexer. *)

  fun (lexer : unit -> 'token) ->

    (* Create a dummy lexing buffer. *)

    let lexbuf : Lexing.lexbuf =
      Lexing.from_string ""
    in

    (* Wrap the revised lexer as a traditional lexer. A traditional
       lexer returns a raw token and updates the fields of the lexing
       buffer with new positions, which will be read by the parser. *)

    let lexer (lexbuf : Lexing.lexbuf) : 'raw_token =
      let token : 'token = lexer() in
      lexbuf.Lexing.lex_start_p <- get_startp token;
      lexbuf.Lexing.lex_curr_p <- get_endp token;
      get_raw_token token
    in

    (* Invoke the traditional parser. *)

    parser lexer lexbuf

(* --------------------------------------------------------------------------- *)

(* Converting a revised parser back to a traditional parser. *)

let revised2traditional
  (make_token : 'raw_token -> Lexing.position -> Lexing.position -> 'token)
  (parser : ('token, 'semantic_value) revised)
: ('raw_token, 'semantic_value) traditional =

  (* Accept a traditional lexer and a lexing buffer. *)

  fun (lexer : Lexing.lexbuf -> 'raw_token) (lexbuf : Lexing.lexbuf) ->

    (* Wrap the traditional lexer as a revised lexer. *)

    let lexer () : 'token =
      let token : 'raw_token = lexer lexbuf in
      make_token token lexbuf.Lexing.lex_start_p lexbuf.Lexing.lex_curr_p
    in

    (* Invoke the revised parser. *)

    parser lexer

(* --------------------------------------------------------------------------- *)

(* Simplified versions of the above, where concrete triples are used. *)

module Simplified = struct

  let traditional2revised parser =
    traditional2revised
      (fun (token, _, _)  -> token)
      (fun (_, startp, _) -> startp)
      (fun (_, _, endp)   -> endp)
      parser

  let revised2traditional parser =
    revised2traditional
      (fun token startp endp -> (token, startp, endp))
      parser

end
end
module IncrementalEngine = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

type position = Lexing.position

open General

(* This signature describes the incremental LR engine. *)

(* In this mode, the user controls the lexer, and the parser suspends
   itself when it needs to read a new token. *)

module type INCREMENTAL_ENGINE = sig

  type token

  (* A value of type [production] is (an index for) a production. The start
     productions (which do not exist in an \mly file, but are constructed by
     Menhir internally) are not part of this type. *)

  type production

  (* The type ['a checkpoint] represents an intermediate or final state of the
     parser. An intermediate checkpoint is a suspension: it records the parser's
     current state, and allows parsing to be resumed. The parameter ['a] is
     the type of the semantic value that will eventually be produced if the
     parser succeeds. *)

  (* [Accepted] and [Rejected] are final checkpoints. [Accepted] carries a
     semantic value. *)

  (* [InputNeeded] is an intermediate checkpoint. It means that the parser wishes
     to read one token before continuing. *)

  (* [Shifting] is an intermediate checkpoint. It means that the parser is taking
     a shift transition. It exposes the state of the parser before and after
     the transition. The Boolean parameter tells whether the parser intends to
     request a new token after this transition. (It always does, except when
     it is about to accept.) *)

  (* [AboutToReduce] is an intermediate checkpoint. It means that the parser is
     about to perform a reduction step. It exposes the parser's current
     state as well as the production that is about to be reduced. *)

  (* [HandlingError] is an intermediate checkpoint. It means that the parser has
     detected an error and is currently handling it, in several steps. *)

  (* A value of type ['a env] represents a configuration of the automaton:
     current state, stack, lookahead token, etc. The parameter ['a] is the
     type of the semantic value that will eventually be produced if the parser
     succeeds. *)

  (* In normal operation, the parser works with checkpoints: see the functions
     [offer] and [resume]. However, it is also possible to work directly with
     environments (see the functions [pop], [force_reduction], and [feed]) and
     to reconstruct a checkpoint out of an environment (see [input_needed]).
     This is considered advanced functionality; its purpose is to allow error
     recovery strategies to be programmed by the user. *)

  type 'a env

  type 'a checkpoint = private
    | InputNeeded of 'a env
    | Shifting of 'a env * 'a env * bool
    | AboutToReduce of 'a env * production
    | HandlingError of 'a env
    | Accepted of 'a
    | Rejected

  (* [offer] allows the user to resume the parser after it has suspended
     itself with a checkpoint of the form [InputNeeded env]. [offer] expects the
     old checkpoint as well as a new token and produces a new checkpoint. It does not
     raise any exception. *)

  val offer:
    'a checkpoint ->
    token * position * position ->
    'a checkpoint

  (* [resume] allows the user to resume the parser after it has suspended
     itself with a checkpoint of the form [AboutToReduce (env, prod)] or
     [HandlingError env]. [resume] expects the old checkpoint and produces a new
     checkpoint. It does not raise any exception. *)

  val resume:
    'a checkpoint ->
    'a checkpoint

  (* A token supplier is a function of no arguments which delivers a new token
     (together with its start and end positions) every time it is called. *)

  type supplier =
    unit -> token * position * position

  (* A pair of a lexer and a lexing buffer can be easily turned into a supplier. *)

  val lexer_lexbuf_to_supplier:
    (Lexing.lexbuf -> token) ->
    Lexing.lexbuf ->
    supplier

  (* The functions [offer] and [resume] are sufficient to write a parser loop.
     One can imagine many variations (which is why we expose these functions
     in the first place!). Here, we expose a few variations of the main loop,
     ready for use. *)

  (* [loop supplier checkpoint] begins parsing from [checkpoint], reading
     tokens from [supplier]. It continues parsing until it reaches a
     checkpoint of the form [Accepted v] or [Rejected]. In the former case, it
     returns [v]. In the latter case, it raises the exception [Error]. *)

  val loop: supplier -> 'a checkpoint -> 'a

  (* [loop_handle succeed fail supplier checkpoint] begins parsing from
     [checkpoint], reading tokens from [supplier]. It continues parsing until
     it reaches a checkpoint of the form [Accepted v] or [HandlingError env]
     (or [Rejected], but that should not happen, as [HandlingError _] will be
     observed first). In the former case, it calls [succeed v]. In the latter
     case, it calls [fail] with this checkpoint. It cannot raise [Error].

     This means that Menhir's traditional error-handling procedure (which pops
     the stack until a state that can act on the [error] token is found) does
     not get a chance to run. Instead, the user can implement her own error
     handling code, in the [fail] continuation. *)

  val loop_handle:
    ('a -> 'answer) ->
    ('a checkpoint -> 'answer) ->
    supplier -> 'a checkpoint -> 'answer

  (* [loop_handle_undo] is analogous to [loop_handle], except it passes a pair
     of checkpoints to the failure continuation.

     The first (and oldest) checkpoint is the last [InputNeeded] checkpoint that
     was encountered before the error was detected. The second (and newest)
     checkpoint is where the error was detected, as in [loop_handle]. Going back
     to the first checkpoint can be thought of as undoing any reductions that
     were performed after seeing the problematic token. (These reductions must
     be default reductions or spurious reductions.)

     [loop_handle_undo] must initially be applied to an [InputNeeded] checkpoint.
     The parser's initial checkpoints satisfy this constraint. *)

  val loop_handle_undo:
    ('a -> 'answer) ->
    ('a checkpoint -> 'a checkpoint -> 'answer) ->
    supplier -> 'a checkpoint -> 'answer

  (* [shifts checkpoint] assumes that [checkpoint] has been obtained by
     submitting a token to the parser. It runs the parser from [checkpoint],
     through an arbitrary number of reductions, until the parser either
     accepts this token (i.e., shifts) or rejects it (i.e., signals an error).
     If the parser decides to shift, then [Some env] is returned, where [env]
     is the parser's state just before shifting. Otherwise, [None] is
     returned. *)

  (* It is desirable that the semantic actions be side-effect free, or that
     their side-effects be harmless (replayable). *)

  val shifts: 'a checkpoint -> 'a env option

  (* The function [acceptable] allows testing, after an error has been
     detected, which tokens would have been accepted at this point. It is
     implemented using [shifts]. Its argument should be an [InputNeeded]
     checkpoint. *)

  (* For completeness, one must undo any spurious reductions before carrying out
     this test -- that is, one must apply [acceptable] to the FIRST checkpoint
     that is passed by [loop_handle_undo] to its failure continuation. *)

  (* This test causes some semantic actions to be run! The semantic actions
     should be side-effect free, or their side-effects should be harmless. *)

  (* The position [pos] is used as the start and end positions of the
     hypothetical token, and may be picked up by the semantic actions. We
     suggest using the position where the error was detected. *)

  val acceptable: 'a checkpoint -> token -> position -> bool

  (* The abstract type ['a lr1state] describes the non-initial states of the
     LR(1) automaton. The index ['a] represents the type of the semantic value
     associated with this state's incoming symbol. *)

  type 'a lr1state

  (* The states of the LR(1) automaton are numbered (from 0 and up). *)

  val number: _ lr1state -> int

  (* Productions are numbered. *)

  (* [find_production i] requires the index [i] to be valid. Use with care. *)

  val production_index: production -> int
  val find_production: int -> production

  (* An element is a pair of a non-initial state [s] and a semantic value [v]
     associated with the incoming symbol of this state. The idea is, the value
     [v] was pushed onto the stack just before the state [s] was entered. Thus,
     for some type ['a], the state [s] has type ['a lr1state] and the value [v]
     has type ['a]. In other words, the type [element] is an existential type. *)

  type element =
    | Element: 'a lr1state * 'a * position * position -> element

  (* The parser's stack is (or, more precisely, can be viewed as) a stream of
     elements. The type [stream] is defined by the module [General]. *)

  (* As of 2017/03/31, the types [stream] and [stack] and the function [stack]
     are DEPRECATED. They might be removed in the future. An alternative way
     of inspecting the stack is via the functions [top] and [pop]. *)

  type stack = (* DEPRECATED *)
    element stream

  (* This is the parser's stack, a stream of elements. This stream is empty if
     the parser is in an initial state; otherwise, it is non-empty.  The LR(1)
     automaton's current state is the one found in the top element of the
     stack. *)

  val stack: 'a env -> stack (* DEPRECATED *)

  (* [top env] returns the parser's top stack element. The state contained in
     this stack element is the current state of the automaton. If the stack is
     empty, [None] is returned. In that case, the current state of the
     automaton must be an initial state. *)

  val top: 'a env -> element option

  (* [pop_many i env] pops [i] cells off the automaton's stack. This is done
     via [i] successive invocations of [pop]. Thus, [pop_many 1] is [pop]. The
     index [i] must be nonnegative. The time complexity is O(i). *)

  val pop_many: int -> 'a env -> 'a env option

  (* [get i env] returns the parser's [i]-th stack element. The index [i] is
     0-based: thus, [get 0] is [top]. If [i] is greater than or equal to the
     number of elements in the stack, [None] is returned. The time complexity
     is O(i). *)

  val get: int -> 'a env -> element option

  (* [current_state_number env] is (the integer number of) the automaton's
     current state. This works even if the automaton's stack is empty, in
     which case the current state is an initial state. This number can be
     passed as an argument to a [message] function generated by [menhir
     --compile-errors]. *)

  val current_state_number: 'a env -> int

  (* [equal env1 env2] tells whether the parser configurations [env1] and
     [env2] are equal in the sense that the automaton's current state is the
     same in [env1] and [env2] and the stack is *physically* the same in
     [env1] and [env2]. If [equal env1 env2] is [true], then the sequence of
     the stack elements, as observed via [pop] and [top], must be the same in
     [env1] and [env2]. Also, if [equal env1 env2] holds, then the checkpoints
     [input_needed env1] and [input_needed env2] must be equivalent. The
     function [equal] has time complexity O(1). *)

  val equal: 'a env -> 'a env -> bool

  (* These are the start and end positions of the current lookahead token. If
     invoked in an initial state, this function returns a pair of twice the
     initial position. *)

  val positions: 'a env -> position * position

  (* When applied to an environment taken from a checkpoint of the form
     [AboutToReduce (env, prod)], the function [env_has_default_reduction]
     tells whether the reduction that is about to take place is a default
     reduction. *)

  val env_has_default_reduction: 'a env -> bool

  (* [state_has_default_reduction s] tells whether the state [s] has a default
     reduction. This includes the case where [s] is an accepting state. *)

  val state_has_default_reduction: _ lr1state -> bool

  (* [pop env] returns a new environment, where the parser's top stack cell
     has been popped off. (If the stack is empty, [None] is returned.) This
     amounts to pretending that the (terminal or nonterminal) symbol that
     corresponds to this stack cell has not been read. *)

  val pop: 'a env -> 'a env option

  (* [force_reduction prod env] should be called only if in the state [env]
     the parser is capable of reducing the production [prod]. If this
     condition is satisfied, then this production is reduced, which means that
     its semantic action is executed (this can have side effects!) and the
     automaton makes a goto (nonterminal) transition. If this condition is not
     satisfied, [Invalid_argument _] is raised. *)

  val force_reduction: production -> 'a env -> 'a env

  (* [input_needed env] returns [InputNeeded env]. That is, out of an [env]
     that might have been obtained via a series of calls to the functions
     [pop], [force_reduction], [feed], etc., it produces a checkpoint, which
     can be used to resume normal parsing, by supplying this checkpoint as an
     argument to [offer]. *)

  (* This function should be used with some care. It could "mess up the
     lookahead" in the sense that it allows parsing to resume in an arbitrary
     state [s] with an arbitrary lookahead symbol [t], even though Menhir's
     reachability analysis (menhir --list-errors) might well think that it is
     impossible to reach this particular configuration. If one is using
     Menhir's new error reporting facility, this could cause the parser to
     reach an error state for which no error message has been prepared. *)

  val input_needed: 'a env -> 'a checkpoint

end

(* This signature is a fragment of the inspection API that is made available
   to the user when [--inspection] is used. This fragment contains type
   definitions for symbols. *)

module type SYMBOLS = sig

  (* The type ['a terminal] represents a terminal symbol. The type ['a
     nonterminal] represents a nonterminal symbol. In both cases, the index
     ['a] represents the type of the semantic values associated with this
     symbol. The concrete definitions of these types are generated. *)

  type 'a terminal
  type 'a nonterminal

  (* The type ['a symbol] represents a terminal or nonterminal symbol. It is
     the disjoint union of the types ['a terminal] and ['a nonterminal]. *)

  type 'a symbol =
    | T : 'a terminal -> 'a symbol
    | N : 'a nonterminal -> 'a symbol

  (* The type [xsymbol] is an existentially quantified version of the type
     ['a symbol]. This type is useful in situations where the index ['a]
     is not statically known. *)

  type xsymbol =
    | X : 'a symbol -> xsymbol

end

(* This signature describes the inspection API that is made available to the
   user when [--inspection] is used. *)

module type INSPECTION = sig

  (* The types of symbols are described above. *)

  include SYMBOLS

  (* The type ['a lr1state] is meant to be the same as in [INCREMENTAL_ENGINE]. *)

  type 'a lr1state

  (* The type [production] is meant to be the same as in [INCREMENTAL_ENGINE].
     It represents a production of the grammar. A production can be examined
     via the functions [lhs] and [rhs] below. *)

  type production

  (* An LR(0) item is a pair of a production [prod] and a valid index [i] into
     this production. That is, if the length of [rhs prod] is [n], then [i] is
     comprised between 0 and [n], inclusive. *)

  type item =
      production * int

  (* Ordering functions. *)

  val compare_terminals: _ terminal -> _ terminal -> int
  val compare_nonterminals: _ nonterminal -> _ nonterminal -> int
  val compare_symbols: xsymbol -> xsymbol -> int
  val compare_productions: production -> production -> int
  val compare_items: item -> item -> int

  (* [incoming_symbol s] is the incoming symbol of the state [s], that is,
     the symbol that the parser must recognize before (has recognized when)
     it enters the state [s]. This function gives access to the semantic
     value [v] stored in a stack element [Element (s, v, _, _)]. Indeed,
     by case analysis on the symbol [incoming_symbol s], one discovers the
     type ['a] of the value [v]. *)

  val incoming_symbol: 'a lr1state -> 'a symbol

  (* [items s] is the set of the LR(0) items in the LR(0) core of the LR(1)
     state [s]. This set is not epsilon-closed. This set is presented as a
     list, in an arbitrary order. *)

  val items: _ lr1state -> item list

  (* [lhs prod] is the left-hand side of the production [prod]. This is
     always a non-terminal symbol. *)

  val lhs: production -> xsymbol

  (* [rhs prod] is the right-hand side of the production [prod]. This is
     a (possibly empty) sequence of (terminal or nonterminal) symbols. *)

  val rhs: production -> xsymbol list

  (* [nullable nt] tells whether the non-terminal symbol [nt] is nullable.
     That is, it is true if and only if this symbol produces the empty
     word [epsilon]. *)

  val nullable: _ nonterminal -> bool

  (* [first nt t] tells whether the FIRST set of the nonterminal symbol [nt]
     contains the terminal symbol [t]. That is, it is true if and only if
     [nt] produces a word that begins with [t]. *)

  val first: _ nonterminal -> _ terminal -> bool

  (* [xfirst] is analogous to [first], but expects a first argument of type
     [xsymbol] instead of [_ terminal]. *)

  val xfirst: xsymbol -> _ terminal -> bool

  (* [foreach_terminal] enumerates the terminal symbols, including [error].
     [foreach_terminal_but_error] enumerates the terminal symbols, excluding
     [error]. *)

  val foreach_terminal:           (xsymbol -> 'a -> 'a) -> 'a -> 'a
  val foreach_terminal_but_error: (xsymbol -> 'a -> 'a) -> 'a -> 'a

  (* The type [env] is meant to be the same as in [INCREMENTAL_ENGINE]. *)

  type 'a env

  (* [feed symbol startp semv endp env] causes the parser to consume the
     (terminal or nonterminal) symbol [symbol], accompanied with the semantic
     value [semv] and with the start and end positions [startp] and [endp].
     Thus, the automaton makes a transition, and reaches a new state. The
     stack grows by one cell. This operation is permitted only if the current
     state (as determined by [env]) has an outgoing transition labeled with
     [symbol]. Otherwise, [Invalid_argument _] is raised. *)

  val feed: 'a symbol -> position -> 'a -> position -> 'b env -> 'b env

end

(* This signature combines the incremental API and the inspection API. *)

module type EVERYTHING = sig

  include INCREMENTAL_ENGINE

  include INSPECTION
    with type 'a lr1state := 'a lr1state
    with type production := production
    with type 'a env := 'a env

end
end
module EngineTypes = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This file defines several types and module types that are used in the
   specification of module [Engine]. *)

(* --------------------------------------------------------------------------- *)

(* It would be nice if we could keep the structure of stacks and environments
   hidden. However, stacks and environments must be accessible to semantic
   actions, so the following data structure definitions must be public. *)

(* --------------------------------------------------------------------------- *)

(* A stack is a linked list of cells. A sentinel cell -- which is its own
   successor -- is used to mark the bottom of the stack. The sentinel cell
   itself is not significant -- it contains dummy values. *)

type ('state, 'semantic_value) stack = {

  (* The state that we should go back to if we pop this stack cell. *)

  (* This convention means that the state contained in the top stack cell is
     not the current state [env.current]. It also means that the state found
     within the sentinel is a dummy -- it is never consulted. This convention
     is the same as that adopted by the code-based back-end. *)

  state: 'state;

  (* The semantic value associated with the chunk of input that this cell
     represents. *)

  semv: 'semantic_value;

  (* The start and end positions of the chunk of input that this cell
     represents. *)

  startp: Lexing.position;
  endp: Lexing.position;

  (* The next cell down in the stack. If this is a self-pointer, then this
     cell is the sentinel, and the stack is conceptually empty. *)

  next: ('state, 'semantic_value) stack;

}

(* --------------------------------------------------------------------------- *)

(* A parsing environment contains all of the parser's state (except for the
   current program point). *)

type ('state, 'semantic_value, 'token) env = {

  (* If this flag is true, then the first component of [env.triple] should
     be ignored, as it has been logically overwritten with the [error]
     pseudo-token. *)

  error: bool;

  (* The last token that was obtained from the lexer, together with its start
     and end positions. Warning: before the first call to the lexer has taken
     place, a dummy (and possibly invalid) token is stored here. *)

  triple: 'token * Lexing.position * Lexing.position;

  (* The stack. In [CodeBackend], it is passed around on its own,
     whereas, here, it is accessed via the environment. *)

  stack: ('state, 'semantic_value) stack;

  (* The current state. In [CodeBackend], it is passed around on its
     own, whereas, here, it is accessed via the environment. *)

  current: 'state;

}

(* --------------------------------------------------------------------------- *)

(* This signature describes the parameters that must be supplied to the LR
   engine. *)

module type TABLE = sig

  (* The type of automaton states. *)

  type state

  (* States are numbered. *)

  val number: state -> int

  (* The type of tokens. These can be thought of as real tokens, that is,
     tokens returned by the lexer. They carry a semantic value. This type
     does not include the [error] pseudo-token. *)

  type token

  (* The type of terminal symbols. These can be thought of as integer codes.
     They do not carry a semantic value. This type does include the [error]
     pseudo-token. *)

  type terminal

  (* The type of nonterminal symbols. *)

  type nonterminal

  (* The type of semantic values. *)

  type semantic_value

  (* A token is conceptually a pair of a (non-[error]) terminal symbol and
     a semantic value. The following two functions are the pair projections. *)

  val token2terminal: token -> terminal
  val token2value: token -> semantic_value

  (* Even though the [error] pseudo-token is not a real token, it is a
     terminal symbol. Furthermore, for regularity, it must have a semantic
     value. *)

  val error_terminal: terminal
  val error_value: semantic_value

  (* [foreach_terminal] allows iterating over all terminal symbols. *)

  val foreach_terminal: (terminal -> 'a -> 'a) -> 'a -> 'a

  (* The type of productions. *)

  type production

  val production_index: production -> int
  val find_production: int -> production

  (* If a state [s] has a default reduction on production [prod], then, upon
     entering [s], the automaton should reduce [prod] without consulting the
     lookahead token. The following function allows determining which states
     have default reductions. *)

  (* Instead of returning a value of a sum type -- either [DefRed prod], or
     [NoDefRed] -- it accepts two continuations, and invokes just one of
     them. This mechanism allows avoiding a memory allocation. *)

  val default_reduction:
    state ->
    ('env -> production -> 'answer) ->
    ('env -> 'answer) ->
    'env -> 'answer

  (* An LR automaton can normally take three kinds of actions: shift, reduce,
     or fail. (Acceptance is a particular case of reduction: it consists in
     reducing a start production.) *)

  (* There are two variants of the shift action. [shift/discard s] instructs
     the automaton to discard the current token, request a new one from the
     lexer, and move to state [s]. [shift/nodiscard s] instructs it to move to
     state [s] without requesting a new token. This instruction should be used
     when [s] has a default reduction on [#]. See [CodeBackend.gettoken] for
     details. *)

  (* This is the automaton's action table. It maps a pair of a state and a
     terminal symbol to an action. *)

  (* Instead of returning a value of a sum type -- one of shift/discard,
     shift/nodiscard, reduce, or fail -- this function accepts three
     continuations, and invokes just one them. This mechanism allows avoiding
     a memory allocation. *)

  (* In summary, the parameters to [action] are as follows:

     - the first two parameters, a state and a terminal symbol, are used to
       look up the action table;

     - the next parameter is the semantic value associated with the above
       terminal symbol; it is not used, only passed along to the shift
       continuation, as explained below;

     - the shift continuation expects an environment; a flag that tells
       whether to discard the current token; the terminal symbol that
       is being shifted; its semantic value; and the target state of
       the transition;

     - the reduce continuation expects an environment and a production;

     - the fail continuation expects an environment;

     - the last parameter is the environment; it is not used, only passed
       along to the selected continuation. *)

  val action:
    state ->
    terminal ->
    semantic_value ->
    ('env -> bool -> terminal -> semantic_value -> state -> 'answer) ->
    ('env -> production -> 'answer) ->
    ('env -> 'answer) ->
    'env -> 'answer

  (* This is the automaton's goto table. This table maps a pair of a state
     and a nonterminal symbol to a new state. By extension, it also maps a
     pair of a state and a production to a new state. *)

  (* The function [goto_nt] can be applied to [s] and [nt] ONLY if the state
     [s] has an outgoing transition labeled [nt]. Otherwise, its result is
     undefined. Similarly, the call [goto_prod prod s] is permitted ONLY if
     the state [s] has an outgoing transition labeled with the nonterminal
     symbol [lhs prod]. The function [maybe_goto_nt] involves an additional
     dynamic check and CAN be called even if there is no outgoing transition. *)

  val       goto_nt  : state -> nonterminal -> state
  val       goto_prod: state -> production  -> state
  val maybe_goto_nt:   state -> nonterminal -> state option

  (* [is_start prod] tells whether the production [prod] is a start production. *)

  val is_start: production -> bool

  (* By convention, a semantic action is responsible for:

     1. fetching whatever semantic values and positions it needs off the stack;

     2. popping an appropriate number of cells off the stack, as dictated
        by the length of the right-hand side of the production;

     3. computing a new semantic value, as well as new start and end positions;

     4. pushing a new stack cell, which contains the three values
        computed in step 3;

     5. returning the new stack computed in steps 2 and 4.

     Point 1 is essentially forced upon us: if semantic values were fetched
     off the stack by this interpreter, then the calling convention for
     semantic actions would be variadic: not all semantic actions would have
     the same number of arguments. The rest follows rather naturally. *)

  (* Semantic actions are allowed to raise [Error]. *)

  exception Error

  type semantic_action =
      (state, semantic_value, token) env -> (state, semantic_value) stack

  val semantic_action: production -> semantic_action

  (* [may_reduce state prod] tests whether the state [state] is capable of
     reducing the production [prod]. This function is currently costly and
     is not used by the core LR engine. It is used in the implementation
     of certain functions, such as [force_reduction], which allow the engine
     to be driven programmatically. *)

  val may_reduce: state -> production -> bool

  (* The LR engine requires a number of hooks, which are used for logging. *)

  (* The comments below indicate the conventional messages that correspond
     to these hooks in the code-based back-end; see [CodeBackend]. *)

  (* If the flag [log] is false, then the logging functions are not called.
     If it is [true], then they are called. *)

  val log : bool

  module Log : sig

    (* State %d: *)

    val state: state -> unit

    (* Shifting (<terminal>) to state <state> *)

    val shift: terminal -> state -> unit

    (* Reducing a production should be logged either as a reduction
       event (for regular productions) or as an acceptance event (for
       start productions). *)

    (* Reducing production <production> / Accepting *)

    val reduce_or_accept: production -> unit

    (* Lookahead token is now <terminal> (<pos>-<pos>) *)

    val lookahead_token: terminal -> Lexing.position -> Lexing.position -> unit

    (* Initiating error handling *)

    val initiating_error_handling: unit -> unit

    (* Resuming error handling *)

    val resuming_error_handling: unit -> unit

    (* Handling error in state <state> *)

    val handling_error: state -> unit

  end

end

(* --------------------------------------------------------------------------- *)

(* This signature describes the monolithic (traditional) LR engine. *)

(* In this interface, the parser controls the lexer. *)

module type MONOLITHIC_ENGINE = sig

  type state

  type token

  type semantic_value

  (* An entry point to the engine requires a start state, a lexer, and a lexing
     buffer. It either succeeds and produces a semantic value, or fails and
     raises [Error]. *)

  exception Error

  val entry:
    state ->
    (Lexing.lexbuf -> token) ->
    Lexing.lexbuf ->
    semantic_value

end

(* --------------------------------------------------------------------------- *)

(* The following signatures describe the incremental LR engine. *)

(* First, see [INCREMENTAL_ENGINE] in the file [IncrementalEngine.ml]. *)

(* The [start] function is set apart because we do not wish to publish
   it as part of the generated [parser.mli] file. Instead, the table
   back-end will publish specialized versions of it, with a suitable
   type cast. *)

module type INCREMENTAL_ENGINE_START = sig

  (* [start] is an entry point. It requires a start state and a start position
     and begins the parsing process. If the lexer is based on an OCaml lexing
     buffer, the start position should be [lexbuf.lex_curr_p]. [start] produces
     a checkpoint, which usually will be an [InputNeeded] checkpoint. (It could
     be [Accepted] if this starting state accepts only the empty word. It could
     be [Rejected] if this starting state accepts no word at all.) It does not
     raise any exception. *)

  (* [start s pos] should really produce a checkpoint of type ['a checkpoint],
     for a fixed ['a] that depends on the state [s]. We cannot express this, so
     we use [semantic_value checkpoint], which is safe. The table back-end uses
     [Obj.magic] to produce safe specialized versions of [start]. *)

  type state
  type semantic_value
  type 'a checkpoint

  val start:
    state ->
    Lexing.position ->
    semantic_value checkpoint

end

(* --------------------------------------------------------------------------- *)

(* This signature describes the LR engine, which combines the monolithic
   and incremental interfaces. *)

module type ENGINE = sig

  include MONOLITHIC_ENGINE

  include IncrementalEngine.INCREMENTAL_ENGINE
    with type token := token
     and type 'a lr1state = state (* useful for us; hidden from the end user *)

  include INCREMENTAL_ENGINE_START
    with type state := state
     and type semantic_value := semantic_value
     and type 'a checkpoint := 'a checkpoint

end
end
module Engine = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

type position = Lexing.position
open EngineTypes

(* The LR parsing engine. *)

(* This module is used:

   - at compile time, if so requested by the user, via the --interpret options;
   - at run time, in the table-based back-end. *)

module Make (T : TABLE) = struct

  (* This propagates type and exception definitions. The functions [number],
     [production_index], [find_production], too, are defined by this [include]
     declaration. *)

  include T

  type 'a env =
      (state, semantic_value, token) EngineTypes.env

  (* ------------------------------------------------------------------------ *)

  (* The type [checkpoint] represents an intermediate or final result of the
     parser. See [EngineTypes]. *)

  (* The type [checkpoint] is presented to the user as a private type (see
     [IncrementalEngine]). This prevents the user from manufacturing
     checkpoints (i.e., continuations) that do not make sense. (Such
     continuations could potentially violate the LR invariant and lead to
     crashes.) *)

  (* 2017/03/29 Although [checkpoint] is a private type, we now expose a
     constructor function, [input_needed]. This function allows manufacturing
     a checkpoint out of an environment. For this reason, the type [env] must
     also be parameterized with ['a]. *)

  type 'a checkpoint =
    | InputNeeded of 'a env
    | Shifting of 'a env * 'a env * bool
    | AboutToReduce of 'a env * production
    | HandlingError of 'a env
    | Accepted of 'a
    | Rejected

  (* ------------------------------------------------------------------------ *)

  (* In the code-based back-end, the [run] function is sometimes responsible
     for pushing a new cell on the stack. This is motivated by code sharing
     concerns. In this interpreter, there is no such concern; [run]'s caller
     is always responsible for updating the stack. *)

  (* In the code-based back-end, there is a [run] function for each state
     [s]. This function can behave in two slightly different ways, depending
     on when it is invoked, or (equivalently) depending on [s].

     If [run] is invoked after shifting a terminal symbol (or, equivalently,
     if [s] has a terminal incoming symbol), then [run] discards a token,
     unless [s] has a default reduction on [#]. (Indeed, in that case,
     requesting the next token might drive the lexer off the end of the input
     stream.)

     If, on the other hand, [run] is invoked after performing a goto
     transition, or invoked directly by an entry point, then there is nothing
     to discard.

     These two cases are reflected in [CodeBackend.gettoken].

     Here, the code is structured in a slightly different way. It is up to the
     caller of [run] to indicate whether to discard a token, via the parameter
     [please_discard]. This flag is set when [s] is being entered by shifting
     a terminal symbol and [s] does not have a default reduction on [#]. *)

  (* The following recursive group of functions are tail recursive, produce a
     checkpoint of type [semantic_value checkpoint], and cannot raise an
     exception. A semantic action can raise [Error], but this exception is
     immediately caught within [reduce]. *)

  let rec run env please_discard : semantic_value checkpoint =

    (* Log the fact that we just entered this state. *)

    if log then
      Log.state env.current;

    (* If [please_discard] is set, we discard the current lookahead token and
       fetch the next one. In order to request a token from the user, we
       return an [InputNeeded] continuation, which, when invoked by the user,
       will take us to [discard]. If [please_discard] is not set, we skip this
       step and jump directly to [check_for_default_reduction]. *)

    if please_discard then
      InputNeeded env
    else
      check_for_default_reduction env

  (* [discard env triple] stores [triple] into [env], overwriting the previous
     token. It is invoked by [offer], which itself is invoked by the user in
     response to an [InputNeeded] checkpoint. *)

  and discard env triple =
    if log then begin
      let (token, startp, endp) = triple in
      Log.lookahead_token (T.token2terminal token) startp endp
    end;
    let env = { env with error = false; triple } in
    check_for_default_reduction env

  and check_for_default_reduction env =

    (* Examine what situation we are in. This case analysis is analogous to
       that performed in [CodeBackend.gettoken], in the sub-case where we do
       not have a terminal incoming symbol. *)

    T.default_reduction
      env.current
      announce_reduce       (* there is a default reduction; perform it *)
      check_for_error_token (* there is none; continue below *)
      env

  and check_for_error_token env =

    (* There is no default reduction. Consult the current lookahead token
       so as to determine which action should be taken. *)

    (* Peeking at the first input token, without taking it off the input
       stream, is done by reading [env.triple]. We are careful to first
       check [env.error]. *)

    (* Note that, if [please_discard] was true, then we have just called
       [discard], so the lookahead token cannot be [error]. *)

    (* Returning [HandlingError env] is equivalent to calling [error env]
       directly, except it allows the user to regain control. *)

    if env.error then begin
      if log then
        Log.resuming_error_handling();
      HandlingError env
    end
    else
      let (token, _, _) = env.triple in

      (* We consult the two-dimensional action table, indexed by the
         current state and the current lookahead token, in order to
         determine which action should be taken. *)

      T.action
        env.current                    (* determines a row *)
        (T.token2terminal token)       (* determines a column *)
        (T.token2value token)
        shift                          (* shift continuation *)
        announce_reduce                (* reduce continuation *)
        initiate                       (* failure continuation *)
        env

  (* ------------------------------------------------------------------------ *)

  (* This function takes care of shift transitions along a terminal symbol.
     (Goto transitions are taken care of within [reduce] below.) The symbol
     can be either an actual token or the [error] pseudo-token. *)

  (* Here, the lookahead token CAN be [error]. *)

  and shift env
      (please_discard : bool)
      (terminal : terminal)
      (value : semantic_value)
      (s' : state) =

    (* Log the transition. *)

    if log then
      Log.shift terminal s';

    (* Push a new cell onto the stack, containing the identity of the
       state that we are leaving. *)

    let (_, startp, endp) = env.triple in
    let stack = {
      state = env.current;
      semv = value;
      startp;
      endp;
      next = env.stack;
    } in

    (* Switch to state [s']. *)

    let new_env = { env with stack; current = s' } in

    (* Expose the transition to the user. (In principle, we have a choice
       between exposing the transition before we take it, after we take
       it, or at some point in between. This affects the number and type
       of the parameters carried by [Shifting]. Here, we choose to expose
       the transition after we take it; this allows [Shifting] to carry
       only three parameters, whose meaning is simple.) *)

    Shifting (env, new_env, please_discard)

  (* ------------------------------------------------------------------------ *)

  (* The function [announce_reduce] stops the parser and returns a checkpoint
     which allows the parser to be resumed by calling [reduce]. *)

  (* Only ordinary productions are exposed to the user. Start productions
     are not exposed to the user. Reducing a start production simply leads
     to the successful termination of the parser. *)

  and announce_reduce env (prod : production) =
    if T.is_start prod then
      accept env prod
    else
      AboutToReduce (env, prod)

  (* The function [reduce] takes care of reductions. It is invoked by
     [resume] after an [AboutToReduce] event has been produced. *)

  (* Here, the lookahead token CAN be [error]. *)

  (* The production [prod] CANNOT be a start production. *)

  and reduce env (prod : production) =

    (* Log a reduction event. *)

    if log then
      Log.reduce_or_accept prod;

    (* Invoke the semantic action. The semantic action is responsible for
       truncating the stack and pushing a new cell onto the stack, which
       contains a new semantic value. It can raise [Error]. *)

    (* If the semantic action terminates normally, it returns a new stack,
       which becomes the current stack. *)

    (* If the semantic action raises [Error], we catch it and initiate error
       handling. *)

    (* This [match/with/exception] construct requires OCaml 4.02. *)

    match T.semantic_action prod env with
    | stack ->

        (* By our convention, the semantic action has produced an updated
           stack. The state now found in the top stack cell is the return
           state. *)

        (* Perform a goto transition. The target state is determined
           by consulting the goto table at the return state and at
           production [prod]. *)

        let current = T.goto_prod stack.state prod in
        let env = { env with stack; current } in
        run env false

    | exception Error ->
        initiate env

  and accept env prod =
    (* Log an accept event. *)
    if log then
      Log.reduce_or_accept prod;
    (* Extract the semantic value out of the stack. *)
    let v = env.stack.semv in
    (* Finish. *)
    Accepted v

  (* ------------------------------------------------------------------------ *)

  (* The following functions deal with errors. *)

  (* [initiate] initiates or resumes error handling. *)

  (* Here, the lookahead token CAN be [error]. *)

  and initiate env =
    if log then
      Log.initiating_error_handling();
    let env = { env with error = true } in
    HandlingError env

  (* [error] handles errors. *)

  and error env =
    assert env.error;

    (* Consult the column associated with the [error] pseudo-token in the
       action table. *)

    T.action
      env.current                    (* determines a row *)
      T.error_terminal               (* determines a column *)
      T.error_value
      error_shift                    (* shift continuation *)
      error_reduce                   (* reduce continuation *)
      error_fail                     (* failure continuation *)
      env

  and error_shift env please_discard terminal value s' =

    (* Here, [terminal] is [T.error_terminal],
       and [value] is [T.error_value]. *)

    assert (terminal = T.error_terminal && value = T.error_value);

    (* This state is capable of shifting the [error] token. *)

    if log then
      Log.handling_error env.current;
    shift env please_discard terminal value s'

  and error_reduce env prod =

    (* This state is capable of performing a reduction on [error]. *)

    if log then
      Log.handling_error env.current;
    reduce env prod
      (* Intentionally calling [reduce] instead of [announce_reduce].
         It does not seem very useful, and it could be confusing, to
         expose the reduction steps taken during error handling. *)

  and error_fail env =

    (* This state is unable to handle errors. Attempt to pop a stack
       cell. *)

    let cell = env.stack in
    let next = cell.next in
    if next == cell then

      (* The stack is empty. Die. *)

      Rejected

    else begin

      (* The stack is nonempty. Pop a cell, updating the current state
         with that found in the popped cell, and try again. *)

      let env = { env with
        stack = next;
        current = cell.state
      } in
      HandlingError env

    end

  (* End of the nest of tail recursive functions. *)

  (* ------------------------------------------------------------------------ *)
  (* ------------------------------------------------------------------------ *)

  (* The incremental interface. See [EngineTypes]. *)

  (* [start s] begins the parsing process. *)

  let start (s : state) (initial : position) : semantic_value checkpoint =

    (* Build an empty stack. This is a dummy cell, which is its own successor.
       Its [next] field WILL be accessed by [error_fail] if an error occurs and
       is propagated all the way until the stack is empty. Its [endp] field WILL
       be accessed (by a semantic action) if an epsilon production is reduced
       when the stack is empty. *)

    let rec empty = {
      state = s;                          (* dummy *)
      semv = T.error_value;               (* dummy *)
      startp = initial;                   (* dummy *)
      endp = initial;
      next = empty;
    } in

    (* Build an initial environment. *)

    (* Unfortunately, there is no type-safe way of constructing a
       dummy token. Tokens carry semantic values, which in general
       we cannot manufacture. This instance of [Obj.magic] could
       be avoided by adopting a different representation (e.g., no
       [env.error] field, and an option in the first component of
       [env.triple]), but I like this representation better. *)

    let dummy_token = Obj.magic () in
    let env = {
      error = false;
      triple = (dummy_token, initial, initial); (* dummy *)
      stack = empty;
      current = s;
    } in

    (* Begin parsing. *)

    (* The parameter [please_discard] here is [true], which means we know
       that we must read at least one token. This claim relies on the fact
       that we have ruled out the two special cases where a start symbol
       recognizes the empty language or the singleton language {epsilon}. *)

    run env true

  (* [offer checkpoint triple] is invoked by the user in response to a
     checkpoint of the form [InputNeeded env]. It checks that [checkpoint] is
     indeed of this form, and invokes [discard]. *)

  (* [resume checkpoint] is invoked by the user in response to a checkpoint of
     the form [AboutToReduce (env, prod)] or [HandlingError env]. It checks
     that [checkpoint] is indeed of this form, and invokes [reduce] or
     [error], as appropriate. *)

  (* In reality, [offer] and [resume] accept an argument of type
     [semantic_value checkpoint] and produce a checkpoint of the same type.
     The choice of [semantic_value] is forced by the fact that this is the
     parameter of the checkpoint [Accepted]. *)

  (* We change this as follows. *)

  (* We change the argument and result type of [offer] and [resume] from
     [semantic_value checkpoint] to ['a checkpoint]. This is safe, in this
     case, because we give the user access to values of type [t checkpoint]
     only if [t] is indeed the type of the eventual semantic value for this
     run. (More precisely, by examining the signatures [INCREMENTAL_ENGINE]
     and [INCREMENTAL_ENGINE_START], one finds that the user can build a value
     of type ['a checkpoint] only if ['a] is [semantic_value]. The table
     back-end goes further than this and produces versions of [start] composed
     with a suitable cast, which give the user access to a value of type
     [t checkpoint] where [t] is the type of the start symbol.) *)

  let offer : 'a . 'a checkpoint ->
                   token * position * position ->
                   'a checkpoint
  = function
    | InputNeeded env ->
        Obj.magic discard env
    | _ ->
        invalid_arg "offer expects InputNeeded"

  let resume : 'a . 'a checkpoint -> 'a checkpoint = function
    | HandlingError env ->
        Obj.magic error env
    | Shifting (_, env, please_discard) ->
        Obj.magic run env please_discard
    | AboutToReduce (env, prod) ->
        Obj.magic reduce env prod
    | _ ->
        invalid_arg "resume expects HandlingError | Shifting | AboutToReduce"

  (* ------------------------------------------------------------------------ *)
  (* ------------------------------------------------------------------------ *)

  (* The traditional interface. See [EngineTypes]. *)

  (* ------------------------------------------------------------------------ *)

  (* Wrapping a lexer and lexbuf as a token supplier. *)

  type supplier =
    unit -> token * position * position

  let lexer_lexbuf_to_supplier
      (lexer : Lexing.lexbuf -> token)
      (lexbuf : Lexing.lexbuf)
  : supplier =
    fun () ->
      let token = lexer lexbuf in
      let startp = lexbuf.Lexing.lex_start_p
      and endp = lexbuf.Lexing.lex_curr_p in
      token, startp, endp

  (* ------------------------------------------------------------------------ *)

  (* The main loop repeatedly handles intermediate checkpoints, until a final
     checkpoint is obtained. This allows implementing the monolithic interface
     ([entry]) in terms of the incremental interface ([start], [offer],
     [handle], [reduce]). *)

  (* By convention, acceptance is reported by returning a semantic value,
     whereas rejection is reported by raising [Error]. *)

  (* [loop] is polymorphic in ['a]. No cheating is involved in achieving this.
     All of the cheating resides in the types assigned to [offer] and [handle]
     above. *)

  let rec loop : 'a . supplier -> 'a checkpoint -> 'a =
    fun read checkpoint ->
    match checkpoint with
    | InputNeeded _ ->
        (* The parser needs a token. Request one from the lexer,
           and offer it to the parser, which will produce a new
           checkpoint. Then, repeat. *)
        let triple = read() in
        let checkpoint = offer checkpoint triple in
        loop read checkpoint
    | Shifting _
    | AboutToReduce _
    | HandlingError _ ->
        (* The parser has suspended itself, but does not need
           new input. Just resume the parser. Then, repeat. *)
        let checkpoint = resume checkpoint in
        loop read checkpoint
    | Accepted v ->
        (* The parser has succeeded and produced a semantic value.
           Return this semantic value to the user. *)
        v
    | Rejected ->
        (* The parser rejects this input. Raise an exception. *)
        raise Error

  let entry (s : state) lexer lexbuf : semantic_value =
    let initial = lexbuf.Lexing.lex_curr_p in
    loop (lexer_lexbuf_to_supplier lexer lexbuf) (start s initial)

  (* ------------------------------------------------------------------------ *)

  (* [loop_handle] stops if it encounters an error, and at this point, invokes
     its failure continuation, without letting Menhir do its own traditional
     error-handling (which involves popping the stack, etc.). *)

  let rec loop_handle succeed fail read checkpoint =
    match checkpoint with
    | InputNeeded _ ->
        let triple = read() in
        let checkpoint = offer checkpoint triple in
        loop_handle succeed fail read checkpoint
    | Shifting _
    | AboutToReduce _ ->
        let checkpoint = resume checkpoint in
        loop_handle succeed fail read checkpoint
    | HandlingError _
    | Rejected ->
        (* The parser has detected an error. Invoke the failure continuation. *)
        fail checkpoint
    | Accepted v ->
        (* The parser has succeeded and produced a semantic value. Invoke the
           success continuation. *)
        succeed v

  (* ------------------------------------------------------------------------ *)

  (* [loop_handle_undo] is analogous to [loop_handle], except it passes a pair
     of checkpoints to the failure continuation.

     The first (and oldest) checkpoint is the last [InputNeeded] checkpoint
     that was encountered before the error was detected. The second (and
     newest) checkpoint is where the error was detected, as in [loop_handle].
     Going back to the first checkpoint can be thought of as undoing any
     reductions that were performed after seeing the problematic token. (These
     reductions must be default reductions or spurious reductions.) *)

  let rec loop_handle_undo succeed fail read (inputneeded, checkpoint) =
    match checkpoint with
    | InputNeeded _ ->
        (* Update the last recorded [InputNeeded] checkpoint. *)
        let inputneeded = checkpoint in
        let triple = read() in
        let checkpoint = offer checkpoint triple in
        loop_handle_undo succeed fail read (inputneeded, checkpoint)
    | Shifting _
    | AboutToReduce _ ->
        let checkpoint = resume checkpoint in
        loop_handle_undo succeed fail read (inputneeded, checkpoint)
    | HandlingError _
    | Rejected ->
        fail inputneeded checkpoint
    | Accepted v ->
        succeed v

  (* For simplicity, we publish a version of [loop_handle_undo] that takes a
     single checkpoint as an argument, instead of a pair of checkpoints. We
     check that the argument is [InputNeeded _], and duplicate it. *)

  (* The parser cannot accept or reject before it asks for the very first
     character of input. (Indeed, we statically reject a symbol that
     generates the empty language or the singleton language {epsilon}.)
     So, the [start] checkpoint must match [InputNeeded _]. Hence, it is
     permitted to call [loop_handle_undo] with a [start] checkpoint. *)

  let loop_handle_undo succeed fail read checkpoint =
    assert (match checkpoint with InputNeeded _ -> true | _ -> false);
    loop_handle_undo succeed fail read (checkpoint, checkpoint)

  (* ------------------------------------------------------------------------ *)

  let rec shifts checkpoint =
    match checkpoint with
    | Shifting (env, _, _) ->
        (* The parser is about to shift, which means it is willing to
           consume the terminal symbol that we have fed it. Return the
           state just before this transition. *)
        Some env
    | AboutToReduce _ ->
        (* The parser wishes to reduce. Just follow. *)
        shifts (resume checkpoint)
    | HandlingError _ ->
        (* The parser fails, which means it rejects the terminal symbol
           that we have fed it. *)
        None
    | InputNeeded _
    | Accepted _
    | Rejected ->
        (* None of these cases can arise. Indeed, after a token is submitted
           to it, the parser must shift, reduce, or signal an error, before
           it can request another token or terminate. *)
        assert false

  let acceptable checkpoint token pos =
    let triple = (token, pos, pos) in
    let checkpoint = offer checkpoint triple in
    match shifts checkpoint with
    | None      -> false
    | Some _env -> true

  (* ------------------------------------------------------------------------ *)

  (* The type ['a lr1state] describes the (non-initial) states of the LR(1)
     automaton. The index ['a] represents the type of the semantic value
     associated with the state's incoming symbol. *)

  (* The type ['a lr1state] is defined as an alias for [state], which itself
     is usually defined as [int] (see [TableInterpreter]). So, ['a lr1state]
     is technically a phantom type, but should really be thought of as a GADT
     whose data constructors happen to be represented as integers. It is
     presented to the user as an abstract type (see [IncrementalEngine]). *)

  type 'a lr1state =
      state

  (* ------------------------------------------------------------------------ *)

  (* Stack inspection. *)

  (* We offer a read-only view of the parser's state as a stream of elements.
     Each element contains a pair of a (non-initial) state and a semantic
     value associated with (the incoming symbol of) this state. Note that the
     type [element] is an existential type. *)

  (* As of 2017/03/31, the type [stack] and the function [stack] are DEPRECATED.
     If desired, they could now be implemented outside Menhir, by relying on
     the functions [top] and [pop]. *)

  type element =
    | Element: 'a lr1state * 'a * position * position -> element

  open General

  type stack =
    element stream

  (* If [current] is the current state and [cell] is the top stack cell,
     then [stack cell current] is a view of the parser's state as a stream
     of elements. *)

  let rec stack cell current : element stream =
    lazy (
      (* The stack is empty iff the top stack cell is its own successor. In
         that case, the current state [current] should be an initial state
         (which has no incoming symbol).
         We do not allow the user to inspect this state. *)
      let next = cell.next in
      if next == cell then
        Nil
      else
        (* Construct an element containing the current state [current] as well
           as the semantic value contained in the top stack cell. This semantic
           value is associated with the incoming symbol of this state, so it
           makes sense to pair them together. The state has type ['a state] and
           the semantic value has type ['a], for some type ['a]. Here, the OCaml
           type-checker thinks ['a] is [semantic_value] and considers this code
           well-typed. Outside, we will use magic to provide the user with a way
           of inspecting states and recovering the value of ['a]. *)
        let element = Element (
          current,
          cell.semv,
          cell.startp,
          cell.endp
        ) in
        Cons (element, stack next cell.state)
    )

  let stack env : element stream =
    stack env.stack env.current

  (* As explained above, the function [top] allows access to the top stack
     element only if the stack is nonempty, i.e., only if the current state
     is not an initial state. *)

  let top env : element option =
    let cell = env.stack in
    let next = cell.next in
    if next == cell then
      None
    else
      Some (Element (env.current, cell.semv, cell.startp, cell.endp))

  (* [equal] compares the stacks for physical equality, and compares the
     current states via their numbers (this seems cleaner than using OCaml's
     polymorphic equality). *)

  (* The two fields that are not compared by [equal], namely [error] and
     [triple], are overwritten by the function [discard], which handles
     [InputNeeded] checkpoints. Thus, if [equal env1 env2] holds, then the
     checkpoints [input_needed env1] and [input_needed env2] are
     equivalent: they lead the parser to behave in the same way. *)

  let equal env1 env2 =
    env1.stack == env2.stack &&
    number env1.current = number env2.current

  let current_state_number env =
    number env.current

  (* ------------------------------------------------------------------------ *)

  (* Access to the position of the lookahead token. *)

  let positions { triple = (_, startp, endp); _ } =
    startp, endp

  (* ------------------------------------------------------------------------ *)

  (* Access to information about default reductions. *)

  (* This can be a function of states, or a function of environments.
     We offer both. *)

  (* Instead of a Boolean result, we could return a [production option].
     However, we would have to explicitly test whether [prod] is a start
     production, and in that case, return [None], I suppose. Indeed, we
     have decided not to expose the start productions. *)

  let state_has_default_reduction (state : _ lr1state) : bool =
    T.default_reduction state
      (fun _env _prod -> true)
      (fun _env -> false)
      ()

  let env_has_default_reduction env =
    state_has_default_reduction env.current

  (* ------------------------------------------------------------------------ *)

  (* The following functions work at the level of environments (as opposed to
     checkpoints). The function [pop] causes the automaton to go back into the
     past, pretending that the last input symbol has never been read. The
     function [force_reduction] causes the automaton to re-interpret the past,
     by recognizing the right-hand side of a production and reducing this
     production. The function [feed] causes the automaton to progress into the
     future by pretending that a (terminal or nonterminal) symbol has been
     read. *)

  (* The function [feed] would ideally be defined here. However, for this
     function to be type-safe, the GADT ['a symbol] is needed. For this
     reason, we move its definition to [InspectionTableInterpreter], where
     the inspection API is available. *)

  (* [pop] pops one stack cell. It cannot go wrong. *)

  let pop (env : 'a env) : 'a env option =
    let cell = env.stack in
    let next = cell.next in
    if next == cell then
      (* The stack is empty. *)
      None
    else
      (* The stack is nonempty. Pop off one cell. *)
      Some { env with stack = next; current = cell.state }

  (* [force_reduction] is analogous to [reduce], except that it does not
     continue by calling [run env] or [initiate env]. Instead, it returns
     [env] to the user. *)

  (* [force_reduction] is dangerous insofar as it executes a semantic action.
     This semantic action could have side effects: nontermination, state,
     exceptions, input/output, etc. *)

  let force_reduction prod (env : 'a env) : 'a env =
    (* Check if this reduction is permitted. This check is REALLY important.
       The stack must have the correct shape: that is, it must be sufficiently
       high, and must contain semantic values of appropriate types, otherwise
       the semantic action will crash and burn. *)
    (* We currently check whether the current state is WILLING to reduce this
       production (i.e., there is a reduction action in the action table row
       associated with this state), whereas it would be more liberal to check
       whether this state is CAPABLE of reducing this production (i.e., the
       stack has an appropriate shape). We currently have no means of
       performing such a check. *)
    if not (T.may_reduce env.current prod) then
      invalid_arg "force_reduction: this reduction is not permitted in this state"
    else begin
      (* We do not expose the start productions to the user, so this cannot be
         a start production. Hence, it has a semantic action. *)
      assert (not (T.is_start prod));
      (* Invoke the semantic action. *)
      let stack = T.semantic_action prod env in
      (* Perform a goto transition. *)
      let current = T.goto_prod stack.state prod in
      { env with stack; current }
    end

  (* The environment manipulation functions -- [pop] and [force_reduction]
     above, plus [feed] -- manipulate the automaton's stack and current state,
     but do not affect the automaton's lookahead symbol. When the function
     [input_needed] is used to go back from an environment to a checkpoint
     (and therefore, resume normal parsing), the lookahead symbol is clobbered
     anyway, since the only action that the user can take is to call [offer].
     So far, so good. One problem, though, is that this call to [offer] may
     well place the automaton in a configuration of a state [s] and a
     lookahead symbol [t] that is normally unreachable. Also, perhaps the
     state [s] is a state where an input symbol normally is never demanded, so
     this [InputNeeded] checkpoint is fishy. There does not seem to be a deep
     problem here, but, when programming an error recovery strategy, one
     should pay some attention to this issue. Ideally, perhaps, one should use
     [input_needed] only in a state [s] where an input symbol is normally
     demanded, that is, a state [s] whose incoming symbol is a terminal symbol
     and which does not have a default reduction on [#]. *)

  let input_needed (env : 'a env) : 'a checkpoint =
    InputNeeded env

  (* The following functions are compositions of [top] and [pop]. *)

  let rec pop_many i env =
    if i = 0 then
      Some env
    else match pop env with
    | None ->
        None
    | Some env ->
        pop_many (i - 1) env

  let get i env =
    match pop_many i env with
    | None ->
        None
    | Some env ->
        top env

end
end
module ErrorReports = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* -------------------------------------------------------------------------- *)

(* A two-place buffer stores zero, one, or two elements. *)

type 'a content =
| Zero
| One of 'a
| Two of 'a * (* most recent: *) 'a

type 'a buffer =
  'a content ref

(* [update buffer x] pushes [x] into [buffer], causing the buffer to slide. *)

let update buffer x =
  buffer :=
    match !buffer, x with
    | Zero, _ ->
        One x
    | One x1, x2
    | Two (_, x1), x2 ->
        Two (x1, x2)

(* [show f buffer] prints the contents of the buffer. The function [f] is
   used to print an element. *)

let show f buffer : string =
  match !buffer with
  | Zero ->
      (* The buffer cannot be empty. If we have read no tokens,
         we cannot have detected a syntax error. *)
      assert false
  | One invalid ->
      (* It is unlikely, but possible, that we have read just one token. *)
      Printf.sprintf "before '%s'" (f invalid)
  | Two (valid, invalid) ->
      (* In the most likely case, we have read two tokens. *)
      Printf.sprintf "after '%s' and before '%s'" (f valid) (f invalid)

(* [last buffer] returns the last element of the buffer (that is, the invalid
   token). *)

let last buffer =
  match !buffer with
  | Zero ->
      (* The buffer cannot be empty. If we have read no tokens,
         we cannot have detected a syntax error. *)
      assert false
  | One invalid
  | Two (_, invalid) ->
      invalid

(* [wrap buffer lexer] *)

open Lexing

let wrap lexer =
  let buffer = ref Zero in
  buffer,
  fun lexbuf ->
    let token = lexer lexbuf in
    update buffer (lexbuf.lex_start_p, lexbuf.lex_curr_p);
    token

(* -------------------------------------------------------------------------- *)
end
module Printers = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

module Make
  (I : IncrementalEngine.EVERYTHING)
  (User : sig
    val print: string -> unit
    val print_symbol: I.xsymbol -> unit
    val print_element: (I.element -> unit) option
  end)
= struct

  let arrow = " -> "
  let dot = "."
  let space = " "
  let newline = "\n"

  open User
  open I

  (* Printing a list of symbols. An optional dot is printed at offset
     [i] into the list [symbols], if this offset lies between [0] and
     the length of the list (included). *)

  let rec print_symbols i symbols =
    if i = 0 then begin
      print dot;
      print space;
      print_symbols (-1) symbols
    end
    else begin
      match symbols with
      | [] ->
          ()
      | symbol :: symbols ->
          print_symbol symbol;
          print space;
          print_symbols (i - 1) symbols
    end

  (* Printing an element as a symbol. *)

  let print_element_as_symbol element =
    match element with
    | Element (s, _, _, _) ->
        print_symbol (X (incoming_symbol s))

  (* Some of the functions that follow need an element printer. They use
     [print_element] if provided by the user; otherwise they use
     [print_element_as_symbol]. *)

  let print_element =
    match print_element with
    | Some print_element ->
        print_element
    | None ->
        print_element_as_symbol

  (* Printing a stack as a list of symbols. Stack bottom on the left,
     stack top on the right. *)

  let rec print_stack env =
    match top env, pop env with
    | Some element, Some env ->
        print_stack env;
        print space;
        print_element element
    | _, _ ->
        ()

  let print_stack env =
    print_stack env;
    print newline

  (* Printing an item. *)

  let print_item (prod, i) =
    print_symbol (lhs prod);
    print arrow;
    print_symbols i (rhs prod);
    print newline

  (* Printing a list of symbols (public version). *)

  let print_symbols symbols =
    print_symbols (-1) symbols

  (* Printing a production (without a dot). *)

  let print_production prod =
    print_item (prod, -1)

  (* Printing the current LR(1) state. *)

  let print_current_state env =
    print "Current LR(1) state: ";
    match top env with
    | None ->
        print "<some initial state>"; (* TEMPORARY unsatisfactory *)
        print newline
    | Some (Element (current, _, _, _)) ->
        print (string_of_int (number current));
        print newline;
        List.iter print_item (items current)

  let print_env env =
    print_stack env;
    print_current_state env;
    print newline

end
end
module InfiniteArray = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(** This module implements infinite arrays, that is, arrays that grow
    transparently upon demand. *)

type 'a t = {
    default: 'a;
    mutable table: 'a array;
    mutable extent: int; (* the index of the greatest [set] ever, plus one *)
  }

let default_size =
  16384 (* must be non-zero *)

let make x = {
  default = x;
  table = Array.make default_size x;
  extent = 0;
}

let rec new_length length i =
  if i < length then
    length
  else
    new_length (2 * length) i

let ensure a i =
  assert (0 <= i);
  let table = a.table in
  let length = Array.length table in
  if i >= length then begin
    let table' = Array.make (new_length (2 * length) i) a.default in
    Array.blit table 0 table' 0 length;
    a.table <- table'
  end

let get a i =
  ensure a i;
  Array.unsafe_get a.table (i)

let set a i x =
  ensure a i;
  Array.unsafe_set a.table (i) x;
  if a.extent <= i then
    a.extent <- i + 1

let extent a =
  a.extent

let domain a =
  Array.sub a.table 0 a.extent

end
module PackedIntArray = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* A packed integer array is represented as a pair of an integer [k] and
   a string [s]. The integer [k] is the number of bits per integer that we
   use. The string [s] is just an array of bits, which is read in 8-bit
   chunks. *)

(* The ocaml programming language treats string literals and array literals
   in slightly different ways: the former are statically allocated, while
   the latter are dynamically allocated. (This is rather arbitrary.) In the
   context of Menhir's table-based back-end, where compact, immutable
   integer arrays are needed, ocaml strings are preferable to ocaml arrays. *)

type t =
  int * string

(* The magnitude [k] of an integer [v] is the number of bits required
   to represent [v]. It is rounded up to the nearest power of two, so
   that [k] divides [Sys.word_size]. *)

let magnitude (v : int) =
  if v < 0 then
    Sys.word_size
  else
    let rec check k max = (* [max] equals [2^k] *)
      if (max <= 0) || (v < max) then
        k
          (* if [max] just overflew, then [v] requires a full ocaml
             integer, and [k] is the number of bits in an ocaml integer
             plus one, that is, [Sys.word_size]. *)
      else
        check (2 * k) (max * max)
    in
    check 1 2

(* [pack a] turns an array of integers into a packed integer array. *)

(* Because the sign bit is the most significant bit, the magnitude of
   any negative number is the word size. In other words, [pack] does
   not achieve any space savings as soon as [a] contains any negative
   numbers, even if they are ``small''. *)

let pack (a : int array) : t =

  let m = Array.length a in

  (* Compute the maximum magnitude of the array elements. This tells
     us how many bits per element we are going to use. *)

  let k =
    Array.fold_left (fun k v ->
      max k (magnitude v)
    ) 1 a
  in

  (* Because access to ocaml strings is performed on an 8-bit basis,
     two cases arise. If [k] is less than 8, then we can pack multiple
     array entries into a single character. If [k] is greater than 8,
     then we must use multiple characters to represent a single array
     entry. *)

  if k <= 8 then begin

    (* [w] is the number of array entries that we pack in a character. *)

    assert (8 mod k = 0);
    let w = 8 / k in

    (* [n] is the length of the string that we allocate. *)

    let n =
      if m mod w = 0 then
        m / w
      else
        m / w + 1
    in

    let s =
      Bytes.create n
    in

    (* Define a reader for the source array. The reader might run off
       the end if [w] does not divide [m]. *)

    let i = ref 0 in
    let next () =
      let ii = !i in
      if ii = m then
        0 (* ran off the end, pad with zeroes *)
      else
        let v = a.(ii) in
        i := ii + 1;
        v
    in

    (* Fill up the string. *)

    for j = 0 to n - 1 do
      let c = ref 0 in
      for _x = 1 to w do
        c := (!c lsl k) lor next()
      done;
      Bytes.set s j (Char.chr !c)
    done;

    (* Done. *)

    k, Bytes.unsafe_to_string s

  end
  else begin (* k > 8 *)

    (* [w] is the number of characters that we use to encode an array entry. *)

    assert (k mod 8 = 0);
    let w = k / 8 in

    (* [n] is the length of the string that we allocate. *)

    let n =
      m * w
    in

    let s =
      Bytes.create n
    in

    (* Fill up the string. *)

    for i = 0 to m - 1 do
      let v = ref a.(i) in
      for x = 1 to w do
        Bytes.set s ((i + 1) * w - x) (Char.chr (!v land 255));
        v := !v lsr 8
      done
    done;

    (* Done. *)

    k, Bytes.unsafe_to_string s

  end

(* Access to a string. *)

let read (s : string) (i : int) : int =
  Char.code (String.unsafe_get s i)

(* [get1 t i] returns the integer stored in the packed array [t] at index [i].
   It assumes (and does not check) that the array's bit width is [1]. The
   parameter [t] is just a string. *)

let get1 (s : string) (i : int) : int =
  let c = read s (i lsr 3) in
  let c = c lsr ((lnot i) land 0b111) in
  let c = c land 0b1 in
  c

(* [get t i] returns the integer stored in the packed array [t] at index [i]. *)

(* Together, [pack] and [get] satisfy the following property: if the index [i]
   is within bounds, then [get (pack a) i] equals [a.(i)]. *)

let get ((k, s) : t) (i : int) : int =
  match k with
  | 1 ->
      get1 s i
  | 2 ->
      let c = read s (i lsr 2) in
      let c = c lsr (2 * ((lnot i) land 0b11)) in
      let c = c land 0b11 in
      c
  | 4 ->
      let c = read s (i lsr 1) in
      let c = c lsr (4 * ((lnot i) land 0b1)) in
      let c = c land 0b1111 in
      c
  | 8 ->
      read s i
  | 16 ->
      let j = 2 * i in
      (read s j) lsl 8 + read s (j + 1)
  | _ ->
      assert (k = 32); (* 64 bits unlikely, not supported *)
      let j = 4 * i in
      (((read s j lsl 8) + read s (j + 1)) lsl 8 + read s (j + 2)) lsl 8 + read s (j + 3)

(* [unflatten1 (n, data) i j] accesses the two-dimensional bitmap
   represented by [(n, data)] at indices [i] and [j]. The integer
   [n] is the width of the bitmap; the string [data] is the second
   component of the packed array obtained by encoding the table as
   a one-dimensional array. *)

let unflatten1 (n, data) i j =
   get1 data (n * i + j)

end
module RowDisplacement = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This module compresses a two-dimensional table, where some values
   are considered insignificant, via row displacement. *)

(* This idea reportedly appears in Aho and Ullman's ``Principles
   of Compiler Design'' (1977). It is evaluated in Tarjan and Yao's
   ``Storing a Sparse Table'' (1979) and in Dencker, Dürre, and Heuft's
   ``Optimization of Parser Tables for Portable Compilers'' (1984). *)

(* A compressed table is represented as a pair of arrays. The
   displacement array is an array of offsets into the data array. *)

type 'a table =
    int array * (* displacement *)
     'a array   (* data *)

(* In a natural version of this algorithm, displacements would be greater
   than (or equal to) [-n]. However, in the particular setting of Menhir,
   both arrays are intended to be compressed with [PackedIntArray], which
   does not efficiently support negative numbers. For this reason, we are
   careful not to produce negative displacements. *)

(* In order to avoid producing negative displacements, we simply use the
   least significant bit as the sign bit. This is implemented by [encode]
   and [decode] below. *)

(* One could also think, say, of adding [n] to every displacement, so as
   to ensure that all displacements are nonnegative. This would work, but
   would require [n] to be published, for use by the decoder. *)

let encode (displacement : int) : int =
  if displacement >= 0 then
    displacement lsl 1
  else
    (-displacement) lsl 1 + 1

let decode (displacement : int) : int =
  if displacement land 1 = 0 then
    displacement lsr 1
  else
    -(displacement lsr 1)

(* It is reasonable to assume that, as matrices grow large, their
   density becomes low, i.e., they have many insignificant entries.
   As a result, it is important to work with a sparse data structure
   for rows. We internally represent a row as a list of its
   significant entries, where each entry is a pair of a [j] index and
   an element. *)

type 'a row =
    (int * 'a) list

(* [compress equal insignificant dummy m n t] turns the two-dimensional table
   [t] into a compressed table. The parameter [equal] is equality of data
   values. The parameter [wildcard] tells which data values are insignificant,
   and can thus be overwritten with other values. The parameter [dummy] is
   used to fill holes in the data array. [m] and [n] are the integer
   dimensions of the table [t]. *)

let compress
    (equal : 'a -> 'a -> bool)
    (insignificant : 'a -> bool)
    (dummy : 'a)
    (m : int) (n : int)
    (t : 'a array array)
    : 'a table =

  (* Be defensive. *)

  assert (Array.length t = m);
  assert begin
    for i = 0 to m - 1 do
      assert (Array.length t.(i) = n)
    done;
    true
  end;

  (* This turns a row-as-array into a row-as-sparse-list. The row is
     accompanied by its index [i] and by its rank (the number of its
     significant entries, that is, the length of the row-as-a-list. *)

  let sparse (i : int) (line : 'a array) : int * int * 'a row (* index, rank, row *) =

    let rec loop (j : int) (rank : int) (row : 'a row) =
      if j < 0 then
        i, rank, row
      else
        let x = line.(j) in
        if insignificant x then
          loop (j - 1) rank row
        else
          loop (j - 1) (1 + rank) ((j, x) :: row)
    in

    loop (n - 1) 0 []

  in

  (* Construct an array of all rows, together with their index and rank. *)

  let rows : (int * int * 'a row) array = (* index, rank, row *)
    Array.mapi sparse t
  in

  (* Sort this array by decreasing rank. This does not have any impact
     on correctness, but reportedly improves compression. The
     intuitive idea is that rows with few significant elements are
     easy to fit, so they should be inserted last, after the problem
     has become quite constrained by fitting the heavier rows. This
     heuristic is attributed to Ziegler. *)

  Array.fast_sort (fun (_, rank1, _) (_, rank2, _) ->
    compare rank2 rank1
  ) rows;

  (* Allocate a one-dimensional array of displacements. *)

  let displacement : int array =
    Array.make m 0
  in

  (* Allocate a one-dimensional, infinite array of values. Indices
     into this array are written [k]. *)

  let data : 'a InfiniteArray.t =
    InfiniteArray.make dummy
  in

  (* Determine whether [row] fits at offset [k] within the current [data]
     array, up to extension of this array. *)

  (* Note that this check always succeeds when [k] equals the length of
     the [data] array. Indeed, the loop is then skipped. This property
     guarantees the termination of the recursive function [fit] below. *)

  let fits k (row : 'a row) : bool =

    let d = InfiniteArray.extent data in

    let rec loop = function
      | [] ->
          true
      | (j, x) :: row ->

          (* [x] is a significant element. *)

          (* By hypothesis, [k + j] is nonnegative. If it is greater than or
             equal to the current length of the data array, stop -- the row
             fits. *)

          assert (k + j >= 0);

          if k + j >= d then
            true

          (* We now know that [k + j] is within bounds of the data
             array. Check whether it is compatible with the element [y] found
             there. If it is, continue. If it isn't, stop -- the row does not
             fit. *)

          else
            let y = InfiniteArray.get data (k + j) in
            if insignificant y || equal x y then
              loop row
            else
              false

    in
    loop row

  in

  (* Find the leftmost position where a row fits. *)

  (* If the leftmost significant element in this row is at offset [j],
     then we can hope to fit as far left as [-j] -- so this element
     lands at offset [0] in the data array. *)

  (* Note that displacements may be negative. This means that, for
     insignificant elements, accesses to the data array could fail: they could
     be out of bounds, either towards the left or towards the right. This is
     not a problem, as long as [get] is invoked only at significant
     elements. *)

  let rec fit k row : int =
    if fits k row then
      k
    else
      fit (k + 1) row
  in

  let fit row =
    match row with
    | [] ->
        0 (* irrelevant *)
    | (j, _) :: _ ->
        fit (-j) row
  in

  (* Write [row] at (compatible) offset [k]. *)

  let rec write k = function
    | [] ->
        ()
    | (j, x) :: row ->
        InfiniteArray.set data (k + j) x;
        write k row
  in

  (* Iterate over the sorted array of rows. Fit and write each row at
     the leftmost compatible offset. Update the displacement table. *)

  Array.iter (fun (i, _, row) ->
    let k = fit row in (* if [row] has leading insignificant elements, then [k] can be negative *)
    write k row;
    displacement.(i) <- encode k
  ) rows;

  (* Return the compressed tables. *)

  displacement, InfiniteArray.domain data

(* [get ct i j] returns the value found at indices [i] and [j] in the
   compressed table [ct]. This function call is permitted only if the
   value found at indices [i] and [j] in the original table is
   significant -- otherwise, it could fail abruptly. *)

(* Together, [compress] and [get] have the property that, if the value
   found at indices [i] and [j] in an uncompressed table [t] is
   significant, then [get (compress t) i j] is equal to that value. *)

let get (displacement, data) i j =
  assert (0 <= i && i < Array.length displacement);
  let k = decode displacement.(i) in
  assert (0 <= k + j && k + j < Array.length data);
    (* failure of this assertion indicates an attempt to access an
       insignificant element that happens to be mapped out of the bounds
       of the [data] array. *)
  data.(k + j)

(* [getget] is a variant of [get] which only requires read access,
   via accessors, to the two components of the table. *)

let getget get_displacement get_data (displacement, data) i j =
  let k = decode (get_displacement displacement i) in
  get_data data (k + j)
end
module LinearizedArray = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* The [entry] array contains offsets into the [data] array. It has [n+1]
   elements if the original (unencoded) array has [n] elements. The value
   of [entry.(n)] is the length of the [data] array. This convention is
   natural and allows avoiding a special case. *)

type 'a t =
  (* data: *)   'a array *
  (* entry: *) int array

let make (a : 'a array array) : 'a t =
  let n = Array.length a in
  (* Build the entry array. *)
  let size = ref 0 in
  let entry = Array.init (n + 1) (fun i ->
    let s = !size in
    if i < n then
      size := s + Array.length a.(i);
    s
  ) in
  assert (entry.(n) = !size);
  (* Build the data array. *)
  let i = ref 0
  and j = ref 0 in
  let data = Array.init !size (fun _ ->
    while !j = Array.length a.(!i) do
      i := !i + 1;
      j := 0;
    done;
    let x = a.(!i).(!j) in
    j := !j + 1;
    x
  ) in
  data, entry

let length ((_, entry) : 'a t) : int =
  Array.length entry

let row_length ((_, entry) : 'a t) i : int =
  entry.(i + 1) - entry.(i)

let row_length_via get_entry i =
  get_entry (i + 1) - get_entry i

let read ((data, entry) as la : 'a t) i j : 'a =
  assert (0 <= j && j < row_length la i);
  data.(entry.(i) + j)

let read_via get_data get_entry i j =
  assert (0 <= j && j < row_length_via get_entry i);
  get_data (get_entry i + j)

let write ((data, entry) as la : 'a t) i j (v : 'a) : unit =
  assert (0 <= j && j < row_length la i);
  data.(entry.(i) + j) <- v

let rec read_interval_via get_data i j =
  if i = j then
    []
  else
    get_data i :: read_interval_via get_data (i + 1) j

let read_row_via get_data get_entry i =
  read_interval_via get_data (get_entry i) (get_entry (i + 1))

let read_row ((data, entry) : 'a t) i : 'a list =
  read_row_via (Array.get data) (Array.get entry) i

end
module TableFormat = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This signature defines the format of the parse tables. It is used as
   an argument to [TableInterpreter.Make]. *)

module type TABLES = sig

  (* This is the parser's type of tokens. *)

  type token

  (* This maps a token to its internal (generation-time) integer code. *)

  val token2terminal: token -> int

  (* This is the integer code for the error pseudo-token. *)

  val error_terminal: int

  (* This maps a token to its semantic value. *)

  val token2value: token -> Obj.t

  (* Traditionally, an LR automaton is described by two tables, namely, an
     action table and a goto table. See, for instance, the Dragon book.

     The action table is a two-dimensional matrix that maps a state and a
     lookahead token to an action. An action is one of: shift to a certain
     state, reduce a certain production, accept, or fail.

     The goto table is a two-dimensional matrix that maps a state and a
     non-terminal symbol to either a state or undefined. By construction, this
     table is sparse: its undefined entries are never looked up. A compression
     technique is free to overlap them with other entries.

     In Menhir, things are slightly different. If a state has a default
     reduction on token [#], then that reduction must be performed without
     consulting the lookahead token. As a result, we must first determine
     whether that is the case, before we can obtain a lookahead token and use it
     as an index in the action table.

     Thus, Menhir's tables are as follows.

     A one-dimensional default reduction table maps a state to either ``no
     default reduction'' (encoded as: 0) or ``by default, reduce prod''
     (encoded as: 1 + prod). The action table is looked up only when there
     is no default reduction. *)

  val default_reduction: PackedIntArray.t

  (* Menhir follows Dencker, Dürre and Heuft, who point out that, although the
     action table is not sparse by nature (i.e., the error entries are
     significant), it can be made sparse by first factoring out a binary error
     matrix, then replacing the error entries in the action table with undefined
     entries. Thus:

     A two-dimensional error bitmap maps a state and a terminal to either
     ``fail'' (encoded as: 0) or ``do not fail'' (encoded as: 1). The action
     table, which is now sparse, is looked up only in the latter case. *)

  (* The error bitmap is flattened into a one-dimensional table; its width is
     recorded so as to allow indexing. The table is then compressed via
     [PackedIntArray]. The bit width of the resulting packed array must be
     [1], so it is not explicitly recorded. *)

  (* The error bitmap does not contain a column for the [#] pseudo-terminal.
     Thus, its width is [Terminal.n - 1]. We exploit the fact that the integer
     code assigned to [#] is greatest: the fact that the right-most column
     in the bitmap is missing does not affect the code for accessing it. *)

  val error: int (* width of the bitmap *) * string (* second component of [PackedIntArray.t] *)

  (* A two-dimensional action table maps a state and a terminal to one of
     ``shift to state s and discard the current token'' (encoded as: s | 10),
     ``shift to state s without discarding the current token'' (encoded as: s |
     11), or ``reduce prod'' (encoded as: prod | 01). *)

  (* The action table is first compressed via [RowDisplacement], then packed
     via [PackedIntArray]. *)

  (* Like the error bitmap, the action table does not contain a column for the
     [#] pseudo-terminal. *)

  val action: PackedIntArray.t * PackedIntArray.t

  (* A one-dimensional lhs table maps a production to its left-hand side (a
     non-terminal symbol). *)

  val lhs: PackedIntArray.t

  (* A two-dimensional goto table maps a state and a non-terminal symbol to
     either undefined (encoded as: 0) or a new state s (encoded as: 1 + s). *)

  (* The goto table is first compressed via [RowDisplacement], then packed
     via [PackedIntArray]. *)

  val goto: PackedIntArray.t * PackedIntArray.t

  (* The number of start productions. A production [prod] is a start
     production if and only if [prod < start] holds. This is also the
     number of start symbols. A nonterminal symbol [nt] is a start
     symbol if and only if [nt < start] holds. *)

  val start: int

  (* A one-dimensional semantic action table maps productions to semantic
     actions. The calling convention for semantic actions is described in
     [EngineTypes]. This table contains ONLY NON-START PRODUCTIONS, so the
     indexing is off by [start]. Be careful. *)

  val semantic_action: ((int, Obj.t, token) EngineTypes.env ->
                        (int, Obj.t)        EngineTypes.stack) array

  (* The parser defines its own [Error] exception. This exception can be
     raised by semantic actions and caught by the engine, and raised by the
     engine towards the final user. *)

  exception Error

  (* The parser indicates whether to generate a trace. Generating a
     trace requires two extra tables, which respectively map a
     terminal symbol and a production to a string. *)

  val trace: (string array * string array) option

end
end
module InspectionTableFormat = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* This signature defines the format of the tables that are produced (in
   addition to the tables described in [TableFormat]) when the command line
   switch [--inspection] is enabled. It is used as an argument to
   [InspectionTableInterpreter.Make]. *)

module type TABLES = sig

  (* The types of symbols. *)

  include IncrementalEngine.SYMBOLS

  (* The type ['a lr1state] describes an LR(1) state. The generated parser defines
     it internally as [int]. *)

  type 'a lr1state

  (* Some of the tables that follow use encodings of (terminal and
     nonterminal) symbols as integers. So, we need functions that
     map the integer encoding of a symbol to its algebraic encoding. *)

  val    terminal: int -> xsymbol
  val nonterminal: int -> xsymbol

  (* The left-hand side of every production already appears in the
     signature [TableFormat.TABLES], so we need not repeat it here. *)

  (* The right-hand side of every production. This a linearized array
     of arrays of integers, whose [data] and [entry] components have
     been packed. The encoding of symbols as integers in described in
     [TableBackend]. *)

  val rhs: PackedIntArray.t * PackedIntArray.t

  (* A mapping of every (non-initial) state to its LR(0) core. *)

  val lr0_core: PackedIntArray.t

  (* A mapping of every LR(0) state to its set of LR(0) items. Each item is
     represented in its packed form (see [Item]) as an integer. Thus the
     mapping is an array of arrays of integers, which is linearized and
     packed, like [rhs]. *)

  val lr0_items: PackedIntArray.t * PackedIntArray.t

  (* A mapping of every LR(0) state to its incoming symbol, if it has one. *)

  val lr0_incoming: PackedIntArray.t

  (* A table that tells which non-terminal symbols are nullable. *)

  val nullable: string
    (* This is a packed int array of bit width 1. It can be read
       using [PackedIntArray.get1]. *)

  (* A two-table dimensional table, indexed by a nonterminal symbol and
     by a terminal symbol (other than [#]), encodes the FIRST sets. *)

  val first: int (* width of the bitmap *) * string (* second component of [PackedIntArray.t] *)

end

end
module InspectionTableInterpreter = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

(* -------------------------------------------------------------------------- *)

(* The type functor. *)

module Symbols (T : sig

  type 'a terminal
  type 'a nonterminal

end) = struct

  open T

  (* This should be the only place in the whole library (and generator!)
     where these types are defined. *)

  type 'a symbol =
    | T : 'a terminal -> 'a symbol
    | N : 'a nonterminal -> 'a symbol

  type xsymbol =
    | X : 'a symbol -> xsymbol

end

(* -------------------------------------------------------------------------- *)

(* The code functor. *)

module Make
  (TT : TableFormat.TABLES)
  (IT : InspectionTableFormat.TABLES
        with type 'a lr1state = int)
  (ET : EngineTypes.TABLE
        with type terminal = int
         and type nonterminal = int
         and type semantic_value = Obj.t)
  (E : sig
     type 'a env = (ET.state, ET.semantic_value, ET.token) EngineTypes.env
   end)
= struct

  (* Including [IT] is an easy way of inheriting the definitions of the types
     [symbol] and [xsymbol]. *)

  include IT

  (* This auxiliary function decodes a packed linearized array, as created by
     [TableBackend.linearize_and_marshal1]. Here, we read a row all at once. *)

  let read_packed_linearized
    (data, entry : PackedIntArray.t * PackedIntArray.t) (i : int) : int list
  =
    LinearizedArray.read_row_via
      (PackedIntArray.get data)
      (PackedIntArray.get entry)
      i

  (* This auxiliary function decodes a symbol. The encoding was done by
     [encode_symbol] or [encode_symbol_option] in the table back-end. *)

  let decode_symbol (symbol : int) : IT.xsymbol =
    (* If [symbol] is 0, then we have no symbol. This could mean e.g.
       that the function [incoming_symbol] has been applied to an
       initial state. In principle, this cannot happen. *)
    assert (symbol > 0);
    (* The low-order bit distinguishes terminal and nonterminal symbols. *)
    let kind = symbol land 1 in
    let symbol = symbol lsr 1 in
    if kind = 0 then
      IT.terminal (symbol - 1)
    else
      IT.nonterminal symbol

  (* These auxiliary functions convert a symbol to its integer code. For speed
     and for convenience, we use an unsafe type cast. This relies on the fact
     that the data constructors of the [terminal] and [nonterminal] GADTs are
     declared in an order that reflects their internal code. In the case of
     nonterminal symbols, we add [start] to account for the presence of the
     start symbols. *)

  let n2i (nt : 'a IT.nonterminal) : int =
    let answer = TT.start + Obj.magic nt in
    (* For safety, check that the above cast produced a correct result. *)
    assert (IT.nonterminal answer = X (N nt));
    answer

  let t2i (t : 'a IT.terminal) : int =
    let answer = Obj.magic t in
    (* For safety, check that the above cast produced a correct result. *)
    assert (IT.terminal answer = X (T t));
    answer

  (* Ordering functions. *)

  let compare_terminals t1 t2 =
    (* Subtraction is safe because overflow is impossible. *)
    t2i t1 - t2i t2

  let compare_nonterminals nt1 nt2 =
    (* Subtraction is safe because overflow is impossible. *)
    n2i nt1 - n2i nt2

  let compare_symbols symbol1 symbol2 =
    match symbol1, symbol2 with
    | X (T _), X (N _) ->
        -1
    | X (N _), X (T _) ->
        1
    | X (T t1), X (T t2) ->
        compare_terminals t1 t2
    | X (N nt1), X (N nt2) ->
        compare_nonterminals nt1 nt2

  let compare_productions prod1 prod2 =
    (* Subtraction is safe because overflow is impossible. *)
    prod1 - prod2

  let compare_items (prod1, index1) (prod2, index2) =
    let c = compare_productions prod1 prod2 in
    (* Subtraction is safe because overflow is impossible. *)
    if c <> 0 then c else index1 - index2

  (* The function [incoming_symbol] goes through the tables [IT.lr0_core] and
     [IT.lr0_incoming]. This yields a representation of type [xsymbol], out of
     which we strip the [X] quantifier, so as to get a naked symbol. This last
     step is ill-typed and potentially dangerous. It is safe only because this
     function is used at type ['a lr1state -> 'a symbol], which forces an
     appropriate choice of ['a]. *)

  let incoming_symbol (s : 'a IT.lr1state) : 'a IT.symbol =
    let core = PackedIntArray.get IT.lr0_core s in
    let symbol = decode_symbol (PackedIntArray.get IT.lr0_incoming core) in
    match symbol with
    | IT.X symbol ->
        Obj.magic symbol

  (* The function [lhs] reads the table [TT.lhs] and uses [IT.nonterminal]
     to decode the symbol. *)

  let lhs prod =
    IT.nonterminal (PackedIntArray.get TT.lhs prod)

  (* The function [rhs] reads the table [IT.rhs] and uses [decode_symbol]
     to decode the symbol. *)

  let rhs prod =
    List.map decode_symbol (read_packed_linearized IT.rhs prod)

  (* The function [items] maps the LR(1) state [s] to its LR(0) core,
     then uses [core] as an index into the table [IT.lr0_items]. The
     items are then decoded by the function [export] below, which is
     essentially a copy of [Item.export]. *)

  type item =
      int * int

  let export t : item =
    (t lsr 7, t mod 128)

  let items s =
    (* Map [s] to its LR(0) core. *)
    let core = PackedIntArray.get IT.lr0_core s in
    (* Now use [core] to look up the table [IT.lr0_items]. *)
    List.map export (read_packed_linearized IT.lr0_items core)

  (* The function [nullable] maps the nonterminal symbol [nt] to its
     integer code, which it uses to look up the array [IT.nullable].
     This yields 0 or 1, which we map back to a Boolean result. *)

  let decode_bool i =
    assert (i = 0 || i = 1);
    i = 1

  let nullable nt =
    decode_bool (PackedIntArray.get1 IT.nullable (n2i nt))

  (* The function [first] maps the symbols [nt] and [t] to their integer
     codes, which it uses to look up the matrix [IT.first]. *)

  let first nt t =
    decode_bool (PackedIntArray.unflatten1 IT.first (n2i nt) (t2i t))

  let xfirst symbol t =
    match symbol with
    | X (T t') ->
        compare_terminals t t' = 0
    | X (N nt) ->
        first nt t

  (* The function [foreach_terminal] exploits the fact that the
     first component of [TT.error] is [Terminal.n - 1], i.e., the
     number of terminal symbols, including [error] but not [#]. *)

  let rec foldij i j f accu =
    if i = j then
      accu
    else
      foldij (i + 1) j f (f i accu)

  let foreach_terminal f accu =
    let n, _ = TT.error in
    foldij 0 n (fun i accu ->
      f (IT.terminal i) accu
    ) accu

  let foreach_terminal_but_error f accu =
    let n, _ = TT.error in
    foldij 0 n (fun i accu ->
      if i = TT.error_terminal then
        accu
      else
        f (IT.terminal i) accu
    ) accu

  (* ------------------------------------------------------------------------ *)

  (* The following is the implementation of the function [feed]. This function
     is logically part of the LR engine, so it would be nice if it were placed
     in the module [Engine], but it must be placed here because, to ensure
     type safety, its arguments must be a symbol of type ['a symbol] and a
     semantic value of type ['a]. The type ['a symbol] is not available in
     [Engine]. It is available here. *)

  open EngineTypes
  open ET
  open E

  (* [feed] fails if the current state does not have an outgoing transition
     labeled with the desired symbol. This check is carried out at runtime. *)

  let feed_failure () =
    invalid_arg "feed: outgoing transition does not exist"

  (* Feeding a nonterminal symbol [nt]. Here, [nt] has type [nonterminal],
     which is a synonym for [int], and [semv] has type [semantic_value],
     which is a synonym for [Obj.t]. This type is unsafe, because pushing
     a semantic value of arbitrary type into the stack can later cause a
     semantic action to crash and burn. The function [feed] is given a safe
     type below. *)

  let feed_nonterminal
        (nt : nonterminal) startp (semv : semantic_value) endp (env : 'b env)
      : 'b env
  =
    (* Check if the source state has an outgoing transition labeled [nt].
       This is done by consulting the [goto] table. *)
    let source = env.current in
    match ET.maybe_goto_nt source nt with
    | None ->
        feed_failure()
    | Some target ->
        (* Push a new cell onto the stack, containing the identity of the state
           that we are leaving. The semantic value [semv] and positions [startp]
           and [endp] contained in the new cell are provided by the caller. *)
        let stack = { state = source; semv; startp; endp; next = env.stack } in
        (* Move to the target state. *)
        { env with stack; current = target }

  let reduce   _env _prod = feed_failure()
  let initiate _env       = feed_failure()

  let feed_terminal
        (terminal : terminal) startp (semv : semantic_value) endp (env : 'b env)
      : 'b env
  =
    (* Check if the source state has an outgoing transition labeled [terminal].
       This is done by consulting the [action] table. *)
    let source = env.current in
    ET.action source terminal semv
      (fun env _please_discard _terminal semv target ->
        (* There is indeed a transition toward the state [target].
           Push a new cell onto the stack and move to the target state. *)
        let stack = { state = source; semv; startp; endp; next = env.stack } in
        { env with stack; current = target }
      ) reduce initiate env

  (* The type assigned to [feed] ensures that the type of the semantic value
     [semv] is appropriate: it must be the semantic-value type of the symbol
     [symbol]. *)

  let feed (symbol : 'a symbol) startp (semv : 'a) endp env =
    let semv : semantic_value = Obj.repr semv in
    match symbol with
    | N nt ->
        feed_nonterminal (n2i nt) startp semv endp env
    | T terminal ->
        feed_terminal (t2i terminal) startp semv endp env

end
end
module TableInterpreter = struct
(******************************************************************************)
(*                                                                            *)
(*                                   Menhir                                   *)
(*                                                                            *)
(*                       François Pottier, Inria Paris                        *)
(*              Yann Régis-Gianas, PPS, Université Paris Diderot              *)
(*                                                                            *)
(*  Copyright Inria. All rights reserved. This file is distributed under the  *)
(*  terms of the GNU Library General Public License version 2, with a         *)
(*  special exception on linking, as described in the file LICENSE.           *)
(*                                                                            *)
(******************************************************************************)

module MakeEngineTable (T : TableFormat.TABLES) = struct

  type state =
      int

  let number s = s

  type token =
      T.token

  type terminal =
      int

  type nonterminal =
      int

  type semantic_value =
      Obj.t

  let token2terminal =
    T.token2terminal

  let token2value =
    T.token2value

  let error_terminal =
    T.error_terminal

  let error_value =
    Obj.repr ()

  (* The function [foreach_terminal] exploits the fact that the
     first component of [T.error] is [Terminal.n - 1], i.e., the
     number of terminal symbols, including [error] but not [#]. *)

  (* There is similar code in [InspectionTableInterpreter]. The
     code there contains an additional conversion of the type
     [terminal] to the type [xsymbol]. *)

  let rec foldij i j f accu =
    if i = j then
      accu
    else
      foldij (i + 1) j f (f i accu)

  let foreach_terminal f accu =
    let n, _ = T.error in
    foldij 0 n (fun i accu ->
      f i accu
    ) accu

  type production =
      int

  (* In principle, only non-start productions are exposed to the user,
     at type [production] or at type [int]. This is checked dynamically. *)
  let non_start_production i =
    assert (T.start <= i && i - T.start < Array.length T.semantic_action)

  let production_index i =
    non_start_production i;
    i

  let find_production i =
    non_start_production i;
    i

  let default_reduction state defred nodefred env =
    let code = PackedIntArray.get T.default_reduction state in
    if code = 0 then
      nodefred env
    else
      defred env (code - 1)

  let is_start prod =
    prod < T.start

  (* This auxiliary function helps access a compressed, two-dimensional
     matrix, like the action and goto tables. *)

  let unmarshal2 table i j =
    RowDisplacement.getget
      PackedIntArray.get
      PackedIntArray.get
      table
      i j

  let action state terminal value shift reduce fail env =
    match PackedIntArray.unflatten1 T.error state terminal with
    | 1 ->
        let action = unmarshal2 T.action state terminal in
        let opcode = action land 0b11
        and param = action lsr 2 in
        if opcode >= 0b10 then
          (* 0b10 : shift/discard *)
          (* 0b11 : shift/nodiscard *)
          let please_discard = (opcode = 0b10) in
          shift env please_discard terminal value param
        else
          (* 0b01 : reduce *)
          (* 0b00 : cannot happen *)
          reduce env param
    | c ->
        assert (c = 0);
        fail env

  let goto_nt state nt =
    let code = unmarshal2 T.goto state nt in
    (* code = 1 + state *)
    code - 1

  let goto_prod state prod =
    goto_nt state (PackedIntArray.get T.lhs prod)

  let maybe_goto_nt state nt =
    let code = unmarshal2 T.goto state nt in
    (* If [code] is 0, there is no outgoing transition.
       If [code] is [1 + state], there is a transition towards [state]. *)
    assert (0 <= code);
    if code = 0 then None else Some (code - 1)

  exception Error =
        T.Error

  type semantic_action =
      (state, semantic_value, token) EngineTypes.env ->
      (state, semantic_value)        EngineTypes.stack

  let semantic_action prod =
    (* Indexing into the array [T.semantic_action] is off by [T.start],
       because the start productions do not have entries in this array. *)
    T.semantic_action.(prod - T.start)

  (* [may_reduce state prod] tests whether the state [state] is capable of
     reducing the production [prod]. This information could be determined
     in constant time if we were willing to create a bitmap for it, but
     that would take up a lot of space. Instead, we obtain this information
     by iterating over a line in the action table. This is costly, but this
     function is not normally used by the LR engine anyway; it is supposed
     to be used only by programmers who wish to develop error recovery
     strategies. *)

  (* In the future, if desired, we could memoize this function, so as
     to pay the cost in (memory) space only if and where this function
     is actually used. We could also replace [foreach_terminal] with a
     function [exists_terminal] which stops as soon as the accumulator
     is [true]. *)

  let may_reduce state prod =
    (* Test if there is a default reduction of [prod]. *)
    default_reduction state
      (fun () prod' -> prod = prod')
      (fun () ->
        (* If not, then for each terminal [t], ... *)
        foreach_terminal (fun t accu ->
          accu ||
          (* ... test if there is a reduction of [prod] on [t]. *)
          action state t ()
            (* shift:  *) (fun () _ _ () _ -> false)
            (* reduce: *) (fun () prod' -> prod = prod')
            (* fail:   *) (fun () -> false)
            ()
        ) false
      )
      ()

  (* If [T.trace] is [None], then the logging functions do nothing. *)

  let log =
    match T.trace with Some _ -> true | None -> false

  module Log = struct

    open Printf

    let state state =
      match T.trace with
      | Some _ ->
          fprintf stderr "State %d:\n%!" state
      | None ->
          ()

    let shift terminal state =
      match T.trace with
      | Some (terminals, _) ->
          fprintf stderr "Shifting (%s) to state %d\n%!" terminals.(terminal) state
      | None ->
          ()

    let reduce_or_accept prod =
      match T.trace with
      | Some (_, productions) ->
          fprintf stderr "%s\n%!" productions.(prod)
      | None ->
          ()

    let lookahead_token token startp endp =
      match T.trace with
      | Some (terminals, _) ->
          fprintf stderr "Lookahead token is now %s (%d-%d)\n%!"
            terminals.(token)
            startp.Lexing.pos_cnum
            endp.Lexing.pos_cnum
      | None ->
          ()

    let initiating_error_handling () =
      match T.trace with
      | Some _ ->
          fprintf stderr "Initiating error handling\n%!"
      | None ->
          ()

    let resuming_error_handling () =
      match T.trace with
      | Some _ ->
          fprintf stderr "Resuming error handling\n%!"
      | None ->
          ()

    let handling_error state =
      match T.trace with
      | Some _ ->
          fprintf stderr "Handling error in state %d\n%!" state
      | None ->
          ()

  end

end
end
module StaticVersion = struct
let require_20170418 = ()
end

end
module Reason_parser : sig 
#1 "reason_parser.mli"

(* The type of tokens. *)

type token = 
  | WITH
  | WHILE
  | WHEN
  | VIRTUAL
  | VAL
  | UNDERSCORE
  | UIDENT of (string)
  | TYPE
  | TRY
  | TRUE
  | TO
  | TILDE
  | THEN
  | SWITCH
  | STRUCT
  | STRING of (string * string option)
  | STAR
  | SLASHGREATER
  | SIG
  | SHARPOP of (string)
  | SHARP
  | SEMISEMI
  | SEMI
  | RPAREN
  | REC
  | RBRACKET
  | RBRACE
  | QUOTE
  | QUESTION
  | PUB
  | PRI
  | PREFIXOP of (string)
  | PLUSEQ
  | PLUSDOT
  | PLUS
  | PERCENT
  | OR
  | OPTIONAL_NO_DEFAULT
  | OPEN
  | OF
  | OBJECT
  | NONREC
  | NEW
  | NATIVEINT of (nativeint)
  | MUTABLE
  | MODULE
  | MINUSGREATER
  | MINUSDOT
  | MINUS
  | LPAREN
  | LIDENTCOLONCOLON of (string)
  | LIDENT of (string)
  | LET
  | LESSSLASHIDENTGREATER of (string)
  | LESSSLASHGREATER
  | LESSSLASH
  | LESSMINUS
  | LESSIDENT of (string)
  | LESSGREATER
  | LESSDOTDOTGREATER
  | LESS
  | LBRACKETPERCENTPERCENT
  | LBRACKETPERCENT
  | LBRACKETLESS
  | LBRACKETGREATER
  | LBRACKETBAR
  | LBRACKETATATAT
  | LBRACKETATAT
  | LBRACKETAT
  | LBRACKET
  | LBRACELESS
  | LBRACE
  | LAZY
  | INT of (string * char option)
  | INITIALIZER
  | INHERIT
  | INFIXOP4 of (string)
  | INFIXOP3 of (string)
  | INFIXOP2 of (string)
  | INFIXOP1 of (string)
  | INFIXOP0 of (string)
  | INCLUDE
  | IN
  | IF
  | GREATERRBRACE
  | GREATER
  | FUNCTOR
  | FUNCTION
  | FUN
  | FOR
  | FLOAT of (string * char option)
  | FALSE
  | EXTERNAL
  | EXCEPTION
  | EQUALGREATER
  | EQUAL
  | EOL
  | EOF
  | END
  | ELSE
  | DOWNTO
  | DOTDOTDOT
  | DOTDOT
  | DOT
  | DONE
  | DO
  | CONSTRAINT
  | COMMENT of (string * Location.t)
  | COMMA
  | COLONGREATER
  | COLONEQUAL
  | COLONCOLONLIDENT of (string)
  | COLONCOLON
  | COLON
  | CLASS
  | CHAR of (char)
  | BEGIN
  | BARRBRACKET
  | BARBAR
  | BAR
  | BANG
  | BACKQUOTE
  | ASSERT
  | AS
  | AND
  | AMPERSAND
  | AMPERAMPER

(* This exception is raised by the monolithic API functions. *)

exception Error

(* The monolithic API. *)

val use_file: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast_404.Parsetree.toplevel_phrase list)

val toplevel_phrase: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast_404.Parsetree.toplevel_phrase)

val parse_pattern: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast_404.Parsetree.pattern)

val parse_expression: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast_404.Parsetree.expression)

val parse_core_type: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast_404.Parsetree.core_type)

val interface: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast_404.Parsetree.signature)

val implementation: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast_404.Parsetree.structure)

module MenhirInterpreter : sig
  
  (* The incremental API. *)
  
  include MenhirLib.IncrementalEngine.INCREMENTAL_ENGINE
    with type token = token
  
end

(* The entry point(s) to the incremental API. *)

module Incremental : sig
  
  val use_file: Lexing.position -> (Ast_404.Parsetree.toplevel_phrase list) MenhirInterpreter.checkpoint
  
  val toplevel_phrase: Lexing.position -> (Ast_404.Parsetree.toplevel_phrase) MenhirInterpreter.checkpoint
  
  val parse_pattern: Lexing.position -> (Ast_404.Parsetree.pattern) MenhirInterpreter.checkpoint
  
  val parse_expression: Lexing.position -> (Ast_404.Parsetree.expression) MenhirInterpreter.checkpoint
  
  val parse_core_type: Lexing.position -> (Ast_404.Parsetree.core_type) MenhirInterpreter.checkpoint
  
  val interface: Lexing.position -> (Ast_404.Parsetree.signature) MenhirInterpreter.checkpoint
  
  val implementation: Lexing.position -> (Ast_404.Parsetree.structure) MenhirInterpreter.checkpoint
  
end

end = struct
#1 "reason_parser.ml"

(* This generated code requires the following version of MenhirLib: *)

let () =
  MenhirLib.StaticVersion.require_20170418

module MenhirBasics = struct
  
  exception Error = Parsing.Parse_error
  
  type token = 
    | WITH
    | WHILE
    | WHEN
    | VIRTUAL
    | VAL
    | UNDERSCORE
    | UIDENT of (string)
    | TYPE
    | TRY
    | TRUE
    | TO
    | TILDE
    | THEN
    | SWITCH
    | STRUCT
    | STRING of (string * string option)
    | STAR
    | SLASHGREATER
    | SIG
    | SHARPOP of (string)
    | SHARP
    | SEMISEMI
    | SEMI
    | RPAREN
    | REC
    | RBRACKET
    | RBRACE
    | QUOTE
    | QUESTION
    | PUB
    | PRI
    | PREFIXOP of (string)
    | PLUSEQ
    | PLUSDOT
    | PLUS
    | PERCENT
    | OR
    | OPTIONAL_NO_DEFAULT
    | OPEN
    | OF
    | OBJECT
    | NONREC
    | NEW
    | NATIVEINT of (nativeint)
    | MUTABLE
    | MODULE
    | MINUSGREATER
    | MINUSDOT
    | MINUS
    | LPAREN
    | LIDENTCOLONCOLON of (string)
    | LIDENT of (string)
    | LET
    | LESSSLASHIDENTGREATER of (string)
    | LESSSLASHGREATER
    | LESSSLASH
    | LESSMINUS
    | LESSIDENT of (string)
    | LESSGREATER
    | LESSDOTDOTGREATER
    | LESS
    | LBRACKETPERCENTPERCENT
    | LBRACKETPERCENT
    | LBRACKETLESS
    | LBRACKETGREATER
    | LBRACKETBAR
    | LBRACKETATATAT
    | LBRACKETATAT
    | LBRACKETAT
    | LBRACKET
    | LBRACELESS
    | LBRACE
    | LAZY
    | INT of (string * char option)
    | INITIALIZER
    | INHERIT
    | INFIXOP4 of (string)
    | INFIXOP3 of (string)
    | INFIXOP2 of (string)
    | INFIXOP1 of (string)
    | INFIXOP0 of (string)
    | INCLUDE
    | IN
    | IF
    | GREATERRBRACE
    | GREATER
    | FUNCTOR
    | FUNCTION
    | FUN
    | FOR
    | FLOAT of (string * char option)
    | FALSE
    | EXTERNAL
    | EXCEPTION
    | EQUALGREATER
    | EQUAL
    | EOL
    | EOF
    | END
    | ELSE
    | DOWNTO
    | DOTDOTDOT
    | DOTDOT
    | DOT
    | DONE
    | DO
    | CONSTRAINT
    | COMMENT of (string * Location.t)
    | COMMA
    | COLONGREATER
    | COLONEQUAL
    | COLONCOLONLIDENT of (string)
    | COLONCOLON
    | COLON
    | CLASS
    | CHAR of (char)
    | BEGIN
    | BARRBRACKET
    | BARBAR
    | BAR
    | BANG
    | BACKQUOTE
    | ASSERT
    | AS
    | AND
    | AMPERSAND
    | AMPERAMPER
  
end

include MenhirBasics

let _eRR =
  MenhirBasics.Error
  
open Migrate_parsetree.OCaml_404.Ast
open Syntax_util
open Location
open Asttypes
open Longident
open Parsetree
open Ast_helper
open Ast_mapper

(*
   TODO:
   - Remove all [open]s from the top of this file one by one and fix compilation
   failures that ensue by specifying the appropriate long identifiers. That
   will make the parser much easier to reason about.
   - Go back to trunk, do the same (remove [open]s, and fully specify long
   idents), to perform a clean diff.

*)

(**

   location.ml:
   ------------
   let mkloc txt loc = { txt ; loc }
   let rhs_loc n = {
     loc_start = Parsing.rhs_start_pos n;
     loc_end = Parsing.rhs_end_pos n;
     loc_ghost = false;
   }
   let symbol_rloc () = {
     loc_start = Parsing.symbol_start_pos ();
     loc_end = Parsing.symbol_end_pos ();
     loc_ghost = false;
   }

   let symbol_gloc () = {
     loc_start = Parsing.symbol_start_pos ();
     loc_end = Parsing.symbol_end_pos ();
     loc_ghost = true;
   }

   ast_helper.ml:
   ------------
   module Typ = struct
    val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
    let mk ?(loc = !default_loc) ?(attrs = []) d =
       {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
     ..
   end

   parse_tree.mli
   --------------
   and core_type = {
     ptyp_desc: core_type_desc;
     ptyp_loc: Location.t;
     ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
   }

   and core_type_desc =
     | Ptyp_any
           (*  _ *)
     | Ptyp_var of string
           (* 'a *)
     | Ptyp_arrow of label * core_type * core_type
           (* T1 -> T2       (label = "")
              ~l:T1 -> T2    (label = "l")
              ?l:T1 -> T2    (label = "?l")
            *)
     | Ptyp_tuple of core_type list
           (* T1 * ... * Tn   (n >= 2) *)

   reason_parser.mly
   ---------------
   In general:

                                          syntax variant          {pblah_desc: core_blah_desc
                                                                   pblah_loc: {txt, loc}
                                                                   pblah_attributes: ... }
                                         /              \            /       \
   val mkblah: ~loc -> ~attributes ->     core_blah_desc     ->      core_blah
   let mkblah = Blah.mk

*)


let dummy_loc () = {
  loc_start = Lexing.dummy_pos;
  loc_end = Lexing.dummy_pos;
  loc_ghost = false;
}

let mklocation loc_start loc_end = {
  loc_start = loc_start;
  loc_end = loc_end;
  loc_ghost = false;
}

let with_txt a txt = {
    a with txt=txt;
}

let make_real_loc loc = {
    loc with loc_ghost = false
}

let make_ghost_loc loc = {
    loc with loc_ghost = true
}

let ghloc ?(loc=dummy_loc ()) d = { txt = d; loc = (make_ghost_loc loc) }

(**
  * turn an object into a real
  *)
let make_real_exp exp = {
    exp with pexp_loc = make_real_loc exp.pexp_loc
}
let make_real_pat pat = {
    pat with ppat_loc = make_real_loc pat.ppat_loc
}
let make_real_cf cf = {
    cf with pcf_loc = make_real_loc cf.pcf_loc
}

(**
  * turn a object into ghost
  *)
let make_ghost_cf cf = {
    cf with pcf_loc = make_ghost_loc cf.pcf_loc
}
let make_ghost_exp exp = {
    exp with pexp_loc = make_ghost_loc exp.pexp_loc
}

let make_ghost_pat pat = {
    pat with ppat_loc = make_ghost_loc pat.ppat_loc
}

(**
  * change the location state to be a ghost location or real location
  *)
let set_loc_state is_ghost loc =
    if is_ghost then make_ghost_loc loc else make_real_loc loc

let mktyp ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Typ.mk ~loc d

let mkpat ?(attrs=[]) ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Pat.mk ~loc ~attrs d

let mkexp ?(attrs=[]) ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Exp.mk ~loc ~attrs d

let mkmty ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Mty.mk ~loc d

let mksig ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Sig.mk ~loc d

let mkmod ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Mod.mk ~loc d

let mkstr ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Str.mk ~loc d

let mkclass ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cl.mk ~loc d

let mkcty ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cty.mk ~loc d

let mkctf ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Ctf.mk ~loc d

(**
  Make a core_type from a as_loc(LIDENT).
  Useful for record type punning.
  type props = {width: int, height: int};
  type state = {nbrOfClicks: int};
  type component = {props, state};
*)
let mkct lbl =
  let lident = Lident lbl.txt in
  let ttype = Ptyp_constr({txt = lident; loc = lbl.loc}, []) in
  {ptyp_desc = ttype; ptyp_loc = lbl.loc; ptyp_attributes = []}

let mkcf ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cf.mk ~loc d

let simple_ghost_text_attr ?(loc=dummy_loc ()) txt =
  let loc = set_loc_state true loc in
  [({txt; loc}, PStr [])]

let mkExplicitArityTuplePat ?(loc=dummy_loc ()) pat =
  (* Tell OCaml type system that what this tuple construction represents is
     not actually a tuple, and should represent several constructor
     arguments.  This allows the syntax the ability to distinguish between:

     X (10, 20)  -- One argument constructor
     X 10 20     -- Multi argument constructor
  *)
  mkpat
    ~loc
    ~attrs:(simple_ghost_text_attr ~loc "explicit_arity")
    pat

let mkExplicitArityTupleExp ?(loc=dummy_loc ()) exp =
  mkexp
    ~loc
    ~attrs:(simple_ghost_text_attr ~loc "explicit_arity")
    exp

let is_pattern_list_single_any = function
  | [{ppat_desc=Ppat_any; ppat_attributes=[]} as onlyItem] -> Some onlyItem
  | _ -> None

let set_structure_item_location x loc = {x with pstr_loc = loc};;

let mkoperator_loc name loc =
  Exp.mk ~loc (Pexp_ident(mkloc (Lident name) loc))

let mkoperator name pos =
  mkoperator_loc name (rhs_loc pos)

(*
  Ghost expressions and patterns:
  expressions and patterns that do not appear explicitly in the
  source file they have the loc_ghost flag set to true.
  Then the profiler will not try to instrument them and the
  -annot option will not try to display their type.

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  How to tell whether your location must be ghost:
  A location corresponds to a range of characters in the source file.
  If the location contains a piece of code that is syntactically
  valid (according to the documentation), and corresponds to the
  AST node, then the location must be real; in all other cases,
  it must be ghost.

  jordwalke: Noticed that ghost expressions are often used when inserting
   additional AST nodes from a parse rule. Either an extra wrapping one, or an
   additional inner node. This is consistent with the above description, I
   believe.
*)


let ghunit ?(loc=dummy_loc ()) () =
  mkexp ~ghost:true ~loc (Pexp_construct (mknoloc (Lident "()"), None))

let mkinfixop arg1 op arg2 =
  mkexp(Pexp_apply(op, [Nolabel, arg1; Nolabel, arg2]))

let mkinfix arg1 name arg2 =
  mkinfixop arg1 (mkoperator name 2) arg2

let neg_string f =
  if String.length f > 0 && f.[0] = '-'
  then String.sub f 1 (String.length f - 1)
  else "-" ^ f

let mkuminus name arg =
  match name, arg.pexp_desc with
  | "-", Pexp_constant(Pconst_integer (n,m)) ->
      mkexp(Pexp_constant(Pconst_integer(neg_string n,m)))
  | ("-" | "-."), Pexp_constant(Pconst_float (f, m)) ->
      mkexp(Pexp_constant(Pconst_float(neg_string f, m)))
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, [Nolabel, arg]))

let mkFunctorThatReturns functorArgs returns =
  List.fold_left (
    fun acc (n, t) -> mkmod (Pmod_functor(n, t, acc))
  ) returns functorArgs

let mkuplus name arg =
  let desc = arg.pexp_desc in
  match name, desc with
  | "+", Pexp_constant(Pconst_integer _)
  | ("+" | "+."), Pexp_constant(Pconst_float _) -> mkexp desc
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, [Nolabel, arg]))

let mkexp_cons consloc args loc =
  mkexp ~loc (Pexp_construct(mkloc (Lident "::") consloc, Some args))

let mkexp_constructor_unit consloc loc =
  mkexp ~loc (Pexp_construct(mkloc (Lident "()") consloc, None))

let ghexp_cons consloc args loc =
  mkexp ~ghost:true ~loc (Pexp_construct(mkloc (Lident "::") loc, Some args))

let mkpat_cons consloc args loc =
  mkpat ~loc (Ppat_construct(mkloc (Lident "::") loc, Some args))

let ghpat_cons consloc args loc =
  mkpat ~ghost:true ~loc (Ppat_construct(mkloc (Lident "::") loc, Some args))

let simple_pattern_list_to_tuple ?(loc=dummy_loc ()) lst =
  match lst with
    | [] -> assert false
    | _ -> mkpat ~loc (Ppat_tuple (List.rev lst))

let mktailexp_extension loc seq ext_opt =
  let rec handle_seq = function
    [] ->
      let base_case = match ext_opt with
        | Some ext ->
          ext
        | None ->
          let loc = make_ghost_loc loc in
          let nil = { txt = Lident "[]"; loc } in
          Exp.mk ~loc (Pexp_construct (nil, None)) in
      base_case
  | e1 :: el ->
      let exp_el = handle_seq el in
      let loc = mklocation e1.pexp_loc.loc_start exp_el.pexp_loc.loc_end in
      let arg = mkexp ~ghost:true ~loc (Pexp_tuple [e1; exp_el]) in
      ghexp_cons loc arg loc in
  handle_seq seq

let mktailpat_extension loc seq ext_opt =
  let rec handle_seq = function
    [] ->
      let base_case = match ext_opt with
        | Some ext ->
          ext
        | None ->
          let loc = make_ghost_loc loc in
          let nil = { txt = Lident "[]"; loc } in
          mkpat ~loc (Ppat_construct (nil, None)) in
      base_case
  | p1 :: pl ->
      let pat_pl = handle_seq pl in
      let loc = mklocation p1.ppat_loc.loc_start pat_pl.ppat_loc.loc_end in
      let arg = mkpat ~ghost:true ~loc (Ppat_tuple [p1; pat_pl]) in
      ghpat_cons loc arg loc in
  handle_seq seq

let makeFrag loc body =
  let attribute = ({txt = "JSX"; loc = loc}, PStr []) in
  { body with pexp_attributes = [attribute] @ body.pexp_attributes }


(* Applies attributes to the structure item, not the expression itself. Makes
 * structure item have same location as expression. *)
let mkstrexp e attrs =
  { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }

let ghexp_constraint loc e (t1, t2) =
  match t1, t2 with
  | Some t, None -> mkexp ~ghost:true ~loc (Pexp_constraint(e, t))
  | _, Some t -> mkexp ~ghost:true ~loc (Pexp_coerce(e, t1, t))
  | None, None -> assert false

let array_function ?(loc=dummy_loc()) str name =
  ghloc ~loc (Ldot(Lident str, (if !Clflags.fast then "unsafe_" ^ name else name)))

let syntax_error_str loc msg =
  if !Reason_config.recoverable then
    Str.mk ~loc:loc (Pstr_extension (Syntax_util.syntax_error_extension_node loc msg, []))
  else
    raise(Syntaxerr.Error(Syntaxerr.Other loc))

let syntax_error () =
  raise Syntaxerr.Escape_error

let syntax_error_exp loc msg =
  if !Reason_config.recoverable then
    Exp.mk ~loc (Pexp_extension (Syntax_util.syntax_error_extension_node loc msg))
  else
    syntax_error ()

let unclosed opening closing =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(opening.loc, opening.txt,
                                           closing.loc, closing.txt)))

let unclosed_extension closing =
  Syntax_util.syntax_error_extension_node closing.loc ("Expecting \"" ^ closing.txt ^ "\"")

let unclosed_mod opening closing =
  if !Reason_config.recoverable then
    mkmod(Pmod_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_cl opening closing =
  if !Reason_config.recoverable then
    mkclass(Pcl_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_mty opening closing =
  if !Reason_config.recoverable then
    mkmty(Pmty_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_cty opening closing =
  if !Reason_config.recoverable then
    mkcty(Pcty_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_exp opening closing =
  if !Reason_config.recoverable then
    mkexp(Pexp_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_pat opening closing =
  if !Reason_config.recoverable then
    mkpat(Ppat_extension (unclosed_extension closing))
  else
    unclosed opening closing

let expecting nonterm =
    raise Syntaxerr.(Error(Expecting(nonterm.loc, nonterm.txt)))

let expecting_pat nonterm =
  if !Reason_config.recoverable then
    mkpat(Ppat_extension (Syntax_util.syntax_error_extension_node nonterm.loc ("Expecting " ^ nonterm.txt)))
  else
    expecting nonterm

let not_expecting start_pos end_pos nonterm =
    raise Syntaxerr.(Error(Not_expecting(mklocation start_pos end_pos, nonterm)))

let bigarray_function ?(loc=dummy_loc()) str name =
  ghloc ~loc (Ldot(Ldot(Lident "Bigarray", str), name))

let bigarray_untuplify = function
    { pexp_desc = Pexp_tuple explist; pexp_loc = _ } -> explist
  | exp -> [exp]

let bigarray_get ?(loc=dummy_loc()) arr arg =
  let get = if !Clflags.fast then "unsafe_get" else "get" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array1" get)),
                       [Nolabel, arr; Nolabel, c1]))
  | [c1;c2] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array2" get)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array3" get)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, c3]))
  | coords ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Genarray" "get")),
                       [Nolabel, arr; Nolabel, mkexp ~ghost:true ~loc (Pexp_array coords)]))

let bigarray_set ?(loc=dummy_loc()) arr arg newval =
  let set = if !Clflags.fast then "unsafe_set" else "set" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array1" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, newval]))
  | [c1;c2] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array2" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, newval]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array3" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, c3; Nolabel, newval]))
  | coords ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Genarray" "set")),
                       [Nolabel, arr;
                        Nolabel, mkexp ~ghost:true ~loc (Pexp_array coords);
                        Nolabel, newval]))

let lapply p1 p2 start_pos end_pos =
  if !Clflags.applicative_functors
  then Lapply(p1, p2)
  else raise (Syntaxerr.Error(Syntaxerr.Applicative_path (mklocation start_pos end_pos)))

let exp_of_label label =
  mkexp ~loc:label.loc (Pexp_ident {label with txt=Lident(Longident.last label.txt)})

let pat_of_label label =
  mkpat ~loc:label.loc (Ppat_var {label with txt=(Longident.last label.txt)})

let check_variable vl loc v =
  if List.mem v vl then
    raise Syntaxerr.(Error(Variable_in_scope(loc,v)))

let varify_constructors var_names t =
  let rec loop t =
    let desc =
      match t.ptyp_desc with
      | Ptyp_any -> Ptyp_any
      | Ptyp_var x ->
          check_variable var_names t.ptyp_loc x;
          Ptyp_var x
      | Ptyp_arrow (label,core_type,core_type') ->
          Ptyp_arrow(label, loop core_type, loop core_type')
      | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
      | Ptyp_constr( { txt = Lident s }, []) when List.mem s var_names ->
          Ptyp_var s
      | Ptyp_constr(longident, lst) ->
          Ptyp_constr(longident, List.map loop lst)
      | Ptyp_object (lst, o) ->
          Ptyp_object
            (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)
      | Ptyp_class (longident, lst) ->
          Ptyp_class (longident, List.map loop lst)
      | Ptyp_alias(core_type, string) ->
          check_variable var_names t.ptyp_loc string;
          Ptyp_alias(loop core_type, string)
      | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
          Ptyp_variant(List.map loop_row_field row_field_list,
                       flag, lbl_lst_option)
      | Ptyp_poly(string_lst, core_type) ->
          List.iter (check_variable var_names t.ptyp_loc) string_lst;
          Ptyp_poly(string_lst, loop core_type)
      | Ptyp_package(longident,lst) ->
          Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
      | Ptyp_extension (s, arg) ->
          Ptyp_extension (s, arg)
    in
    {t with ptyp_desc = desc}
  and loop_row_field  =
    function
      | Rtag(label,attrs,flag,lst) ->
          Rtag(label,attrs,flag,List.map loop lst)
      | Rinherit t ->
          Rinherit (loop t)
  in
  loop t

let pexp_newtypes ?loc newtypes exp =
  List.fold_right (fun newtype exp -> mkexp ?loc (Pexp_newtype (newtype, exp)))
    newtypes exp

(**
  I believe that wrap_type_annotation will automatically generate the type
  arguments (type a) (type b) based on what was listed before the dot in a
  polymorphic type annotation that uses locally abstract types.
 *)
let wrap_type_annotation newtypes core_type body =
  let exp = mkexp(Pexp_constraint(body,core_type)) in
  let exp = pexp_newtypes newtypes exp in
  let typ = mktyp ~ghost:true (Ptyp_poly(newtypes,varify_constructors newtypes core_type)) in
  (exp, typ)


let struct_item_extension (ext_attrs, ext_id) structure_item =
  mkstr ~ghost:true (Pstr_extension ((ext_id, PStr [structure_item]), ext_attrs))

let extension_expression (ext_attrs, ext_id) item_expr =
  mkexp ~ghost:true ~attrs:ext_attrs (Pexp_extension (ext_id, PStr [mkstrexp item_expr []]))

(* There's no more need for these functions - this was for the following:
 *
 *     fun % ext [@foo] arg => arg;
 *
 *   Becoming
 *
 *     [%ext  (fun arg => arg) [@foo]]
 *
 *   Which we no longer support.
 *)
(* Applies the attributes to the body, then wraps entire thing in an extension
 * expression, whose payload consists of a single structure item that is body
 *)
(* let wrap_exp_attrs body (ext, attrs) = *)
(*   (* todo: keep exact location for the entire attribute *) *)
(*   let body = {body with pexp_attributes = attrs @ body.pexp_attributes} in *)
(*   match ext with *)
(*   | None -> body *)
(*   | Some id -> mkexp ~ghost:true (Pexp_extension (id, PStr [mkstrexp body []])) *)

(* Why not just mkexp with the right attributes in the first place? *)
(* let mkexp_attrs d attrs = *)
(*   wrap_exp_attrs (mkexp d) attrs *)

let mkcf_attrs ?(loc=dummy_loc()) d attrs =
  Cf.mk ~loc ~attrs d

let mkctf_attrs d attrs =
  Ctf.mk ~attrs d

type let_binding =
  { lb_pattern: pattern;
    lb_expression: expression;
    (* The meaning of lb_leading_attributes and lbs_extension are dependent on
     * the context of the let binding (module/expression etc) *)
    lb_attributes: attributes;
    (* lb_docs: docs Lazy.t; *)
    (* lb_text: text Lazy.t; *)
    lb_loc: Location.t; }

type let_bindings =
  { lbs_bindings: let_binding list;
    lbs_rec: rec_flag;
    lbs_extension: string Asttypes.loc option;
    (* In Reason, we use this field to represent
       extension attributes attached to the extension on a series of "let/and"
       bindings As in: let [@extAttrs ] [%id] [@attribute] x = ...; It only
       makes sense to have [lbs_attributes] when there is an [lbs_extension].
     *)
    lbs_attributes: attributes;
    lbs_loc: Location.t }

let mklb (p, e) attrs loc =
  { lb_pattern = p;
    lb_expression = e;
    (* Only some individual let bindings are allowed to have attributes
     * depending on the context *)
    lb_attributes = attrs;
    lb_loc = loc; }

let mklbs (extAttrs, extId) rf lb loc =
  { lbs_bindings = [lb];
    lbs_rec = rf;
    lbs_extension = extId ;
    lbs_attributes = extAttrs;
    lbs_loc = loc; }

let addlb lbs lb =
  { lbs with lbs_bindings = lb :: lbs.lbs_bindings }

let val_of_let_bindings lbs =
  let bindings =
    List.map
      (fun lb ->
         Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
           (* ~docs:(Lazy.force lb.lb_docs) *)
           (* ~text:(Lazy.force lb.lb_text) *)
           lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
  let str = mkstr(Pstr_value(lbs.lbs_rec, List.rev bindings)) in
  (* Note that for value bindings, when there's an extension, the
   * lbs_attributes are attributes on the extension *)
  match (lbs.lbs_extension) with
    | None -> str
    | Some ext_id -> struct_item_extension (lbs.lbs_attributes, ext_id) str

let expr_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         (* Individual let bindings in an *expression* can't have item attributes. *)
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
  (* The location of this expression unfortunately includes the entire rule,
   * which will include any preceeding extensions. *)
  let item_expr = mkexp (Pexp_let(lbs.lbs_rec, List.rev bindings, body)) in
  (* Note that for let expression bindings, when there's an extension, the
   * lbs_attributes are attributes on the entire [let ..in x] expression. *)
  match lbs.lbs_extension with
    | None -> item_expr
    | Some ext_id -> extension_expression (lbs.lbs_attributes, ext_id) item_expr

let class_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    if lbs.lbs_extension <> None then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "extension")));
    if lbs.lbs_attributes <> [] then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "attributes")));
    mkclass(Pcl_let (lbs.lbs_rec, List.rev bindings, body))

(*
 * arity_conflict_resolving_mapper is triggered when both "implicit_arity" "explicit_arity"
 * are in the attribtues. In that case we have to remove "explicit_arity"
 *
 * However, if we simply remove explicit_arity, we would end up with a
 * wrapping tuple which has only one component (inner tuple).
 * This is against the invariance where tuples must have 2+ components.
 * Therefore, in the case we have to remove explicit_arity, we also need to
 * unwrap the tuple to expose the inner tuple directly.
 *
 *)
let arity_conflict_resolving_mapper =
{ default_mapper with
  expr = begin fun mapper expr ->
    match expr with
      | {pexp_desc=Pexp_construct(lid, args);
         pexp_loc;
         pexp_attributes} when attributes_conflicted "implicit_arity" "explicit_arity" pexp_attributes ->
         let new_args =
           match args with
             | Some {pexp_desc = Pexp_tuple [sp]} -> Some sp
             | _ -> args in
         default_mapper.expr mapper
         {pexp_desc=Pexp_construct(lid, new_args); pexp_loc; pexp_attributes=
          normalized_attributes "explicit_arity" pexp_attributes}
      | x -> default_mapper.expr mapper x
  end;
  pat = begin fun mapper pattern ->
    match pattern with
      | {ppat_desc=Ppat_construct(lid, args);
         ppat_loc;
         ppat_attributes} when attributes_conflicted "implicit_arity" "explicit_arity" ppat_attributes ->
         let new_args =
           match args with
             | Some {ppat_desc = Ppat_tuple [sp]} -> Some sp
             | _ -> args in
         default_mapper.pat mapper
         {ppat_desc=Ppat_construct(lid, new_args); ppat_loc; ppat_attributes=
          normalized_attributes "explicit_arity" ppat_attributes}
      | x -> default_mapper.pat mapper x
  end;
}

(* NB: making this a function might have parse-time performance penalties *)
let default_mapper_chain () =
  let chain = [default_mapper; arity_conflict_resolving_mapper;
               reason_to_ml_swap_operator_mapper;
               unescape_stars_slashes_mapper]
  in
  if !Reason_config.add_printers then chain @ [create_auto_printer_mapper]
  else chain

let rec string_of_longident = function
    | Lident s -> s
    | Ldot(longPrefix, s) ->
        s
    | Lapply (y,s) -> string_of_longident s

let built_in_explicit_arity_constructors = ["Some"; "Assert_failure"; "Match_failure"]

let jsx_component module_name attrs children loc =
  let firstPart = (List.hd (Longident.flatten module_name)) in
  let lident = if String.get firstPart 0 != '_' && firstPart = String.capitalize firstPart then
    (* firstPart will be non-empty so the 0th access is fine. Modules can't start with underscore *)
    Ldot(module_name, "createElement")
  else
    Lident firstPart
  in
  let ident = mkloc lident loc in
  let body = mkexp(Pexp_apply(mkexp(Pexp_ident ident) ~loc, attrs @ children)) ~loc in
  let attribute = ({txt = "JSX"; loc = loc}, PStr []) in
  { body with pexp_attributes = attribute :: body.pexp_attributes }

let ensureTagsAreEqual startTag endTag loc =
  if startTag <> endTag then
     let startTag = (String.concat "" (Longident.flatten startTag)) in
     let endTag = (String.concat "" (Longident.flatten endTag)) in
     let _ = Location.raise_errorf ~loc "Syntax error: Start tag <%s> does not match end tag </%s>" startTag endTag in
     ()

type object_record =
  | Object_open
  | Object_closed
  | Record

type core_type_object =
  | Core_type of core_type
  | Record_type of label_declaration list

let only_core_type t loc =
  match t with
  | Core_type ct -> ct
  | Record_type _ -> Location.raise_errorf ~loc "Record type is not allowed"

let only_labels l =
  let rec loop label_declarations result =
    match label_declarations with
    | hd :: tail ->
      let (l, a) = hd in
      if (List.length a > 0) then
        syntax_error ()
      else
        loop tail (result @ [l] )
    | [] -> result
  in
  loop l []


module Tables = struct
  
  include MenhirBasics
  
  let token2terminal : token -> int =
    fun _tok ->
      match _tok with
      | AMPERAMPER ->
          127
      | AMPERSAND ->
          126
      | AND ->
          125
      | AS ->
          124
      | ASSERT ->
          123
      | BACKQUOTE ->
          122
      | BANG ->
          121
      | BAR ->
          120
      | BARBAR ->
          119
      | BARRBRACKET ->
          118
      | BEGIN ->
          117
      | CHAR _ ->
          116
      | CLASS ->
          115
      | COLON ->
          114
      | COLONCOLON ->
          113
      | COLONCOLONLIDENT _ ->
          112
      | COLONEQUAL ->
          111
      | COLONGREATER ->
          110
      | COMMA ->
          109
      | COMMENT _ ->
          108
      | CONSTRAINT ->
          107
      | DO ->
          106
      | DONE ->
          105
      | DOT ->
          104
      | DOTDOT ->
          103
      | DOTDOTDOT ->
          102
      | DOWNTO ->
          101
      | ELSE ->
          100
      | END ->
          99
      | EOF ->
          98
      | EOL ->
          97
      | EQUAL ->
          96
      | EQUALGREATER ->
          95
      | EXCEPTION ->
          94
      | EXTERNAL ->
          93
      | FALSE ->
          92
      | FLOAT _ ->
          91
      | FOR ->
          90
      | FUN ->
          89
      | FUNCTION ->
          88
      | FUNCTOR ->
          87
      | GREATER ->
          86
      | GREATERRBRACE ->
          85
      | IF ->
          84
      | IN ->
          83
      | INCLUDE ->
          82
      | INFIXOP0 _ ->
          81
      | INFIXOP1 _ ->
          80
      | INFIXOP2 _ ->
          79
      | INFIXOP3 _ ->
          78
      | INFIXOP4 _ ->
          77
      | INHERIT ->
          76
      | INITIALIZER ->
          75
      | INT _ ->
          74
      | LAZY ->
          73
      | LBRACE ->
          72
      | LBRACELESS ->
          71
      | LBRACKET ->
          70
      | LBRACKETAT ->
          69
      | LBRACKETATAT ->
          68
      | LBRACKETATATAT ->
          67
      | LBRACKETBAR ->
          66
      | LBRACKETGREATER ->
          65
      | LBRACKETLESS ->
          64
      | LBRACKETPERCENT ->
          63
      | LBRACKETPERCENTPERCENT ->
          62
      | LESS ->
          61
      | LESSDOTDOTGREATER ->
          60
      | LESSGREATER ->
          59
      | LESSIDENT _ ->
          58
      | LESSMINUS ->
          57
      | LESSSLASH ->
          56
      | LESSSLASHGREATER ->
          55
      | LESSSLASHIDENTGREATER _ ->
          54
      | LET ->
          53
      | LIDENT _ ->
          52
      | LIDENTCOLONCOLON _ ->
          51
      | LPAREN ->
          50
      | MINUS ->
          49
      | MINUSDOT ->
          48
      | MINUSGREATER ->
          47
      | MODULE ->
          46
      | MUTABLE ->
          45
      | NATIVEINT _ ->
          44
      | NEW ->
          43
      | NONREC ->
          42
      | OBJECT ->
          41
      | OF ->
          40
      | OPEN ->
          39
      | OPTIONAL_NO_DEFAULT ->
          38
      | OR ->
          37
      | PERCENT ->
          36
      | PLUS ->
          35
      | PLUSDOT ->
          34
      | PLUSEQ ->
          33
      | PREFIXOP _ ->
          32
      | PRI ->
          31
      | PUB ->
          30
      | QUESTION ->
          29
      | QUOTE ->
          28
      | RBRACE ->
          27
      | RBRACKET ->
          26
      | REC ->
          25
      | RPAREN ->
          24
      | SEMI ->
          23
      | SEMISEMI ->
          22
      | SHARP ->
          21
      | SHARPOP _ ->
          20
      | SIG ->
          19
      | SLASHGREATER ->
          18
      | STAR ->
          17
      | STRING _ ->
          16
      | STRUCT ->
          15
      | SWITCH ->
          14
      | THEN ->
          13
      | TILDE ->
          12
      | TO ->
          11
      | TRUE ->
          10
      | TRY ->
          9
      | TYPE ->
          8
      | UIDENT _ ->
          7
      | UNDERSCORE ->
          6
      | VAL ->
          5
      | VIRTUAL ->
          4
      | WHEN ->
          3
      | WHILE ->
          2
      | WITH ->
          1
  
  and error_terminal =
    0
  
  and token2value : token -> Obj.t =
    fun _tok ->
      match _tok with
      | AMPERAMPER ->
          Obj.repr ()
      | AMPERSAND ->
          Obj.repr ()
      | AND ->
          Obj.repr ()
      | AS ->
          Obj.repr ()
      | ASSERT ->
          Obj.repr ()
      | BACKQUOTE ->
          Obj.repr ()
      | BANG ->
          Obj.repr ()
      | BAR ->
          Obj.repr ()
      | BARBAR ->
          Obj.repr ()
      | BARRBRACKET ->
          Obj.repr ()
      | BEGIN ->
          Obj.repr ()
      | CHAR _v ->
          Obj.repr _v
      | CLASS ->
          Obj.repr ()
      | COLON ->
          Obj.repr ()
      | COLONCOLON ->
          Obj.repr ()
      | COLONCOLONLIDENT _v ->
          Obj.repr _v
      | COLONEQUAL ->
          Obj.repr ()
      | COLONGREATER ->
          Obj.repr ()
      | COMMA ->
          Obj.repr ()
      | COMMENT _v ->
          Obj.repr _v
      | CONSTRAINT ->
          Obj.repr ()
      | DO ->
          Obj.repr ()
      | DONE ->
          Obj.repr ()
      | DOT ->
          Obj.repr ()
      | DOTDOT ->
          Obj.repr ()
      | DOTDOTDOT ->
          Obj.repr ()
      | DOWNTO ->
          Obj.repr ()
      | ELSE ->
          Obj.repr ()
      | END ->
          Obj.repr ()
      | EOF ->
          Obj.repr ()
      | EOL ->
          Obj.repr ()
      | EQUAL ->
          Obj.repr ()
      | EQUALGREATER ->
          Obj.repr ()
      | EXCEPTION ->
          Obj.repr ()
      | EXTERNAL ->
          Obj.repr ()
      | FALSE ->
          Obj.repr ()
      | FLOAT _v ->
          Obj.repr _v
      | FOR ->
          Obj.repr ()
      | FUN ->
          Obj.repr ()
      | FUNCTION ->
          Obj.repr ()
      | FUNCTOR ->
          Obj.repr ()
      | GREATER ->
          Obj.repr ()
      | GREATERRBRACE ->
          Obj.repr ()
      | IF ->
          Obj.repr ()
      | IN ->
          Obj.repr ()
      | INCLUDE ->
          Obj.repr ()
      | INFIXOP0 _v ->
          Obj.repr _v
      | INFIXOP1 _v ->
          Obj.repr _v
      | INFIXOP2 _v ->
          Obj.repr _v
      | INFIXOP3 _v ->
          Obj.repr _v
      | INFIXOP4 _v ->
          Obj.repr _v
      | INHERIT ->
          Obj.repr ()
      | INITIALIZER ->
          Obj.repr ()
      | INT _v ->
          Obj.repr _v
      | LAZY ->
          Obj.repr ()
      | LBRACE ->
          Obj.repr ()
      | LBRACELESS ->
          Obj.repr ()
      | LBRACKET ->
          Obj.repr ()
      | LBRACKETAT ->
          Obj.repr ()
      | LBRACKETATAT ->
          Obj.repr ()
      | LBRACKETATATAT ->
          Obj.repr ()
      | LBRACKETBAR ->
          Obj.repr ()
      | LBRACKETGREATER ->
          Obj.repr ()
      | LBRACKETLESS ->
          Obj.repr ()
      | LBRACKETPERCENT ->
          Obj.repr ()
      | LBRACKETPERCENTPERCENT ->
          Obj.repr ()
      | LESS ->
          Obj.repr ()
      | LESSDOTDOTGREATER ->
          Obj.repr ()
      | LESSGREATER ->
          Obj.repr ()
      | LESSIDENT _v ->
          Obj.repr _v
      | LESSMINUS ->
          Obj.repr ()
      | LESSSLASH ->
          Obj.repr ()
      | LESSSLASHGREATER ->
          Obj.repr ()
      | LESSSLASHIDENTGREATER _v ->
          Obj.repr _v
      | LET ->
          Obj.repr ()
      | LIDENT _v ->
          Obj.repr _v
      | LIDENTCOLONCOLON _v ->
          Obj.repr _v
      | LPAREN ->
          Obj.repr ()
      | MINUS ->
          Obj.repr ()
      | MINUSDOT ->
          Obj.repr ()
      | MINUSGREATER ->
          Obj.repr ()
      | MODULE ->
          Obj.repr ()
      | MUTABLE ->
          Obj.repr ()
      | NATIVEINT _v ->
          Obj.repr _v
      | NEW ->
          Obj.repr ()
      | NONREC ->
          Obj.repr ()
      | OBJECT ->
          Obj.repr ()
      | OF ->
          Obj.repr ()
      | OPEN ->
          Obj.repr ()
      | OPTIONAL_NO_DEFAULT ->
          Obj.repr ()
      | OR ->
          Obj.repr ()
      | PERCENT ->
          Obj.repr ()
      | PLUS ->
          Obj.repr ()
      | PLUSDOT ->
          Obj.repr ()
      | PLUSEQ ->
          Obj.repr ()
      | PREFIXOP _v ->
          Obj.repr _v
      | PRI ->
          Obj.repr ()
      | PUB ->
          Obj.repr ()
      | QUESTION ->
          Obj.repr ()
      | QUOTE ->
          Obj.repr ()
      | RBRACE ->
          Obj.repr ()
      | RBRACKET ->
          Obj.repr ()
      | REC ->
          Obj.repr ()
      | RPAREN ->
          Obj.repr ()
      | SEMI ->
          Obj.repr ()
      | SEMISEMI ->
          Obj.repr ()
      | SHARP ->
          Obj.repr ()
      | SHARPOP _v ->
          Obj.repr _v
      | SIG ->
          Obj.repr ()
      | SLASHGREATER ->
          Obj.repr ()
      | STAR ->
          Obj.repr ()
      | STRING _v ->
          Obj.repr _v
      | STRUCT ->
          Obj.repr ()
      | SWITCH ->
          Obj.repr ()
      | THEN ->
          Obj.repr ()
      | TILDE ->
          Obj.repr ()
      | TO ->
          Obj.repr ()
      | TRUE ->
          Obj.repr ()
      | TRY ->
          Obj.repr ()
      | TYPE ->
          Obj.repr ()
      | UIDENT _v ->
          Obj.repr _v
      | UNDERSCORE ->
          Obj.repr ()
      | VAL ->
          Obj.repr ()
      | VIRTUAL ->
          Obj.repr ()
      | WHEN ->
          Obj.repr ()
      | WHILE ->
          Obj.repr ()
      | WITH ->
          Obj.repr ()
  
  and default_reduction =
    (16, "\000\000\000\000\000\000\002X\001~\001x\000\000\000\000\001e\000\000\000\000\002Y\001f\000\000\000\002X\000\000\003i\000\000\000\000\000\000\000\000\000\000\003+\003*\003)\003(\003'\002\003&\003%\003$\003#\003\"\003\021\003!\003 \003\031\003\030\003\029\003\028\003\027\003\026\003\025\003\024\003\023\003\022\002\003\020\003\019\003\018\003\017\003\016\003\015\003\014\003\r\003\012\003\011\003\n\003\t\003\b\003\007\003\006\003\005\003\004\003\003\003\002\003\001\003\000\002\002\002\002\000\000\000\000\001T\000\000\000\000\002v\000\000\000\000\000\156\000\000\001\001\000\155\000\000\000\158\000\000\000\157\000\000\000\000\000\000\159\000\000\000\000\000\000\002T\000\000\000\000\000\000\000\000\002R\000\000\000\000\000\000\002S\002\000\000\000\000\000\143\000\000\000\000\001e\000\000\000\000\001f\000\142\000\000\000\141\000\000\000\000\000\143\000\000\000\000\000\000\000\142\000\000\001\001\000\141\000\000\000\000\000\000\000\000\000\153\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000\000\003^\000\000\002\153\000\000\000\000\000\150\000\000\000\000\000\000\002w\002f\000\000\002y\000\000\000\000\000\000\000\000\001~\000\000\000\000\000\000\000\000\001x\000\000\000\000\000\000\000\002\138\002\132\001|\000\000\003i\000\000\000\000\000\000\000\000\000\000\000\000\001I\001H\003C\003B\000\000\002\146\000\000\000\000\002\147\002\141\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\022\000\000\001\027\000\000\000\000\003_\000\000\002\002\000\000\002\002\000\000\001\022\000\000\003^\001\027\000\000\000\000\003_\001|\002~\002\135\000\000\002\002\000\000\000\000\001)\000\000\000\000\000\000\001+\001*\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002g\000\144\002\000\000\000\151\000\000\000\000\000\152\002i\002h\000\000\002\000\145\002\000\000\002\000\000\002\150\000\000\000\000\000\000\002q\002o\000\154\002L\002p\002l\002k\000\000\000\139\002n\001\152\001\151\000\000\000\000\000\000\002K\002J\000\000\000\000\000;\001J\000\000\000\000\001K\002I\003D\000\000\001W\003E\002\000\000\000\150\000\000\000\000\000\149\000\000\000\000\000\000\000\147\000\000\000\146\000\000\000\000\000\000\000\148\000\000\002w\000\000\002y\000\000\002|\000\000\001\001\000\000\002x\000\000\002{\000\000\000\000\000\000\002z\000\144\000\145\000\000\002q\002o\000\154\002L\002p\000\000\000\000\000\000\000\000\000\000\000\000\002l\002k\000\000\000\000\000\000\000\000\003+\003*\003)\003(\003'\002\003&\003%\003$\003#\003\"\003\021\003!\003 \003\031\003\030\003\029\003\028\003\027\003\026\003\025\003\024\003\023\003\022\002\003\020\003\019\003\018\003\017\003\016\003\015\003\014\003\r\003\012\003\011\003\n\003\t\003\b\003\007\003\006\003\005\003\004\003\003\003\002\003\001\003\000\002\002\002\002\000\000\000\000\001T\001\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001v\001y\001}\001w\000\000\000\003k\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\002\157\000\000\000\000\002\002\156\000\000\000\000\000\000\000\000\002\002\000\000\000\000\000\000\001)\000\000\000\000\001+\001*\000\000\000\000\000\000\002d\002c\002\137\000\000\002\148\002\139\000\000\000\000\001{\000\000\001\000\000\000\000\001\000\000\001\029\001\028\000\000\000\000\000\000\002\155\002\001\002\002\000\000\000\000\000\000\000\000\001v\002\133\002\131\002\130\002\129\002\128\000\000\002\149\001y\001}\000\000\001w\000\000\002g\001\020\001\021\000\000\000\000\000\001\024\002\000\000\000\000\000\000\001\026\000\000\000\000\002Y\002\002\001,\001\025\002C\002B\002\000\000\000\000\002\002\002A\002\145\002\142\002\127\002\143\002\144\000\000\000\000\000\000\000\000\000\000\000\000\002\134\002\136\000\000\003j\000\000\000\001$\000\000\000\000\001{\000\000\002\159\000\000\001\031\001\030\000\000\000\000\000\000\000\000\000\000\000\002\002\002?\000\000\000\000\000\000\000\000\001\029\001\028\000\000\000\000\000\000\001$\000\000\000\000\000\000\001\020\001\021\000\000\000\000\000\001\024\002\000\000\000\000\000\000\001\026\000\000\002\002\001,\001\025\002C\002B\002\000\000\000\000\002\002\002A\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003j\000\002\000\000\000\000\000\000\000\000\002\002\002?\002\002@\000\000\001%\001#\000\000\001(\002n\001\152\001\151\000\000\000\000\000\000\002K\002J\000\000\000\000\000;\000\000\001'\001&\002I\000\002\000\000\001%\001#\000\000\001(\000\000\001'\001&\000\000\000\000\000\000\000\001\031\001\030\001!\000\000\000\000\000\000\000\000\001\"\001 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001!\000\000\000\000\001\"\001 \000\000\000\000\000\000\000\000\002\024\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003k\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\001\000\000\000\000\000\000\000\000\000\000\000w\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002d\002c\000y\000\000\002\001\012\000\127\0029\002`\0028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\001\000\000\000\000\001\000\000\002\000\001\001\000\000\0024\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\001\000\000\000\000\001\000\001\001\000\000\0024\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\001\001\001\000\000\000\000\001\000\000\000\000\003l\000\000\001\002\001\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000q\000\000\000J\000\000\002\002\002\0025\000\000\000\000\0021\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\001\001\001\000\000\000\000\001\000\000\000\000\003l\000\000\001\002\001\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000q\000\000\000J\000\000\002\002\002\0025\000\000\000\000\0021\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\001\001\000E\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\b\002\007\000\000\000D\000\000\000\000\000\000\000\000\000P\000\000\000\000\000\000\001\000\000\000\000\003O\000\000\003N\000\000\000\000\003Q\001\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\003O\000\000\003N\000\000\000\000\003Q\000\000\000\000\000\001\007\000\000\000\000\001\n\000\000\000\000\001\b\000\000\000\000\001\t\001\011\000\000\000\000\000\000\000\000\000\000\000w\000\000\000\000\000\000\000\000\001\007\000\000\000\000\001\n\000\000\000\000\001\b\000\000\000\000\001\t\001\011\000\000\000z\001\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\156\000\000\000\155\000\000\000\158\000\000\000\157\000\000\000\000\000\000\159\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\140\000\000\001\154\001\153\000\000\001\000\000\001\140\000\000\000\000\001\000\000\000\000\001\145\000\000\000\000\000\000\000\000\001\142\000\000\000\000\000\000\001\141\000\000\000\000\000\147\000\000\000\146\000\000\000\000\000\000\000\148\000\000\000\000\001\144\000\000\000\000\001\143\000\000\000\000\000\000\001\134\000\000\000\000\001\139\000\000\000\000\000\000\001\136\000\000\000\000\000\000\001\135\000\000\000\000\001\138\000\000\000\000\001\137\003V\000\000\001\150\003X\000\000\000\000\001\149\003Y\000\000\000\000\000\000\000\000\000\000\000\000\003[\003\\\000\000\000\000\000\000\000\000\003]\003Z\003W\001\131\000\000\000\000\000\000\000\000\001\127\001\130\000\000\002\002\000\000\000\000\001\131\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\0011\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\001W\000\000\001\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000\000\001\000\000\001\000\000\000\000\000\000\000\000\001\000\000\001\000\000\000\000\000\000\000\000\001\000\000\001\000\000\000\000\000\000\001\000\000\001\000\000\000\000\000\000\001\000\000\001\000\000\003-\000\000\003,\000\000\002\000\000\003w\000\000\000\000\001r\000\000\003d\003e\000\000\001t\000\000\000\000\000\000\001i\000\000\000%\000$\000\000\000\000\000\000\000\000\000\000\000\000\003s\000\000\000\000\000\000\000\000\003t\000\000\000,\000\000\000\000\003u\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003g\000\000\000\000\000\000.\002\000\002G\000\000\000\000\000\000\000\000\000\000\000-\000\000\000\000\000\000\001u\001d\000'\000\000\000\000\000\000\000\000\000+\000&\002.\000\000\000\000\000\000\001\128\000\000\000/\001l\000\000\0000\0001\000\000\000\000\001o\002,\001k\001n\000\000\000\000\000\000\001B\003`\003b\002H\001s\000\000\002\029\000\000\001r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\156\001\159\001\157\000A\000\000\000\000\000\000\000\000\000\000\000\000\002\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\016\000\000\000\000\000\000\001\158\000\000\000@\002\015\0020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\020\000\000\002\000\000\001a\000\000\000\000\000\000\000\000\000\000\001p\001]\000\018\000\000\000\000\0002\000\000\000\015\002*\002&\000!\002)\000\r\000\000\000\000\000)\001g\001^\000\000\000\000\002\012\002\021\000\000\002\r\000\019\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003p\000\000\000\023\000\000\000\000\000\000\000\000\000\000\000\000\003n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002M\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\002G\000\000\000\000\000\000\000\000\000\000\001\156\001\159\002N\000\000\000\024\000\000\000\000\000\025\000\000\000\000\000\000\000\027\000\000\000\000\000\000\000\000\002\000\000\000\022\000\000\000\000\000\026\001h\001_\000\000\000\028\000\029\000\000\000\000\002\002%\000\021\000\000\002>\002'\000\000\000\000\001O\002\022\000\000\0004\0003\000\000\0008\0007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001X\000\011\002-\000\t\000\000\000\000\000\n\000\000\0006\0005\000\000\000\000\000\000\001t\000\000\000\000\000%\000$\000\000\000\000\001u\001d\000'\000\000\000\000\000\000\000&\002.\000\000\000\000\000\000\000\000\000\000\000\000\001X\000\011\002-\000\t\000\000\000\000\000\n\000\000\000\000\000\000\001\129\001`\000\000\000\000\000\000\000\000\000\000\000\000\000\133\000\000\000\000\000\000\002j\000\000\002/\000\031\000\030\002(\001Z\001Y\002+\000\000\002\025\001.\000\000\000\000\003>\0013\0014\000\000\000\000\000\000\000\000\000y\000\000\002\001\012\000\127\0029\002`\0028\000\000\000\000\000\134\000\129\001\015\000\000\001\014\000\000\000\000\000\000\000\000\000\000\003\127\000\000\003y\000\000\001\131\000\000\000\000\000\000\000\000\001\127\001\130\000\000\000\000\000\000\000\000\000\000\000\000\002T\000\000\000\000\000\000\000\000\000\000\002R\000\000\000\000\000\000\002S\000\000\000\000\000\000\000\000\000\000\003}\003|\001\r\000\000\000\000\000\136\002\002m\002b\001\018\002=\002<\002;\000\000\000\000\000\000\000\000\000\000\000\000\002}\000\000\000\000\000\000\000\000\000\134\000\129\001\015\000\000\000\000\000\000\000\000\000\000\000\000\003y\000\000\001\131\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003}\003|\000\000\000\000\000\136\002\002m\002b\001\018\002=\002<\002;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\001\0019\003A\003@\000\000\000\000\000\000\000\000\002\002\000\000\000\000\001\131\000\000\000\000\001R\002$\000\000\000\000\000\000\001Q\002\"\000\000\000\000\000\000\001N\002\030\000\000\000\000\000\000\001L\002\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001O\002\022\002\012\002\021\000\000\001-\002\r\000\000\001=\001>\000\000\0010\002F\002E\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\001\000\000\002\000\000\000\000\000\000\001r\000\000\000\000\000\000\000\000\002\029\000\000\001r\000\000\000\000\001\\\000\000\002\027\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000u\002_\002:\000\000\000v\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\031\000\002\000\000\000\000\000\000\000\000\000\000\000\000\001R\002$\000\000\000\000\000\000\001P\002 \000\000\000\000\000\000\001N\002\030\000\000\000\000\000\000\001M\002\028\000\000\000\000\002D\000\000\001\017\001\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002[\002Z\002t\002^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\0027\000\000\000\000\002!\000\000\0015\000\000\003?\000\000\001\002#\000\000\000\000\002\000\000\000\000\000\000\000\000\002\002\002\000\000\000\000\003a\000\000\001\017\001\016\000\000\001\014\001\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\005\001\004\000\000\001<\000\000\001\003\000\000\000z\001\006\000\000\000\000\001\005\001\004\000\000\001\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\001\000\000\001\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\001\002\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\000E\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\b\002\007\000\000\000D\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\001\000\000\001\003\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\157\000A\000\000\000\000\000\000\000\000\000\000\000\000\002\017\000\000\000\000\000\000\000\000\000\000\002\016\000\000\000\000\000\000\001\158\000\000\000@\002\015\0020\000\000\002\020\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\0036\000\000\000\002\000\000\000\000\0039\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002[\002Z\000\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0023\0022\000\000\002^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0027\0038\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0023\0022\000\000\000\000\002\005\000\000\000G\002\n\002\t\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000I\000\000\000\000\000H\000\000\000\001\000\000\000\000\001\000\000\000~\000\000\000}\000\000\000|\000\000\000{\000\000\000\000\0018\0017\000\000\001\002}\000\000\001U\000\139\000\000\000\000\000\000\002\002\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000~\000\000\000}\000\000\000|\000\000\000{\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000P\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000G\000\000\001U\000\000\000\000\000\000\001\000\000\002|\000\000\002x\000\000\002{\000\000\000\000\002z\000\000\000\149\000\000\000\151\000\000\000\000\000\152\000\000\000\000\000\000\000\000\000\000\000\000\002\002\000\000\000\000\002\000\000\000\000\000\000\000\153\000\000\000\140\000\000\000\000\001\000\000\000\000\001\140\000\000\000\000\001\145\000\000\000\000\000\000\000\000\001\142\000\000\000\000\000\000\001\141\000\000\000\000\001\144\000\000\000\000\001\143\000\000\000\000\000\000\001\134\000\000\000\000\001\139\000\000\000\000\000\000\001\136\000\000\000\000\000\000\001\135\000\000\000\000\001\138\000\000\000\000\001\137\003V\000\000\001\150\003X\000\000\000\000\001\149\003Y\000\000\000\000\000\000\000\000\000\000\000\000\003[\003\\\000\000\000\000\000\000\000\000\003]\003Z\003W\001\131\000\000\000\000\000\000\000\000\002#\000\000\000\000\000\000\000\000\000\000\000\000\0031\0030\0032\003/\003.\000\000\001\000\000\001\000\000\001\000\000\000\000\001\001\001\000\000\000\000\000I\000\000\000\000\000H\000\000\000\000\000\000\000\000\003<\003;\000\000\001\000\001\000\000\000\000\000\000\002\000\000\001\000\002\000\000\000\003\000\000\002\000\000\000\004\000\000\002\000\000\000\000\002\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\0031\0030\0032\003/\003.\000\000\000\000\003L\003G\003H\003K\003I\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0018\0017\000\000\000\000\000\000\001<\000\000\000\000\000\000\000\000\000\000\000\000\0011\000\000\000\000\003-\000\000\003,\001@\000\000\000\000\001r\000\000\000\000\000\000\000\000\0008\0007\000\000\000\000\0006\0005\000\000\000\000\0004\0003\000\000\001a\000\000\000\000\000\000\000\000\000\000\001p\001]\000\018\000\000\000\000\0002\000\000\000\015\002*\002&\000!\002)\000\r\000\000\000\000\000\000\000\000\000\000\001\129\001`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\030\002(\001Z\001Y\002+\000\000\002\025\000\006\000\000\001A\001.\000\000\001?\0013\0014\000\000\000\000\002t\000\000\000\000\002!\000\000\0015\0019\003A\003@\000\000\000\000\000\000\000\000\001Q\002\"\000\000\000\000\000\000\000\000\001L\002\026\000\000\000\000\001-\000\000\001=\001>\000\000\0010\002F\003M\002E\000\000\001C\000\007\000\000\000\000\001E\000\000\000\000\001D\003h\001F\001G")
  
  and error =
    (128, "\128\000\0183(~ \000\024p\1290\0183(~ \000\024p\001 \128\000\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\018=x\000\001\ts\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\b\000\000\000\002\000\000\000\000\000\000\000 \000\002\000\b\000\000\000\002\000\128\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\001 \128\000\128\016)1\000\024\000\000\b`}\016A\005\012\000\000X9\028p\020\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128$\0183(~\000\1288p}\016A\005\012\000\000X9\028p\020\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128$\0183(~\000\0008p\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000 \000\012\000\000\001\128\000\004\000\000\000\128\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000 \000\012\000\000\001\128\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000 \000\012\000\000\001\128\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\b\000\000\000\016\000\004\003 \004\t\000\0008\001\128\000\b\001\000@\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \144 \132\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\003\000\004\b\000\0028\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0028\001\128\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000@\000\001\128\000\000 \000\012\000\000\001\130\000\004\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\128\000\000\000\000\000\000\000\000\000\002\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000 \003\000\004(\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000 \003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\016\000\004\b\000\000\000\000\000\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127}\016A\005\012\000\000X9\028p\020\028\128$\0183(~\000\0008p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\001\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\001 \128\000\128\016)1\000\024\000\000\b`!b\128\000\0161\bx\000\000\np\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\018=x\000\001\ts\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\128\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016)1\000\024\000\000\b`!b\128 \0161\bx\002\000\bp\001 \128\000\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\b\000\000\000\004\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\004 \000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\018=x\000\001Is\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\128\0161\bx\000\000\bp!b\128\128\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\005\000\000\128\000\000 \001\000\128\000@\000\000\000\000!b\128\000\0161\bx\000\000\bp}\016A\005\012\000\000X9\028p\020\028\128$\0183(~\000\0008p\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \128\002\r\"\026\000\001Ic\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000 \000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\001\000\000 \000\012\000\000\001 \128\000\000\128\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000 \001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\002\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\127C\000\005\000\000(\001\128\002\001\022\000\142\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004(\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\003\000\004\b\000\000(\001\128\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\004\b\000\000\000\000\000\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\016\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\000(\001\128\000\001\022\002\140\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\005\000\000(\001\128\000\001\022\002\140\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000}\016A\005\012\000\000X9\028p\020\028\128$\0183(~\000\0008p}\016A\005\012\000\000X9\028p\020\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\128\000\0183(~\000\128\024p}\016A\005\012\000\000X9\028p\020\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000}\016A\005\012\000\000X9\028p\020\028\128$\0183(~\000\0008p\001\128\000@\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\128\b\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\005\000\000\128\000\000 \001\000\128\000@\000\000\000\000!b\128\000\0161\bx\000\000\bp\001\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000 \000\000\000\b\000\000\000\002\000\000\128\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\002\000\bp\001 \128\000\128\016(1\000\024\000\000\b`b\128\019\0183\bx\002\016\bx\129 \020\016=\024\000\133c!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\np!b\128 \0161\bx\002\000\bp\001 \128\000\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\001 \128\000\128\016(1\000\024\000\000\b`\127\001\000\000\000\000\000(\000\002\128\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\b\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\004\000\000\128\000\000\000\000\000\b\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000b\128\019\0183\bx\002\016\bx\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132@\017\002h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \003 \132\000\016\000h\001\"\000\026\000\000\n \000\000\000\000\000\000\000\000\000 \000\016\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \128\002\r\"\026\000\001Ic\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\001\000\000 \000\012\000\000\001 \128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000 \000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\n \003 \132 \016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\131\000\000\016\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\004 \000\003 \132\000\016\000h\001\"\000\026\000\000\b \003 \132\000\016\000h\001\"\000\024\000\000\b \003 \128\002\r\"\026\000\001\tc\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\016\000@\000\000 \000\016\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\001\000\000\000\000\004\000\000\000\000\004b\136\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131 \133\016\000h\001&\000\024\000\004j\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\001\000\000\000\000\004\000\000\000\000\004b\136\128\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000`\000\000\012\000\007\000\000\001\001C\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \003 \132 \016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\003 \132\000\016\000h\001\"\000\026\002\000\b \003 \132\000\016\000h\001\"\000\026\000\000\b \128\000\001 \000\000\000\000\000\000\000\000\000\000\000\128\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\001 \000\000\000\000\000\000\000\000\000\004\000\128\128\000\001 \000\000\000\000\000\000\000\000\000\004\000\128\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\024\000\000\b \003 \128\002\r\"\026\000\001\tc\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\128\000\016\000@\000\000 \000\016\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\001\000\000\000\000\004\000\016\001\004`\136\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\019 \133\016\000h\001&\016\025\004h\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\131 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\001\000\000\000\000\004\000\016\001\004`\136\128\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000`\000\000\012\000\007\000\000\001\001C\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\004\000\128\128\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \128\000\001\000\000\000\000\000\000\000\000\000\000\004\002\128\128\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\001\000\000\000\000\000\000\000\000\000\000\004\002\128\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\004\000\000\000\000\004@\b\003 \132\000\016\000h\001\"\000\026\000\000\b \128\000\000\128\000\000\000\000\004\000\000\000\000\000@\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001&\000\024\128\002\003\128\002\r\"\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\b\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \003\128\002\r\"\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \003 \132\000\016\000h\001\"\000\024\000\000\b \003 \132\000\018\000x\001\"\000\025\128\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\003 \140\000\016\000x\001\"\000\025\000\128 \000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\001\000\000\000\000\000(\000#\128\000\000\000\000\000\000!b\000\018=x\000\001\ts\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\128\016\0183(~\000\000\024p\003 \132@\016\002h\001\"\000\026\000\000\b }\016A\005\012\000\000X9\028p\020\028\128$\0183(~\000\0008p}\016A\005\012\000\000X9\028p\020\028\128$\0183(~\000\0008p\001 \128\000\128\016(1\000\024\000\000\b`\001 \128\000\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\001\000\000\000\000\000(\000\002\128\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\001 \128\000\128\016(1\000\024\000\000\b`\001 \140\000\128\016(1\000\024\000\128\b`\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\003 \132\000\016\000x\001\"\000\024\000\000\136\003\128\002\r\"\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \003\128\002\r\"\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 !b\128\000\0161\bx\000\000\bp\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\128\001 \128\000\128\016(1\000\024\000\000\b`\000\016\012\000\000\000\000\000\000\000\000\000\004\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\001 \140\000\128\016(1\000\024\000\128\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000(\000#\128\000\000\000\000\000\000!b\000\018=x\000\001\ts\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\003\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000A\000\001\128\000\000 \001\012\128\000\001\000\000\004\005\000\000\128\000\000 \001\000\128\000@\000\000\000\000!b\128\000\0161\bx\000\000\bp!b\128\018=x\000\001Is\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\001\000\000\128\000\000 \001\004\128\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000@\000\001\128\000\000 \000\012\000\000\001\130\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000A\000\001\128\000\000 \001\012\128\000\001\128 \004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\128\0161\bx\000\000\bp!b\128\128\0161\bx\000\000\bp\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\127\001 \128\000\128\016(1\000\024\000\000\b`\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016*1\000\024\000\000\b`\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \140\000\128\016+1\000\024\000\128\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\001 \140\000\128\016(1\000\024\000\128\b`\127!b\128\000\0161\bx\000\000\bp\003 \132\000\016\000x\001\"\000\024\000\000\136\003\128\002\r\"\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \003\128\002\r\"\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 !b\128\000\0161\bx\000\000\bp\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\128\001 \128\000\128\016(1\000\024\000\000\b`\000\016\012\000\000\000\000\000\000\000\000\000\004\128\000\000\001 \128\000\128\016(1\000\024\000\000\b`\001 \140\000\128\016(1\000\024\000\128\b`\127\001 \128\000\128\016(1\000\024\000\000\b`\127!b\128\000\0161\bx\000\000\bp\127\001\000\000\000\000\000(\000\002\128\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\001 \128\000\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016*1\000\024\000\000\b`\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\001\000\000\000\000\000(\000\002\128\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\004\128\016(1\000\024\000\000\b`\001 \128\000\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp\127\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\001 \128\004\128\016(1\000\024\000\000\b`\001 \128\000\128\016(1\000\024\000\000\b`\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\000\000`\004|\000\012\004\007\000\000\001!\003!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\nx\000\000\bp!b\128\000\0161\bx\000\000\bp\127\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\127\000\000`\004|\000\012\004\007\000\000\001!\003!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\nx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp\128\000`\132|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp\128\000`$|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp\000\000`\020|\000\012\004\007\000\000\001\001\003!b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp\128\000`\132|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\128\000`$|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127!b\128\000\0161\bx\000\000\bp\127!b\128\000\0161\bx\000\000\bp\000\000`\020|\000\012\004\007\000\000\001\001\003\127!b\128\000\0161\bx\000\000\bp\127\127!b\128\000\0161\bx\000\000\bp\127\127\000\000a|\000\012\012\007\001 \007!\135\003 \132\000\018\000x\001\"\000\025\128\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\003 \140\000\016\000x\001\"\000\025\000\128 \003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000a|\000\012\012\007\001 \007!\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \016\000\000\000\000\000\000\000\000\000\000\001\000\000\000\128\016\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000`\004|\000\012\004\007\001\000\001\001\003!b\128\000\0161\bx\000\000\bp\000\000a|\000\012\012\007\001 \007!\135!b\128\000\0161\bx\000\000\bp\000\000a|\000\012\012\007\001 \007!\135\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000`\004|\000\012\004\007\000\000\005\001\003!b\128\000\0161\bx\000\000\bp\000\000`\132|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\128\128\016(1\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\128\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000`\132|\000\012\004\007\000\000\003!\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\016\0183(~\000\000\024p\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\001\000\000\000\000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000 \001\012\128\000\001 \000 \004\005\000\000\128\000\000 \001\000\128\000@\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000`\132|\000\012\004\007\000\000\003!\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\128\000\000 \001\004\128\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\003\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\000\128\000\000 \000\004\000\000\001\000\128 \000\128\128\000\016\001\002\004\002\016\000 \006\000\000\016\000\127\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\016\000\004\003 \004\t\000\0008\001\128\000\b\001\000@\128\003\000\005\b\000\128(\001\128\000\000 \144 \132\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\003\000\005\b\000\000(\001\128\000\000 \016 \132\003\000\005\b\000\000(\001\128\000\000 \016 \132\000\000\001\000\000\000\000\000\012\000\000\000 \016 \132\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0028\001\128\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\012\000\000\000 \016 \132\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \004\b\000\0008\001\128\000\b\000\000@\128\003\000\004\136\000\0028\001\128\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004(\000\000(\001\128\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\003\000\004\b\000\000(\001\128\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000 \016\000\132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000 \016\000\132\000\000\001\000\000\000\000\000\b\000\000\000 \016\000\132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\016\000\004\001 \000\001\000\000 \000\002\128\000\b\001\000@\128\003\000\005\b\000\128(\001\128\000\000 \016 \132\001 \000\000\000\000 \000\002\128\000\b\000\000@\128\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000 \016\000\004\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\001\000@\000\000\000\b\000\000\000\016\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000 \016\000\004\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127}\016A\005\012\000\000X9\028p\020\028\128$\0183(~\000\0008p\000\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\1290\000\000\000\000\b\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\131\000\0058\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\000(\001\128\000\000 \016 \132\131\000\0058\000\000(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\012\000\000\000 \016 \132\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\128\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\016\000@\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\001\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132\000\001\019\000\000\000\002\016\b\000\000\000\016\000\b\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132\000\001\019\000\000\000\002\016\b\000\000\000\016\000\000\b\000\000\000\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\001\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\005\000\000(\001\128\000\000 \000\000\004\131\000\005\000\000(\001\128\000\000 \000\000\004\128\000\001\016\000\000\000\000\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\012\000\000\000 \000\000\004\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\b\016\000x\001\"\000\024\128\000 \000\000\000\b\000\000\000\000\000 \000\016\000\000\000\000\000\000\000\b\000\000\000\000\000 \000\016\000\000\000\000\001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\133\000\000\019\b\000,\003\016\152\000@\000\016\016\b\003 \132@\016\000h\001\"\000\026\000\000\b \003 \132\000\016\000h\001\"\000\026\000\000\b \003 \132\000\016\000x\001&\000\024\128\002\003\128\002\r\"\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \003\128\002\r\"\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 !b\128\000\0161\bx\000\000\bp\127\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000a\020|\000\012\012\007\000 \001\001\135\003 \132\000\016\000x\001\"\000\025\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\128\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000a\020|\000\012\012\007\000 \001\001\135\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\000\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\128\000`\136\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\127\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\128!b\128\000\0161\bx\000\000\bp\127\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\024\000\000\136 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000\136 \001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\131\000\005\000\000(\001\128\000\000 \000 \012\131\000\005\000\000(\001\128\000\000 \000 \012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129 \129\128\01681\000\024 \000l\129 \129\128\01681\000\024 \000l\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\001\000\000\000\000\012\000\000\000 \000 \012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\004\133\000\000\019\b\000,\003\016\152\000@\000\016\016\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132\000\000\019\000\000\000\002\016\024\000\000\000\016\000\000\b\000\000\000\000\004\b\000\000\000\000\000\000\000\000@\000\000\000\000\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\128\000\001\016\000\000\000\000\b\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\b\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\128\000\001\016\000\000\000\000\b\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\002 \000!b\128\000\0161\bx\000\000\bp\128\000a\020|\000\012\012\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\128\000a\020|\000\012\012\007\000\000\001\001\003\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000@\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\128\000 !b\128\000\0161\bx\000\000\bp!b\128\000\0161\bx\000\000\bp\128\000a\020|\000\012\012\007\000\000\001\001\003\003\128\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\128\000a\020|\000\012\012\007\000\000\001\001\003\000\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\128\000a\020|\000\012\012\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000!b\128\000\0161\bx\000\000\bp\128\000a4|\000\012\012\007\000 \001\001\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000(\001\000\128\000@\000\000\016@\001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\128\000\001\016\000\000\000\000\012\000\000\000\000\000\000\b\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\001\016\000\000\000\000\000\000\000\000\000\000\000\000\132\000\000\019\000\000\000\002\016\024\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\128\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\001\000\000\000\000\000\b\001\000\128\000\000\000\000\000\000\128\000\000\128\000\000\000\000\004\000\000\000\000\000\000\000\003\000\004\012\000\000(\001\128\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\012\000\000\000 \000\000\004\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\001\000\000\000\000\000\b\001\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132\000\001\019\000\000\000\002\016\b\000\000\000\016\000\b\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\136\000\000(\001\128\000\001\000\000\004\003\000\005\136\000\000(\001\128\000\001\000\000\004\000\000\001\128\000\000\000\000\012\000\000\000\128\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\012\000\000(\001\128\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\128\000\0010\000\000\000\000\012\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\128\000\0010\000\000\000\000\012\000\000\000 \000\000\004\001\000\000\000\000\000(\001\000\128\000\000\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\128\000\0010\000\000\000\000\012\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\000\000\000\000 \000\000\000\1280\0183(~ \000\024p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\128\000 \000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\129\000\0010\000\000 \001\012\128\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000 \001\012\128\000\001 \128 \004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\003\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\002\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\128\001\000\000\003\000\004\t\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\012\000\000\001 \016\000\004\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\129\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000 \000\012\000\000\001 \128\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\012\000\000\001 \128\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000 \000\012\000\000\001 \128\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000 \000\012\000\000\001 \128\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\128\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\012\000\000\001 \128\000\004\000\001\000\000\000\000\012\000\000\001 \000\000\004\000\128\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\001\000\000\000\000\012\000\000\001 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\128\128\000\016\001\002\004\002\016\000 \006\000\000\016\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\128\000@\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\128\000\000\000\002\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\128\001\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000\000\000\012\000\000\001\016\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\129\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000\000\000\012\000\000\001\128\000\004\000\000\000\000\000\000\000\000\000\000\000\000\128\128\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000\000\000\012\000\000\001\128\000\004@\000\001\128\000\000\000\000\012\000\000\001\000\000\004\000\128\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000@\000\001\128\000\000\000\000\012\000\000\001\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000}\016A\005\012\000\000X9\028p\020\028\128$\0183(~\000\0008p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\000\000\000\000 \000\000\004\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\b\000\000\000\016\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\b\000\000\000 \016\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\000\000\000\000 \000\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\000\000\000\000 \000\000\004\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\000\000\000\000 \000\000\004\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\004\000\000\000\128\000`\136\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\128!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\128\000\0183(~\000\000\024p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000}\016A\005\012\000\000X9\028p\020\028\128$\0183(~\000\0008p\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\000\000\000\b\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\003\000\005\b\000\128(\001\128\000\000\000\000 \128\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000\000 \128\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000\000 \128\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000\000 \128\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000\000 \128\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000\000 \128\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\128\000\000\000\000\b\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\016\000@\000\000\000\000\000\128\000\000\000\001\000\000\000\000\000\b\001\000\128\000\000\000\000\000\000\000\000\001\000\000\000\000\000\012\000\000\000 \000\000\004\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\016\000@\000\000\000\000\000\000\000 \000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\128\128\000\016\001\002\004\002\016\000 \006\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\128\000 \000\001\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000@\000\000\128\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000 \000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000@\000\001\000\000\000\000\000\012\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000@\000\001\000\000\000\000\000\012\000\000\001\000\000\000\004\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\004\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\127\000\000\001\000\000\000\000\000\b\000\000\000\016\000\004\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\004\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\004\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\128\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000@\000\001\128\000\000\000\000\012\000\000\001\000\000\004@\000\000\000\000\000\000\000\004\000\000\001\128\000\000\000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\129\000\0010\000\000 \001\012\128\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\001\000\000 \000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\129\000\0010\000\000 \001\012\128\000\000 \000\000\004\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000@\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\129\000\0010\000\000 \001\012\128\000\000 \000\000\004@\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\1280\0183(~ \000\024p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\001 \000\001\000\000 \000\002\000\000\b\000\000@\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \000\000\000\000 \000\002\000\000\b\000\000@\128\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\127\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000@\000\000\128\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\001\000\000\000\000\012\000\000\001 \000\000\000\000\000\128\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\128\000\000 \001\004\128\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\000\128\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\128\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\001\000\000\000\000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000A\000\001\128\000\000 \001\012\128\000\001\000 \004\001\000\000\000\000\000 \001\004\128\000\000\000\000 \000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\004\002\000b\128\000\0161\bx\000\000\np\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\002\000\bp!b\128\000\0161\bx\000\000\bp\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\004\000\000!b\128 \0161\bx\002\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\004\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\016\000\000\b\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\129\000\000\016\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\004 \000!b\128\000\0161\bx\000\000\bp\128\000`\020|\000\012\004\007\000\000\005\001\003\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004 \000!b\128\000\0161\bx\000\000\bp\128\000`\020|\000\012\004\007\000\000\005\001\003\128\000a|\000\012\012\007\000 \007#\135\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000!b\128\000\0161\bx\000\000\bp\128\000a|\000\012\012\007\000 \007#\135\003 \132\000\016\000x\001\"\000\025\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000`\004|\000\012\004\007\001\000\001\001\003!b\128\000\0161\bx\000\000\bp\128\000a|\000\012\012\007\000 \007#\135!b\128\000\0161\bx\000\000\bp\128\000a|\000\012\012\007\000 \007#\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000`\132|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\128\000`$|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000`\020|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000 \001\004\128\000\000\000\000 \000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\128\000\000\000\000\000\000\000\000\000\000\000\000\004\002\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\002\000\bp!b\128\000\0161\bx\000\000\bp\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\004\000\000!b\128 \0161\bx\002\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\004\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\016\000\000\b\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\128\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000a4|\000\012\012\007\000 \001\001\007\000\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\001\000\128\016\000\000\b\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\004 \000!b\128\000\0161\bx\000\000\bp\128\000`\020|\000\012\004\007\000\000\005\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\128\000\128\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0181\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\128\000 \000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\001\000\001\000\000\000 \001\012\128\000\000 \000\000\004\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000@\000\000\000\000\000\000\000\004\000\000\001\128\000\000\000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\001\000\001\000\000\000 \001\012\128\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0181\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0181\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\001\000\000 \000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\001\000\001\000\000\000 \001\012\128\000\000 \000\000\004\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000@\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\001\000\001\000\000\000 \001\012\128\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000(\000#\128\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000`\132|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\128\000`$|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000`\020|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000\000\000\000\000\128\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\016\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000`\004|\000\012\004\007\001\000\001\001\003!b\128\000\0181\bx\000\000\bp\003 \132@\017\002h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0181\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\128\000 \000\127\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0181\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0181\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\127\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0181\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\004\002\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000`\020|\000\012\004\007\000\000\005\001\003!b\128\000\0161\bx\000\000\bp\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\012\000\000\000\000\000\000\128\000\000\000\128\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016*1\000\024\000\000\b`\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000`\132|\000\012\004\007\000\000\003!\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\128\000\000 \001\004\128\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000 \001\012\128\000\001 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\128\000\000\000\000\000\000\000\000\000\000\000\004\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\004\000\000\000\000\004@\b\003 \132\000\016\000h\001\"\000\026\000\000\b \128\000\000\128\000\000\000\000\004\000\000\000\000\000@\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000 \000\000\000\000\000\000\000\000\000\000\000\128!b\128\000\0161\bx\000\000\bp\000\000`$|\000\012\004\007\000\000\001\001\003\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000`\132|\000\012\004\007\000\000\003!\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\128\000\000 \001\004\128\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\128\000\000 \001\004\128\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000`\004|\000\012\004\007\000\000\005\001\003!b\128\000\0161\bx\000\000\bp\000\000`\132|\000\012\004\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000`\004|\000\012\004\007\000\000\005\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\004\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \140\000\128\016(1\000\024\000\128\b`\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\004\002\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\002\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000\000\000\000\000\128\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\004 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\002\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\127\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\002\000\004\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000C\000\005\000\000(\001\128\002\001\022\000\142\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\012\000\000\000 \016 \132\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0028\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \004\b\000\0008\001\128\000\b\000\000@\128\003\000\004\136\000\0028\001\128\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004(\000\000(\001\128\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\b\000\000\000 \016\000\132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\b\000\000\000 \016\000\132\128\000\0010\000\000\000\000\b\000\000\000 \016\000\132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\b\000\000\000\016\000\004\001 \000\001\000\000 \000\002\128\000\b\001\000@\128\131\000\0058\000\128(\001\128\000\000 \016 \132\001 \000\000\000\000 \000\002\128\000\b\000\000@\128\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\b\000\000\000 \016\000\004\128\000\0010@\000\000\000\b\000\000\000\016\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\001 \000\001\000\000 \000\002\000\000\b\000\000@\128\001 \000\000\000\000 \000\002\000\000\b\000\000@\128\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000,\000\000\000\b\000\000\000\002\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\016(1\000\024\000\000\b`\000\000,\000\000\000\b\000\000\000\002\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\012\000\000\000\000\000\000\128\000\000\000\128\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\001 \140\000\128\016(1\000\024\000\128\b`\1280\0183(~ \000\024p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\002\004\002\016\000 \006 \000\016\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\002\004\002\016\000 \006 \000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0161\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000`\004|\000\012\004\007\000 \001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000h\001\"\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000 \000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\132\000\0183(~ \000\024p\127\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\001 \000\001\000\000 \000\002\000\000\b\000\000@\128\001 \000\000\000\000 \000\002\000\000\b\000\000@\128\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\003\000\005\b\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\b\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\001 \129\000\000\000(\000\000 \000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000 \128\000\000\001\128\000@\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\128\b\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132@\016\002h\001\"\000\026\000\000\b \001\000\000\000\000\000 \001\000\128\000@\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \000\000\000\000 \000\002\000\000\b\000\000@\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\128\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\b\016\000x\001\"\000\024\128\000 \001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\128\000\000\128\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\128\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\000\000\019\b\000,\003\016\152\000@\000\016\016\b\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\024\000\000\136 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000\136 \001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\003\000\005\b\000\000(\001\128\000\000 \000\000\004\003\000\005\b\000\000(\001\128\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \129\000\128\01681\000\024 \000d\001 \129\000\128\01681\000\024 \000d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\012\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\012\000\000\000 \000\000\004\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\000\000\001\000\000\000\000\000\012\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\000x\001\"\000\025\000\000 \001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\000\000\001\000\000\000\000\000\012\000\000\000 \000\000\004\001\000\000\000\000\000(\001\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000(\001\000\128\000@\000\000\016\000\000\000\001\000\000\000\000\000\012\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\128\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\001\000\000\000\000\000\000\000\000\000 \000\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\001\000\000\000\000\000\000\000\000\000 \000\000\004\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127!\128\000\0183(~\000\000\024p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\132\000\0183(~ \000\024p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000 \000\000\000!\132\000\0183(~ \000\024p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000 \000\000\000!\132\000\0183(~ \000\024p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")
  
  and start =
    7
  
  and action =
    ((32, "\000\000ȴ\000\000ȴ\000\000\127\148\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\148\000\000|\000\000\000\000\000\000\000\0006\000\000\000\000\000\000\000\000\000\000\000\000\000\000l\000\000\000\000\000\000\127\148\000\000\000\000\000\000\134\000\000\134\000\000\127\148\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\130\000\000\000\000\000\000\000\000ȴ\000\000f\000\000\000\000\000\000z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000D\000\000\000\000\000\000\000\000*\000\000\000\000\002\000\000\000@\000\000\000\000\000\000,\000\000\002\000\000\000Ţ\000\000\000\000\000\000\000\000\000\000,\000\000\148\000\000\000\000\000\000`\000\0006\000\000\000\000\000\000\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000.\000\000\000\000\000\000|\000\000g\000\000|\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\000\000P\000\000ܼ\000\000(\000\000\000\000\000\000\000\000Į\000\000\006\000\000\000\000\000\000X\000\000J\000\000\000\000\000\000\000\000.\000\000.\000\000\000\000\000\000\130\000\000\000\000\000\000\134\000\000<\000\000\000\000\000\000\134\000\000\132\000\000\n\000\000\000\000\000\000\000\000\000\000R\000\000\000\000\000\000\158\000\000h\000\000\000\000ȴ\000\000\000\000\000\000\127\148\000\000\030\000\000(\000\000ȴ\000\000\000\000\000\000\029\000\0006\000\000\000\000\000\000x\000\000\000\000\000\000\000\000\000\000\000\000\000\000,\000\000\000\000\000\000(\000\000\144\000\000\127\148\000\000Ŧ\000\000L\000\000[\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000x\000\000\000\000\000\000^\000\000\024\000\000\000\000\000\000\000\000\000\000h\000\000ˬ\000\000[\000\000\001\000\000\000\000\000ȴ\000\001\006\000\000\000\000\000\000g\000\000\000\000\000\000\000\000̪\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000J\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000ǰ\000\000.\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000ʺ\000\000\000\000\000\000\000\000\000\000Ȳ\000\000\000\000\000\000\000\000\000\000\000\000\030\000\000\000\000\000\000\000\000\000\000à\000\000\000\000\006\000\000D\000\000.\000\0006\000\000\002\000\000\000\130\000\000\134\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000r\000\000\000\000\000\000r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\000\000\000\000\000\000\000\000\000\000.\000\000j\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000k\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000l\000\000.\000\000m\000\000\000\000\000\000\000\000\000\000$\000\000\006\000\000\000\000\000\000\000\000\000\000n\000\000.\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\000\000\000\000\000\000\000\000\000\000\000\000\000\000ٲ\000\000\000\000\000\000\134\000\000<\000\000\000\000\000\000x\000\000\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\030\000\000\134\000\000\016\000\000\000\000\000\000<\000\000\000\000\000\000\\\000\000\000\000\000\000\000\000\000\000\000\000R\000\000\000\000\000\000\000\000\000\000ʢ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000.\000\000@\000\000\130\000\000.\000\000\003\000\000\000>\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000ȴ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\000\000\000\000\000\000\000\000\000\000\000\000N\000\000\000\000\000\000\b\000\000\005\000\000\000\000\000ȴ\000\000\030\000\000i\000\000\000\000\005\000\000\000\000\000\000Ψ\000\000ˬ\000\000@\000\000[\000\000\030\000\000\134\000\0006\000\000\000\000\000\000\000\000\000\000\000\000$\000\000\127\148\000\000P\000\000\134\000\000[\000\000\000\000$\000\000\127\148\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\148\000\000\000\000\000\000\000\000\000\000o\000\000\127\148\000\000p\000\000b\000\000[\000\000r\000\000\000\000\000\000x\000\000\146\000\000\000\000\000\000Ȥ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000\000\000\000\006\000\000\128\000\000\000\000\000\000\000\000\000\001\006\000\001\005\000\000&\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000ɤ\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\152\000\000B\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000\000\000\000\000\000\000\000\001\006x\000\001\005\000\000\000\000\000\0000\000\000\000\000\000\000Ϣ\000\000~\000\000\000\000\000\000T\000\000\000\000\000\000\000\000\000\000b\000\000V\000\000f\000\000\000\000\000\000\000\000\000\000\000\000\000\000\156\000\001\005\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\b\000\000\000\000\000\000\000\000\000\000\"\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\t\000\000P\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\000\000\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\000\001\005\000\000\000\000\000\000\000\000^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000к\000\000\000\000\000\000\000\000\000\000\014\000\000\000\000\000\001\006\000\001\006x\000\000\000\000\000\000\012\000\000\000\000\000\000B\000\000\000\000\000\000\000\000\000\000\018\000\001\005\000\001\005\000\000\156\000\001\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000&\000\000x\000\0000\000\000\000\000\000\000\000\000\000\000\000\000r\000\000J\000\000p\000\000\000\000\000\000\020\000\001\006\000\001\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000q\000\000r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000r\000\000\000\000\000\000\000\000\000\000s\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000t\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000u\000\001\006\000\000\000\000\000\000J\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000v\000\000.\000\000\000\000\000\001\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\r\000\000\000\000\000\000\000\000\000\000.\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\000\000.\000\000\015\000\000\000\000\000\000\000\000\000\000Ѵ\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000̶\000\000\000\000\000\000\000\000\000\000\000\000\000\000\019\000\001\005\000\000T\000\000|\000\000\000\000\000\000\000\000\000\000N\000\000\000\000\\\000\001\006\000\000X\000\001\005\000\000,\000\000\000\000\000\000\000\000\000\000\000\000\000\000\019\000\000\000\000\000\000\000\000\000\000\000\000`\000\000J\000\000\022\000\000\022\000\000\000\000\000\000Z\000\000\000\000ϸ\000\000\022\000\000t\000\000\000\000r\000\000\000\000\000\000\000\000\127\148\000\000T\000\000*\000\000\000\000\000\000\000\000\000\000\000\000\000\000w\000\000Ĳ\000\000`\000\000h\000\000ȴ\000\000\128\000\000\000\000ȴ\000\000\000\000ȴ\000\000\029\000\000\029\000\000\000\000\000\000\000\000\000\000\020\000\000\029\000\000\021\000\000о\000\000[\000\000\127\148\000\000\000\000\022\000\000F\000\000\000\000\000\000\000\000\000\000[\000\001\0072\000\000x\000\000\022\000\000\154\000\000.\000\0008\000\000\022\000\000\014\000\000.\000\000[\000\001\006\000\000b\000\000\127\148\000\000\030\000\000\000\000\000\000\000\000\000\000\127\148\000\000\000\000\023\000\000\000\000\000\000\024\000\000P\000\000 \000\000h\000\000\000\000\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000Ӧ\000\000P\000\000\142\000\000Ԯ\000\000h\000\000\000\000\000\000\000\000\128\000\000\000\000l\000\000h\000\000,\000\000\000\000\000\000˸\000\000\000\000\000\000\000\000\000\000\000\000Ԩ\000\000Ү\000\0000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\138\000\000D\000\000զ\000\000v\000\000\000\000\001\000\000\000\127\148\000\000x\000\000\000\000\000\000\b\000\000\000\000\000\000(\000\000\128\000\000\000\000\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\148\000\000\150\000\000y\000\000\000\001\007\000\000\000\000\022\000\000\030\000\000\000\000Ҹ\000\000\022\000\000\"\000\000\000\000\000\001\006\000\000\156\000\000\127\148\000\000\030\000\000\127\148\000\000\150\000\000z\158\000\000\127\148\000\000{\156\000\000\000\000|\154\000\000>\000\000[\000\000\029\000\000\025\000\000\000\000\000\000̢\000\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000[\000\000\026\000\000n\000\000[\000\000\027\000\000\028\000\000\000\000\000\000\029\000\000\000\000\029\000\000\030\000\000\000\000\000\000\000\000\000\000\000\000\000\000d\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000[\000\000 \000\000[\000\000!\000\000[\000\000\"\000\000\000\000\000\000#\000\000\000\000\000\000$\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000[\000\000%\000\000\000\000\000\000[\000\000&\000\000\000\000}\152\000\000~\150\000\000\000\000\000\000\127\148\000\000(\000\000\127\148\000\000\128\146\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132\000\0000\000\000\000\000\000\000>\000\000\000\000\000\000\000\000\129\144\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000r\000\000\000\000\130\142\000\000\000\000\131\140\000\000\000\000\132\138\000\000\000\000\000\000\133\136\000\000\000\000\000\000\134\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\135\132\000\000\000\000\000\000\000\000\136\130\000\000\000\000\000\000\000\000\137\128\000\000\000\000\138~\000\000\000\000\139|\000\000\000\000\140z\000\000\000\000\141x\000\000\000\000\142v\000\000\000\000\143t\000\000\000\000\144r\000\000\000\000\145p\000\000\000\000\146n\000\000\000\000\147l\000\000\000\000\148j\000\000\000\000\149h\000\000\000\000\000\000\150f\000\000\151d\000\000\000\000\152b\000\000\000\000\153`\000\000\000\000\154^\000\000\000\000\155\\\000\000\000\000\156Z\000\000\140\000\000[\000\000'\000\000[\000\000(\000\000[\000\000)\000\000[\000\000*\000\000[\000\000+\000\000[\000\000,\000\000[\000\000-\000\000[\000\000.\000\000[\000\000/\000\000[\000\0000\000\000[\000\0001\000\000[\000\0002\000\000[\000\0003\000\000[\000\0004\000\000ȴ\000\000[\000\0005\000\0006\000\000[\000\0007\000\000[\000\0008\000\000[\000\0009\000\000[\000\000:\000\000l\000\000\000\000\000\000;\000\000[\000\000<\000\000[\000\000\000\000\000\000\000\000=\000\000[\000\000>\000\000\000\000\000\000?\000\000[\000\000@\000\000A\000\000[\000\000B\000\000C\000\000l\000\000\000\000\000\000\157X\000\000\000\000\158V\000\000[\000\000\000\000\000\000\000\000\159T\000\000\000\000R\000\000\000\000\140\000\000P\000\000\000\000N\000\000L\000\000\000\000J\000\000H\000\000ذ\000\000p\000\000\000\000\000\000\127\148\000\000\000\000.\000\000ͦ\000\000\000\000\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\006\000\000\142\000\000\128\000\000\000\000\000\000\000\000T\000\000\000\000&\000\000U\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000F\000\000\140\000\000\000\000\140\000\000\000\000\000\001\0002\000\000f\000\000[\000\000\000\000\000\000D\000\000.\000\000\000\000\000\000.\000\000\000\000\000\000E\000\000.\000\000\000\000\000\000\000\000\000\000l\000\000\000\000\000\000ȴ\000\000\000\000\000\000&\000\000\000\000\000\000F\000\000\000\000\000\000\000\000\000\000.\000\000\000\000\000\000.\000\000\000\000\000\000D\000\000.\000\000\000\000\000\000B\000\000\000\000\000\000\000\000\000\000\000\000P\000\000.\000\000\000\000\000\000P\000\000\004\000\000\000\000\000\000P\000\0000\000\000\000\000\000\000\000\000\000\000ȴ\000\000ˬ\000\000\000\000\000\000ˬ\000\000\000\000\000\000h\000\000\000\000\000\000\000\140\000\000\000\000\000\000P\000\0002\000\000\000\000\000\000P\000\000Z\000\000\000\000\000\000P\000\0006\000\000\000\000\000\000\000\000\000\000\132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\142\000\000\138\000\000f\000\000\144\000\000@\000\000\000\000\000\000\006\000\000\000\000\000\000n\000\000\000\000\000\000\006\000\000\000\000\000\000b\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000b\000\000ն\000\001\007\000\000g\000\001\n\000\001\011\026\000\000\000\000.\000\000\000\000\000\000\014\000\000f\000\000\028\000\000\000\000\000\000.\000\000\000\000\000\000\000\000\000\000.\000\000\000\000\000\000h\000\000\000\000\000\000\012\000\000.\000\000\000\000\000\001\tJ\000\000h\000\000\000\000\000\000F\000\000n\000\001\tJ\000\000h\000\000\000\000\000\000\132\000\001\tJ\000\000h\000\000\000\000\000\000\134\000\000\000\000\000\000\000\000\152\000\000\000\000\000\000z\000\000\134\000\000\000\000\000\000\000\001\tJ\000\000h\000\000\000\000\000\001\tJ\000\000h\000\000\000\000\000\000&\000\001\tJ\000\000h\000\000\000\000\000\001\tJ\000\000h\000\000\000\000\000\000<\000\001\tJ\000\000h\000\000\000\000\000\000<\000\001\tJ\000\000h\000\000\000\000\000\001\tJ\000\000h\000\000\000\000\000\001\tJ\000\000h\000\000\000\000\000\000\000\000\000\000n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\000\001\tJ\000\000t\000\000F\000\000D\000\000\000\000\000\000\000\000\000\000\000\000R\000\000\000\000F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000(\000\000.\000\000\000\000.\000\000\000\000\000\000\000\000\000\000>\000\000\000\000\000\000\000\000\000\000<\000\000b\000\000\000\000\000\000\000\000<\000\000\000\000\000\000:\000\000\000\000ȴ\000\0000\000\000֤\000\000.\000\000\000\000\156\000\000\156\000\000\000\000\000\000G\000\000\000\000\000\000G\000\000\000\000\000\000h\000\000f\000\000\144\000\000x\000\000^\000\000H\000\000\000\000\000\000H\000\000\000\000\000\000.\000\000\000\000\000\001\000\000\001\0014\000\000H\000\000\000\000\000\000V\000\000.\000\000\000\000\000\001\001\000\000\144\000\000H\000\000\000\000\000\000H\000\000\000\000\000\000h\000\001\002&\000\000\144\000\000H\000\000\000\000\000\000H\000\000\000\000\000\000f\000\001\002\144\000\000\144\000\000H\000\000\000\000\000\000H\000\000\000\000\000\001\002\000\000\144\000\000H\000\000\000\000\000\000H\000\000\000\000\000\001\003d\000\000\144\000\000H\000\000\000\000\000\000H\000\000\000\000\000\000G\000\000\000\000\000\000G\000\000\000\000\000\000.\000\000\000\000\000\000\144\000\000\000\000\000\000\144\000\000:\000\000\000\000\000\000\140\000\000\000\000\000\000\000\000\000\000\024\000\000\000\000\000\000\000\000\000.\000\000z\000\000\000\000\000\000\152\000\000\000\000\000\000\000\000\000\000\000\000*\000\000R\000\000*\000\000\000\000.\000\000\000\000\000\000\144\000\000*\000\000\000\000.\000\000\000\000\000\000G\000\000\000\000\000\000\000\000.\000\000\000\000\000\0000\000\000\000\000\000\000*\000\000\000\001\014p\000\000\000\000I\000\000\000\000\006\000\000\000\000\000\000.\000\000\000\000\000\000G\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000\000*\000\000\000\001\014p\000\000G\000\000\000\000\000\000\024\000\000\006\000\000Ӿ\000\000\000\000\000\000\000\000\000\000\000\000\000\001\t\000\001\n<\000\000\028\000\000G\000\000\000\000\000\000\000\000\000\000\000\000\000\000.\000\000\024\000\000.\000\000\000\000\000\000G\000\000\000\000\000\000\000\000\000\000G\000\000\000\000\000\000\000\000\000\000J\000\000K\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\024\000\000ע\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000G\000\000\000\000\000\000t\000\000\000\000\000\000b\000\000\000\000͠\000\0006\000\0006\000\001\nx\000\000\128\000\001\006\000\000\000\000x\000\000\022\000\000׸\000\001\003\000\0008\000\000\022\000\000׺\000\001\003\000\000\000\0008\000\000.\000\000h\000\000\000\000\000\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\148\000\000\022\000\000\030\000\000.\000\0002\000\000\000\000\000\000\000\000\140\000\000\006\000\000I\000\000Ϯ\000\000.\000\0008\000\000\000\000\000\000\000\000@\000\000\000\0006\000\000\000\000\000\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\144\000\000.\000\000B\000\000\000\0004\000\000>\000\000\000\0002\000\000:\000\000\000\000\000\000:\000\000\000\000\000\000\000\000\000\000\000\001\b\146\000\0006\000\0006\000\001\0040\000\001\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000r\000\000\000\000\000\000<\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000B\000\001\nx\000\000\000\000\000\000\000\000\000\000\158\000\000\000\000\000\000\000\000\000\000\000\000è\000\000R\000\000*\000\000*\000\000.\000\000 \000\000\000\000\000\000G\000\000\000\000\000\000t\000\000Ѷ\000\000*\000\000,\000\000.\000\000z\000\000\000\000\000\000*\000\000n\000\000[\000\000\150\000\000R\000\000[\000\000&\000\000`\000\000\000\000*\000\0004\000\001\014p\000\000\000\000\000\000\000\000[\000\000L\000\000[\000\000\000\000\128\000\000\022\000\000V\000\000.\000\000j\000\000[\000\000F\000\000X\000\000.\000\000\000\000\000\000p\000\000[\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000.\000\000\006\000\000[\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000G\000\000\000\000\000\000`\000\000G\000\000\000\000\000\000~\000\000[\000\000M\000\000\000\000\000\000N\000\0006\000\000T\000\000\000\000\000\000\000\000G\000\000\000\000\000\000.\000\000G\000\000\000\000\000\000\000\000\000\000\000\000\000\000G\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\006\000\000:\000\000\000\000\000\000\000\000\000\000r\000\000\000\000\000\000\000\000\000\000x\000\000\000\000\000\000\000\000\000\000\000\000\024\000\0000\000\000n\000\000.\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\0148\000\000\000\000\000\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\011\000\001\011\000\000\000\000\000\000\000\000\000\000\000\000D\000\000.\000\0004\000\001\0148\000\000Ҡ\000\001\0148\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\0148\000\000\000\000\000\000\136\000\0006\000\000\000\000\000\000\000\000\000\000\000\001\004\000\0006\000\000\128\000\000\000\001\0148\000\000\026\000\000\000\000\000\000\142\000\0006\000\000\000\000\000\000\000\000D\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000G\000\000\000\000\000\000\000\000\000\000\000\000ȴ\000\000\000\000\000\000\000\000\000\000\000\000\000\000ˢ\000\000\000\000ˬ\000\000d\000\000\000\000\000\000*\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000P\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\000<\000\000\142\000\001\006B\000\000\000\000\000\000.\000\000\000\000\000\000.\000\000\000\000\000\000\132\000\000.\000\000\142\000\000.\000\000\000\000\000\000\000\000\000\000D\000\000R\000\000F\000\000\000\000\002\000\000\000\000\000\000\000\000\000\"\000\000H\000\000(\000\000\002\000\000\000\018\000\000\000\000\000\000\000\000\002\000\000\000԰\000\000\000\000\000\000Ҧ\000\000F\000\000B\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000v\000\000P\000\000\138\000\000N\000\000r\000\0000\000\000\000\000\000\000\000\000\006\000\000\000\000\000P\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000*\000\000\006\000\000<\000\000N\000\000.\000\000\000\000\000\000.\000\000\000\000\000\000\130\000\000T\000\000\006\000\000\002\000\000\000t\000\000\148\000\000\002\000\000\000\000\000\000\000*\000\000\000\000\000\000\000\000\000\000P\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000X\000\000\136\000\000.\000\000:\000\000\000\000\000\000\000\000ȴ\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0004\000\000$\000\000N\000\000O\000\000\000\000\000\000\000\000\000\000N\000\000,\000\000\000\000\000\000\000\000G\000\000\000\000\000\000\000\000\000\000\000\000ˢ\000\000G\000\000\000\000\000\000\000\000\000\0000\000\000\144\000\000G\000\000\000\000\000\000\000\000\000\000B\000\000\144\000\000G\000\000\000\000\000\000\000\000\000\000P\000\001\006\000\000ɾ\000\000.\000\000׶\000\000[\000\000Q\000\000\144\000\000[\000\000R\000\000G\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000ȴ\000\000\000\000\000\000\000\000\000\000G\000\000\000\000\000\000\000\000\000\000M\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000ȴ\000\000N\000\000\000\000\000\000P\000\000\000\000\000\000\000\0000\000\000צ\000\000.\000\000\000\000Z\000\000Z\000\000\000\000\000\000:\000\000\000\000\000\000\000\000\134\000\000h\000\000\000\000\000\000\134\000\000h\000\000\000\000\000\000`\000\000\134\000\000h\000\000\000\000\000\000^\000\000\134\000\000h\000\000\000\000\000\000\134\000\000h\000\000\000\000\000\000\134\000\000h\000\000\000\000\000\000:\000\000\000\000\000\000j\000\000\144\000\000.\000\000\000\000\000\000\000\000\000\000N\000\000:\000\000\000\000\000\0006\000\000\000\000\000\000\154\000\001\0148\000\000\000\000\000\000:\000\000\000\000\000\000r\000\000\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000ˠ\000\000\136\000\000\000\000P\000\000\b\000\000&\000\000P\000\000V\000\000\000\000\000\000\000\000\000\000\000\000\000\000&\000\000\000\000\000\000r\000\0000\000\000\000\000\000\000:\000\000\000\000\000\000\156\000\000\000\000P\000\000\b\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\000\000$\000\000\148\000\000<\000\000<\000\000b\000\000:\000\000\000\000\000\000\000\000\000\000\152\000\000\156\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\144\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\144\000\000:\000\000\000\000\000\000\000\000\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\000\000r\000\000\000\000\000\000\000\000\000\000\000\000\000\000P\000\000\016\000\000Ű\000\000ˬ\000\000d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000;\000\000ˬ\000\000d\000\000P\000\000ɢ\000\000ˬ\000\000\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000ˢ\000\000G\000\000\000\000\000\000G\000\000\000\000\000\000ȴ\000\000\000\000\000\000\134\000\000\000\000\000\000\000\000\000\000z\000\000\000\000\000\000\000\000j\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\020\000\000\000\000\000\000$\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000P\000\000l\000\000\004\000\000\000\000\026\000\000`\000\000\000\000\000\000\000\000\000\000S\000\000\000\000\000\000\142\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\134\000\000\000\000\000\000\000\000h\000\000V\000\000\156\000\000\000\000\000\000\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000>\000\000\000\000\000\000\000\000\000\000\000\000T\000\000\000\000\000\000\000\000\000\000[\000\000\000\000\000\0002\000\000.\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000$\000\000\000\000\154\000\000\000\000\000\000\000\000\000\000\000\000\000\000\156\000\000\000\000\000\000\000\000\000\000\146\000\000x\000\0008\000\000\000\000\000\000\000\000\000\000\026\000\000\000\000\000\000\000\000\b\000\0000\000\000\000\000\000\000\\\000\000\144\000\000\000\000\000\000X\000\000[\000\000\000\000L\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\000\0000\000\000\000\000\000\000\130\000\000[\000\000l\000\000\012\000\000.\000\000\000\000[\000\000\000\000.\000\000\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000[\000\000ְ\000\000[\000\000\130\000\000U\000\000\000\000\000\000\000\000\000\000.\000\000\000\000\000\000V\000\000l\000\000\000\000\000\000[\000\000\000\000\000\000\000\000\000\000n\000\000\000\000\000\000\000\000\000\000W\000\000ظ\000\000\000\000\000\000غ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000r\000\000\000\000\000\000X\000\000\000\000\000\000\000\000\000\000[\000\0002\000\000^\000\000\000\000\000\000\000\000\000\000\144\000\000\000\000\000\000\000\000\000\000\000\000ޢ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\146\000\000x\000\000ղ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000~\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\r\000\000\022\000\0006\000\000.\000\000H\000\000[\000\000\000\000\000\000\134\000\000վ\000\000.\000\000N\000\000[\000\000\000\000\000\000T\000\000[\000\000Y\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000G\000\000\000\000\000\000\000\000\138\000\0000\000\000:\000\000[\000\000\000\000\000\000\000\000\148\000\000¢\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000D\000\000¢\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000*\000\000\000\000\000\000\000\000\000\000Z\000\000\000\000\000\000\000\000\000\000\000\000N\000\000r\000\0000\000\000\000\000[\000\000\000\000\000\000\022\000\000\000\000h\000\000\000\000P\000\000,\000\000h\000\000d\000\000\000\000\000\000\000\000\000\000:\000\000\000\000[\000\000\000\000\000\000\000\000\000\000\000\000\000\000Z\000\000[\000\000\000\000\000\000[\000\000\000\000\000\000M\000\000\\\000\000[\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Ϻ\000\000h\000\000\000\000P\000\000X\000\000h\000\000,\000\000\000\000\000\000\000\000\000\000]\000\000֠\000\000^\000\000t\000\000\000\000\000\000\000\000\000\000l\000\000\000\000\000\000[\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000U\000\000\020\000\000\000\000\140\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000N\000\000r\000\0000\000\000\006\000\000\000\000\000\000\000\0002\000\000\000\000:\000\000\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\000\000h\000\000\000\000\000\000\000\000\000\000L\000\000\000\000\138\000\000\016\000\000\000\000\000\000v\000\000\000\000\000\000\000\000\000\000֠\000\000\000\000\000\000\000\000\000\000ֶ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000U\000\000Ͼ\000\000\000\000\000\000\000\000\000\000D\000\000\000\000\000\000(\000\000\000\000\000\000\000\000f\000\000\000\000\000\000\000\000\000\000\000\000\028\000\000\000\000\000\000z\000\000\000\000\000\001\014\b\000\000_\000\000\000\000\000\000\000\000\000\000\"\000\000\000\000\000\000\000\000\000\000$\000\000\000\000\000\000\000\000\000\000`\000\000.\000\000a\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0008\000\000\006\000\001\006\000\000Ψ\000\001\005\000\000.\000\000\000\000\000\000\000\000\000\000b\000\000\000\000\140\000\0008\000\000\000\000\000\000\000\000\000\000\000\000Դ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Т\000\000\000\000\000\000\000\000\000\000\000\000B\000\000\000\000\000\000J\000\000\026\000\000\000\000\140\000\000\000\000n\000\000\000\000\000\000\130\000\000\000\000\000\000P\000\000\000\000\000\000b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000x\000\000\000\000\000\000\000\000\000\000\000\000\150\000\000\000\000\000\000\000\000\022\000\000\000\000\000\000c\000\000\000\000\000\0002\000\000.\000\000\000\000\000\000\000\000\000\000\"\000\000\000\000\000\000\020\000\000\000\000\000\000\144\000\000\000\000\000\000\128\000\000U\000\000\026\000\000\000\000\000\000^\000\000\000\000\000\000Ӯ\000\000\148\000\000h\000\000\000\000\000\000L\000\000\000\000\000\000J\000\000\000\000\000\000d\000\000\000\000\000\000\000\000`\000\000\000\000\000\000T\000\000\000\000\000\000\150\000\000\000\000\000\000r\000\000Z\000\000\000\000\000\000\000\000\000\000.\000\000\000\000.\000\000\000\000\000\000\000\000\000\000\000\000\030\000\000Į\000\000\000\000\000\000\n\000\000P\000\000l\000\000\000\000\000\000\000\000\000\000\000\000\000\000.\000\000\000\000\000\000.\000\000H\000\000\000\000\000\000f\000\000H\000\000\000\000\000\000:\000\001\001\128\000\000f\000\000H\000\000\000\000\000\000~\000\000f\000\000H\000\000\000\000\000\000f\000\000H\000\000\000\000\000\000f\000\000H\000\000\000\000\000\000\150\000\000f\000\000H\000\000\000\000\000\000f\000\000H\000\000\000\000\000\000r\000\000f\000\000H\000\000\000\000\000\000t\000\000f\000\000H\000\000\000\000\000\000f\000\000H\000\000\000\000\000\000f\000\000H\000\000\000\000\000\000\000\000\000\000t\000\000\000\000\000\000\000\000\000\000x\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000ʮ\000\000f\000\000\140\000\000\138\000\000\142\000\000\000\000\000\000\000\000\000\000>\000\000R\000\000\000\000\154\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\130\000\000N\000\000\000\000G\000\000\000\000\000\000\144\000\000\000\000j\000\000h\000\000d\000\000h\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000٠\000\000\000\000\000\000l\000\000\000\000\000\000\000\000\000\000\000\000\127\148\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Ҩ\000\000\000\000\000\000\000\000U\000\000,\000\000\000\000\000\000\000\000\000\000e\000\000ȴ\000\000\000\000\000\000\000\000\000\000\028\000\000\000\000\000\000\000\000\000\000\134\000\000ٺ\000\000\134\000\000\000\000\000\000*\000\000\000\000\000\000\000\000\000\000.\000\000\000\000\000\000.\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\006\000\000>\000\000\000\000\000\000\000\000\000\000\000\000f\000\000\144\000\000ٴ\000\000\000\000j\000\000\n\000\001\tJ\000\000x\000\000l\000\000\144\000\000h\000\000\000\000\000\001\012@\000\000x\000\000h\000\000\000\000\000\000\000\001\012\140\000\000x\000\000h\000\000\000\000\000\000\000\001\012\000\000x\000\000h\000\000\000\000\000\001\rP\000\000x\000\000h\000\000\000\000\000\001\r\156\000\000x\000\000h\000\000\000\000\000\000\000\000\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\0000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000>\000\000L\000\000i\000\000\006\000\000\150\000\000P\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000h\000\000\136\000\000\000\000\000\0000\000\000*\000\000.\000\000P\000\000Z\000\000:\000\000\000\000\000\000\n\000\000:\000\000\000\000\000\000:\000\000\000\000\000\000\000\000\000\000j\000\000٪\000\000\000\000\000\000\000\000\142\000\0006\000\000\134\000\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000\000\000\000\000\000\000\001\nx\000\000<\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\t\000\000\000\142\000\000|\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000(\000\000\000\000\000\000\000\000h\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\001\0148\000\000T\000\000\142\000\000Ѽ\000\000\000\000\000\000\000\000\000\001\005v\000\000\142\000\000Ҷ\000\000\000\000Z\000\000\142\000\000<\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\020\000\000\000\000\000\000\000\000\020\000\000:\000\000\000\000\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000\000\020\000\000:\000\000\000\000\000\000\000\000\000\000Ѣ\000\000\128\000\000\144\000\000:\000\000\000\000\000\000\000\000\000\000\134\000\000\000\000\000\000\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\144\000\000\000\000\000\000\000\000\000\000\000\000\144\000\000\000\000\000\000^\000\000\144\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"), (16, "\n\149\n\149\n\149\n\149\n\149\n\149\001F\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\001J\n\149\n\149\n\149\n\149\n\149\n\149\001Z\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\001j\001z\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\tQ\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\007\133\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\0025\0025\0025\0025\0025\0025\001\001~\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\001\0025\0025\0025\0025\0025\0025\001\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\001\0025\003b\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\003\026\003\004\0025\0025\0025\0025\004\0025\004\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\002=\002=\002=\002=\002=\002=\001\001~\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\001\002=\002=\002=\002=\002=\002=\001\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\001\002=\003b\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\003\026\003\004\002=\002=\002=\002=\004\002=\004\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005f\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\006Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\bJ\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\006Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\006r\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\007\133\r\r\r\r\r\r\r\r\r\r\r\r\007\r\r\r\r\007\r\r\r\r\r\r\r\r\r\r\r\r\r\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\b&\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004e\004e\004e\004e\004e\004e\003Z\000>\004e\004e\002\142\004e\004e\004e\004e\004e\002\004e\004e\004e\004e\003^\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\0076\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\007:\007\004e\002\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\003\026\004e\004e\007\138\004e\004e\004e\007\142\004e\007\150\004e\007\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\007\b\002\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\b\n\004e\004e\004e\004e\004e\b\014\004e\004e\004e\004e\004e\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\bJ\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\004a\004a\004a\004a\004a\004a\003Z\000>\004a\004a\002\142\004a\004a\004a\004a\004a\002\004a\004a\004a\004a\003^\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\0076\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\007:\007\004a\002\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\003\026\004a\004a\007\138\004a\004a\004a\007\142\004a\007\150\004a\007\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\007\b\002\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\b\n\004a\004a\004a\004a\004a\b\014\004a\004a\004a\004a\004a\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\005f\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\b\154\n\n\n\n\n\n\n\n\n\n\b\n\n\n\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\b\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\n\002\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\n\006\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\n\n\002\133\002\133\002\133\002\133\002\133\b\002\133\002\133\002\133\002\133\002\133\002\133\002\133\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n2\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nB\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\nF\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\nZ\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\n^\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\nb\002\133\002\133\002\133\002\133\002\133\b\002\133\002\133\002\133\002\133\002\133\002\133\002\133\nn\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\nr\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\b\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\n\150\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011n\011\138\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011v\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011v\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\011n\011\138\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\011\150\0011\0011\0011\011v\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\011n\011\138\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\011v\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\011\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\011n\011\138\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\011v\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\011n\011\138\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\r\130\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\0031\0031\0031\0031\0031\0031\0031\000>\0031\0031\002\142\0031\0031\0031\0031\0031\002\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\002\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\002\0031\0031\0031\0031\0031\0031\002\0031\002\0031\0031\0031\0031\0031\000J\0031\0031\0031\0031\003\026\006\138\0031\006\0031\0031\0031\006\006\007\022\0031\007\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\007\b\002\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\b\n\0031\0031\0031\0031\011^\b\014\0031\0031\0031\0031\0031\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\011n\011\138\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\011v\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001\005\001\005\001\005\001\005\001\005\001\005\001\005\000>\001\005\001\005\002\142\001\005\001\005\001\005\001\005\001\005\002\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\002\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\002\001\005\001\005\001\005\001\005\001\005\001\005\002\r\154\002\001\005\001\005\001\005\001\005\001\005\000J\002\001\005\001\005\001\005\003\026\006\138\001\005\006\001\005\001\005\001\005\006\006\007\022\001\005\007\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\007\b\002\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\r\r\001\005\001\005\b\n\001\005\001\005\001\005\001\005\011^\b\014\001\005\001\005\001\005\001\005\001\005\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\011n\011\138\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\011v\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\001\t\001\t\001\t\001\t\001\t\001\t\001\t\000>\001\t\001\t\002\142\001\t\001\t\001\t\001\t\001\t\002\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\002\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\002\001\t\001\t\001\t\001\t\001\t\001\t\002\r\154\002\001\t\001\t\001\t\001\t\001\t\000J\002\001\t\001\t\001\t\003\026\006\138\001\t\006\001\t\001\t\001\t\006\006\007\022\001\t\007\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\007\b\002\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\r\r\001\t\001\t\b\n\001\t\001\t\001\t\001\t\011^\b\014\001\t\001\t\001\t\001\t\001\t\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\r\014&\001\001\001\001\001\001\001\001\001\001\014.\001\001\001\015\138\015\015\015\146\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\005f\001\001\001\001\001\001\001\r\015\154\015\015\015\001\001\001\001\015\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016\026\001\001\001\001\001\001\001\016\002\001\001\001\001\001\001\016\n\016\018\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\005f\001i\001i\001i\001i\001i\001i\001i\r\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\005f\001U\001U\001U\001U\001U\001U\001U\r\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\003-\003-\003-\003-\003-\003-\003-\000>\003-\003-\002\142\003-\003-\003-\003-\003-\002\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\002\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\002\003-\003-\003-\003-\003-\003-\002\003-\002\003-\003-\003-\003-\003-\000J\003-\003-\003-\003-\003\026\006\138\003-\006\003-\003-\003-\006\006\007\022\003-\007\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\007\b\002\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\b\n\003-\003-\003-\003-\011^\b\014\003-\003-\003-\003-\003-\004I\004I\004I\004I\004I\004I\004I\000>\004I\004I\002\142\004I\004I\004I\004I\004I\002\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\002\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\002\004I\004I\004I\004I\004I\004I\002\004I\002\004I\004I\004I\004I\004I\000J\002\004I\004I\004I\003\026\006\138\004I\006\004I\004I\004I\006\006\007\022\004I\007\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\007\b\002\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\b\n\004I\004I\004I\004I\011^\b\014\004I\004I\004I\004I\004I\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\005f\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\005f\001Q\001Q\001Q\001Q\001Q\001Q\001Q\r\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\r\014&\001\001\001\001\001\001\001\001\001\001\014.\001\001\001\015\138\015\015\015\146\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\005f\001\001\001\001\001\001\001\r\015\154\015\015\015\001\001\001\001\015\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016\026\001\001\001\001\001\001\001\016\002\001\001\001\001\001\001\016\n\016\018\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\r\014&\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\015\146\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\005f\001\137\001\137\001\137\001\137\001\137\001\137\001\137\r\015\154\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\005f\001\141\001\141\001\141\001\141\001\141\001\141\001\141\r\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\005f\001M\001M\001M\001M\001M\001M\001M\r\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\r\014&\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\015\146\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\005f\001]\001]\001]\001]\001]\001]\001]\r\015\154\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\r\014&\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\015\146\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\005f\001Y\001Y\001Y\001Y\001Y\001Y\001Y\r\015\154\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\r\014&\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015\138\015\015\015\146\015\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015\015\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015\015\001u\001u\001u\001u\001u\001u\001u\005f\001u\001u\001u\001u\001u\001u\001u\r\015\154\015\015\015\001u\001u\001u\001u\015\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\016\002\001u\001u\001u\001u\001u\001u\016\n\016\018\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\r\014&\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\015\146\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\005f\001e\001e\001e\001e\001e\001e\001e\r\015\154\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\r\014&\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\015\146\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\005f\001a\001a\001a\001a\001a\001a\001a\r\015\154\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\r\014&\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\015\138\015\015\015\146\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\015\015\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\005f\001\145\001\145\001\145\001\145\001\145\001\145\001\145\r\015\154\015\015\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\r\014&\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\015\146\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\005f\001I\001I\001I\001I\001I\001I\001I\r\015\154\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\r\014&\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\015\138\015\015\015\146\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\015\015\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\005f\001E\001E\001E\001E\001E\001E\001E\r\015\154\015\015\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\r\014&\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015\138\015\015\015\146\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015\015\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015\001m\001m\001m\001m\001m\001m\001m\001m\005f\001m\001m\001m\001m\001m\001m\001m\r\015\154\015\015\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\r\014&\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015\138\015\015\015\146\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015\015\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015\001A\001A\001A\001A\001A\001A\001A\001A\005f\001A\001A\001A\001A\001A\001A\001A\r\015\154\015\015\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\r\014&\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015\138\015\015\015\146\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015\015\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\005f\001\149\001\149\001\149\001\149\001\149\001\149\001\149\r\015\154\015\015\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\r\014&\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015\138\015\015\015\146\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015\015\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015\001q\001q\001q\001q\001q\001q\001q\001q\005f\001q\001q\001q\001q\001q\001q\001q\r\015\154\015\015\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\r\014&\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015\138\015\015\015\146\015\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015\015\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015\015\001y\001y\001y\001y\001y\001y\001y\005f\001y\001y\001y\001y\001y\001y\001y\r\015\154\015\015\015\001y\001y\001y\001y\015\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\016\002\001y\001y\001y\001y\001y\001y\016\n\016\018\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\r\014&\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015\138\015\015\015\146\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015\015\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015\015\001}\001}\001}\001}\001}\001}\001}\005f\001}\001}\001}\001}\001}\001}\001}\r\015\154\015\015\015\001}\001}\001}\001}\015\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\016\n\016\018\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\r\014&\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015\138\015\015\015\146\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015\015\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015\015\001\129\001\129\001\129\001\129\001\129\001\129\001\129\005f\001\129\001\129\001\129\001\129\001\129\001\129\001\129\r\015\154\015\015\015\001\129\001\129\001\129\001\129\015\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\016\n\016\018\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\r\014&\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\014.\001\133\001\133\001\133\015\138\015\015\015\146\015\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015\015\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015\015\001\133\001\133\001\133\001\133\001\133\001\133\001\133\005f\001\133\001\133\001\133\001\133\001\133\001\133\001\133\r\015\154\015\015\015\001\133\001\133\001\133\001\133\015\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\016\026\001\133\001\133\001\133\001\133\001\133\001\133\001\133\016\002\001\133\001\133\001\133\001\133\001\133\001\133\016\n\016\018\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\016.\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\r\014&\001\001\001\001\001\001\001\001\001\001\014.\001\001\001\015\138\015\015\015\146\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\005f\001\001\001\001\001\001\001\r\015\154\015\015\015\001\001\001\001\015\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016\026\001\001\001\001\001\001\001\016\002\001\001\001\001\001\001\016\n\016\018\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\016F\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\r\014&\001\001\001\001\001\001\001\001\001\001\014.\001\001\001\015\138\015\015\015\146\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\005f\001\001\001\001\001\001\001\r\015\154\015\015\015\001\001\001\001\015\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016\026\001\001\001\001\001\001\001\016\002\001\001\001\001\001\001\016\n\016\018\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\016Z\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\r\014&\001\001\001\001\001\001\001\001\001\001\014.\001\001\001\015\138\015\015\015\146\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\005f\001\001\001\001\001\001\001\r\015\154\015\015\015\001\001\001\001\015\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016\026\001\001\001\001\001\001\001\016\002\001\001\001\001\001\001\016\n\016\018\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\016f\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\r\014&\001\001\001\001\001\001\001\001\001\001\014.\001\001\001\015\138\015\015\015\146\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\001\001\001\015\015\001\001\001\001\001\001\001\005f\001\001\001\001\001\001\001\r\015\154\015\015\015\001\001\001\001\015\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016\026\001\001\001\001\001\001\001\016\002\001\001\001\001\001\001\016\n\016\018\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\005f\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\r\014&\006\006\006\006\006\006\006\006\006\006\014.\006\006\006\015\138\015\015\015\146\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\005f\006\006\006\006\006\006\006\r\015\154\015\015\015\006\006\006\006\015\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017Z\016\026\006\006\017b\006\006\006\006\016\002\006\006\006\006\006\006\016\n\016\018\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\017n\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\017\150\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\r\014&\006\006\006\006\006\017\154\006\006\006\006\014.\006\006\006\015\138\015\015\015\146\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\005f\006\006\006\006\006\006\006\r\015\154\015\015\015\006\006\006\006\015\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\158\016\026\006\006\017\006\006\006\006\016\002\006\006\006\006\006\006\016\n\016\018\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\006Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005f\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\r\149\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\r\149\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\022\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\ny\ny\ny\ny\ny\021\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\021\022:\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\011J\ny\ny\ny\ny\011R\ny\ny\ny\ny\ny\ny\ny\ny\022R\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\022\134\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\r\014&\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\014.\006i\006i\006i\015\138\015\015\015\146\015\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\015\015\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\015\015\006i\006i\006i\006i\006i\006i\006i\005f\006i\006i\006i\006i\006i\006i\006i\r\015\154\015\015\015\006i\006i\006i\006i\015\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\016\026\006i\006i\006i\006i\006i\006i\006i\016\002\006i\006i\006i\006i\006i\006i\016\n\016\018\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\r\014&\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\014.\011\025\011\025\011\025\015\138\015\015\015\146\015\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\015\015\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\015\015\011\025\011\025\011\025\011\025\011\025\011\025\006Z\005f\011\025\011\025\011\025\011\025\011\025\011\025\011\025\r\015\154\015\015\015\011\025\011\025\011\025\011\025\015\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\016\026\011\025\011\025\011\025\011\025\011\025\011\025\011\025\016\002\011\025\011\025\011\025\011\025\011\025\011\025\016\n\016\018\n\149\n\149\n\149\n\149\n\149\n\149\001F\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\001J\n\149\n\149\n\149\n\149\n\149\n\149\001Z\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\001j\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\153\n\153\n\153\n\153\n\153\n\153\001F\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\001J\n\153\n\153\n\153\n\153\n\153\n\153\001Z\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\001j\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\029\004\004\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\r\014&\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\014.\bI\bI\bI\015\138\015\015\015\146\015\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\015\015\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\015\015\bI\bI\bI\bI\bI\bI\bI\005f\bI\bI\bI\bI\bI\bI\bI\r\015\154\015\015\015\bI\bI\bI\bI\015\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\016\026\bI\bI\bI\bI\bI\bI\bI\016\002\bI\bI\bI\bI\bI\bI\016\n\016\018\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\r\014&\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\014.\bE\bE\bE\015\138\015\015\015\146\015\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\015\015\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\015\015\bE\bE\bE\bE\bE\bE\bE\005f\bE\bE\bE\bE\bE\bE\bE\r\015\154\015\015\015\bE\bE\bE\bE\015\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\016\026\bE\bE\bE\bE\bE\bE\bE\016\002\bE\bE\bE\bE\bE\bE\016\n\016\018\011\025\011\025\011\025\011\025\011\025\011\025\011\025\000>\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\018\014\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\003\026\011\025\011\025\011\025\011\025\006Z\005f\011\025\011\025\017\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025!j\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\r\014&\006\006\006\006\006!n\006\006\006\006\014.\006\006\006\015\138\015\015\015\146\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\005f\006\006\006\006\006\006\006\r\015\154\015\015\015\006\006\006\006\015\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\158\016\026\006\006\017\006\006\006\006\016\002\006\006\006\006\006\006\016\n\016\018\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\016\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\r\014&\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015\138\015\015\015\146\015\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015\015\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015\015\001-\001-\001-\001-\001-\001-\001-\005f\001-\001-\001-\001-\001-\001-\001-\r\015\154\015\015\015\001-\001-\001-\001-\015\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\016\002\001-\001-\001-\001-\001-\001-\016\n\016\018\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\011n\011\138\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\011v\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\"\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\r\014&\006\006\006\006\006\"\006\006\006\006\014.\006\006\006\015\138\015\015\015\146\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\005f\006\006\006\006\006\006\006\r\015\154\015\015\015\006\006\006\006\015\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\158\016\026\006\006\017\006\006\006\006\016\002\006\006\006\006\006\006\016\n\016\018\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\r\014&\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\014.\b5\b5\b5\015\138\015\015\015\146\015\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\015\015\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\015\015\b5\b5\b5\b5\b5\b5\b5\005f\b5\b5\b5\b5\b5\b5\b5\r\015\154\015\015\015\b5\b5\b5\b5\015\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\016\026\b5\b5\b5\b5\b5\b5\b5\016\002\b5\b5\b5\b5\b5\b5\016\n\016\018\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu$z\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\029\nu\nu\ny\ny\000\n\ny\ny\ny\ny\000>\ny\000B\002\142\ny\ny\ny\002\146\ny\002\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\002\ny\002\002\005n\ny\ny\n}\ny\ny\ny\002\ny\ny\007\026\ny\002\002\002\ny\003\022\007\"\ny\ny\ny\ny\000J\002\ny\ny\ny\003\026\006\138\ny\006\ny\ny\ny\006\006\007\022\011Z\007\ny\ny\ny\ny\ny\ny\ny\ny\ny\011~\ny\ny\ny\ny\011\154\011\007\b\002\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\b\n\ny\ny\ny\ny\011^\b\014\rF\ny\ny\ny\ny\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu$\146\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005$\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\007\r\r\r\r\007\r\r\r\r\r\r\r\r\r\r\r\r\r\011\025\027\154\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\006Z\005f\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\028>\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000'J\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\r\014&\006\006\006\006\006'N\006\006\006\006\014.\006\006\006\015\138\015\015\015\146\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\006\006\006\015\015\006\006\006\006\006\006\006\005f\006\006\006\006\006\006\006\r\015\154\015\015\015\006\006\006\006\015\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\158\016\026\006\006\017\006\006\006\006\016\002\006\006\006\006\006\006\016\n\016\018\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011n\011\138\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011v\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\006Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025)\158\011\025\011\025\011\025\011\025\011\025\011\025\011\025\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\011n\011\138\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\011v\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\001:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\0025\0025\0025\0025\0025\001\001~\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\001\0025\0025\0025\0025\0025\0025\001\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\002\014\0025\002J\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\000Z\002N\002Z\0025\0025\0025\0025\002f\0025\002j\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\002\134\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\n\133\n\133\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\n\133\005U\005U\005U\005U\005U\005U\n\133\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\004\018\005U\005U\005U\005U\005U\005U\005U\005U\005U\n\133\n\133\n\133\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\n\133\n\133\n\133\005U\005U\005U\002\134\n\133\005U\n\133\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\n\133\005U\002=\002=\002=\002=\002=\001\001~\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\001\002=\002=\002=\002=\002=\002=\001\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002\014\002=\002J\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\000Z\002N\002Z\002=\002=\002=\002=\002f\002=\002j\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\002\134\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\004\130\005U\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\006\011\"\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\006\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\006\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\tV\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004e\004e\004e\004e\004e\003&\000\014\004e\004e\000\018\004e\004e\004e\004e\004e\000\022\004e\004e\004e\004e\003*\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\003>\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\003J\t.\004e\000F\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\000Z\004e\004e\0072\004e\004e\004e\b\004e\t\026\004e\006\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\006\006\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\006\004e\004e\004e\004e\004e\003\004e\004e\004e\004e\004e\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\006\146\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\004a\004a\004a\004a\004a\003&\000\014\004a\004a\000\018\004a\004a\004a\004a\004a\000\022\004a\004a\004a\004a\003*\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\003>\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\003J\t.\004a\000F\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\000Z\004a\004a\0072\004a\004a\004a\b\004a\t\026\004a\006\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\006\006\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\006\004a\004a\004a\004a\004a\003\004a\004a\004a\004a\004a\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\002\134\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\t\n\n\n\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\t\002\133\002\133\002\133\002\133\002\133\t\002\133\002\133\002\133\002\133\002\133\002\133\002\133\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\0116\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\006\011\"\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\006\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\006\011\"\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\012\0011\0011\0011\006\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\006\011\"\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\006\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\006\011\"\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\006\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\006\011\"\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\r>\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\0031\0031\0031\0031\0031\0031\000\014\0031\0031\000\018\0031\0031\0031\0031\0031\000\022\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\000\026\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\000\030\0031\0031\0031\0031\0031\0031\000:\0031\000F\0031\0031\0031\0031\0031\000J\0031\0031\0031\0031\000Z\002\150\0031\002\158\0031\0031\0031\002\002\006\0031\006\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\006\006\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\006\0031\0031\0031\0031\006\003\0031\0031\0031\0031\0031\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\006\011\"\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\006\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001\005\001\005\001\005\001\005\001\005\001\005\000\014\001\005\001\005\000\018\001\005\001\005\001\005\001\005\001\005\000\022\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\000\026\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\000\030\001\005\001\005\001\005\001\005\001\005\001\005\000:\014B\000F\001\005\001\005\001\005\001\005\001\005\000J\000V\001\005\001\005\001\005\000Z\002\150\001\005\002\158\001\005\001\005\001\005\002\002\006\001\005\006\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\006\006\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\014V\014Z\001\005\001\005\006\001\005\001\005\001\005\001\005\006\003\001\005\001\005\001\005\001\005\001\005\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\006\011\"\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\006\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\001\t\001\t\001\t\001\t\001\t\001\t\000\014\001\t\001\t\000\018\001\t\001\t\001\t\001\t\001\t\000\022\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\000\026\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\000\030\001\t\001\t\001\t\001\t\001\t\001\t\000:\014B\000F\001\t\001\t\001\t\001\t\001\t\000J\000V\001\t\001\t\001\t\000Z\002\150\001\t\002\158\001\t\001\t\001\t\002\002\006\001\t\006\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\006\006\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\014V\014Z\001\t\001\t\006\001\t\001\t\001\t\001\t\006\003\001\t\001\t\001\t\001\t\001\t\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\146\014\001\001\001\001\001\001\001\001\001\001\014\001\001\001\014\014\014\014\015\006\001\001\001\001\001\001\001\001\001\001\015\014\015\022\001\001\001\001\001\001\001\001\001\001\015\030\0156\001\001\001\001\001\001\001\002\134\001\001\001\001\001\001\001\014\154\014\015&\015.\015>\001\001\001\001\015F\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015n\001\001\001\001\001\001\001\015V\001\001\001\001\001\001\015^\015f\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\002\134\001i\001i\001i\001i\001i\001i\001i\014\154\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\002\134\001U\001U\001U\001U\001U\001U\001U\014\154\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\003-\003-\003-\003-\003-\003-\000\014\003-\003-\000\018\003-\003-\003-\003-\003-\000\022\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\000\026\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\000\030\003-\003-\003-\003-\003-\003-\000:\003-\000F\003-\003-\003-\003-\003-\000J\003-\003-\003-\003-\000Z\002\150\003-\002\158\003-\003-\003-\002\002\006\003-\006\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\006\006\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\006\003-\003-\003-\003-\006\003\003-\003-\003-\003-\003-\004I\004I\004I\004I\004I\004I\000\014\004I\004I\000\018\004I\004I\004I\004I\004I\000\022\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\000\026\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\000\030\004I\004I\004I\004I\004I\004I\000:\004I\000F\004I\004I\004I\004I\004I\000J\000V\004I\004I\004I\000Z\002\150\004I\002\158\004I\004I\004I\002\002\006\004I\006\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\006\006\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\006\004I\004I\004I\004I\006\003\004I\004I\004I\004I\004I\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\002\134\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\002\134\001Q\001Q\001Q\001Q\001Q\001Q\001Q\014\154\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\014\146\014\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\014\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\002\134\001\137\001\137\001\137\001\137\001\137\001\137\001\137\014\154\014\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\002\134\001\141\001\141\001\141\001\141\001\141\001\141\001\141\014\154\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\002\134\001M\001M\001M\001M\001M\001M\001M\014\154\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\014\146\014\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\014\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\002\134\001]\001]\001]\001]\001]\001]\001]\014\154\014\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\014\146\014\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\014\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\002\134\001Y\001Y\001Y\001Y\001Y\001Y\001Y\014\154\014\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\014\146\014\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\014\014\014\014\015\006\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015\014\015\022\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015\030\0156\001u\001u\001u\001u\001u\001u\001u\002\134\001u\001u\001u\001u\001u\001u\001u\014\154\014\015&\015.\015>\001u\001u\001u\001u\015F\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015V\001u\001u\001u\001u\001u\001u\015^\015f\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\014\146\014\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\014\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\002\134\001e\001e\001e\001e\001e\001e\001e\014\154\014\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\014\146\014\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\014\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\002\134\001a\001a\001a\001a\001a\001a\001a\014\154\014\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\014\146\014\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\014\014\014\014\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\015\014\015\022\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\002\134\001\145\001\145\001\145\001\145\001\145\001\145\001\145\014\154\014\015&\015.\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\014\146\014\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\014\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\002\134\001I\001I\001I\001I\001I\001I\001I\014\154\014\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\014\146\014\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\014\014\014\014\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\015\014\015\022\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\002\134\001E\001E\001E\001E\001E\001E\001E\014\154\014\015&\015.\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\014\146\014\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\014\014\014\014\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015\014\015\022\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015\030\001m\001m\001m\001m\001m\001m\001m\001m\002\134\001m\001m\001m\001m\001m\001m\001m\014\154\014\015&\015.\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\014\146\014\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\014\014\014\014\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015\014\015\022\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015\030\001A\001A\001A\001A\001A\001A\001A\001A\002\134\001A\001A\001A\001A\001A\001A\001A\014\154\014\015&\015.\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\014\146\014\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\014\014\014\014\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015\014\015\022\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015\030\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\002\134\001\149\001\149\001\149\001\149\001\149\001\149\001\149\014\154\014\015&\015.\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\014\146\014\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\014\014\014\014\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015\014\015\022\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015\030\001q\001q\001q\001q\001q\001q\001q\001q\002\134\001q\001q\001q\001q\001q\001q\001q\014\154\014\015&\015.\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\014\146\014\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\014\014\014\014\015\006\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015\014\015\022\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015\030\0156\001y\001y\001y\001y\001y\001y\001y\002\134\001y\001y\001y\001y\001y\001y\001y\014\154\014\015&\015.\015>\001y\001y\001y\001y\015F\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015V\001y\001y\001y\001y\001y\001y\015^\015f\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\014\146\014\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\014\014\014\014\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015\014\015\022\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015\030\0156\001}\001}\001}\001}\001}\001}\001}\002\134\001}\001}\001}\001}\001}\001}\001}\014\154\014\015&\015.\015>\001}\001}\001}\001}\015F\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015^\015f\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\014\146\014\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\014\014\014\014\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015\014\015\022\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015\030\0156\001\129\001\129\001\129\001\129\001\129\001\129\001\129\002\134\001\129\001\129\001\129\001\129\001\129\001\129\001\129\014\154\014\015&\015.\015>\001\129\001\129\001\129\001\129\015F\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015^\015f\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\014\146\014\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\014\001\133\001\133\001\133\014\014\014\014\015\006\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015\014\015\022\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015\030\0156\001\133\001\133\001\133\001\133\001\133\001\133\001\133\002\134\001\133\001\133\001\133\001\133\001\133\001\133\001\133\014\154\014\015&\015.\015>\001\133\001\133\001\133\001\133\015F\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015n\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015V\001\133\001\133\001\133\001\133\001\133\001\133\015^\015f\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\146\014\001\001\001\001\001\001\001\001\001\001\014\001\001\001\014\014\014\014\015\006\001\001\001\001\001\001\001\001\001\001\015\014\015\022\001\001\001\001\001\001\001\001\001\001\015\030\0156\001\001\001\001\001\001\001\002\134\001\001\001\001\001\001\001\014\154\014\015&\015.\015>\001\001\001\001\015F\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015n\001\001\001\001\001\001\001\015V\001\001\001\001\001\001\015^\015f\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\016~\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\146\014\001\001\001\001\001\001\001\001\001\001\014\001\001\001\014\014\014\014\015\006\001\001\001\001\001\001\001\001\001\001\015\014\015\022\001\001\001\001\001\001\001\001\001\001\015\030\0156\001\001\001\001\001\001\001\002\134\001\001\001\001\001\001\001\014\154\014\015&\015.\015>\001\001\001\001\015F\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015n\001\001\001\001\001\001\001\015V\001\001\001\001\001\001\015^\015f\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\016\150\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\146\014\001\001\001\001\001\001\001\001\001\001\014\001\001\001\014\014\014\014\015\006\001\001\001\001\001\001\001\001\001\001\015\014\015\022\001\001\001\001\001\001\001\001\001\001\015\030\0156\001\001\001\001\001\001\001\002\134\001\001\001\001\001\001\001\014\154\014\015&\015.\015>\001\001\001\001\015F\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015n\001\001\001\001\001\001\001\015V\001\001\001\001\001\001\015^\015f\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\016\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\146\014\001\001\001\001\001\001\001\001\001\001\014\001\001\001\014\014\014\014\015\006\001\001\001\001\001\001\001\001\001\001\015\014\015\022\001\001\001\001\001\001\001\001\001\001\015\030\0156\001\001\001\001\001\001\001\002\134\001\001\001\001\001\001\001\014\154\014\015&\015.\015>\001\001\001\001\015F\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015n\001\001\001\001\001\001\001\015V\001\001\001\001\001\001\015^\015f\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\016\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\146\014\001\001\001\001\001\001\001\001\001\001\014\001\001\001\014\014\014\014\015\006\001\001\001\001\001\001\001\001\001\001\015\014\015\022\001\001\001\001\001\001\001\001\001\001\015\030\0156\001\001\001\001\001\001\001\002\134\001\001\001\001\001\001\001\014\154\014\015&\015.\015>\001\001\001\001\015F\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015n\001\001\001\001\001\001\001\015V\001\001\001\001\001\001\015^\015f\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\002\134\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\014\146\014\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\014\014\014\014\015\006\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015\014\015\022\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015\030\0156\001-\001-\001-\001-\001-\001-\001-\002\134\001-\001-\001-\001-\001-\001-\001-\014\154\014\015&\015.\015>\001-\001-\001-\001-\015F\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015V\001-\001-\001-\001-\001-\001-\015^\015f\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\017\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\r=\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\n\149\n\149\n\149\n\149\n\149\018n\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\018r\n\149\n\149\n\149\n\149\n\149\n\149\018z\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\018\138\001z\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\tQ\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\153\n\153\n\153\n\153\n\153\018n\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\018r\n\153\n\153\n\153\n\153\n\153\n\153\018z\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\018\138\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\153\n\149\n\149\n\149\n\149\n\149\018n\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\018r\n\149\n\149\n\149\n\149\n\149\n\149\018z\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\018\138\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\n\149\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\020Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\014\146\014\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\014\006i\006i\006i\014\014\014\014\015\006\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\015\014\015\022\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\015\030\0156\006i\006i\006i\006i\006i\006i\006i\002\134\006i\006i\006i\006i\006i\006i\006i\014\154\014\015&\015.\015>\006i\006i\006i\006i\015F\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\006i\015n\006i\006i\006i\006i\006i\006i\006i\015V\006i\006i\006i\006i\006i\006i\015^\015f\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\014\146\014\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\014\b5\b5\b5\014\014\014\014\015\006\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\015\014\015\022\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\015\030\0156\b5\b5\b5\b5\b5\b5\b5\002\134\b5\b5\b5\b5\b5\b5\b5\014\154\014\015&\015.\015>\b5\b5\b5\b5\015F\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\b5\015n\b5\b5\b5\b5\b5\b5\b5\015V\b5\b5\b5\b5\b5\b5\015^\015f\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\014\146\014\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\014\bI\bI\bI\014\014\014\014\015\006\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\015\014\015\022\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\015\030\0156\bI\bI\bI\bI\bI\bI\bI\002\134\bI\bI\bI\bI\bI\bI\bI\014\154\014\015&\015.\015>\bI\bI\bI\bI\015F\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\bI\015n\bI\bI\bI\bI\bI\bI\bI\015V\bI\bI\bI\bI\bI\bI\015^\015f\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\014\146\014\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\014\bE\bE\bE\014\014\014\014\015\006\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\015\014\015\022\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\015\030\0156\bE\bE\bE\bE\bE\bE\bE\002\134\bE\bE\bE\bE\bE\bE\bE\014\154\014\015&\015.\015>\bE\bE\bE\bE\015F\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\bE\015n\bE\bE\bE\bE\bE\bE\bE\015V\bE\bE\bE\bE\bE\bE\015^\015f\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\020Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\006\146\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\020Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\028\142\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\028\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\020Z\002\134\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\028\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\020Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025 \150\011\025\011\025\011\025\011\025\011\025\011\025\011\025\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\014\146\014\006\006\006\006\006\006\006\006\006\006\014\006\006\006\014\014\014\014\015\006\006\006\006\006\006\006\006\006\006\006\015\014\015\022\006\006\006\006\006\006\006\006\006\006\015\030\0156\006\006\006\006\006\006\006\002\134\006\006\006\006\006\006\006\014\154\014\015&\015.\015>\006\006\006\006\015F\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\158\015n\006\006\017\006\006\006\006\015V\006\006\006\006\006\006\015^\015f\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu%r\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\025\nu\nu\ny\002\ny\ny\ny\ny\000\014\ny\006\000\018\ny\ny\ny\006\ny\000\022\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\000\026\ny\002\002\005n\ny\ny\n}\ny\ny\ny\000\030\ny\ny\007\026\ny\002\002\0122\ny\012\154%&\ny\ny\ny\ny\000J\000V\ny\ny\ny\000Z\002\150\ny\002\158\ny\ny\ny\002\002\006\012\158\006\ny\ny\ny\ny\ny\ny\ny\ny\ny\012\ny\ny\ny\ny\012\r\018\006\006\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\006\ny\ny\ny\ny\006\003\r.\ny\ny\ny\ny\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\014\146\014\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\014\011\025\011\025\011\025\014\014\014\014\015\006\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\015\014\015\022\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\015\030\0156\011\025\011\025\011\025\011\025\011\025\011\025\020Z\002\134\011\025\011\025\011\025\011\025\011\025\011\025\011\025\014\154\014\015&\015.\015>\011\025\011\025\011\025\011\025\015F\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\015n\011\025\011\025\011\025\011\025\011\025\011\025\011\025\015V\011\025\011\025\011\025\011\025\011\025\011\025\015^\015f\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu%\138\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\nu\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006'V\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\006\011\"\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\006\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\006\011\"\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\006\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\020Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025*\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\020Z\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025+B\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\000\014\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\012*\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\000Z\011\025\011\025\011\025\011\025\020Z\002\134\011\025\011\025\011B\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\011\025\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\025\004\004\005\002z\000\014\001^\0079\0079\004\005\018b\021r\005\007\000>\021v\012\002\142\005\005\005\002r\005\005\000*\005\002r\001b\t\145\005\0079\005#\t\145\005\005\005\005\005\005\007\028r\001~\012\002&\005\012\002\018Z\028\130\000\"\005\005\005\005\005\029\"\001z\020\154\001\134\r\005\005\005\005\0296\005\005\n\005\030*\005\005\005\005\005\0079\005\020\158\003\005\005\005\005\005\030:\026\006v\026^\005\003\018V\001\142\001R\005\005\030F\030j\000.\000Z\b\002\011\141\0079\003\003\026\001\018\005\026b\018\n\tQ\012\018^\005\005\005\006\030\005\001\007\017\005\007\005\005\000\n\001\007\005\005\000>\001B\000B\002\142\000\014\rM\ni\002\146\001\138\002\002\002\0002\n\003\011!\003\002\019\n\002F\002J\024z\n\n\n\002\002\002\002\003\002\003\006\000Z\002N\002Z(\014\n\002\n\019\026\003\n\002j\012\134\012\138\002\n\003\022)z\b\001\002\rM\000J\002\007\130\007\134\003\003\026\006\138\002\006\019N\n\n\006\006\007\022\011Z\007\001n\n\007\007\007\007\007\000\003\011~\018\007\rM\019Z\011\154\011\007\b\002\021\n\019f\rM\001r\ni\000\014\006N(\018+\026\001\001\000\006(z+\030\000\n\b\130\002\030'\026\rM\r\021\b\n\003\003\b\134&\017F\b\014\rF\000\n\001\b\142\b\146\025\000>\005\000B\002\142\n\021\003\002\146\n\002\002\002\011&\t\011\r\000F\006N\003v(\138\005B\003b\006Z\005f\026\002\007a\002\002\002\002\003\002\003\006\003\026\003\004\002*\000.\002+\"(\154\0126\004\012\134\012\138\002\000R\003\022\005\002\134\001N\n\005f\000J\002\007\130\007\134+&\003\026\006\138\000N\006(\r\021\006\006\006\007\022\011Z\007\005f\003\150\007\007\007\007\007\r\141\005\011~\011:\007\000F(\011\154\011\007\b\002\006\0026(\nq\006f\002\007a\001R\"\021\001\001~\"#&#:\000\014)\005\b\130\025\142\012\142\nq\t\b\n\006\146\001\b\134\026\006\017F\b\014\rF\000\n\001\b\142\b\146\003B\000>\001\154\000B\002\142\000\014\n]\030Z\002\146\n]\002\002\002\000\014\011)(N\000\018\003F\002B\002\014\002F\002J\0119\023\006\n\001\002\002\002\002\003\002\003\006\000Z\002N\002Z\028\003\026\002\003\154\002f\011>\002j\012\134\012\138\002\023\n\003\022\n\003\014\n]\n\001\000J\002\007\130\007\134*\142\003\026\006\138\011)\006\000Z\023\007\006\006\007\022\011Z\007\n]\011B\007\007\007\007\007*\146\002\130\011~\028\007\002\001\138\011\154\011\007\b\002\011\024\002\011)\007\n]\000\n\012\002\012\006\006\158\000\014\000>\006\000B\002\142\t\129\0312\002\134\002\146\b\130\002\002\002\bY\b\n\012\n\n]\b\134'^\017F\b\014\rF\007\002R\b\142\b\146\002\002\002\002\003\002\003\006\017~\028 \018\001\138\006E\002\ne\018~\011\n\012\134\012\138\002+\003\022\031\"\b\007\t\129\002\134\000J\002\007\130\007\134\ne\003\026\006\138\006E\006\018\130\006E\006E\006\006\007\022\011Z\007+\0036\007\007\007\007\007\007\028\011~\002\154\007\000M\006\011\154\011\007\b\002\b\000^\000b\000f\000j\000n\bY\000r\000v\000z\000~\000\130\003\158\000\134\000\138\000\142\004\006E\b\130\000\146\t\129\000M\000.\b\n\0316\000\150\b\134\005f\017F\b\014\rF\000\154\005\014\b\142\b\146\r\ne\000\158\n\000\000\000\000\000\007\000\000\006E\000\014!\000\014\006v\000\000\017\130\018V\006E\001R\r#\006\n\r\005f\n\012>\b\001\003\026(\ni\n+\000\006E\000\000\018^\019\003N\005J\018\000\000\000\r\r\000\000\000\000\012*\000\000\000\007\154\003R\006E\004\000\000\001\002\019\r\000Z\001\006\001\n\001\014\r\r\002\134\r\r\011B\004\001\018\b\001\022\002\n\002\134\019\027>\001\026\001\030\001\"\005r\005v\005z\005~\005\130\024\142\005\134\005\138\005\142\005\146\005\150\t\005\154\005\158\005\019\006E\0111\005 j&\146\n\012\012\005\007^\ne\r\r\012B\005\002\002\b\005\000\029\000\029\005\019N\005\005\005\005\005\n\005\005\006E\019j\019\007b\019v\005\005\002n\r\006E\005\r\019Z\005\005\t\006N\000F\rE\019f\027\n\019f\011\007\002r\005\006E\005\005\002\006\004\t\145\000\029\002\134\005\005\005\r\003n\005\005\005\005\019\130\006\002\006\006\006\n\012\n\001\134\007\006\014\006\018\006\022\005\005f\007\n\006\026\006\030\006\"\000\029\005\022\rE\019\146\000\006\005f\000\n\006&\027V\006*\003\146\000>\0016\000B\002\142\006.\0062\0066\002\146\028\002\011m\002v'\005\019\027~*\006\ni\000\029\012\012\rE\003\"\027\150\027\154\002\n\002\002\005n\020\030 \002\006J\025%\019\002\011m\b\154\006b\005\002\002\002\004Q\003\022\011F\028:\rE\b\n\000J\002\003\024\011J\003\026\006\138\0036\006\011R\007\b\006\006\007\022\011Z\007\017\158\n\007\014\004Q\017\007\007\017\002\134\011~\002\022\015\007\000\014\011\154\011\007\b\002\020b\020\142\004Q\023\020\146\012\005f\020\t\004Q\005I\r\005I\004Q\007\007\028\005I\005I\005I\005I\021f\021n\b\n\005I'\138\005I\002\001\011^\b\014\rF\012\022\028>\r\r\027\130\005I\002\006\003\134\005I\007\154\016\005I\r\137\005I\005I\005I\020\000Z\005I\021\134\007R\003\005I\002\003\138\005I\028n\005I\005I\005I\b\005I\005I\021\138&&\026\021\n\005I\005I\005i\rI\005I\005I\005I\003\005I\005I\r\r\005I\005I\005I\005I\005I\006\011\"\006\004\021&\006\011\"\005I\005i\005I\002\001\005i\005i\004\005I\005I\005I\005I\005I\005I\r\r\004\r\004Q\021>\021\142\n\000\157\001*\000\n\rI\020\030\000\157\004r\000> >\000B\002\142\005I\005I\005I\002\146\018\142\006\021r\005I\005I\005I\030\r\004Q&\"\005i\005f\000\157\007V%\018\000\157\000\157\002\rI\002\002\005n\018\146\000\014\n}\004Q\029\020\030\002\006\011\"\007\026\004Q\002\002\002\004Q\007\030\007\")>\005i\006(z\000J\002\rI\006\000\157\003\026\006\138\r\006\000\157\005\006\003\006\006\007\022\011Z\007\000\157\000\157\n\021)B\011Y\006I+\005i\000\"\011~\n\002r\ni\003\011\154\011\007\b\002\t\145\000Z\004')F\000\014\000\157(B\000\n%+\000\157\002r\000>\000\157\000B\002\142\012\006M\t\145\002\146\004\006\b\n)J\n\029\0111+\011^\b\014\rF\024B\006I\000\157\003\134\006\000\157\000\157\002\028\002\002\005n\007>\004\n}(\004\004\002\002.\003\138\007\026+\002\002\002)R\007\030\007\"\007B\001\006I\006M\000J\002(\026(\000\157\003\026\006\138\006I\006\000\157(\007>\006\006\007\022\011Z\007\000\157\000\157\027R\019f\012\003\018\012F\000>\006I\011~\005\030\007B\006M\002\022\011\154\011\007\b\002\t\"\0111 V\006M\0111\002\017\001\002\134#\000\014*n\006\000\018\000\157\030n\019f\006\030z\000\022\004\006M\n-\b\n+\018 \134\031\"\t&\011^\b\014\rF\024B\006\130\t]\028\000\026\007)\002\002\005n\002\006\t]\028r\001~\0111\003\026\000\030\029Z\027+2\011\002\002\0122\017\012\154+R\b\030\134\006\011\"\000J\000V\003\0111\0296\000Z\002\150\000.\002\158\030*\017\031R\002\002\006\012\158\006\030\150\028\024Z\007)\007)\b\007+V\0111\012\021\146\015J\0316\017\006\012\r\018\006\006+b+~\002\003\026\030+\147 \000\014*n\006\000\018\0111\021\150\000\014\006\007)\000\022\002:\0111\n\134\001\142+\018+\150\006\007)\030\b\rV\006\003\r.\018\000\026\r\137\002\002\005n\007)\001\028r\021\134\002\134\007)\000\030\011\n\138+2\006\002\002\0122\002\134\012\154+R\021\138\023\012**c\000J\000V\001\001\0296\000Z\002\150\003:\002\158\030*\027\000Z\002\002\006\012\158\006\002\134\r\137\028\011B\t\000\029\n+V\021\134\012\t\025\017\022\005N\012\r\018\006\006+b+~\rZ\t\021\138-/\003Z\000>\n#\002\002\142\000\029\001\001\ne&6\002\002\002\000\014\004\003^+\150\006\003v\n\030!2\006\003\r.\028\003z\002\003~\003\130\003\002\003\006\002r\001\001\ne\001\001\001\t\145\003\142(z\007z\007~\007F\030\002\007*!\030\001\138\005f\t\003\000F\007\130\007\134\006\003\026\002.\001\007\138\031\030(\134\028\007\142\r\145\007\150\007\007\nq\028\134\007\007\007\007\007$&:$\031f\007(\138\005B\003b\0192\007\b\002\nq\b\006\011\004\005\002\005I\002\134\003\026\003\004\005I\005I\005I\005I(\154\011\004\005I\b\130\005I&\028\002\134\b\n\003N\022\022\b\134\012\b\138\b\014\007\r\026\028\b\142\b\146\005I(\005I\005I\t\n\003R\005I\002\001\007\bN\005I)2\016\005I\n\005I\005I\005I\012\005I\005I(\n\r .\005I\005I\n(\005I\005I\005I\t\005I\005I\007\012\005I\005I\005I\005I\005I\t6 6(\n\r(\n\005I\r\005I\011\002\134\002\003\005I\005I\005I\005I\005I\005I!6\012\019:\022\030\003Z\000>!r\002\022\002\142\006>!\146!!\002\001\002\002\002\028$N\003^\005I\005I\002\006z\006~(\005I\005I\005I\r\003z\002\003~\003\130\003\002\003\006\007N\rQ\012$\004\001\001~#\007J(\007z\007~\007F\011\002\n\002\006\002\134\017!\001\024\007\130\007\134\n\003\026\b\001\007\138\b\018(\007\142\n\007\150\007\007\nq+6\007\007\007\007\007\b\002\018\rQ#\007\002\014\002F\002J)\n\007\b\002\nq\b\006&\018\002$>\011Y\t\000Z\002N\002Z\001\001~\000}\021\002f\011)\002j\t\b\130\019\n\rQ$F\b\n\004\001\b\134\007!\b\138\b\014\rQ\020v\001\b\142\b\146\003Z\000>\011\002\011)\002\142\021\011)\011)\000.\018\002\002\002\rQ\017\003^\031\138\022\022\003v\002\014\000.\002J\000}\002\134&*\018\003z\002\003~\003\130\003\002\003\006\000Z\002N\002Z\002\t\027\154\007!\007!\002f\003\142\002j\007z\007~\007F\011\002\019J\011)\023J\000\014\b\000}\002\007\130\007\134\005i\003\026\002\t\002\t\007\138\002\t\002\t\t\007\142\000F\007\150\007\007\n!\007\007\007\007\007\007\004\011)\000}\007\"\"\007j\018\r%\007\b\002\007\b\006\007!$\003\n\023\146'\002.\003Z\000>\011\0182\002\142\005i\002\134\002\t\005f\b\130\002\002\002$\b\n\003^\002r\b\134\003v\b\138\b\014\016\000\014\t\145\b\142\b\146\003z\002\003~\003\130\003\002\003\006\025J\t]\028>\005i\000\014\002\t\002'\006\003\142\t]\007z\007~\007F\003\002\000\014\028!\000\014\b\b\t>\007\130\007\134\004\003\026\002\002\007\138\002\005i\r%\007\142\012*\007\150\007\007\014j#>\007\007\007\007\007\024J(\"\000Z\011z\007\007\154\n,\002\134\007\b\002\011B\b\006\0186\012*\n\001\142\b\t\002.\003Z\000>\011\"\138\002\142\"\150\007n\000Z\002\134\b\130\002\002\002\002\134\b\n\003^\011B\b\134\003v\b\138\b\014\002\134\002\025\b\142\b\146\003z\002\003~\003\130\003\002\003\006\018J'\n\002\002\000.\002\007\000>\003\142\003r\007z\007~\007F\000\014\002(.\002!\025\001R\002\002\007\130\007\134\018N\003\026\"\002\007\138\024\n\002\007\142\007\007\150\007\007\024\158\004\007\007\007\007\007\t\145\t \027\154\007\007\018\014\000\n6\007\b\002\000\014\b\006\024\007\154\ne\"\027\158\026J\003\026\003Z\000>\012\002\022\002\142\005f \tm\017\b\130\002\002\002\t\149\b\n\003^\n\b\134\003v\b\138\b\014&\026N\ne\b\142\b\146\003z\002\003~\003\130\003\002\003\006\000\002\134\012*\027\000\014\"R\002\002\134\003\142\011&\007z\007~\007F&\002\000Z\002\006\004\018R\005f\tm\002\134\007\130\007\134\011B\003\026\002\002\007\138\002\000':\007\142\026\030\007\150\007\007\002\134\022\022\007\007\007\007\007\031\028>!\rB\007\002.\tm)\n\007\b\002\ne\b\006\000\005f\002\134\012Z\002\134\n\026&\003Z\000>\r\002\016\134\002\142\016\158\006\011\"\002\134\b\130\002\002\002\tm\b\n\003^\005\133\b\134\003v\b\138\b\014\026>\002\026\b\142\b\146\003z\002\003~\003\130\003\002\003\006!\002\"b\002\002!~\002\b\154\000>\003\142\002\006\007z\007~\007F\ne\002,\002\b\025\030\002\134\t\002\007\130\007\134!\006\003\026)\002\007\138\005\133\002\134\002\007\142,\007\150\007\007\027\029\007\007\007\007\007\017\130\026 \027\154\007\028\"\018\014\005\137\027\007\b\002\000\014\b\006\006\146\006\005\133\000\014\002\134\t\003\026\003Z\000>\023\030\n\002\142\005f \tq\017\b\130\002\002\002\018j\b\n\003^\011\n\b\134\003v\b\138\b\014\011\142\005\133\026\b\142\b\146\003z\002\003~\003\130\003\002\003\006\005\137\002\134\012*\011\001\142\002\134&R\r\134\003\142\007\154\007z\007~\007F\002\022\002\000Z\007\137\001\142!\n\005f\tq\002\134\007\130\007\134\011B\003\026\020>\0166\007\138\016N\005\137\002\r\007\142\026j\007\150\007\007\027-:\007\007\007\007\007&Z\028>!\018\027\154\007\022^\tq\002\022\028\007\b\002\029^\b\006\005\137\002\006\028\026n\011\026z\028\n\003Z\000>\023.\006\134\002\142\000>!\022\002\028\b\130\002\002\002\tq\b\n\003^\006\146\b\134\003v\b\138\b\014!Z\018B\031\b\142\b\146\003z\002\003~\003\130\003\002\003\006\002\006\028\007\137\012\018\029n\n]\n]'\003\142\031&\007z\007~\007F\012\026\002\031\142\006\130-W\031\005f\n]\004\007\130\007\134&\003\026\031J\n]\007\138\003\026&\002\022\007\142\003\001\007\150\007\007\002\022\017\007\007\007\007\007\002\025\028>\028\026\001\138\007\n]\000\014\n]!\138\007\b\002\017\b\006\ne'\014\003\025\031\146\012\030\n]\n]\n]\002\022\002\025\002\025\006\n]\003\021\n]\012N\b\130!^%\026\002\006\031\138\b\n\001\142 \b\134\002\006\b\138\b\014\r\014&\011\b\142\b\146!\006\006\012*\006\006\004\014.\n]\n]\"\002\015\138\015\015\015\146\015\000Z \002\134\"\002\006\002\025\002\134\n]%\011B\015\015\002^\002R\n]\n]\012V, #F\001\138\"\006\015\015(\006\012.!&\000>\"6\031\006\005f\002\025\002\025#\018\002\025\n]\"\n]\r\015\154\015\015\015\017#2#J\006\015\n]\n]\n]\ne\001\018\031\n]\018\n]#\006%\002\025\012\146!\142\012\150\031\006\001!\006\130\006\006\016\026\012\001\006'j\019\006\022\022\006\016\002\006\003\026\r\014&#\006\016\n\016\018\006\006\017\006\006(^\014.\019\n\002F\002J\015\138\015\015\015\146\015$\006\002R'\150\n]\017\000Z\002N\002Z\007%\000}\015\015\019\026\003\002j'\"!^\012'\r\n%\015\015$\018#6\rb$\n)#\006\005f\000}\000}\019N\000}\000}$%\r\015\154\015\015\015'\019\004\005\006\015-F#z$\022\004\005\007%\007%\019Z''n\r%\006\r\019f\r$%\bN\b\r\004\005\004\005&\002\006\006\016\026\014^\018\006\000}\005f&\014\006\016\002\006\007%\r\014&%\006\016\n\016\018\b\r\b\r\007%\b\r\b\r\004\005\014.&\006'\018\015\138\015\015\015\146\015\007%&\018\000}\004\005\011\007%$\016\004\005\004\005\015\015\004\005+*\134'\154\016*\158\000}-S!r\004\015\015!\146!!\014\138\000}\000}\b\r\005f+\004\017N\004\005\004\005+\004\005\r\015\154\015\015\015\006\146\017\142\001\b\r\015\017\017\018&\000\014\018>\004\005\019B\019\134*\019\150+\b\r\019\014\019\030\019\020\n\004\005\020&\b\t\001\001\020j\b\r\b\r\016\026\020r\007\146\b\r*\020\021\014\b\r\016\002\b\r\021~\r\014&\021\b\r\016\n\016\018\b\t\b\t\021\b\t\b\t\012*\014.\021\021*\015\138\015\015\015\146\015\022\006\004\022F\000Z\022Z\022\142\022\022\001\002\134\015\015\011B\023&\0236*\023r\007a\023z\006\011\"\023\154\015\015\004\023\023\004\004\023\014\b\t\005f\024\134\024\024\001\001\024\001\r\015\154\015\015\015\025\n\002\025\018\b\t\015\025*\000\014\000N\006\000\018\001\025v\025\146\006\026v\000\022\b\t\026\026\027\002\027\001\027\027\027\007\146\028j\b\t\b\t\016\026\028\000\026\b\t\002\002\029*\b\t\016\002\b\t\029F\029\007a\000\030\b\t\016\n\016\018\0306\002\002\0122\030N\012\154\030V\030\138\030\154\004\030\000J\000V\006\030\031\n\000Z\002\150\031*\002\158\031j\031n \006\002\002\006\012\158\006 v \130    !>!F\029\142\012!\158!\014\146\014\012\r\018\006\006\006\006!\006\006\"\022\014\"\"!\150\014\014\014\014\015\006\"\"\005#\n#\030#b#j\005\006#\130\015\014\015\022#\142\006\003\r.##$\030$.$:$f\015\030\0156\rM\005\004%6%F\005\006\002\134\005\005%R\004%^%&\030\014\154\014\015&\015.\015>&B&z&\134\rM\015F\004\rM\rM\004\004&&&\006\004'\022\006\004\004'\030\005'\"'B\019'\130\005\018\006\006\015n''\006'\005(&(V\015V\006(\014\146\014(\006\015^\015f\006\006\rM\006\006(\142\014\n]\n](\158\014\014\014\014\015\006)Z)f)\142)\005\019)\n])*\023\015\014\015\022\004*&\n]\001*3\rM*G\004*z\021\154\015\030\0156*\019\rM\0115\004*\006\002\134+j+r+\158,6\n],Z\n]\014\154\014\015&\015.\015>\rM,\139\029\019N\015F\n]\n]\n],\151\000\000\000\000\029\n]\006\n]\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\019Z\000\000\000\000\006\006\015n\000\000\019f\006\000\000\000\000\000\000\000\000\015V\006\000\000\014\146\014\000\000\006\015^\015f\b\r\b\r\000\000\b\r\b\r\000\000\014\001\001~\000\000\014\014\014\014\015\006\000\000\002R\000\000\n]\000\000\000\000\000\000\001\000\000\000\000\015\014\015\022\019\030\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\030\0156\000\000\000\000\000\000\000\000\000\000\000\000\b\r\002\134\000\000\000\000\000\000\000\000\002\014\000\000\002J\014\154\014\015&\015.\015>\000\000\000\000\000\000\005\015F\000Z\002N\002Z\021\nY\nY\000\000\002f\b\r\002j\000\000\b\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nY\000\000\005\b\r\b\r\015n\005\nY\b\r\021\022:\000\000\000\000\015V\b\r\000\000\014\146\014\000\000\b\r\015^\015f\b\t\b\t\000\000\b\t\b\t\000\000\014\nY\nY\nY\014\014\014\014\015\006\000\000\019*\r\003\011J\nY\nY\nY\000\000\011R\015\014\015\022\nY\000\000\nY\000\000\000\000\000\000\022R\000\000\000\000\000\000\015\030\0156\r\r\000\000\000\000\000\000\000\000\b\t\002\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\154\014\015&\015.\015>\000\000\000\000\000\000\000\000\015F\022\134\000\000\000-\000\000\000\000\000\000\000\000\000\000\b\t\000>\000\000\b\t\002\142\000\000\000\000\000\000\000\000\000\000\002\004\026\r\r\b\t\b\t\015n\000-\000-\b\t\000-\000-\000\000\r\158\015V\b\t\002\000\000\000\000\000\000\b\t\015^\015f\000\000\000\000\000\000\000\000\002\000\000\r\r\000\000\r\000\000\002\r\154\002\000\000\001\138\000\000\000\000\000\000\000J\002\000\000\000\000\000\000\003\026\006\138\000\000\006\000\000\000-\000-\006\006\007\022\000\000\007\r\000\000\0005\000\000\000\000\000\000&b\000\000\000\000\000>\000\000\000\000\002\142\000>\000\000\000\000\007\b\002\002\000\000\000\000\000\000\000\000\000-\000\000\0005\0005\000\000\0005\0005\018N\000\000\000\000\000\000\002\000\000\000\000\r\r\000-\0079\b\n\000\000\000\000\000\000\002\011^\b\014\000\000\000-\000-\000\000\002\r\154\002\000\000\018\014\000\000\000\000\000\000\000J\002\0079\0079\000\000\003\026\006\138\000\000\006\003\026\0005\0005\006\006\007\022\005f\007\000\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001z\000\000\000\000\000\000\007\b\002\000\000\ni\000\000\000\n\000\000\0005\000\000\000\000\000>\000\000\000B\002\142\0079\0079\000\000\002\146\000\000\002\000\000\r\r\0005\000\000\b\n\000\000\018R\000\000\000\000\011^\b\014\000\000\0005\0005\002\000\000\002\002\000\000\000\000\0079\0079\000\000\0079\000\000\002\000\000\000\000\000\000\tQ\002\002\002\000\000\003\022\0079)>\000\000\000\000(z\000J\002\000\000\000\000\000\000\003\026\006\138\000\000\006\000\000\0079\000\000\006\006\007\022\011Z\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011~\000\000\000\000\000\000\000\000\011\154\011\007\b\002\000\000\002\000\000\000\000)F\000\000\000\014\000\000\006\000\018\000\000\000\000\000\000\006\000\000\000\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\n)J\ni\0115\000\000\011^\b\014\rF\000\026\000\000\002\002\000\000\000\000\0079\000\000\000\000\000\000\000\000\000\030\000\000\000\000\000\000(\002\002\0122\000\000\012\154\000\000\000\000\000\000\007%\000\000\000J\000V\0079\0079\000\000\000Z\002\150\000\000\002\158\000\000(\000\000\002\002\006\012\158\006(\000\000\000\000\000\000\007%\000\000\000\000\007%\007%\012\000\000\000\000\001\146\000\000\012\r\018\006\006\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\014!\150\006\000\018\0079\0079\000\000\006\000\000\000\022\000\000\000\000\000\000\000\000\000\000\006\000\000\000\000\000\000\ni\006\003\r.\007%\007%\000\026\000\000\002\002\000\000\000\000\0079\0079\000\000\0079\000\000\000\030\000\000\000\000\000\000\tU\002\002\0122\000\000\012\154\0079\000\000\000\000\000\000\000\000\000J\000V\007%\000\000\000\000\000Z\002\150\000\000\002\158\000\000\0079\007%\002\002\006\012\158\006\000\000\020\000\000\000\000\000\000\000\000\000\000\007%\000\000\012\000\000\000\000\007%\000\000\012\r\018\006\006\000\000\000\000\000\000\005!\000\000\000\000\000\000\000\000\005!#\002\005!\005!\000\000\000\000\006I\005!\000\000\005!\000\000\000\000\000\000\000\000\000\000\006\000\000\n\025\000\000\000\000\006\003\r.\000\000\000\000\005!\000\000\005!\005!\006I\000\000\000\000\006I\006I\000\000\000\000\005!\000\000\000\000\000\000\000\000\005!\005!\005!\000\000\005!\000\000\000\000\000\000\000\000\000\000\005!\005!\000\000\000\000\000\000\005!\005!\000\000\005!\000\000\000\000\000\000\005!\005!\005!\005!\005!\000\000\000\000\000\000\000\000\000\000\000\000\006I\000\000\000\000\005!\000\000\018\018\000\000\000>\005!\005!\005!\005!\000\000\000\000\005\029\000\000\000\000\000\000\000\000\005\029\000\000\005\029\005\029\000\000\018B\000\000\005\029\000\000\005\029\000\000\006I\000\000\000\000\000\000\000\000\005!\n\021\000\000\000\000\006I\005!\005!\005!\000\000\005\029\000\000\005\029\005\029\000\000\000\000\006\130\000\000(\000\000\000\000\005\029\000\000\006I\000\000\000\000\005\029\005\029\005\029\003\026\005\029\000\000\001\001~\000\000\000\000\005\029\005\029\017\000\000\000\000\005\029\005\029\000\000\005\029\000\000\000\000\001\005\029\005\029\005\029\005\029\005\029\000\000\001\017\000\000\000\000\000\000\000\000\000\000\000\000\005\029\000\000\000\000\000\014\000\000\005\029\005\029\005\029\005\029\000\000\000\n\000\000\000\000\000\000\002\014\000>\002J\000B\002\142\001\000\000\000\002\146\000\000\002\000\000\000\000\000Z\002N\002Z\000\000\000\000\005\029\000\000\002f\000\000\002j\005\029\005\029\005\029\002\000\000\002\002\000\000\000\012*\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\002\002\002\000Z\003\022\000\000\000\000\000\000\001\002\134\000J\002\011B\000\000\000\000\003\026\006\138\000\000\006\000\000\000\000\000\000\006\006\007\022\011Z\007\000\000\004\000\000\003\000\000\000\000\000\005f\000\000\011~\000\000\001\000\000\000\000\011\154\011\007\b\002\011\141\000\000\r\t\000\000\000\000\000\000\000\000\r\t\018b\r\t\r\t\000\000\000\000\000\000\r\t\000\000\r\t\000\000\000\000\000\001\000\000\000\000\b\n\n!%\000\000\011\141\011^\b\014\rF\000\000\r\t\000\000\r\t\r\t\000\000\000\000\028\028r\000\000\000\000\000\000\r\t\000\000\000\028\130\000\000\r\t\r\t\r\t\000\000\r\t\029\"\000\000\000\000\000\000\000\000\r\t\r\t\002\t\002\t\0296\r\t\r\t\000\000\r\t\030*\000\000\000\000\r\t\r\t\r\t\r\t\r\t\000\000\000\000\000\000\000\000\000\000\000\000\000\000\030:\000\000\r\t\000\000\000\000\000\000\000\014\r\t\r\t\r\t\r\t\030F\030j\r\005\000\000\000\000\000\000\000\000\r\005\000\000\r\005\r\005\001\002\t\002\134\r\005\000\000\r\005\000\000\000\000\000\000\000\000\000\000\030\r\t\n\029\000\000\000\000\000\000\r\t\r\t\r\t\000\000\r\005\000\000\r\005\r\005\000\000\000\000\012*\028\002\t\000\000\002\t\r\005\000\000\000\000\000\000\000\000\r\005\r\005\r\005\000Z\r\005\000\000\000\000&\001\002\134\r\005\r\005\011B\000\000\000>\r\005\r\005\000\000\r\005\000\000\000\000\002\t\r\005\r\005\r\005\r\005\r\005\000\000\000\000\000\000\000\000!\006\000\000\000\000\000\000\000\000\r\005\000\000\001\001\001~\r\005\r\005\r\005\r\005\000\000\002\153\000\000\000\000\003&\000\014\000\000\000\000\000\018\001\000\000\000=\018\014\000\000\000\022\000\000\001\000\000\002\003*\001\002\153\002\153\r\005\002\153\003\026\000\000\000\000\r\005\r\005\r\005\005f\000\000\003>\017\000\000\000\000\000\000\002\014\000\000\002J\002\002\000\000\002\002\000\000\003J\t.\011\014\000F\000Z\002N\002Z\000\000\000\000\000=\000=\002f\000\000\002j\000Z\000\000\000\000\0072\005\133\000\000\002\153\b\000\000\t\026\000\000\006\000\000\000\000\000\000!\n\002!\000\000\000\000\000\000\002\153\001\001~\000\000\000\000\000=\005f\005\133\006\006\005\133\005\133\002\153\002\153\000\000\002\153\001\000\000\002!\002!\000\000\002!\002!\001\002!\000\000\002\153\000\000\000\000\016\002\153\002\153\000=\006\000\000\000\000\000\000\002\153\000\000\003\000\000\002\153\000\000\000\000\000\000\002\014\002\002J\rQ\000\000\002\002\005\133\005f\000\000\002\000\000\002\000Z\002N\002Z\002\002\153\002!\002!\002f\000\000\002j\003Z\000>\000\000\rQ\002\142\000\000\rQ\rQ\000\000\000\000\002\000\000\000\000\002!\005\133\003^\000\000\002\153\002\153\000\000\002\153\002\153\002!\002!\000\000\002!\000\000\000\000\000\000\0076\000\000\000\000\001\001\002!\000\000\002!\002!\000\000\000>\000\000\005\133\000\000\007:\007\000\000\002\002!\rQ\000\000\000\000\002!\002!\002!\000\000\001\001\003\026\001\001\007\138\000\000\000\000\002\153\007\142\000\000\007\150\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000):\000\000\rQ\000\000\000\000\000\000\018\014\000\000\000\000\007\b\002\rQ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\026\000\000\000\000\000\000\000\000\001\005f\006}\002\153\017\rQ\000\000\002\153\002\153\000\000\b\n\000\000\002\153\000\000\002\153\000\000\b\014\000\000\002\153\r\014&\002\005\027\154\000\000\000\000\006}\000\000\001\006}\006}\001\014.\000\000\000\000\000\000\015\138\015\015\015\146\015\000\000\000\000\000\000\000\000\002\005\002\005\001\002\005\002\005\000\000\015\015\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\000\000\000\000\000\000\006}\005f\000\000\000\000\000\000\b\000\000\000\000\000\000\r\015\154\015\015\015\000\000\000\000\000\000\000\000\015\002\005\005f\000\000\r\014&\000\000\000\000\000\000\000\000\b\000\000\006}\b\b\000\000\014.\000\000\000\000\000\000\015\138\015\015\015\146\015\016\026\014\146\014\028>\000\000\000\000\002\005\000\000\016\002\000\000\015\015\000\000\014\006}\016\n\016\018\014\014\014\014\015\006\015\015\000\000\000\000\000\000\000\000\000\000\002%\b\005f\015\014\015\022\001\001~\000\000\000\000\000\000\r\015\154\015\015\015\015\030\0156\000\000\000\000\015\001\000\000\002%\002%\002\134\002%\002%\001\002%\000\000\000\000\b\014\154\014\015&\015.\015>\000\000\000\000\000\000\000\000\015F\000\000\000\000\016\026\000\000\000\000\000\000\000\000\002\014\017\014\002J\016\002*W\000\000\000\000\000\000\000\000\b\016\n\016\018\000\000\000Z\002N\002Z\000\000\015n\002%\002%\002f\000\000\002j\000\000\000\000\015V\000\000\000\000\002%\002%\000\000\000\000\015^\015f\001\001~\002%\000\000\0079\0079\000\000\000\000\000\000\000\000\000\000\002%\002%\000\000\002%\001\000\000\002%\002%\000\000\002%\002%\001\002%\000\000\002%\002%\0079\0079\000\000\0079\0079\000\000\000\000\000\000\000\000\002%\000\000\000\000\000\000\002%\002%\002%\000\000\001\000\000\003b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001z\000\000\000\000\003\026\003\004\004\005\004\005\002%\002%\004\000\000\004\004\005\000\000\000\000\002!\002!\0079\0079\000\000\000\000\001\001~\000\000\000\000\000\000\000\000\000\000\004\005\004\005\000\000\004\005\004\005\000\000\002%\002%\001\002%\002!\002!\000\000\002!\002!\001\0079\000\000\002%\0079\002%\002%\000\000\000\000\000\000\tQ\000\000\004\005\000\000\002%\000\000\002%\000\000\000\000\000\000\002%\002%\001\rM\003b\004\005\000\000\000\000\000\000\000\000\004\005\004\005\000\000\000\000\004\005\003\026\003\004\0079\0079\002!\002!\004\000\000\004\000\000\rM\000\000\000\000\rM\rM\000\000\000\000\000\000\000\000\000\000\011!\004\005\000\000\000\000\004\005\0079\0079\000\000\0079\0079\bJ\002!\002!\000\000\002!\000\000\000\000\000\000\000\000\000\000\004\005\000\000\000\000\002!\000\000\002!\002!\014\146\014\000\000\000\000\004\005\001\146\006}\002!\rM\002!\006}\000\000\014\002!\002!\000\000\014\014\014\014\015\006\000\000\000\000\0079\0079\000\000\000\000\000\000\000\000\000\000\000\000\015\014\015\022\000\000\000\000\000\000\001\000\000\rM\000\000\000\000\000\000\000\000\015\030\0156\000\000\000\000\rM\000\000\000\000\0079\006}\002\134\0079\000\000\001\001~\000\000\000\000\tU\014\154\014\015&\015.\015>\rM\000\000\000\000\000\000\015F\001\000\000\000\000\014\146\014(\158\000\000\001\"Z\b\017B\006}\011\017\b\000\000\014\000\000\000\000\000\000\014\014\014\014\015\006\015n\000\000\000\000\015v\000\000\002\014\000\000\002J\015V\006}\015\014\015\022\000\000\000\000\006}\015^\015f\000\000\000Z\002N\002Z\000\000\015\030\0156\000\000\002f\000\000\002j\000\000\000\000\b\002\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\154\014\015&\015.\015>\000\000\000\000\000\000\000\014\015F\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022%\"\000\000\000\000\b\000\000\000\000\000-\000\000\000\000\000\000\000\000\000\000\014F\000\000\017:\000\026\015n\000\000\004\015\130\003\000\000\000\000\000\000\015V\b\000\030\000\000\000\000\000\000\b\015^\015f\000:\014B\000F\000\000\011\011\000\000\000\000\000J\000V\001\001~\023j\000Z\002\150\000\000\002\158\000\000\000-\000-\002\002\006\000\000\006\001\000\000\000\000\000\000\000\000\000\000\000\000\023\134\000\000\000\014\000\000\000\000\000\018\005\137\000\000\000\000\006\006\000\022\000\000\000\000\000\000\000\000\000-\000\000\0005\000\000\000\000\011i\002\014\002F\002J\000\000\024v\000\026\000\000\005\137\014V\014Z\005\137\005\137\006\000Z\002N\002Z\000\030\006\003\000\000\002f\000-\002j\000:\014B\000F\011i\n\014\000\000\024\025f\000J\000V\001\001~\000\000\000Z\002\150\000\000\002\158\000\000\0005\0005\002\002\006\000\000\006\003\000\000\000\000\000\000\005\137\005f\000\000\001\000\000\000\000\003&\000\014\000\000\011J\000\018\000\000\006\006\011R\000\000\000\022\000\000\000\000\0005\000\000\003*\025r\025\130\000\000\001\005B\003b\000\000\000\000\005\137\000\000\000\000\014V\014Z\003>\000\000\006\003\026\003\004\006M\006\003\000\000\004\0005\004\000\000\003J\n\011\014\000F\000\000\025\158\rI\000\000\005\137\000\000\000\000\000\000\003&\000\014\000Z\006M\000\018\0072\006M\006M\004M\b\000\022\t\026\000\000\006\000\000\003*\000\000\rI\000\000\nf\rI\rI\000\000\000\000\000\000\001\001~\000\000\000\000\003>\006\006\000\000\000\000\000\000\004M\000\000\000\000\000\000\000\000\003\000\000\000\000\003J\023\026\011\014\000F\001\006M\017\158\000\000\016\004M#V\000\000\006\000\000\000Z\000\000\004M\0072\003\rI\004M\b\000\000\t\026\000\000\006\001\005B\003b\000\000\000\000\000\000\000\000\000\000\000\000\006M\000\000\001\001~\003\026\003\004\006\006\006M\000\000\004\004M\004\rI\000\000\r\001\000\000\000\000\019\014\000\000(\027\001\026\022\017\158\006M\016\004M\023f\000\000\006\r\014&\000\000\004M\000\000\003\r\004M\rI\002\018\r\000\000\014.\002\014\002F\002J\015\138\015\015\015\146\015\000\000\000\000\000\000\000\000\000\000\000Z\002N\002Z\000\000\000\000\015\015\002f\000\000\002j\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\015\028\000\000\000\000\000\000\000\000\000\000\r\005f\r\r\r\000\000\000\000\000\000\000\000\r\015\154\015\015\015\000\000\000\000\002\005\002\005\015\000\000\000\000\r\014&\000\000\000\000\r\r\r\r\r\000\000\r\000\000\014.\000\000\000\000\000\000\015\138\015\015\015\146\015\000\000\016\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\002\015\015\000\000\000\000\000\000\000\000\016\n\016\018\000\000\002\005\002\134\000\000\015\015\000\000\000\000\000\000\000\000\r\r\r\005f\000\000\000\000\t=\000\000\000\000\000\000\000\000\r\015\154\015\015\015\000\000\000\000\028\002\005\015\002\005\000\000\r\014&\000\000\000\000\r\000\000\t=\r\000\000\000\000\t=\000\000\014.\027\000\000\000\000\015\138\015\015\015\146\015\000\000\016\026\000\000\000\000\002\005\000\000\000\000\000\000\000\000\016\002\015\015\000\000\r\000\000\000\000\016\n\016\018\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\000\000\000\000\000\000\t=\005f\r\r\tA\000\000\000\000\000\000\000\000\r\015\154\015\015\015\000\000\000\000\000\000\000\000\015\000\000\000\000\r\014&\000\000\000\000\r\r\tA\r\r\000\000\tA\000\000\014.\rE\000\000\000\000\015\138\015\015\015\146\015\000\000\016\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\002\015\015\000\000\000\000\000\000\rE\016\n\016\018\rE\rE\000\000\000\000\015\015\r\000\000\000\000\000\000\r\r\tA\005f\000\000\000\000\t9\000\000\000\000\000\000\000\000\r\015\154\015\015\015\000\000\000\000\r\r\015\000\000\000\000\r\014&\000\000\000\000\r\000\000\t9\r\000\000\rE\t9\000\000\014.\027\000\000\000\000\015\138\015\015\015\146\015\000\000\016\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\002\015\015\000\000\r\000\000\000\000\016\n\016\018\rE\r\r\000\000\015\015\000\000\000\000\000\000\027\000\000\000\000\t9\005f\000\000\000\000&J\000\000\000\000\000\000\000\000\r\015\154\015\015\015\000\000\rE\r\r\015\r\000\000\r\014&\000\000\000\000\001\138\000\000\000\000\018\026\000\000\000\000\000\000\000\000\014.\000\000\000\000\000\000\015\138\015\015\015\146\015\000\000\016\026\000\000\000\000\r\000\000\tQ\tQ\000\000\016\002\015\015\000\000\000\000\000\000\000\000\016\n\016\018\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\000\000\000\000\tQ\tQ\005f\tQ\tQ&\000\000\000\000\000\000\002\r\015\154\015\015\015\000\000\000\000\000\000\000\000\015\000\000\000\000\r\014&\000\000\000\000\000\000\027\000\000\017\000\000\000\000\002\002\014.\002\002\000\000\015\138\015\015\015\146\015&N\016\026\tQ\tQ&V\000\000\000\000\000\000\000\000\016\002\015\015\000\000\000\000\000\000\000\000\016\n\016\018\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\000\000\000\000\tQ\000\000\005f\tQ\000\000\000\000\005f\000\000\000\000\tQ\r\015\154\015\015\015\000\000\000\000\000\000\000\000\015\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\tQ\000\000\000\000\006\011\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000&\016\026\000\026\002&\000\000\000\000\b\154\002\016\002\000\000\000\000\002\000\030\002\000\000\016\n\016\018\002\000\000\000:\000\000\000F\000\000\011\011\000\000\000\000\000J\000V\000\000\000\000\000\000\000Z\002\150\000\000\002\158\000\000\014\146\014\002\002\006\000\000\006\017\000\000\000\000\016V\000\000\014\000\000\000\000\000\000\014\014\014\014\015\006\000\000\000\000\006\006\000\000\000\000\000\000\000\000\000\000\000\000\015\014\015\022\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\015\030\0156\000\000\000\000\000\000\006\000\000\000\000\000\000\002\134\006\003\001\001~\025\002\000\000\000\000\014\154\014\015&\015.\015>\000\000\000\000\000\000\000\000\015F\001\000\000\014\146\014\000\000\000\000\000\000\023\134\000\000\018\026\000\000\000\000\016\000\000\014\000\000\000\000\000\000\014\014\014\014\015\006\017\015n\000\000\000\000\017\000\000\002\014\002F\002J\015V\015\014\015\022\000\000\000\000\000\000\000\000\015^\015f\007\000Z\002N\002Z\015\030\0156\000\000\000\000\002f\000\000\002j\000\000\000\000\002\134\000\000\000\000\000\000\r\014&\000\000\000\000\014\154\014\015&\015.\015>\000\000\007\000\000\014.\015F\000\000\000\000\015\138\015\015\015\146\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000'*\018\030\015n\t\000\000\018*\000\000\015\015\000\000\015V\000\000\000\000\000\000\000\000\000\000\005f\015^\015f\000\000\r\014&\000\000\000\000\r\015\154\015\015\015\000\000\t\000\000\014.\015\000\000\000\000\015\138\015\015\015\146\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\007\000\000\016\026\012\000\000\000\000\000\000\015\015\000\000\016\002\000\000\000\000\000\000\000\000\000\000\005f\016\n\016\018\000\000\r\014&\000\000\000\000\r\015\154\015\015\015\000\000\012\000\000\014.\015\000\000\000\000\015\138\015\015\015\146\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\007\000\000\016\026\t\000\000\000\000\000\000\015\015\000\000\016\002\000\000\000\000\000\000\000\000\000\000\005f\016\n\016\018\000\000\r\014&\000\000\000\000\r\015\154\015\015\015\000\000\t\000\000\014.\015\000\000\000\000\015\138\015\015\015\146\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\012\000\000\016\026\006\000\000\000\000\000\000\015\015\000\000\016\002\000\000\000\000\000\000\000\000\000\000\005f\016\n\016\018\000\000\r\014&\000\000\000\000\r\015\154\015\015\015\000\000\000\000\000\000\014.\015\000\000\000\000\015\138\015\015\015\146\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\012\000\000\016\026\000\000\000\000\000\000\000\000\015\015\000\000\016\002\000\000\000\000\000\000\000\000\000\000\005f\016\n\016\018\000\000\000\000\001\001~\000\000\r\015\154\015\015\015\000\000\000\000\000\000\006\015\000\000\016&\001\000\000\000\000\000\000\000\000\000\000\000\000\001\026\158\000\000\000\000\000\000\000\000\000\000\000\000\000\000\r\014&\000\000\000\000\006\000\000\016\026\016*\000\000\000\000\000\000\000\000\014.\002\014\016\002\002J\015\138\015\015\015\146\015\016\n\016\018\000\000\000\000\000\000\000Z\002N\002Z\000\000\000\000\015\015\002f\000\000\002j\000\000\000\000\000\000\016>\000\000\000\000\000\000\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005f\000\000\000\000\000\000\r\014&\001\001\r\015\154\015\015\015\016B\000\000\000\000\014.\015\000\000\000\000\015\138\015\015\015\146\015\000\000\000\000\000\000\000\000\001\001\000\000\001\001\000\000\015\015\000\000\000\000\000\000\000\000\000\000\016\026\000\000\000\000\000\000\000\000\015\015\000\000\016\002\000\000\000\000\000\000\000\000\tm\005f\016\n\016\018\016v\000\000\000\000\000>\000\000\r\015\154\015\015\015\000\000\000\000\000\000\000\000\015\001\001\r\014&\tm\000\000\000\000\tm\tm\016z\000\000\000\000\000\000\000\000\014.\000\000\000\000\000\000\015\138\015\015\015\146\015\000\000\016\026\000\000\000\000\001\000\000\000\000\001\018\014\016\002\015\015\000\000\000\000\000\000\000\000\016\n\016\018\016\142\000\000\000\000\003\026\015\015\000\000\000\000\tm\005f\000\000\000\000\017\005f\000\000\000\000\028.\r\014&\000\000\000\000\r\015\154\015\015\015\016\146\000\000\000\000\014.\015\000\000\000\000\015\138\015\015\015\146\015\tm\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\000\000\000\000\016\026\000\000\000\000\000\000\000\000\015\015\000\000\016\002\000\000\tm\000\000\000\000\tq\005f\016\n\016\018\016&\000\000\000\000\000>\000\000\r\015\154\015\015\015\000\000\000\000\000\000\000\000\015\000\000\000\000\r\014&\tq\000\000\000\000\tq\tq\"\134\000\000\000\000\000\000\000\000\014.\000\000\000\000\000\000\015\138\015\015\015\146\015\000\000\016\026\000\000\000\000\000\000\000\000\000\000\000\000\018\014\016\002\015\015\000\000\000\000\000\000\000\000\016\n\016\018\016>\000\000\000\000\003\026\015\015\000\000\000\000\tq\005f\000\000\000\000\017\005f\000\000\000\000\000\000\r\014&\000\000\000\000\r\015\154\015\015\015\"\146\000\000\000\000\014.\015\000\000\000\000\015\138\015\015\015\146\015\tq\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\000\000\000\000\016\026\000\000\000\000\000\000\000\000\015\015\000\000\016\002\000\000\tq\000\000\000\000\001\005f\016\n\016\018\016v\000\000\000\000\000>\000\000\r\015\154\015\015\015\000\000\000\000\000\000\000\000\015\000\000\000\000\r\014&\001\000\000\000\000\001\001$\000\000\000\000\000\000\000\000\014.\000\000\000\000\000\000\015\138\015\015\015\146\015\000\000\016\026\000\000\000\000\000\000\000\000\000\000\000\000\018\014\016\002\015\015\000\000\000\000\000\000\000\000\016\n\016\018\016\142\000\000\000\000\003\026\015\015\000\000\000\000\001\005f\000\000\000\000\017\005f\000\000\000\000\000\000\r\014&\000\000\000\000\r\015\154\015\015\015$\000\000\000\000\014.\015\000\000\000\000\015\138\015\015\015\146\015\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\015\000\000\000\000\000\000\tQ\000\000\016\026\000\000\000\000\000\000\000\000\015\015\000\000\016\002\000\000\001\007!\000\000\000\000\005f\016\n\016\018\001\001~\000\000\tQ\tQ\r\015\154\015\015\015\000\000\000\000\000\000\000\000\015\001\000\000\007!\000\000\000\000\007!\007!\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001z\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\016\026\000\000\000\000\000\000\000\000(n\000\000\003b\016\002\tQ\tQ\000\000\000\000\000\000\000\000\016\n\016\018\000\000\003\026\003\004\000\000\000\000\007!\007!\004\000\000\004\007\007\000\000\000\000\007\000\000\000\000\000\000\tQ\tQ\007\tQ\000\000\000\000\000\000\007\000\000\tQ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007!\000\000\tU\tU\007\000\000\tQ\011\022\000\000\007!\000\000\000\000\000\000\tQ\000\000\000\000\020\000\000\007\007\007\007\007!\000\000\000\000\tU\tU\007!\tU\tU\007\007\007\000\000\007\007\000\000\000\000\000\000\007\007\007\000\000\007\006\011\"\000\000\000\000\000\000\000\000\000\000\000\000\028\002\000\000\000\000\000\000\000\000\000\000\000\000\007\007\007\000\000\000\000\007\011\026\000\000\000\000\000\000\000\000\tU\tU\000\000\007\007\007\007\000\000\000\000\000\000\000\000\007\000\000\007\000\000\007\000\000\007\000\000\000\000\007\007\000\000\000\000\007\000\000\007\tU\007\000>\tU\000\000\002\142\000\000\000\000\000\000\tU\000\000\002\000\000\000\000\000\000\006\011\"\000\000\007\007\000\000\000\000\007\000\000\000\000\tU\tU\002\000\000\000\000\tU\006\000\000\000\000\000\000\000\000\000\000\000\000\002\007\000\000\007\000\000\007\000\000\002\000\000\002\000\000\007\000\000\000\000\001\146\000J\002\000\000\000\000\000\000\003\026\006\138\000\000\006\000\000\000\000\000\000\006\006\007\022\000\000\007\tU\tU\000\000\000\000\000\000\007\007\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\007\007\b\002\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\tU\tU\006\tU\000\000\tY\tY\007\000\000\tU\016\000\000\000\000\000\000\b\n\000\000\000\000\000\000\000\000\011^\b\014\007\007\007\007\000\000\000\000\000\000\tY\tY\tU\tY\tY\007\007\007\000\000\007\007\000\000\000\000\000\000\007\007\007\000\000\007\006\011\"\000\000\000\000\000\000\000\000\000\000\000\000\028\018\000\000\000\000\000\000\000\000\000\000\000\000\007\007\007\000\000\000\000\007\016\000\000\000\000\000\000\000\000\tY\tY\000\000\007\007\007\007\000\000\000\000\000\000\000\000\007\000\000\007\000\000\007\000\000\007\000\000\000\000\007\007\000\000\000\000\007\000\000\007\tY\007\000\000\tY\000\000\000\000\000\000\000\000\000\000\tY\000\000\000\000\000\000\000\000\000\000\000\000\014\146\014\007\007\000\000\000\000\007'2\000\000\000\000\"\158\000\000\014\000\000\tY\006\014\014\014\014\015\006\000\000\000\000\007\000\000\007\000\000\007\000\000\000\000\000\000\015\014\015\022\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\030\0156\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\134\007)\000\000\014\146\014\000\000\000\000\000\000\014\154\014\015&\015.\015>%\006\000\000\014\000\000\015F\001\014\014\014\014\015\006\007)\000>\000\000\007)\007)\000\000\000\000\000\000\000\000\000\000\015\014\015\022\000\000\000\000\000\000\000\000\000\000\001\015n\000\000\001\001\015\030\0156\000\000\000\000\015V\000\000\000\000\000\000\000\000\002\134\000\000\015^\015f\000\000\000\000\000\000\000\000\014\154\014\015&\015.\015>\018\014\007)\007)\000\000\015F\000\000\011A\011A\000\000\000\000\011A\000\000\000\000\003\026\000\000\000\000\011A\000\000\001\005f\000\000\011A\017\000\000\000\000\007&\000\000\000\000\000\000\015n\000\000\007)\000\000\000\000\000\000\011A\000\000\015V\000\000\n\129\007)\000\000\000\000\000\000\015^\015f\007*(f\001\011A\011A\000\000\011A\007)\000\000\000\000\000\000\000\000\007)\000\000\000\000\000\000\000\000\011A\002\002\011A\000\000\000\000\000\000\011A\000\000\011A\011A\011A\001\000\000\000\000\000\000\003z\002\003~\b\003\002\003\006\000\000\000\000\tY\000\000\000\000\000\000\011A\011A\000\000\011A\007z\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\130\007\134\tY\tY\000\000\000\000\000\000\000\000\000\000\011A\000\000\000\000\003&\000\014\000\000\011A\000\018\007\007\007\007\007\000\022\000\000\000\000\000\000\007\003*\000\000\001\000\000\000\000\000\000\000\000\r\137\000\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000\000\000\000\000\000\000\000\tY\tY\001\001~\b\130\000\000\000\000\000\000\022\t.\011\014\000F\b\134\000\000\b\138\000\000\000\000\001\000\000\b\142\b\146\000\000\000Z\000\000\001\0072\000\000\tY\tY\b\tY\t\026\000\000\006\003&\000\014\tY\000\000\000\018\026\n\000\000\000\000\000\000\000\000\000\022\000\000\002\014\026\018\002J\003*\006\006\000\000\000\000\000\000\023\002\000\000\tY\000\000\000Z\002N\002Z\000\000\003>\000\000\000\000\002f\000\000\002j\000\000\000\000\016\000\000\026V\000\000\006\000\000\003J\n\011\014\000F\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007!\000\000\000Z\000\000\000\000\0072\001\001~\000\000\b\000\000\t\026\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\007!\000\000\000\000\007!\007!\001\000\000\006\006\000\000\000\000\024\024\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\003&\000\014\000\000\000\000\000\018\000\000\001\016\003b\024\000\022\006\000\000\000\000\000\000\003*\000\000\003\000\000\003\026\003\004\r\137\000\000\007!\007!\004\000\000\004\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\022\t.\011\014\000F\000\000\000\000\000\000\000\000\000\000\020\150\000\000\007!\000\000\000\000\000Z\000\000\000\000\0072\000\000\000>\007!\b\002\142\t\026\000\000\006\000\000\020\002\000\000\000\000\000\000\000\000\007!\000\000\000\000\t\000\000\007!\000\000\000\000\000\000\006\006\002\000\000\000\000+\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\002\016\002,.\000\000\006\000\000\000\000\000J\002\000\000\003\000\000\003\026\006\138\000\000\006\000\000\000\000\000\000\006\006\007\022\000\000\007\000\000\000\000\000\000\000\000\000\000\003&\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\007\b\002\000\000\000\000\003*\000\000\001\001~\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003>\000\000\000\000\001\000\000\000A\000\000\b\n\000\000\000\000\001\000\000\011^\b\014\003J\n\011\014\000F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003&\000\014\000Z\000\000\000\018\0072\002\014\000\000\002J\b\000\022\t\026\000\000\006\000\000\003*\000\000\000\000\000\000\000Z\002N\002Z\000\000\000\000\000A\000A\002f\000\000\002j\003>\006\006\000\000\000\000\024\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003J\011\011\014\000F\000\000\000\000\000\000\000\000\016\000\000\025B\000A\006\000\000\000Z\000\000\000\000\0072\003\000\000\000\000\b\000\000\t\026\000\000\006\003&\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000A\000\000\000\000\003*\006\006\000\000\000\000\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003>\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\".\000\000\006\000\000\003J\012\011\014\000F\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Z\000\000\000\000\0072\000\000\000>\000\000\b\002\142\t\026\000\000\006\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\t\000\000\000\000\000\000\000\000\000\000\006\006\002\000\000\r\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\002\016\002\016\000\000\006\000\000\000\000\000J\002\000\000\003\006\r\003\026\006\138\000\000\006\000\000\001\001~\006\006\007\022\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\006\r\000\000\000\000\006\r\006\r\001\007\b\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\003b\000\000\b\n\000\000\000\000\000\000\000\000\011^\b\014\000\000\000\000\003\026\003\004\000\000\006\017\006\r\006\r\004\000\000\004\001\001~\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\006\017\000\000\000\000\006\017\006\017\001\000\000\000\000\006\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\r\000\000\000\000\000\000\001\001~\000\000\006\r\000\000\000\000\001\000\000\003b\006\r\007!\000\000\000\000\000\000\006\r\001\001\001~(\142\003\026\003\004\001\000\000\006\017\006\017\004\000\000\004\000\000\000\000\001\000\000\007!\000\000\000\000\007!\007!\001\000\000(N\000\000\000\000\000\000\002\014\002F\002J\000\000\000\000\000\000\001\000\000\000\000\000\000\006\017\000\000\000\000\000Z\002N\002Z\001\000\000\003b\006\017\002f\000\000\002j\000\000\000\000\000\000\006\017\000\000\000\000\003\026\003\004\006\017\007!\007!\007!\004\006\017\004\001\001~\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\007!\000\000\000\000\007!\007!\001\020\000\000\007!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\020\000\000\000\000\001\000\000\003b\007!\000\000\000\000\000\000\000\000\000\000\001\001~\000\000\000\000\003\026\003\004\000\000\000\000\007!\007!\004\000\000\004\000\000\001\000\000\007!\000\000\000\000\007!\007!\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\020\000\000\007!\000\000\000\000\000\000\000\000\001\000\000\003b\007!\000\000\000\000\000\000\000\000\000\000\001\001~\020\000\000\003\026\003\004\000\000\007!\007!\007!\004\000\000\004\000\000\001\000\000\007!\000\000\000\000\007!\007!\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\021\018\000\000\007!\000\000\000\000\000\000\000\000\001\000\000\003b\007!\000\000\000\000\000\000\000\000\000\000\001\001~\020\000\000\003\026\003\004\000\000\007!\007!\007!\004\000\000\004\000\000\001\000\000\007!\000\000\000\000\007!\007!\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\021*\000\000\007!\000\000\003&\000\014\000\000\001\000\018\003b\000\000\000\000\000\000\000\000\000\022\000\000\000\000\000\000\020\003*\003\026\003\004\000\000\007!\007!\007!\004\000\000\004\000\000\000\000\000\000\003>\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003J\023*\011\014\000F\000\000\000\000\021B\000\000\007!\000\000\000\000\000\000\000=\000\000\000Z\000\000\000\000\0072\001\001~\000\000\b\000\000\t\026\020\006\000\000\000\000\000\000\000\000\007!\000\000\000\000\001\000\000\000=\000=\000\000\000=\000=\001\000\000\006\006\000\000\000\000\023:\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\016\003b\023B\000\000\006\000\000\000\000\000\000\000\000\000\000\003\000\000\003\026\003\004\000\000\000A\000=\000=\004\000\000\004\001\001~\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000A\000A\000\000\000A\000A\001\000\000\000\000\000=\000\000\003&\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000\000\000\000\000=\003*\000\000\001\000\000\003b\000\000\000\000\000\000\000\000\000=\000=\000\000\000\000\000\000\003>\003\026\003\004\000\000\000\000\000A\000A\004\000\000\004\000\000\000\000\000\000\003J\t.\011\014\000F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Z\000\000\000\000\0072\000\000\000\000\000\000\b\000A\t\026\000\000\006\003&\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000A\000\000\000\000\003*\006\006\000\000\000\000\026\000\000\000A\000A\000\000\000\000\000\000\000\000\000\000\003>\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\026\000\000\006\000\000\003J\t.\011\014\000F\003\000\000\b\158\000\000\000\000\000\000\000\000\000\000\003Z\000>\000Z\000\000\002\142\0072\000\000\000\000\000\000\b\002\t\026\000\000\006\000\000\003^\000\000\000\000\000\000\000\000\007\146\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0076\006\006\000\000\000\000,J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007:\007F\000\000\002\r\r\000\000\000\000\016\000\000,R\000\000\006\000\000\003\026\000\000\000\000\007\138\003\r\000\000\007\142\000\000\007\150\007\007\r\000\000\000\000\027\000\000\003Z\000>\000\000\000\000\002\142\000\000\000\000\000\000\000\000\000\000\002\007\b\002\000\000\b\006\003^\000\000\r\r\r\b\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\0076\r\r\r\000\000\000\000\000\000\b\n\r\n\r\000\000\000\000\b\014\007:\007F\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\t\000\000\003\026\000\000\000\000\007\138\003&\000\014\000\000\007\142\000\018\007\150\007\007\000\000\000\000\000\022\000\000\000\000\000\000\000\000\003*\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\b\002\000\000\b\006\000\000\003>\000\000\000\000\003&\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\003J\003V\000\000\000F\003*\000\000\b\n\000\000\n\142\000\000\000\000\000\000\b\014\000\000\000Z\000\000\000\000\0072\003>\000\000\000\000\b\000\000\t\026\t*\006\000\000\000\000\000\000\000\000\000\000\000\000\003J\011\158\011\014\000F\000\000\000\000\000\000\000\000\000\000\000\000\006\006\000\000\tB\000Z\000\000\000\000\0072\000\000\000\000\000\000\b\000\000\t\026\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\003&\000\014\000\000\000\000\000\018\003\006\006\000\000\000\000\000\022\000\000\000\000\000\000\000\000\003*\000\000\001\001~\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\003>\000\000\006\001\000\000\007!\016\000\000\003\000\000\001\000\000\000\000\000\000\003J\012\011\014\000F\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000Z\000\000\000\000\0072\018\000\000\002J\b\000\000\t\026\000\000\006\000\000\000\000\000\000\000\000\000\000\000Z\002N\002Z\000\000\000\000\007!\007!\002f\000\000\002j\000\000\006\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003&\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\016\000\022\000\000\007!\006\000\000\003*\000\000\016\tQ\003\000\000\007!\000\000\000\000\000\000\000\000\000\000\000\000\018\003>\000\000\000\000\000\000\000\000\007!\000\000\000\000\000\000\000\000\007!\000\000\000\000\000\000\003J\t.\011\014\000F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003&\000\014\000Z\000\000\000\018\0072\000\000\000\000\000\000\b\000\022\t\026\000\000\006\000\000\003*\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003>\006\006\000\000\000\000\023\000\000\000\000\001\001~\000\000\000\000\000\000\000\000\003J\t.\011\014\000F\000\000\000\000\000\000\000\000\016\001\000\000\007!\006\000\000\000Z\000\000\001\0072\003\000\000\000\000\b\000\000\t\026\000\000\006\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\014\000\000\002J\000\000\006\006\000\000\000\000+\000\000\000\000\000\000\000\000\000Z\002N\002Z\000\000\000\133\007!\007!\002f\000\000\002j\001\001~\016\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\001\000\000\000\133\000\133\000\000\000\133\000\133\001*\138\000\000\007!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007!\000\000\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\001\000\000\003b\007!\000\137\000\000\000\000\000\000\007!\000\000\001\001~\000\000\003\026\003\004\000\000\000\000\000\133\000\133\004\000\000\004\000\000\000\000\001\000\000\000\137\000\137\000\000\000\137\000\137\001\000\000\000\157\000\000\000\000\000\000\000\000\000\157\000\000\000\014\000\000\000\000\000\000\000\000\000\000\000\000\000\133\000\000\000\000\000\000\000\000\000\000\001\000\000\003b\000\000\000\000\000\000\000\000\000\157\000\000\000\000\000\157\000\157\000\000\003\026\003\004\005n\000\000\000\137\000\137\004\000\133\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\023\006\000\000\001\023\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\157\003\026\001\001~\000\000\000\157\000\137\000\000\000\000\000\000\023\n\000\000\000\000\000\157\000\157\000\000\000\000\001\000\000\006\r\000\000\000\000\000\000\000\000\001\001\001~\023\000\000\000\000\000\000\000\000\000\000\000\137\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\006\017\000\000\000\000\000\157\002\014\001\002J\000\000\000\000\000\000\000\000\024\002\000\000\000\000\000\000\000\000\000\000\000Z\002N\002Z\024B\000\000\006\r\006\r\002f\000\000\002j\002\014\000\000\002J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Z\002N\002Z\000\000\000\000\006\017\006\017\002f\000\000\002j\000\000\000\000\006\r\000\000\001\001~\000\000\000\000\000\000\000\000\000\000\006\r\000\000\000\000\000\000\000\000\000\000\000\000\006\r\001\000\000\000\133\000\133\000\000\006\r\006\017\001\000\000\000\000\006\r\000\000\000\000\000\000\000\000\006\017\000\000\000\000\000\000\000\000\000\000\000\000\006\017\001\001~\000\000\000\000\000\000\006\017\002\014\000\000\002J\000\000\006\017\000\000\000\000\000\000\000\000\001\000\000\000\137\000\137\000Z\002N\002Z\001\000\000\000\133\000\133\002f\000\000\002j\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001~\000\000\000\000\000\000\000\000\002\014\000\000\002J\000\000\000\000\000\000\000\000\000\133\000\133\001\000\133\007!\000\000\000Z\002N\002Z\001\000\000\000\137\000\137\002f\000\000\002j\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\001\001~\000\000\000\000\000\000\000\133\002\014\000\000\002J\000\000\000\000\000\000\000\000\000\137\000\137\001\000\137\007!\000\000\000Z\002N\002Z\001\000\000\007!\007!\002f\000\000\002j\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\001\001~\000\000\000\000\000\000\000\137\002\014\000\000\002J\000\000\000\000\000\000\000\000\000\000*\001\007!\007!\000\000\000Z\002N\002Z\001\000\000\007!\007!\002f\000\000\002j\000\000\000\000\000\000\018\000\000\018\000\000\000\000\000\000\007!\000\000\000\000\000\000\000\000\000\000\002\014\000\000\002J\000\000\000\000\000\000\000\000\000\000*\000\000\007!\000\000\000\000\000Z\002N\002Z\001\001~\007!\007!\002f\000\000\002j\000\000\000\000\000\000\018\000\000\000\000\000\000\000\000\001\007!\007!\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000*\000\000\007!\000\000\018\000\000\000\000\000\000\001\001~\000\000\000\000\000\000\000\000\002\014\000\000\002J\000\000\018\000\000\000\000\000\000\000\000\001\007!\007!\000\000\000Z\002N\002Z\001\000\000\007!\007!\002f\000\000\002j\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\001\001~#Z\000\000\000\000\000\000\002\014\000\000\002J\000\000\002\025\002\025\000\000\000\000*\001\007!\000>\000\000\000Z\002N\002Z\023\134\000\000\007!\007!\002f\000\000\002j\000\000\000\000\000\000\018\002\025\002\025\000\000\002\025\002\025\007!\000\000\001\001~\000\000\000\000\002\014\002F\002J\000\000\000\000\000\000\000\000\000\000*\000\000\007!\001\000\000\000Z\002N\002Z\018\014\000\000\001\000\000\002f\000\000\002j\000\000\001\001~\018\000\000\000\000\003\026\000\000\000\000\007!\026Z\002\025\005f\000\000\000\000\017\003\002\014\026\154\002J\000\000\000\000\000\000\022\n\000\000\000\000\000\000\000\000\000\000\000\000\000Z\002N\002Z\000\000\000\000\000\000\000\000\002f\002\025\002j\000\000\002\025\000\000\000\000\000\000\001\005B\003b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\026\003\004\000\000\000\000\000\000\000\000\004\000\000\004"))
  
  and lhs =
    (16, "\000\006\000\005\000\004\000\003\000\002\000\001\000\000\0018\0018\0018\0018\0017\0017\0017\0017\0017\0017\0017\0016\0016\0016\0015\0015\0015\0015\0015\0015\0015\0015\0014\0014\0013\0013\0012\0012\0012\0012\0012\0012\0011\0011\0010\0010\0010\0010\0010\0010\0010\0010\001/\001/\001/\001/\001/\001/\001/\001.\001-\001-\001,\001,\001,\001,\001+\001+\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001*\001)\001)\001(\001(\001(\001'\001'\001'\001'\001'\001'\001'\001'\001'\001&\001&\001&\001&\001%\001%\001$\001$\001$\001#\001#\001#\001\"\001\"\001\"\001\"\001\"\001\"\001\"\001\"\001\"\001\"\001\"\001\"\001\"\001\"\001\"\001!\001!\001!\001!\001!\001!\001 \001\031\001\031\001\030\001\030\001\030\001\030\001\030\001\030\001\030\001\030\001\030\001\030\001\030\001\030\001\029\001\029\001\028\001\028\001\028\001\028\001\027\001\027\001\027\001\027\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\026\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\023\001\023\001\023\001\023\001\023\001\023\001\022\001\021\001\021\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\020\001\019\001\019\001\019\001\018\001\018\001\018\001\018\001\018\001\018\001\018\001\018\001\018\001\018\001\018\001\018\001\018\001\018\001\018\001\017\001\017\001\017\001\016\001\015\001\015\001\015\001\015\001\015\001\014\001\014\001\r\001\r\001\012\001\011\001\n\001\t\001\b\001\007\001\006\001\005\001\005\001\004\001\003\001\003\001\002\001\001\001\001\001\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\159\000\158\000\157\000\156\000\155\000\154\000\153\000\152\000\151\000\150\000\149\000\148\000\147\000\146\000\145\000\144\000\143\000\142\000\141\000\140\000\139\000\138\000\137\000\136\000\135\000\134\000\133\000\132\000\131\000\130\000\129\000\128\000\127\000~\000}\000|\000|\000|\000|\000|\000{\000{\000{\000z\000z\000z\000y\000y\000x\000x\000w\000w\000v\000u\000t\000s\000r\000q\000q\000p\000p\000o\000n\000n\000m\000l\000l\000k\000j\000i\000h\000h\000g\000f\000e\000d\000d\000c\000c\000c\000c\000c\000c\000b\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000`\000`\000_\000_\000^\000^\000]\000]\000\\\000\\\000[\000[\000Z\000Z\000Y\000Y\000X\000X\000W\000V\000U\000U\000T\000T\000S\000R\000R\000Q\000Q\000P\000O\000N\000M\000M\000L\000L\000K\000K\000K\000J\000I\000I\000H\000G\000F\000F\000F\000F\000E\000D\000D\000C\000C\000B\000B\000A\000A\000@\000@\000?\000?\000>\000>\000=\000=\000<\000<\000;\000;\000:\000:\000:\0009\0008\0007\0006\0006\0005\0004\0004\0003\0002\0002\0002\0002\0002\0001\0000\0000\000/\000/\000.\000-\000,\000,\000+\000*\000)\000)\000(\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000&\000&\000%\000%\000%\000%\000$\000#\000#\000\"\000\"\000\"\000!\000!\000 \000 \000 \000 \000 \000 \000\031\000\030\000\029\000\029\000\028\000\028\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\026\000\025\000\025\000\024\000\024\000\023\000\023\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\021\000\021\000\020\000\019\000\018\000\017\000\017\000\017\000\016\000\016\000\015\000\014\000\014\000\r\000\r\000\012\000\012\000\012\000\012\000\012\000\012\000\011\000\011\000\011\000\n\000\n\000\t\000\t\000\t\000\t\000\b\000\b\000\007\000\007")
  
  and goto =
    ((16, "\006h\018t F\000\000\000\000\000\000V\000\151\000\000\000\000\000\000\000\000\000\000\000\000#D\000\000c\000\000\001+\001\029l*\003\144\000\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000B\000\000\007H\000\027\000\000\000t\000\155\000\000\000\000\000\000\000\000\000\000\000\000\000\000\151\000\000\000\000\000\000\0008\000\000\000M\000\000\000\000\000\000\000\000\000\000\000\146\000\000\000\000\000\000\001\028\000\000\000\000\000\000\003\026\000\000\000\000$\001\n\000\000\000\000\000\000\000\000\000\000\001\000\000\002\146<\000\000\001\003\002\018\000\000\002:\000\000\000\000\000\000=\022\001\150\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000m\006\000\000\000\003\000\000\025\152\003\000\000\028<\014\000\159\000\000\000\000\001:\000\000\000\000\000T\003\134\b\000\000\132L\001N&\146(F\000\000\133B\002B\000\000#\000\000\000\000\000\000\133B\000\0004l)\012\133X\001N\000\000=d\000\000\000\000\000\000\000\000#\000\000\000\000\000\000\000\000\000\000\000B\001\132=\000\000\003\156\t\1320\136\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002 \000\000\000\000\000\000\000\000\000\000\003\001\022\000\000nx\002\134\006\130\004\"\156\004\n\000\000\000\000\000\000\000\000\000\000\004D\004\000\000\000\000\000\000/n\000\000\000\000\000\000\000\145\000\000\0050\000\000=\b\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004F\000\000\000\000\000\000\000\000\000\000\007\n\000\000\000\000\000\000\000\000\004\000\000\000\000\003n\000\000\000\000\000\000\004\006\000\000\000\000\000\000\006\000\0000h\000\000\000\000X\0282\128\000\000\000\000\000\000\000\000\000\000_\000\000\000\000\002>\000\000\002B\000\000\000\000\000\000\000\151\000\000\000\000\002^\000\000\000\000\000\000\006\000\151\000\000\000\000\000\000\000\000\025\018\000\000\000\000\000\000\000\000\000\000\b>\004F\000\000\tF\n\025\018\000\000\000\000\005\004d\n\005\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005@\000\000\000\000\007F\000\000\007>\001\154\005N\011\000\000\007\152\007\b\004.\003\000\000\000\000\003\006\">p\002\130\007P\000\000\000\000\000\000\000\000)(\133b\000\027\000\000>)*b\133\128\000\000\000\000\000\000\000\000\134\022\000\000\000\000\000\000\1342\000\000\004\136>\005\000\000\b*\007\000\000\000\000\000\000\000\000\000\000\000j\000\000\000\000\t\022\000\000\000\000+V\020\000\000\000\000\000\000\000\000\005\016\000\000\000\000\000\000\003D\000\000\000\000\000\000\000\000\b@\000\000\000\000\000\000\000\000\000\000\000\000\000\000$\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\t6\000\000\000\000\000\000\000\0000\150a\005\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016<\000\000\bj\000\000\000\000\000\000\000\000\000\000\001z\000\000\000\000\b\002\000\000o\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0005|p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\002\018x\000\000\b\002\n\012\000\000\005\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007L\014\000\000\000\t\146\000\000\000\000\000\000\000\000\000\00001\000\0002\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132(\002\000\000\000\000\000\000\t\136Q\146\000\000\000\000\000\000\000\000\002D\000\000\000\000\bJ\000\000\132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000]b\132\000\000\000\000\000\000\bJy\000\000\bJ\nv\000\000\002\000\000\000\000\000\000\000\000\000\000ox\000\0002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000o\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\t\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000o\000\000\000\000\000\000\000\000\000\000\000\000\t\000\000\000\000\000\000\000\000\n\0263.\000\000\000\000\000\000\000\000\000\000\000\000\000\000}\bJ~f\b\002\000\000\000\000\000\000\nN\000\000\000\000\000\0009>\002\t\t\000\000\000\000!\024\002\t\000\000L\132\000\000\000\000\134Z\000\000\t\000\000\000\000\000\000\000\000\0114$$\012\019\t\022\005\r\028\005\r\134t\135\014\000\000\000\000\000\000\135*\000\000\005?L\135D\135N\000\000\t\000\000\000\000?'\002\nL\000\000v\002\nP\000\000{\140?3<\000\000\135d\t\000\000\000\000\135l\135\136\000\000\000\000\000\000\011$d\015r\001u\n4\000\000\000\000\000\000\000\000\005\000\000\000\000\015\000\000\001T\019\138@#D\020\030\001T\000\000\003\000\000\000\000\000\000\000\000\nH\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000A@\000\000\136\"\000\000\000\000\000\000\000\0007Z\000\000\000\000G\154\000\000\000\000\000\000\000\000\000\000\000\000\136F\136d\000\000A}T\002\n\000\000\128\030\002\n\000\000\128dA3\136\000\000\136\128\n^\136\137\022\000\000\1376\000\000BX\000\000\006\006B\137P\000\000\000\000\000\000\000\000L\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000C6\000\000\006*Cj\137x\000\000\000\000\026\018,X\000\000\000\000\000\000\000\000\000\000\000`\000\000\000\000\011\000\000\022v\000\000\000\000\000\000\000\000\000\000C\000(D \000(D\140\000(\000\000\012\000\000\000>\004\000\000\000\000\000\000\000\000D\000(\000\000E,\000(E\158\138\026\000\000\000\000/\146Ef$\000\000\000\000\000\000\000\000\000\000\003D\000\000\000\000\0114\000\000\024\004\000\000\000\000\000\000\000\000\000\000F>\003vF\136\003vF\003v\000\000\014<\000\000\132\142\000\000\000\000\000\000\000\000G(\003v\000\000Gr\003vH\012\003vH~\003vH\003vI$\003vI\144\003vI\003vJP\003vJ\003vK2\003vK|\003vK\003vL\028\003vL\142\003vL\003vM\154M\003v\003vNP\003vNX\003vN\003vO\003vO\003v\003vP*\000(P\148\000(Q\n\000(Q\000(Q\000(R8\000(R\000(Sn\000(S\134\000(S\000(TL\000(T\000(U6\000(U\154\000(UVj\000(\000(V\000(V\000(W\152\000(X\002\000(\000(\000\000\000\000X\014\000(Xv\000(\000\000\000\000Y<\000(Yv\003v\000\000Z*\000(\000\000ZB\000(\000(\000(\000\000\000\000[\014\003v[B\000(\000\000\000\000[\003v\\ \003v\000\000\\\003v\000\000\\\003v\003v\003v\000\000\000\000\138*\000\000\nz\004F]\003v\000\000\128v\000\000\000\000\000\0004\142\000\000\000\000]\003v^|\003v^\003v\000\t\000\000\000\000\128\000\000\003v\003v_V\003v\000\000\135\014\000\0004T\000\000\000(p\000\000[\018\000\000\000\000q\020\000\000\000\000\011r\000\0005\018\000\000\000\000\000\000\000\000\000\000\000q$\000\000\023\000\000\000\000qh\000\000\000\000\000\000\003v\000\000\004\\\000\000\000\000\005\000\000\000\000\007.\000\000\000\000\000\000\020\021\142\001m\n\026,\000\000\002\128\027_\136\003v\000\000\007\148\000\000\000\000\b\012\000\000\000\000\bd\000\000\000\000\000\000\002\128\000\000\000\000\b&\026^\000\000\000M\011\001\000w\000\000\n\000\000\000\000\000\000\n\000\000\000\000\000\000\011\006\000\000\000\000\r\028%4\020\011\130\014\004\r\000\000q\000\000_\000\000\000\000\000\000r$\000\000\000\000r\142\000\000\006d\000\000\000\000r\000\000\028\006\000\000%p=\022(\006\000\000\014)z\007B\000\000|\000\000\000\000\000\000\000\000\000\000\137\138\000\000\000\000*\140\007N\000\0001\130\007v\000\000\000\0007:\007\146\000\000:\007\000\000\000\000@\007\000\000\000\000B*\007\000\000CL\007\000\000J<\b\000\000\000\000\000\011\146\000\000\000\000\005\016\011\146\000\000\000\000\000\000\000\020\001c\000\000\000\000\000\000\000\000\000\000\002z\012\000\000\000\000\000\000\000\000\011\000\000` \000\000s\026\000\000\000\000\004&\000\000\000\000\000?\r`\011\000\000\000\027\000\000\006*\005\015X\r\134\000\000s\000\000\r&\r*\000\000\006j\000\000\006\000\000\b\142YB\000\000\000\000\000\bP\000\000\b\128\000\000s\000\000\016@\025\018\b\136\000\000\000\000t2\000\000]\005\n\b\000\000\b\000\000\000\000^^\005N\b\000\000\t\014\000\000\000\000b\006\t6\000\000\tB\000\000e \006\tb\000\000\t~\000\000g\012\007V\t\138\000\000\t\142\000\000\007\000\000\b:\000\000tn\000\000\004X\000\000\002\000\000\011\006\000\000\000\000\000\000\000\tt\000\000\000\000\000\000\000\000\000\000\000\000\004h\012\012R\000\000t\000\000\r\012j\000\000u\000\000\b\144\000\000\000\000u\000\000\rp\000\000\012\140\000\000%\012|\000\000\000\000\012\000\000v\000\000\b\000\000\000\000\000\000\000\000\r\012\000\000&R\b\000\000\000\000\000\000\000\000\000\000\000\000\000\017V\025\018\003\140\b\000\000\000\000\000\000`\134\000\000v\000\000\t.\000\000\000\000\t2\000\000\000\000\r\003\000\000\000\000\000\000\000\000\003\140\004p\012\000\000\000\000\000\000\000\000\000\000\t`\000\000\000\000\012\017\000\000\000\000\000\000\0010\158\014\"+z9x\002\rN\000\000XX\002\rl\000\000eRa\014\003v5\132\004Fav\003vfJ\000\000\000\000\000\000\000\000\023\rp\000\000w\030\000\0005p\000\000\003v\rN\000\000\000\000wZ\000\0005\000\000\000\000a\132\003v\000\000h\000\000\000\000\000\000\000\000w\150\000\000bB\003v\000\000bP\003v\tn\000\000\t\000\000#\000\000P\n\144\003\152\018|\025\018\000\000\000\000\000\000~\022v\000\000\001\000\000\000\000\000\000\000\000\000\000\000\0006\138\000\000\000\000\000\000\000\000\011\n6,\000\000\000\000\r\000\000\000\000\000!\004@\014 \r\000\000w\000\000\000\000\t\000\000\014J\000\000\r\000\000xr\000\000\000\000\r\015&b\000(\000\000c\028\000(\000\014\004\014\016\000\000'T\000\000\128c,\000(d\006\000('\014D\000\000x\000\000d8\000(\000\000x\000\000\000\000d\000(\000\000\000\000\000\000m@4\004Fe\018\000(\000\000\000\000\000\000\n$\000\000\005 \nD\000\000\000\000ez\003(\000\000\014\011\001\000\000\000\000\nb\000\000e\n\144\000\000\000\000\000\000\n\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000+\n\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\026\000\007\003\140UXZl\004F\028f\004F\029\026\000\000\000\000\000\000\000\000\004F\029\000\000\000\000\000\000\000\000\001\030\005D\000\000\n\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\021\030\r\r\000\000\000\000\137\138f\004F\031\146\004F+\000\000\000\000\000\000\000\000\004F\128\000\000\000\000\r\001\000\000\000\0009\150\017\001\001z\129\000\000\000\000\000\000\020:\001\000\000\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\000\000\000\000\000\000\022\012\000\000\000\000\000\000\015\020\000\030D\002\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nb \022\000\000\000\000\000\000\006\000\000\011\006\000 \015\000\000\000\000y&\000\000yh\014V\000\000f\030\000\000y\000\000\000\000\015:\000\000\011N\000\000\011Z\000\000\000\000\000\000\000\000\000\000\011\158\000\000\000\000\000\000\011\000\000\000\000\000\000\011\000\000\000\000\016\"\000\000\000\000\000\000\012\158\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\023L\015\148\015d\011\016\000\000\000\000\014\011\020B\000\000\000\000\000\000\004D\012\b\b\000\\\016Xz`\000\000z\156\014\000\000\015\140\000\000\011\000\000\000\000\011\000\000\000\000\016t\000\000\000\000Nr\004D\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016n\000\000{X\011~\000\000\006\\\0168\000\000\000\000\000\000\000\000\000\000\000\000\014\130\016x\000\155\006\142\000\000\000\000\004.\016\136\014\000\000\011\150\000\000\000\000\014\015\011\000\000\000\000\014\007\146\011\000\000\000\000\014\006\012\016\000\000\000\000\b,d\000\000{\148\000\000fh\000(\000\000g\b\000(\012 \000\000\000\000\000\000\000\000\024\000\000\000\000\012$\000\000\000\000\005&\000\000\000\000\000\000\007,\017\148\000\000\000\000S\0058\000\000\016\000\000{\000\000\016X\016\\\000\000\0124\000\000\015>hj\n\000\000r\158\011\028\000\000\000\000u*\0114\000\000\000\000y\011<\000\000\130V\011r\000\000\134x\011\000\000\012N\000\000\b\020\007\000\000\015\014\006\n\r\012d\000\000\000\000\015\"\006\130\n\000\000\012r\000\000\000\000&\000\000\000\000\000\000\000\000\004N\000\000\000\000[`\004D\004\\\004D\000\000\000\000\000\000\005\014\000\000\016\026\012z\000\000\012\142\000\000\016.\000\000jH\004D\012\000\000\000\000\000\000\015\020\016\000w\005\r`\012\000\000\000\000\015\022\016F\012\000\000\000\000\015$\007\012\000\000\000\000\015&\bN\r\030\000\000\000\000\r4\000\000\000\000\000\000\000\000\000\000\000\000\004D\000\000uv\004D\004D\031\028\002\128\000\000\000\000\000\000\000\000\n R\002\128z.\000\000\"H\002\128\004D\000\000\000\000\000\000\016z\rH\000\000\rL\000\000\022\000\000\000\000\000\000\000\000\000\000\016\000\000\016\144\001\140\r\136\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\000\000\000\000\000\128\152\004D\000\000\130\006\006\000\000\000\000\002\128\000\000\000\000\000\000\002\128\000\000\000\000\131<\006\000\000\000\000\004D\000\000\n$\128\001T\001T\tj\000\000\000\000\000\000\000\0007 \000\000\003v\000\000\000\000\000\0007\148\000\000\b\006\000\000\000\000+n\000\000\016\1548Z\000\000\000\000\000\000\000\000,8v\000\000\000\000\016\156-\130\000\000\000\000\000\000\000\000\012X\016\158\000\000\000\000\000\000\000M\000\0008\000\000\003\136\000\000\000\000\004t\000\000\000\000gR\000(\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000g\000(\000(\138\004Fg\000(\130`\000\000\000\000\000\000\000\000hd\003vh\000(ip\000(\006p\000\000\000\000\130\150\000\000\000(\000(\000\000i\000(\000\000j&\003v\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001T\t\000\000\000\000\000\000\000\000\000\000\b\006\000\000\000\000-\016\000\000\000\000\000\000.9|\000\000\000\000\016.\000\000\000\000\000\000\000\000\012b\016\000\000\000\000\000\000\005L\000\000\000\000\000\000\000\000\000\000\000\000-\158\016\016\000\000|\018\000\0009\000\000\000(\000\000|N\000\000:f\000\000\000\000j.\000(\000\000~\000\000\000\000\000\000\r\146\000\000:\016\003\136\000\000j\000(\000\000\000\000\r\000\000\000\000\000\000\000\000\000\000\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016|\r\000\000\026\144\000\000\000\000\000`%\001T\131f\004D*\000\001T\000\000\000\000\r\000\000\027r\000\000\000\000\000\000\b\028&\000\000\"~\000\000\006\020\016\029\b\000\000\000\000\000\000\000\000\000\000\000\000\n*\146\001T\131\000\000-\001T\000\000\000\000\000\000\011\000\000\000\000\000\000\000\000\000(\000\000k\128\000(\000\000k\142\003v\000\000\000\000\000\000\002\000\000l\000\003v\029\014\"\000\000\000\000\000\000\016\016\132\r\000\000\030\158\000\000\000\000\001F\r\000\000\031R\000\000\000\000\000\000\011\n 4\000\000\"\000\000\006\156\016 \000\000\000\000\000\000\000\000\000\000!\000\000\007\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000(;D\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\007\000\000\000\000\000\000\000\000U&\000\000\000\000\000(\000\000\007\148\000\000\b\012\000\000\002\128\000\000\002\128\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0230\000\000\000\000\000\000\000\000\r\000\000\000\000\000\000~\bJ\127\b\002\000\000\000\000\000\000lj\003v\000\000\000\000\000(\000\000\004\\\000\000\005\000\000\002\128\000\000\001T\000\000\t\000\000\000\000\000\000\000\000\000\000l\003vm\003v\000\000\016\000\000\000\000\000\000\b$\000\000\000\000\000\000\000\000\000(\000\000\016\000\000\000\000\000\000\138T\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000.\000\000\000\000\004\007\000\000\000\000\000\000\000\000(\016\012\000\000\000\000\000\000\003T\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\r\004\000\000\004F\000\000\"\000\0002\000\000\000\000\000\000\000\000\014<\000\000\r\t\000\000\000\000\000\000\000\000\000\000|\138\000\000mx\r\002\000\000\138 \r\022\000\000&<\139\022\rX\000\000X\028\139B\rf\000\000\139l\rr\000\000\139t\rx\000\000\000\000\139\r\134\000\000\139\r\000\000\000\000\139\r\000\000\000\000\140.\r\000\000\140T\r\000\000\140j\r\000\000\000\000\015\000\000\000\000\006\015\000\000\000\000\000\000\002\000$\000\000\000\000\000\000\000\000\000\000\000\004\016\000\000\000\000\000\000\000\000\015\000\000\006h\016\136\014(\000\000\000\000\017(\016\004\014`\014\\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016,\000\000\138\158\016.\000\000\000\000\000\000\000\000\000\000\000\000\006\004\007\000\000\000\000\1390\000\000\024H\000\000\000\000\000\000\000\000\000\000\021h\000\000R\140\000\000\000\000\000\000\000\000m\000\000\000\000\000\000;\000\000\003v\000\000/\000\000\000\000\000\000\001\016\003\000\000\017F\017\012\005fhj\t\000\000\000\000\014\002\000\000r\158\011T\014\006\000\000\000\000u*\011X\014*\000\000\000\000y\011\0142\000\000\130V\r\\\014F\000\000\134x\r\014t\000\000\014\138\014\000\000\000\000\000\000\000\000\000\000\0166\007X\000\000\000\000\000\000\000\000\000\000\000\000\000\000\017\"\016B\014\142\131\007J\000\000\000\000\014\"1$\007b\000\000\017\000\000}*\000\000\017b\014\000\000\014\014\000\000\015\030\000\000\000\000\br\000\000\016\012\019<\022\142\024\001\000\000\000\000\130\130\000\000\000\000\000\000;\000\000\000\000\000\000}\146\000\000~$ \007$\021\r\000\000\000\000\000\000\127\132\024\004\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\015\130\000\000)\b\015\000\000\000\000sd)R\015\004\024\000\000+\015\000\000\000\000\000\000\000\000\000\000\000\000\0158\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\017*\007\142\000\000\017.\015D\000\000\015Z\000\000\000\000\000\000\000\000\015\020\015\0172\015n\000\000\000\000\015$\015\tR\015r\000\000\000\000\011\n\025\000\000\015\136\000\000\000\000\b\150\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\004,\000\000\000\000\005\012\000\000\000\000\000\000\000\000"), (16, "\002\002\0066\001\000\141\005\150\000h\b\007\b\b\b\t\000l\000m\007Y\007\b-\007\003_\007\001\006\bI\b\b\020\b\004\128\b\128\b\020\005\150\000h\004\004\005\r\000s\001\000\000J\b\n\003`\000\005\153\001I\001\006X\006k\b\tz\004^\000\n\nx\t}\t\128\004\004\004\004\nw\007\004\005\017\005\r\005\153\007\003o\002\001\001\b\131\002\002\004A\006\004\001\000\144\000J\006\005\004\005\021\005\r\005\020\t\007\003\t\t\014\na\003_\000\141\000a\000h\b\000P\b\t4\b\131\000V\001\001\b\011\007\b\020\005\154\003c\001\002H\001\003`\004\006\005\r\000\001\t5\b\b\t\001@\001U\t\001\t\004\001?\001J\005\154\005\150\000h\005\155\004o\005/\006\006\nc\006\020\007\000Z\007\007\007\005\004\007,\005\r\003T\t\028\t\029\003e\000\000h\005\155\001M\t\007\b\132\t\014\b\133\006l\t\b\136\006\007\005\153\005\157\003\027\t4\b\131\005\006\t\t\030\007\127\007\007\128\003f\003c\006\149\t\022\t\023\t\024\003p\b\132\007\b\133\000\014\t5\b\136\004I\003\028\003 \003x\b*\000h\003U\006m\003Z\t!\b\021\001'\001%\005\004\001J\006\020\006o\t+\000f\000h\001W\001X\005\001Y\003[\003T\t\028\t\029\003e\t#\000\000h\005\005\005\154\007[\006\012\000\000h\003\026\001M\002\133\002\134\002\135\006\r\n\029\003\128\003]\t\030\007\127\002\018\007\128\003f\005\015\000^\001N\t\131\006\029\005\155\b\132\006p\b\133\002\011\004\130\b\136\005\005\007\003x\006\132\003\029\003U\0053\003Z\t!\b%\t,\000s\b\020\000M\003\135\005\015\005\020\000\141\001\001\005\022\000j\000h\006r\003[\003^\000\t'\t(\t#\t\011!\011\"\005\015\003N\011$\011%\003\127\t\022\t\023\tV\011'\003\137\011(\000\135\001\003\128\003]\003\027\006v\006s\000L\n\015\n\016\003O\006\t8\006\029\t\001%\005\005\005\015\001N\b \001O\t+\t\006\157\000h\003\031\003\028\006\000\137\002\136\nN\nG\n\\\nJ\nL\003\135\006f\003\021\000h\000\003!\000s\nG\nT\nJ\nL\003^\005\015\t'\t(\006\006\002W\011)\005)\006\006\t3\0111\t\001@\000\n\001I\003\137\004\005\004\004\004\000\003\127\006v\003\141\t\t\141\b*\000h\000\005_\006\006\004\t,\002\b\020\006\005\006l\001\001\011M\002\006\t\001\0112\0113\000v\001O\002\139\003\029\000\000\n\011N\b=\003N\011$\011Q\002\140\002\147\001\000h\011'\003*\011(\000\003\143\000\002\007\006\002\b\005\"\003\025\006m\006\003O\000s\b)\002\t\0114\0115\000\011:\006o\011;\n]\011@\006\024\006\006\006\025\003\144\nV\002\012\006\001J\000\003\030\003\153\001\002&\005/\002M\002O\tF\006\002\128\003\006\001\003+\000s\0032\011A\011C\002B\006\007\003\031\000\000h\011)\001M\000x\006\t\011E\0111\002r\t3\006p\0033\006\127\006\000\000h\011F\bU\001\001\003\141\006`\002\015\006\001\000}\001E\001@\001<\001@\002\006\002\018\003\0035\b\b\000\131\006\000J\0112\0113\001C\001@\006\002\021\002\022\002\027\002~\002C\000J\001\006\011\np\0030\005\020\005\001\001@\003*\005\022\006\012\003\143\000\127\001\t\141\006\006s\003\006\r\005\"\011I\011H\011J\000\0114\0115\002X\011:\0036\011;\000\011@\006\024\006\006\025\003\144\000\000\003\154\001\000h\tk\001N\tn\004\130\003\001\001\011P\t\t\003\003\019\n\158\003+\006%\0032\011A\011C\n\025\011N\tF\003N\011$\011Q\005\002\000\150\011E\011'\000\011(\001\0033\005y\002\023\002\006\011F\006\000s\000\137\003O\006\t\155\005\nG\n[\nJ\nL\003\021\000h\001\000h\005\003\0035\002\028\002\012\006\000J\001\002\t\157\005\"\003*\000\153\n\019\001\015\b*\000h\007\019\007\020\007\021\007G\t\154\t\001@\005\014\001O\006\001\000l\007]\007Y\000\000h\011)\001\012\006'\003\011T\0111\011\022\011H\011J\by\bz\002\025\002\026\b}\0036\004t\006\006\003\141\006\157\000h\002 \002\127\002D\003+\ng\0032\005\158\002\000\000\003\001\001\011S\002\006\005\003\127\0112\0113\t\138\007\tn\0033\000\137\003\025\011N\001\003N\011$\011Q\006\006\003\021\000h\011'\003*\011(\007\022\003\143\000\002\007\001\143\002\b\001\0034\0035\007\003O\tF\005\002\t\0114\0115\000\141\011:\003\011;\005\011@\006\024\006\002\006\025\003\144\001\143\000\006\005\005\007\001\r\000J\002&\000\0022\002O\000\001\002\150\003\007\136\n\003+\000\0032\011A\011C\002B\005\"\007\145\0036\006\011)\b\0066\007\011E\0111\002/\005\000\0033\005\007\023\001$\001%\011F\b|\bz\005{\003\141\b}\002\015\001\b\003\025\006\007\024\007\007\025\002\018\002\tC\002\018\003\0035\000J\006\001&\001%\000J\0112\0113\006\006[\b\131\002\021\002\022\002\027\002~\002C\b\135\bz\001\t\007\b}\000J\001\014\006\003*\006\157\000h\003\143\000\141\002\018\t\007%\tn\003\011T\007?\001\019\011H\011J\005\0114\0115\006\011:\0036\011;\006\011@\006\024\005\015\006\025\003\144\001[\007[\nX\001@\nl\nm\006\006\004\130\003\002\002\004\007\005\r\003\001\030\005\003+\tF\0032\011A\011C\t$\007\004w\003_\006\006\n\133\000J\001I\011E\006\b\031\006\005\"\0033\b\132\002\023\b\133\007&\011F\b\136\001\002\005\003`\007'\bG\001\001\016\001\017\004\n\b\000\137\004\003\021\000h\0058\003\0035\002\028\002\012\003\021\000h\006\005!\000\000h\000\141\001\012\001\020\007\b\148\007@\007A\007B\005\t\152\005\n\n\005\006\000l\n`\007Y\001\001\146\006\006\tb\005?\003\011T\007S\003\127\011H\011J\001\t\006\002\025\002\026\007Z\0036\007?\006\006\003c\001J\001\145\002 \002\127\002D\001K\001P\b\001\152\002\t\156\007\003\002\002\n}\002R\tn\005#\007T\007U\n\001\000\000h\000J\001M\004-\003\025\003_\006\006\007P\001\001\003\025\006\003T\006\007C\003e\000\141\002S\001+\002T\004\025\005\"\005_\006\003`\001\r\001G\002U\007V\007c\t\007h\005\007m\003\026\007r\007\127\002\007\128\003f\002\018\002\006\001\002\n\nn\004z\b\156\002k\001\016\001\017\002\149\001\018\002\018\002v\003x\n\005\024\003U\001\149\003Z\007\129\007\132\002{\005\"\n\135\000\000h\006\001\012\001\020\001\021\007\134\007S\007\000\137\007\003[\000\n\007D\005\015\003\127\007\135\006\003\021\000h\003c\007\002[\005\001N\001\150\007E\005W\007F\bU\002\004\137\002^\003\128\003]\001\014\001\026\002\018\n\001\155\007T\007U\006\003\027\t\002_\002`\002e\002~\002|\007\005\"\007O\001\t\004\001%\tF\006\003T\005\"\000\137\003e\t\022\t\023\011+\006\003\028\003\135\n\003\021\000h\007\137\007\138\nK\007V\007c\nL\007h\003^\007m\001\156\007r\007\127\003\007\128\003f\007[\004\001%\005F\t+\004\140\001\r\004\001%\003\137\002\002\005Y\003\025\001O\003x\005L\001\025\003U\007[\003Z\007\129\007\132\001\005\007\018\003_\006\006\007P\001\000\007\134\006\000\137\006\005\003[\007o\002a\000\141\006\007\135\003\021\000h\001\002\003`\006\b9\004\143\003\029\001\016\001\017\n\001R\005z\001\000h\011G\003\128\003]\002f\002X\t,\003\025\b\020\005R\t\000\000h\007\140\001\012\001\020\005\"\007\019\007\020\007\021\tm\000\137\004\001%\001\001\014\001\026\007?\004\001%\003\021\000h\005\139\006\005\148\001\027\003\135\n\007S\003\030\007\137\007\138\001U\007j\002c\002d\005\159\003^\004\001%\007+\003c\001\002\t*\002j\002\127\002}\001\n\001\015\003\031\001\002\004\001%\003\137\002\002\003\025\002R\004\001%\007T\007U\004\001%\000\000h\005\001\012\005\001\003_\006\006\007P\004\001%\005\"\006\003T\006\007\022\003e\001\002S\007\002T\007\t3\004\001%\003`\005\001\r\002U\007V\007c\001\007h\005\007m\003\025\007r\007\127\002\005\007\128\003f\004\001%\002\014\001J\003\127\t\bO\007\002k\001W\001X\002u\001Y\005\"\002v\003x\005\0021\003U\003\127\003Z\007\129\007\132\002{\005V\005X\000\000h\006\001M\002\133\002\134\007\134\007S\0029\000\137\007\003[\002Z\007\023\005*\005+\007\135\005\003\021\000h\003c\005\"\002[\005\"\001\r\b\007\024\006&\007\025\011\031\002\t\002^\003\128\003]\005\"\001\014\001\026\005,\005+\007T\007U\0052\005+\002t\002_\002`\002e\002~\002|\003\n\021\002^\001\t\000\137\0059\005+\006Y\003T\002\143\000\137\003e\002\003\021\000h\007%\005\"\003\135\005\"\003\021\000h\007\137\007\138\006\\\007V\007c\002\007h\003^\007m\000\137\007r\007\127\007~\007\128\003f\005;\005+\006g\003\021\000h\005\"\001N\005@\005+\003\137\002\002\005\003\025\001\014\003x\002\t\003U\002\003Z\007\129\007\132\005B\005+\006j\003_\006\006\007P\002\001I\007\134\006\006n\006\006z\003[\002\002a\002\007&\007\135\005G\005+\001\002\003`\007'\b\004\005I\005+\001\016\001\017\003\156\0047\011=\003\021\000h\003\025\003\128\003]\002f\002X\005\003\025\005M\005+\t\000\000h\002\001\012\001\020\005\"\007@\007A\007B\006\000s\005O\005+\n\001O\002\139\003\025\005S\005+\005U\005+\007 \006\007H\002\140\003\135\002\007S\002\007\137\007\138\000\002\002c\002d\005\"\003^\005j\005m\003r\003c\001J\th\002j\002\127\002}\001V\001P\006\004\003\004\002\005\"\006\005\003\137\002\002\003\024\002\006\006\157\000h\007T\007U\006\154\005m\000\000h\005\"\001M\003>\003\025\003_\006\006\007P\007\011\007\014\007M\006\003T\006\007C\003e\003B\002\007\003I\002\b\002\002\007a\005\"\003`\006\001\r\002\t\007V\007c\004c\007h\005\"\007m\005\007r\007\127\006\006\007\128\003f\006\007\004\002^\001\002\002^\t\158\006\000h\002&\004\003\129\003\130\002\002<\002F\003x\003i\b\019\003U\004\154\003Z\007\129\007\132\002B\006\007\007f\000\000h\006\001\012\004\158\006\t\007\134\007S\007k\005\"\004\003[\006\n\007D\007\002\000h\007\135\007p\006\004\003c\005\002\015\005\001N\007}\007E\007\133\007F\002^\002\000s\002\018\003\128\003]\007\154\001\014\001\026\007\006\000h\007T\007U\006\007\n\007\004\002\021\002\022\002\027\007\002C\0079\007<\002\007\0075\000h\0078\000h\003T\007\006\012\003e\002\007\158\001%\006\007\003\135\006\r\006\004\007\007\137\007\138\006\005\007V\007c\005\007h\003^\007m\007\007r\007\127\006{\007\128\003f\007\001%\005\"\003\132\003T\n\001\r\n\003\t\003\137\002\002\007\001%\001O\003x\007\001%\003U\005\006\003Z\007\129\007\132\004\006\007\003_\006\006\007P\004\003\133\007\134\006\007\006\007\003[\006\006\002\023\005\002\006\007\135\007\001%\005\"\003`\006\007\017\007\003U\005\007\003Z\005\018\005\"\005\019\001\000h\n\003\128\003]\002\028\002\012\005\"\005\026\006\007\007\b\005 \003[\005\031\005\"\006\t\005\"\007\019\007\020\007\021\007\b\006c\005a\005\001\014\003\027\007\001%\005p\b\024\005q\b\026\006\003\\\003]\003\135\005\007S\005u\007\137\007\138\000\005v\002\025\002\026\005\128\003^\005\003\028\003 \003c\bp\001\002 \005\002D\b\001\005\005\129\002\b(\005\132\003\137\002\002\b\002\006\005\006\012\007T\007U\b\b\t\011\003\134\000\006\r\003^\001\003_\006\006\007P\b\b\t\025\006\003T\006\007\022\003e\002^\002\007\005\135\002\b\001\001\tQ\005\003`\tW\005\144\002\t\007V\007c\005\145\007h\005\007m\005\007r\007\127\005\007\128\003f\t\t\003\029\001\002\005\b\005\005\002&\001\011\003\003\0027\002<\002F\003x\003\147\005\003U\005\003Z\007\129\007\132\002B\005\nb\000\000h\006\001\012\t\001%\007\134\007S\005\005\005\003[\001\002\007\023\n\006\000\007\135\004\001\015\005\"\003c\005\"\002\015\n\018\n\016\005\007\024\nk\007\025\002^\002\000s\002\018\003\128\003]\000\000h\006\027\001\012\006 \007T\007U\003\031\n\030\005+\002\021\002\022\002\027\n\002C\n\005\002\n!\005+\006!\005\"\003!\003T\000\006.\003e\002\006*\005\n\004\003\135\n\006\004\n\007\137\007\138\006\005\007V\007c\005\007h\003^\007m\006/\007r\007\127\0062\007\128\003f\n&\005+\005\003\003*\005\001\r\n*\005+\003\137\002\002\004\n-\005+\003x\n0\005+\003U\006;\003Z\007\129\007\132\n4\005+\0068\003_\006\006\007P\006B\003\007\134\006\006b\006\n\003[\006\006\002\023\006\001\r\007\135\n7\005+\005\"\003`\n;\005+\011 \003+\001\002\0032\n?\005+\011.\003\t\001\003\n\003\128\003]\002\028\002\012\001\004\b\025\006\007\0110\b\029\006\0033\nB\005+\006\t\005\"\000\000h\0118\001\012\011>\006\nE\005+\001\014\ni\nj\n\001%\n\001%\011D\006\0034\0035\003\135\005\007S\005\007\137\007\138\001U\006\002\025\002\026\007\b\003^\n\001%\007\r\003c\n\001%\002 \007\030\002D\005\003\t\005\001\014\002\n\001%\003\137\002\002\007\031\002\006\bL\006\012\007T\007U\007#\003\027\007/\003\001I\006\r\0036\0071\003_\006\006\007P\n\001%\0076\006\003T\006\007;\003e\007J\002\007\007b\002\b\003\028\003 \n\n\003`\n\n\002\t\007V\007c\007`\007h\001\r\007m\005\007r\007\127\007^\007\128\003f\007_\007g\007e\001J\007l\007Q\007q\005\002\r\001W\001X\003\n\001Y\005\007\147\003x\003\027\007\153\003U\007\152\003Z\007\129\007\132\007\005\007\000\000h\006\001M\002\133\002\134\007\134\007S\005\007\005\003[\001J\003\028\003 \007\007\135\0050\001P\007\003c\005\002\015\002R\003\029\007\005\007\007\005\002\007\002\018\003\128\003]\000\000h\007\001M\007\007T\007U\001\014\b\023\b#\002\021\002\022\002\027\b$\002S\b'\004:\bb\bl\bq\b\b\b\003T\002U\b\003e\b\t\t\t\n\t)\tO\003\135\tP\tg\tr\007\137\007\138\001I\007V\007c\tx\007h\003^\007m\t\007r\007\127\003\029\007\128\003f\t\t\t\nH\003\031\nY\001N\n^\ne\003\137\002\002\nf\ns\nv\003x\n\157\002\138\003U\003!\003Z\007\129\007\132\n\n\n\003_\006\006\007P\n\n\007\134\006\002]\006\n\003[\n\002\023\n\001N\007\135\011\005\002^\011/\003`\011-\0119\0117\011?\000\000\000\000\000\000\000\000\000\000\000\000\002_\002`\003\128\003]\002\028\002\012\003\031\000\000\001J\000\000\007\141\000\000\000\000\005\156\001P\000\000\000\000\000\000\000\000\000\000\000\000\003!\000\000\000\000\006\001O\002\139\006\000\000\000\000\000\000\000\000h\006\001M\002\140\003\135\000\000\007S\000\000\007\137\007\138\000\000\000\000\002\025\002\026\000\000\003^\000\000\000\000\000\000\003c\006\000\000\002 \000\000\000\000\000\000\000\000\000\000\001O\002\000\000\000\000\003\137\002\002\000\000\002\006\000\000\000\000\007T\007U\000\000\000\000\000\000\000\000\001I\000\000\000\000\002a\003_\006\006\n\132\000\000\000\000\000\000\006\003T\006\000\000\003e\000\000\002\007\000\000\002\b\002\002\006\000\000\003`\002b\002X\002\t\007V\007c\000\000\007h\000\000\007m\000\000\007r\007\127\000s\007\128\003f\000\000\006\000\000\000\000\000\000\000\000\001N\000\000\002)\000\000\000\000\000\000\000\000\000\000\000\000\003x\003i\000\000\003U\000\000\003Z\007\129\007\132\000\000\000\000\002c\002d\000\000\006\000\000\000\000\000\000\007\134\007S\000\000\006\004\000\000\003[\001J\006\005\000\000\000\000\007\135\006\003\001P\000\000\003c\000\000\002\015\002R\000\000\006\005\000\000\000\000\005\002\006\002\018\003\128\003]\000\000h\000\000\001M\000\000\007T\007U\000\000\000\000\000\000\002\021\002\022\002\027\000\000\002S\000\000\004:\002\000\000\000\000\000\000\001O\000\000\003T\002U\000\000\003e\002\000\000\006\006\000\000\000\000\003\135\000\000\000\000\000\000\007\137\007\138\000\000\007V\007c\000\000\007h\003^\007m\000\000\007r\007\127\000\000\007\128\003f\000\000\000\000\000\000\000\000\003T\006\007\000\000\000\000\004\130\003\137\002\002\006\t\000\000\000\000\003x\000\000\000\000\003U\006\003Z\007\129\007\132\000\000\000\000\000\000\003_\006\006\b\000\000\003k\007\134\006\002]\006\000\000\003[\000\000\002\023\000\000\001N\007\135\000\000\002^\000\000\003`\000\000\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\000\000\002_\002`\003\128\003]\002\028\002\012\000\000\000\000\000\000\000\000\006\012\000\000\003[\000\000\000\000\000\000\000\000\000\000\006\r\000\000\000\000\b@\000\000\000\000\011\016\003\t\006\011\017\000\000\000\000\000\000\000\000\000\000\006\003\\\003]\003\135\000\000\007S\000\000\007\137\007\138\000\000\000\000\002\025\002\026\000\000\003^\000\000\006\006\003c\011\018\000\000\002 \000\000\000\000\000\000\000\000\000\000\001O\002\000\000\000\000\003\137\002\002\000\000\002\006\000\000\000\000\007T\007U\000\000\000\000\000\000\000\000\000\000\000\003^\002a\003_\006\006\b>\000\000\000\000\000\000\006\003T\006\000\000\003e\000\000\002\007\003\015\002\b\000\000\000\000\011\028\003\027\003`\002b\002X\002\t\007V\007c\000\000\007h\000\000\007m\000\000\007r\007\127\000s\007\128\003f\000\000\011\029\006\000\000\000\000\000\000\003\028\003 \002&\000\000\000\000\000\000\000\002\002\003x\000\000\000\000\003U\000\000\003Z\007\129\007\132\002B\000\000\002c\002d\000\000\006\000\000\000\000\000\000\007\134\007S\000\000\006\004\000\000\003[\001\002\006\005\000\000\000\000\007\135\000\000\004\000\000\003c\000\000\002\015\000\000\000\000\011\030\000\000\000\000\000\000\000\000\002\011\027\002\018\003\128\003]\000\000h\000\000\001\012\000\000\007T\007U\006\000\000\000\000\002\021\002\022\002\027\000\000\002C\003\029\000\000\n\137\n\140\007\000\000\007\006\003T\000\000\000\000\003e\000\000\001\002\006\006\000\000\004\130\003\135\006\001\015\000\000\007\137\007\138\000\007V\007c\000\000\007h\003^\007m\000\000\007r\007\127\000\000\007\128\003f\000\000h\000\000\001\012\000\000\006\007\000\000\000\000\007\003\137\002\002\006\t\007\000\000\003x\000\000\000\000\003U\006\003Z\007\129\007\132\000\000\000\000\000\000\003_\006\006\006\003\031\004\007\134\006\000\000\006\000\000\003[\000\000\002\023\000\000\001\r\007\135\000\000\000\000\003!\003`\000\000\007\000\000\b<\000\000\000\000\000\000\000\000\006\000\000\000\000\004\003\128\003]\002\028\002\012\002\002\001\002\000\000\006\012\000\000\000\000\n\001\015\000\000\000\000\000\000\006\r\000\000\000\000\006\006\007\000\000\007\007\007\000\000\000\000\000\000\000\000h\006\001\012\001\r\003\135\000\000\007S\000\000\007\137\007\138\003i\000\000\002\025\002\026\000\000\003^\000\000\000\000\000\000\003c\000\000\000\000\002 \000\000\002D\007\000\000\n\142\001\014\002\000\000\000\000\003\137\002\002\007\000\000\000\000\000\000\007T\007U\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003_\006\006\b\028\000\000\000\000\000\000\006\003T\006\006\003e\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003`\000\000\000\000\002\007V\007c\001U\007h\000\000\007m\001\014\007r\007\127\002\007\128\003f\000\000\000\000\000\000\000\000\000\000\000\000\001\r\000\000\000\000\000\n\000\000\000\000\000\000\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\007\129\007\132\007\000\000\003T\000\000\000\000\006\000\000\000\000\000\000\007\134\007S\007\007\007\003[\007\000\000\006\000\000\007\135\000\000\000\000\000\000\003c\n\000\000\000\000\000\000\n\003t\000\000\000\000\006\002\000\000\000\000\003\128\003]\000\000\000\000\003u\000\000\003v\007T\007U\001J\000\000\000\000\003U\000\000\003Z\001W\001X\007\001Y\005\000\000\000\000\007\001\014\001\t\003T\000\000\004k\003e\001\001\003[\000\000h\003\135\001M\002\133\002\134\007\137\007\138\000\000\007V\007c\011\000\007h\003^\007m\000\000\007r\007\127\000\000\007\128\003f\003\\\003]\000\000\000\000\007\000\000\000\000\000\000\000\000\003\137\002\002\003\147\000\000\000\000\003x\000\000\011\001\003U\000\000\003Z\007\129\007\132\000\000\011\003\000\000\003_\006\006\n\131\000\000\011\011\007\134\006\000\000\006\007\003[\007\007\007\000\000\007\135\000\000\000\000\003^\003`\000\000\000\000\001\002\000\000\000\000\000\000\000\000\000\000\001\016\001\017\000\000\001\018\003\128\003]\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\001N\000\000h\002\001\012\001\020\001\021\001\022\011\006\007\000\000\t\000\000\002\000\000\000\000\011\007\000\000\000\000\006\000\000\000\000\003\135\000\000\007S\000\000\007\137\007\138\000\000\002\002\000\000\000\000\003^\000\000\000\000\000\000\003c\000\000\000\000\000\000\003*\000\000\000\000\000\000\003_\007\130\002\001I\000\000\003\137\000\000\006\000\000\006\000\000\000\000\007T\007U\000\000\000\000\000\000\000\000\000\000\000\000\003`\000\000\000\000\003\158\000\000\000\000\000\000\000\000\000\000\000\000\003T\001O\002\139\003e\003\159\000\000\003\007\000\000\000\000\000\000\002\140\003+\000\000\0032\000\000\007V\007c\001\r\007h\000\000\007m\000\000\007r\007\127\000\000\007\128\003f\000\000\001\023\004l\0033\000\000\000\000\006\000\000\000\000\000\000\000\000\007S\000\000\000\000\000\003x\000\000\000\000\003U\000\003Z\007\129\007\132\001J\003c\0034\0035\000\000\000\000\001L\000\000\000\000\007\134\000s\002\000\000\000\000\003[\001\001\000\000\000\000\007\135\000\000\007T\000\000\000\000h\000\000\001M\n\003\001(\000\000\000\000\003N\011B\000\000\000\000\000\000\003\128\003]\011'\003T\011(\000\000\003e\001\014\001\026\000\000\000\000\0036\006\004\000\000\000\000\003O\006\005\001\027\001#\007V\007c\000\000\007h\000\000\007m\000\000\000\000\007\131\000\000\000\000\003f\001\002\000\000\000\000\003\135\000\000\000\000\001\003\007\137\007\138\000\000\000\000\000\000\001\004\000\000\003^\003x\000\000\000\000\003U\000\000\003Z\004\130\007\132\000\000h\000\000\001\012\000\000\011)\000\000\000\000\003\137\007\134\0111\000\000\000\000\006\006\003[\002\002\000\000\000\000\007\135\000\000\000\000\006\003\141\000\000\001N\000\000\000\000\000\000\002\002\003_\000\000\002\000\000\000\000\003\128\003]\000\000\000\000\006\007\000\000\000\000\0112\000\000\000\000\000\000\006\t\000\000\000\000\000\000\003`\000\000\000\000\n\001\t\000\000\000\000\b\t\r\000\000\003*\000\000\003s\003\143\003i\000\000\000\000\004\131\000\000\003\135\000\000\000\000\006\007\137\000\000\000\000\0114\0115\000\000\011:\003^\011;\000\000\006\006\027\000\000\000\000\003\144\000\000\006\b0\001\r\t\007\000\000\t\014\006\006\003\137\001\000h\001O\006\012\000\000\003\000\000\000\000\003+\000\000\0032\006\r\011C\000\000\003c\000\000\000\000\000\000\007\019\007\020\007\021\000\000\011E\000\000\002\000\000\000\000\0033\002\002\002\000\000\011F\000\000\001\002\000\000\000\000\000\000\002\000\000\001\016\001\017\000\000\006\137\000\000\003_\000\000\000\000\000\000\003\0035\000\000\003T\t\028\t\029\003e\000\000\000\000h\000\000\001\012\001\020\000\000\000\000\000\000\003`\003T\006\000\000\001\014\000\000\000\000\b\t\027\000\000\t\030\007\127\000\000\007\128\003f\000\000\001\000\000\003\b3\000\000\000\000\011H\000\000\000\000\000\000\006\139\007\022\003t\0036\003x\000\000\000\000\003U\000\000\003Z\t!\000\000\000\000\003w\000\000\003v\t\007\000\000\t\014\000\000\003\003U\000\000\003Z\000\000\000\000\003[\000\000\002\002\000\000\t#\000\000\000\000\004\130\000\000\003c\000\000\000\000\000\000\003[\000\000\006\000\000\003_\000\000\002\000\003\128\003]\000\000\000\000\000\000\000\000\000\000\000\000\000\006\001\r\000\000\000\000\000\000\003\\\003]\003`\000\000\007\023\000\000\001\t\000\000\000\000\b\t \000\000\003T\t\028\t\029\003e\000\000\007\024\000\000\007\025\003\135\000\000\000\000\n\001\001(\000\000\000\000\000\000\000\000\000\000\000\000\003^\000\000\t'\t(\t\030\007\127\000\000\007\128\003f\006\146\000\000\004\146\000\000\t\007\003^\t\014\006\003\137\000\000\000\000\000\000\000\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\t!\000\000\001\002\003c\000\000\000\000\000\000\000\000\001\003\006\006\001\014\001\026\002\001\004\000\000\003[\000\000\002\002\000\000\t#\000\000\001\002\000\000\000\000h\000\000\001\012\001\016\001\017\000\000\006\137\006\141\003_\001\t\000\000\000\000\003\128\003]\000\000\003T\t\028\t\029\003e\000\000\000\000h\000\000\001\012\001\020\000\000\000\000\000\000\003`\000\000\000\000\000\000\000\000\000\000\000\000\b\t&\000\000\t\030\007\127\000\000\007\128\003f\001\002\000\000\000\000\003\135\000\000\000\000\004\000\000\000\000\000\000\006\006\139\000\000\000\000\003^\003x\t'\t(\003U\000\000\003Z\t!\000\000\000\000h\000\000\001\012\t\007\000\000\t\014\000\000\003\137\000\000\000\000\000\000\000\000\000\000\003[\000\000\001\001\000\000\t#\000\000\001\002\000\000\000\000\003c\001\r\000\000\001\016\001\017\000\000\006\137\000\000\003N\000\000\002\000\000\003\128\003]\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\001\r\001\012\001\020\000\000\000\000\000\000\003O\006\000\000\000\000\001\t\000\000\000\000\tK\tL\000\000\003T\t\028\t\029\003e\000\000\000\000\006\000\000\003\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\139\000\000\000\000\003^\004\t'\t(\t\030\007\127\000\000\007\128\003f\006\142\000\000\001\r\000\000\tM\000\000\tT\000\000\003\137\000\000\000\000\001\014\000\000\000\000\000\000\003x\000\000\000\000\003U\004\003Z\t!\000\000\000\000\003\141\000\000\000\000\004\130\000\000\000\000\000\000\000\000\001\014\001\026\002\000\000\000\000\003[\000\000\001\001\000\000\t#\000\000\001\002\000\000\001\r\000\000\000\000\000\000\001\016\001\017\000\000\006\137\006\141\003N\001\t\000\000\000\000\003\128\003]\000\000\003*\tZ\t[\003\143\000\000\000\000h\000\000\001\012\001\020\000\000\000\000\000\000\003O\000\000\000\000\001\014\000\000\000\000\000\000\tK\tS\000\000\t\\\006\024\000\000\006\025\003\144\006\140\000\000\000\000\003\135\000\000\000\000\000\000\006\000\000\000\000\000\000\006\139\006\000\000\003^\003\t'\t(\003+\000\000\0032\t_\000\000\000\000\000\000\000\000\000\000\tM\000\000\tT\000\000\003\137\001\014\001\026\000\000\006\006\0033\000\000\001\001\000\000\ta\000\000\001\002\004\130\000\000\003\141\000\000\000\000\001\016\001\017\000\000\006\006\141\003N\000\000\002\000\000\003\0035\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\001\r\001\012\001\020\000\000\000\000\000\000\003O\000\000\000\000\000\000\001\t\000\000\000\000\tK\tY\000\000\003*\tZ\t[\003\143\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\000\000\000\0036\006\te\tf\t\\\006\024\000\000\006\025\003\144\006\145\000\000\b\006\000\000\tM\000\000\tT\006\003\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\t_\000\000\000\000\003\141\000\000\000\000\000\000\000\000\000\000\006\006\001\014\001\026\002\000\000\000\000\0033\000\000\001\001\000\000\ta\000\000\001\002\000\000\001\r\000\000\001\001\001\016\001\017\000\000\006\006\141\003N\006\000\000\006\003\0035\000\000\003*\tZ\t[\003\143\000\000\000\000h\000\000\001\012\001\020\000\000\006\000\000\003O\000\000\000\000\000\000\000\000\000\000\000\000\tK\t^\n\128\t\\\006\024\004\130\006\025\003\144\006\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\006\006\000\000\000\000\0036\003\te\tf\003+\000\000\0032\t_\000\000\000\000\000\000\000\000\000\000\tM\006\tT\000\000\003\001\014\001\026\006\006\000\000\0033\000\000\001\001\000\000\ta\001\000h\000\000\000\000\003\141\000\000\000\000\000\000\000\000\000\000\000\000\006\003N\002\002\000\000\003\0035\007\019\007\020\007\021\002R\000\000\002\b\r\000\000\001\r\000\000\000\000\006\000\000\000\000\003O\006\000\000\000\000\000\000\000\000\000\000\tK\td\000\000\003*\tZ\t[\003\143\000\000\002S\006\004:\003\003*\006\006\000\000\000\000\000\000\002U\000\000\000\000\000\000\0036\000\000\te\tf\t\\\006\024\000\000\006\025\003\144\006\000\000\000\000\000\000\tM\000\000\tT\000\000\003\000\000\000\000\001\000\000\000\000\007\026\003\000\000\000\000\003+\000\000\0032\t_\007\022\000\000\003\141\000\000\000\000\003+\000\000\0032\000\000\000\000\001\014\001\026\002\000\n\000\000\0033\000\000\001\001\000\000\ta\000\000\000\000\000\000\0033\000\000\002]\000\000\000\000\000\000\006\000\000\006\003N\000\000\000\000\002^\003\0035\000\000\003*\tZ\t[\003\143\000\000\000\000\0034\0035\000\000\002_\002`\n\000\000\003O\000\000\n\000\000\000\000\000\000\000\000\tK\tj\000\000\t\\\006\024\007\023\006\025\003\144\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\007\024\000\000\007\025\000\000\0036\003\te\tf\003+\000\000\0032\t_\000\000\0036\000\000\000\000\000\000\tM\006\tT\000\000\003\000\000\006P\000\000\000\000\000\000\0033\011\000\002\002\000\000\ta\006\000\000\004\130\000\000\003\141\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003_\000\000\002\000\000\003\0035\002a\000\000\000\000\000\011\001\000\000\000\000\b\000\006V\000\000\011\003\000\000\000\000\003`\000\000\000\000\000\000\011\004\000\000\000\000\t\"\002b\002X\003*\tZ\t[\003\143\001\001\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\001\t\000\001(\000\000\000\000\0036\003N\te\tf\t\\\006\024\000\000\006\025\003\144\000\000\000\000\b\017\000\000\t\007\000\000\t\014\006\003\000\000\002c\002d\003O\000\000\011\006\003\000\000\000\000\003+\t`\0032\t_\011\007\000\000\003c\002\002\001\002\000\000\000\000\006\006\000\000\001\003\002\000\000\000\000\0033\000\000\001\004\000\000\003_\ta\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\000\000\001\012\tM\000\000\tT\000\000\000\000\003\0035\003`\003T\t\028\001\002\003e\000\000\000\000\000\000\000\000\001\016\001\017\000\000\001\018\003\141\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\002\000\000\007\131\000\000h\003f\001\012\001\020\001\021\003\003_\000\000\000\000\000\000\000\000\000\000\006\000\000\000\000\000\000\0036\003x\te\tf\003U\002r\003Z\000\000\003*\tZ\003`\003\143\000\000\000\000\002R\000\000\000\000\003\000\000\003c\000\000\000\000\000\000\003[\000\000\000\000\000\000\000\000\t#\002\000\000\000\000\006\027\002\002\003\144\000\000\000\000\001\r\000\000\002S\000\000\004:\000\000\000\000\003\128\003]\000\000\000\000\003_\002U\003\000\000\000\000\003+\000\000\0032\003T\002/\000\000\003e\000\000\006\000\000\000\000\002\002\000\000\000\000\003`\000\000\000\000\003c\0033\000\000\001\r\000\000\006\ta\003\135\000\000\003_\002\000\000\003f\000\000\n\011\000\000\000\000\000\000\003^\000\000\t'\000\000\000\000\003\0035\000\000\000\000\000\000\003x\003`\002\006\003U\000\000\003Z\000\000\003\137\000\000\000\000\003T\002]\003\t\003e\001\014\000\000\000\000\002r\000\000\000\000\000\000\002^\003[\004S\000\000\000\000\004_\004e\002\007\003\002\b\003c\000\000\000\000\002_\002`\000\000\003f\002\t\000\000\0036\002\te\000\000\003\128\003]\000\000\000\000\000\000\002/\000\000\001\014\001\026\003x\000\000\000\000\003U\003\003Z\002&\005\001\027\000\000\003c\002\002\000\000\000\000\000\000\003T\000\000\000\000\003e\002\002B\003[\004S\001\t\003\135\t\t\000\000\bK\000\000\000\000\000\000\005\003\027\000\000\003^\000\000\000\000\000\000\000\000\000\000\000\000\003f\003\128\003]\002\015\000\000\003T\000\000\000\000\003e\000\000\003\137\001\t\000\000\002\018\003\028\003 \003x\000\000\002a\003U\000\000\003Z\000\000\000\000\000\000\000\000\002\021\002\022\002\027\000\000\002C\000\000\003f\000\000\000\000\003\135\000\000\000\000\003[\bQ\002b\002X\b\b\000\000\000\000\003^\000\000\003x\005\133\000\000\003U\000\000\003Z\001U\006\016\000\000\000\000\000\000\001\002\003\128\003]\000\000\003\137\000\000\001\016\001\017\000\000\001\018\000\000\003[\bQ\000\000\000\000\bV\bZ\000\000\000\000\000\000\000\000\002c\002d\000\000h\003\029\001\012\001\020\001\021\001\022\001\002\000\000\000\000\003\128\003]\003\135\001\016\001\017\000\000\001\018\000\000\000\000\003\t\005\138\000\000\000\000\003^\002\023\000\000\000\000\000\000\000\000\006\015\000\000h\000\000\001\012\001\020\001\021\001\022\005\133\000\000\000\000\003\137\000\000\001U\000\000\003\135\000\000\002\028\002\012\000\000\000\000\001J\000\000\000\000\000\000\000\000\003^\001W\001X\000\000\001Y\000\000\000\000\000\000\000\000\000\000\000\000\001\001\003\031\000\000\000\000\000\000\003\137\000\000h\000\000\001M\002\133\002\134\002\135\000\000\005\140\000\000\003!\000\000\000\000\002\025\002\026\000\000\t\017\005\147\000\000\001\r\000\000\003\027\000\000\002 \000\000\002D\000\000\000\000\t\0030\001\023\004\004\005\005\004\004\000\000\001U\007\007\007\000\000\007\000\000\003\028\003 \000\000\001J\000\000\001\r\000\000\000\000\000\000\001W\001X\000\000\001Y\000\000\000\000\000\000\001\023\004\004\004\004\004\000\000\000\000\000\000\000\000\000\000h\000\000\001M\002\133\002\134\002\135\000\000\005\140\000\000\007\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\002\001N\005\133\000\000\001\014\001\026\000\000\001U\000\000\000\000\002\000\000\002\136\005\141\001\027\001#\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\029\001J\000\000\000\000\000\000\000\000\007\001W\001X\000\000\001Y\001\014\001\026\000\000\000\000\003*\000\000\000\000\000\000\000\000\000\000\001\027\001#\000\000\000\000h\000\000\001M\002\133\002\134\002\135\006G\006:\000\000\000\000\000\000\001\t\000\000\007\000\000\007\007\007\000\000\000\000\000\000\000\000\000\000\001N\005\142\000\000\002R\000\000\000\000\001O\002\139\000\000\000\000\000\000\002\136\005\141\003+\001J\0032\002\140\002\147\003\031\000\000\001W\001X\000\000\001Y\007\006G\000\000\000\000\000\000\002S\001\t\004:\0033\003!\007\000\000\006J\000\000h\002U\001M\002\133\002\134\002\135\000\000\005\140\000\000\000\000\000\000\002\002\000\000\000\000\000\000\0034\0035\000\000\000\000\000\000\000\000\000\000\b\148\000\000\000\000\000\000\003_\001\002\000\000\001N\000\000\000\000\005\142\001\016\001\017\000\000\001\018\001O\002\139\t\002\136\nF\nG\nI\nJ\nL\003`\002\140\002\147\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\006M\000\000\0036\002]\000\000\000\000\000\000\000\000\000\000\000\000\007\001\002\000\000\002^\000\000\000\000\000\000\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\000\000\002_\002`\000\000\000\000\000\000\000\000\001N\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\006M\002\136\005\141\000\000\000\001O\002\139\000\000\003c\001\001\000\000\000\000\000\000\000\000\002\140\002\147\000\000\002\000\000\000\000\000\000\000\000\001\001\003N\000\000\000\000\b\155\000\000\b\157\000\000\000\000\000\000\000\000\000\000\b\158\000\000\000\000\003N\000\000\000\000\001\r\000\000\000\000\003O\003T\000\000\000\000\003e\000\000\000\000\000\000\001\023\006N\000\000\000\000\000\000\000\000\003O\000\000\005\142\000\000\000\000\002a\000\000\001O\002\139\000\000\000\000\000\000\000\000\000\003f\000\000\000\000\002\140\002\147\000\000\000\000\000\000\000\000\001\002\000\000\001\r\000\000\002b\002X\004\003x\000\000\000\000\003U\000\000\003Z\001\023\006N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\003\141\001\012\000\000\000\000\003[\b^\006O\t\000\n\004V\002\001\014\001\026\000\000\003\141\002\002\000\000\000\000\002c\002d\001\027\001#\000\000\002\000\000\003\128\003]\000\000\000\000\000\000\003_\000\000\000\000\000\000\000\000\000\000\000\000\003*\000\000\000\000\003\143\000\000\001\002\000\000\000\n\n\000\000\006O\004\n\003`\003*\001\014\001\026\003\143\000\000\003\t\000\000\000\000\003\135\000\000\000\000\001\027\001#\003\144\000\000h\000\000\001\012\000\000\003^\000\000\001\001\000\000\000\000\000\000\000\000\003\144\004\003\000\000\n\003+\000\000\0032\n\003\137\003N\001\r\000\000\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\011\000\000\0033\b\t\000\000\004\bT\003O\000\000\000\000\000\000\003c\000\000\000\000\000\000\0033\bi\t\140\000\000\000\000\bT\002\000\000\003\0035\t\021\011\001\000\000\003\t\000\000\003\027\000\000\000\000\011\003\000\000\000\000\011\000\003\0035\000\000\011\015\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\003T\000\000\000\000\003e\003\028\003 \000\000\001\r\003\000\000\000\000\000\000\000\000\000\000\011\001\001\014\000\000\000\000\000\000\0036\003\141\011\003\003\000\000\004\000\000\000\000\003f\011\020\001\002\002\000\000\000\000\0036\000\000\004\003\000\000\000\000\011\006\000\000\000\000\000\000\003x\000\000\002\003U\011\007\003Z\t.\003\000\000\000\000h\003\027\001\012\002\002\003*\000\000\000\000\003\143\000\000\005\000\000\003[\b^\000\000\tq\000\000\004V\007t\003_\002T\003\029\000\000\011\006\003\028\003 \000\000\000\000\002U\000\000\001\014\011\007\003\144\000\000\003\128\003]\005\000\000\002T\003`\000\000\000\000\000\000\000\000\000\000\000\000\002U\000\000\003\002k\000\000\003+\005\0032\000\000\007y\000\000\000\000\000\000\000\000\001\t\000\000\000\000\000\000\002{\000\000\000\000\002k\003\135\000\000\0033\bi\to\005\000\000\bT\000\000\000\000\005\003^\002T\004\002{\000\000\000\000\000\000\000\000\003\031\002U\002[\000\000\001\r\003\0035\003\029\000\000\003\137\000\000\000\000\002^\000\000\003c\003!\000\000\000\000\000\000\000\000\002[\004\002k\000\000\002\002_\002`\002e\005\002|\002^\000\000\000\000\002\002\000\000\000\000\002{\000\000\003\002\000\000\000\000\002_\002`\002e\000\000\002|\000\000\000\000\0036\001\002\003T\000\000\000\000\003e\000\000\001\016\001\017\000\000\006\000\000\002[\000\000\000\000\b\007t\003\002T\003i\000\000\000\000\002^\003\031\000\000h\002U\001\012\001\020\003f\001\014\000\000\000\000\005\000\000\002_\002`\002e\003!\002|\000\000\000\000\000\000\000\000\000\000\003x\000\n\002k\003U\000\000\003Z\000\000\000\000\007y\000\000\002a\000\000\000\000\006\000\000\000\000\000\000\002{\000\000\001\001\000\000\003[\b^\000\000\b_\000\000\004V\002a\000\000\006y\000\000\002f\002X\000\000\003N\002\000\000\000\000\n\000\000\000\000\002[\n\003\128\003]\002\000\000\000\000\000\000\002f\002X\002^\000\000\000\000\003O\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002_\002`\002e\000\000\002|\002a\001\r\002c\002d\003T\000\000\000\000\000\000\003\135\000\000\000\000\000\000\002j\000\000\002}\000\000\000\000\001\001\003^\002c\002d\002f\002X\011\000\000\000\000\000\000\000\000\000\000\000\002j\003j\002}\003N\b\007|\003\137\000\000\000\000\001\t\000\000\000\000\004k\000\000\000\000\006\000\000\003\141\000\000\000\000\003U\011\001\003Z\003O\000\000\000\000\000\000\002\011\003\000\000\000\000\000\000\002c\002d\000\000\011\024\002\002\000\000\003[\000\000\000\000\002j\000\000\002}\002a\000\000\001\014\001\026\000\000\000\000\000\000\003_\000\000\000\000\003*\000\000\000\000\003\143\000\000\000\000\003\\\003]\000\000\000\000\003\t\000\000\002f\002X\006\000\000\000\000\003`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\144\011\006\000\000\003\141\000\000\001\002\000\000\000\000\000\000\011\007\000\000\001\016\001\017\002\001\018\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\003^\002c\002d\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\002j\000\000\002}\0033\bi\bn\003*\000\000\bT\003\143\000\000\000\000\000\000\000\000\001\001\000\000\003c\t2\000\000\000\000\001\001\003\027\000\000\003\0035\002\001\001\003N\000\000\000\000\003\144\000\000\000\000\000\000\003N\000\000\000\000\000\000\000\000\000\000\000\000\003N\000\000\003\028\003 \000\000\003\003O\000\000\003+\000\000\0032\003T\000\000\003O\003e\003\000\000\000\000\000\000\000\000\003O\000\000\000\000\000\000\000\000\000\000\0036\0033\bi\bk\000\000\000\000\bT\000\000\000\000\000\000\000\000\000\000\003f\000\000\000\000\001\r\000\000\003\000\000\000\000\000\000\000\000\000\000\003\0035\000\000\001\023\004l\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\141\000\000\000\000\000\000\003\029\000\000\000\000\003\141\003[\b^\002\b\000\004V\003\141\003\000\000\002\000\000\000\000\000\000\000\001\001\002\000\000\0036\000\000\000\000\000\000\003\128\003]\000\000\000\000\000\000\000\000\000\000\000\000\003*\000\000\000\000\003\143\000\000\003\000\000\003*\000\000\000\000\003\143\001\014\001\026\001\001\003*\000\000\000\000\003\143\003\157\000\000\003\147\001\027\001#\000\000\000\000\000\000\003\135\003\144\000\000\000\000\000\000\000\000\003\031\002R\003\144\000\000\000\000\003^\000\000\000\000\000\000\003\144\000\000\003\000\000\000\000\003+\003!\0032\000\000\003\000\000\001\002\003+\003\137\0032\000\000\003\001\003\002S\003+\002T\0032\000\000\001\004\0033\b\b\000\000\002U\bT\000\000\0033\b\b\000\000h\bT\001\012\0033\b\t\002\000\000\bT\000\000\000\000\003\0035\000\000\002k\000\000\002\000\000\003\0035\n\152\n\154\000\000\000\000\000\003\0035\000\000\000\000\002{\000\000\000\002R\000\000\000\000\000\000\000\000\000\000\000\000\002\006\000\000\000\000\000\000\000\000\003*\003\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\002[\000\000\0036\000\000\002S\003\002T\001,\001(\0036\002^\002\007\000\000\002\b\002U\000\000\0036\003\158\000\000\003\000\000\002\t\000\000\002_\002`\002e\003\002|\003\000\000\003\000\000\002\006\003\000\000\002k\003+\001\r\0032\000\000\000\000\t\002&\000\000\000\000\000\000\000\000\001\002\002\159\000\000\002{\000\000\000\000\001\003\000\000\0033\000\000\002B\002\007\001\004\002\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\t\000\000\000\000h\000\000\001\012\000\000\002[\000\000\0034\0035\000\000\000\000\000\000\002\015\000\000\000\000\002^\000\000\000\000\003\t\002&\000\000\000\000\002\018\000\000\000\000\002E\000s\000\000\002_\002`\002e\000\000\002|\002a\002B\002\021\002\022\002\027\000\000\002C\000\000\000\000\000\001\014\006\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0036\000\000\000\000\002f\002X\000\000\000\000\002\015\000\000\000\000\000\000\000\000\006\004\000\000\000\000\006\021\006\005\002\018\000\000\000\000\000\000\000\000\000\000\000\000\002\006\006\022\006\024\000\000\006\025\000\000\002\021\002\022\002\027\000\000\002C\000\000\n\000\000\000\000\000\000\001\r\003\027\000\000\002c\002d\000\000\000\000\000\000\000\000\000\000\002\007\006\026\002\b\002j\000\000\002}\002a\000\000\000\000\000\000\002\t\000\000\000\000\002\023\003\028\003 \001\002\006\006\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\002f\002X\000\000\002&\000\000\000\000\000\000\002\028\002\012\002?\000\000\000\000h\000\000\001\012\000\000\006\007\000\000\002B\000\000\000\000\006\028\006\029\006\t\000\000\000\000\000\000\000\000\000\000\006|\006u\000\000\002\023\000\000\000\000\002\006\000\000\000\001\014\000\000\002c\002d\000\000\002\015\000\000\000\000\000\002\025\002\026\000\000\002j\002R\002}\002\018\002\028\002\012\003\029\002 \000\000\002D\000\000\002\007\000\000\002\b\000\000\000\000\002\021\002\022\002\027\000\000\002C\002\t\000\000\000\000\000\000\0010\001(\002S\006\012\002T\006v\000\000\000\000\000\000\000\000\006w\006\r\002U\000\000\000\000\000\000\000\000\002&\004\002\025\002\026\000\000\000\000\002A\001\t\000\000\000\000\000\000\001\r\002 \000\000\002D\002B\002k\000\000\000\000\000\000\000\000\000\000\002z\001\002\000\000\002\006\000\000\000\000\004\001\003\003\031\002{\002R\000\000\000\000\001\004\000\000\000\000\000\000\000\000\002\015\000\000\000\000\000\000\000\000\003!\000\000h\000\000\001\012\002\018\002\007\000\000\002\b\002\023\000\000\002[\000\000\002S\000\000\002T\002\t\000\000\002\021\002\022\002\027\002^\002C\002U\000\000\002R\000\000\000\000\000\000\000\000\000\000\002\028\002\012\000\000\002_\002`\002e\002&\002|\000\000\001\002\000\000\001\014\002\002k\000\000\001\016\001\017\000\000\001\018\002\002S\002B\002T\000\000\000\000\000\000\000\000\000\000\002{\000\000\002U\000\000\000\000h\000\000\001\012\001\020\001\021\000\000\000\000\002\025\002\026\000\000\000\000\000\000\000\000\002\015\000\000\000\000\000\000\002 \002k\002D\002[\000\000\000\000\002\018\003F\000\000\000\000\000\000\000\000\001\r\002^\000\000\000\000\002{\002\023\000\000\002\021\002\022\002\027\000\000\002C\000\000\000\000\002_\002`\002e\000\000\002|\000\000\000\000\002a\000\000\000\000\000\000\000\000\000\000\002\028\002\012\002[\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\002^\000\000\000\000\000\000\002f\002X\001\001\000\000\000\000\003_\000\000\000\000\002_\002`\002e\000\000\002|\000\000\000\000\000\000\000\000\000\000\001\r\002R\000\000\000\000\000\000\002\025\002\026\003`\000\000\000\000\000\000\n\r\000\000\000\000\001\014\002 \000\000\002D\t\0030\000\000\002c\002d\000\000\000\000\002\023\000\000\002S\000\000\002T\000\000\002j\002a\002}\000\000\000\000\000\000\002U\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\028\002\012\000\000\000\000\000\000\000\000\000\000\002f\002X\000\000\000\000\002k\000\000\000\000\000\000\000\000\000\000\004@\000\000\002\002\000\000\003c\002a\000\000\000\000\002{\000\000\000\000\001\014\001\026\000\000\002\000\000\002\003_\000\000\000\000\000\000\001\027\002\025\002\026\000\000\000\000\002\002f\002X\002c\002d\000\000\002 \002[\002D\000\000\000\000\003`\000\000\002j\000\000\002}\003T\002^\000\000\003e\000\000\000\000\001\001\000\000\000\000\000\000\000\000\003*\002\006\002_\002`\002e\000\000\002|\000\000\000\000\000\000\003N\000\000\001\t\002c\002d\003f\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002j\000\000\002}\000\000\002\007\002\029\002\031\003O\003x\000\000\000\000\003U\000\000\003Z\002\t\000\000\000\000\000\000\000\000\000\000\001\001\003c\003+\000\000\0032\000\000\000\000\000\000\000\000\003[\004U\002\000\000\000\000\004V\003N\000\000\000\000\000\000\000\000\000\000\0033\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\128\003]\000\000\000\000\003O\000\000\000\000\002a\003T\000\000\000\000\003e\0034\0035\000\000\001\002\000\000\003\141\000\000\000\000\000\000\001\016\001\017\002\017\005\000\000\000\000\002\000\000\002f\002X\000\000\000\000\002\018\003\135\003f\000\000\000\000\000\000h\000\000\001\012\001\020\000\000\000\000\003^\002\021\002\022\000\000\000\000\000\000\003x\000\000\005\003U\003*\003Z\0036\003\143\000\000\000\000\002R\003\137\000\000\000\000\000\000\003\141\000\000\000\000\002c\002d\000\000\000\000\003[\004b\000\000\002\000\000\004V\002j\000\000\002}\003\144\000\000\000\000\000\000\000\000\002S\000\000\002T\000\000\000\000\000\000\000\000\000\000\003\128\003]\002U\003\000\000\000\000\003+\005\0032\003*\000\000\000\000\003\143\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002k\000\000\0033\000s\000\000\000\000\006\018\005\002\023\000\000\000\000\003\135\001\r\003\144\000\000\002{\000\000\001\001\000\000\000\000\006\020\003^\000\000\003\0035\000\000\000\000\000\000\003\002\024\002\012\003+\003N\0032\000\000\000\000\000\000\000\003\137\002[\006\004\000\000\000\000\006\021\006\005\001\001\000\000\000\000\002^\0033\000\000\003O\006\022\006\024\005\006\025\003\000\000\000\000\000\000\000\000\002_\002`\002e\000\000\002|\000\000\0036\002\025\002\026\000\000\003\0035\001\001\000\000\000\000\000\000\006\026\003.\0030\000\000\000\000\000\000\003\000\000\001\014\001\026\000\000\003N\000\000\000\000\000\000\000\000\006\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\003O\000\000\000\000\000\000\003\141\001\002\000\000\0036\000\000\000\000\000\000\004\006\007\000\000\002\000\000\000\000\006\028\006\029\006\t\000\000\000\000\000\000\000\000\003\006t\006u\000\000\000\000h\000\000\001\012\002a\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003*\002\000\000\003\143\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002f\002X\000\000\000\000\000\000\000\000\000\000\000\000\003\141\002\002\000\000\000\000\000\000\000\000\003\144\000\000\003*\002\000\000\006\012\000\000\006v\001\001\003_\000\000\006w\006\r\000\000\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\003N\002c\002d\000\000\000\000\000\000\003`\003*\000\000\000\000\003\143\002j\000\000\002}\0033\bS\000\000\004\000\000\bT\003O\000\000\000\000\000\000\003+\000\000\0032\001\r\000\000\000\000\000\000\000\000\000\000\000\000\003\144\000\000\003\0035\001\001\000\000\000\000\000\000\0033\004\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\003+\003N\0032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0034\0035\000\000\003c\000\000\003\000\000\0033\bY\003O\000\000\000\000\bT\002\000\000\000\000\0036\003\141\000\000\000\000\002R\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\003\0035\b\000\000\003\000\000\000\000\000\000\000\000\001\014\000\000\000\000\003T\000\000\000\000\003e\0036\002S\000\000\004:\002R\001\001\000\000\000\000\000\000\003*\002U\000\000\003\143\000\000\005\000\000\000\000\003\002R\000\000\003N\000\000\003f\000\000\000\000\003\141\000\000\000\000\0036\002S\000\000\004:\000\000\000\000\000\000\002\003\144\000\000\003x\002U\003O\003U\000\000\003Z\002S\003\004:\000\000\000\000\000\000\000\000\000\000\003\000\000\002U\003+\000\000\0032\000\000\000\000\003[\ba\000\000\003*\000\000\004V\003\143\000\000\002\002\000\000\002]\000\000\000\000\0033\bg\000\000\000\000\000\000\bT\000\000\002^\003\128\003]\003_\000\000\000\000\000\000\000\000\000\000\003\144\000\000\000\000\000\000\002_\002`\003\0035\000\000\000\000\002]\000\000\003\141\000\000\003`\000\000\003\000\000\000\000\003+\002^\0032\002\b\000\000\002]\003\135\000\000\000\000\000\000\000\000\002\002\002_\002`\002^\000\000\003^\0033\bw\003\000\000\000\000\bT\000\000\000\000\000\000\003_\002_\002`\003*\0036\005\003\143\003\137\000\000\b\000\000\000\000\000\000\003\0035\000\000\000\000\000\000\000\000\000\000\003`\003\000\000\000\000\000\000\000\000\000\000\000\000\006\003c\003\144\000\000\000\000\000\000\000\000\000\000\000\000\002a\005\002\000\000\001\001\000\000\000\000\b\003\003\000\000\003+\000\000\0032\000\000\006\000\000\000\000\000\003N\0036\002b\002X\000\000\000\000\000\000\000\000\b\002a\003T\0033\b\003e\000\000\000\000\bT\005\003\000\000\003O\000\000\000\000\000\000\002a\003c\000\000\000\000\000\000\000\000\000\000\002b\002X\003\0035\002\000\000\003f\001\001\000\000\000\000\002c\002d\000\000\000\000\002b\002X\000\000\000\000\000\000\000\000\000\000\003x\003N\000\000\003U\000\000\003Z\000\000\006\b\006\003T\000\000\b\003e\003\000\000\000\000\000\000\002c\002d\000\000\003O\003[\000\000\001\002\0036\000\000\b\000\000\003\141\004\000\000\000\000\002c\002d\000\000\000\000\003f\000\000\002\000\000\005\003\000\000\003\128\003]\000\000\000\000h\000\000\001\012\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\000\000\000\000\000\000\006\000\000\003*\001\001\003\143\000\000\000\000\000\000\000\000\003[\000\000\000\000\003\135\000\000\b\000\000\000\000\003\141\003N\000\000\000\000\000\000\000\000\003^\000\000\000\000\000\000\002\003\144\000\000\000\000\003\128\003]\000\000\000\000\000\000\000\000\000\000\003O\000\000\003\137\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\000\000\000\000\003*\000\000\000\000\003\143\000\000\000\000\000\000\000\000\004\000\000\003\135\0033\b\n\148\000\000\000\000\bT\000\000\001\r\000\000\000\000\003^\000\000\000\000\000\000\000\000\000\000\003\144\000\000\000\000\000\000\000\000\000\000\003\0035\004\000\000\000\000\003\137\000\000\000\000\000\000\000\000\003\000\000\003\141\003+\000\000\0032\000\000\000\000\000\000\000\000\000\000\000\000\002\001\t\000\000\000\000\000\000\000\000\000s\000\000\000\000\000\000\0033\tw\003\000\000\000\000\bT\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0036\006\020\000\000\000\000\000\000\003*\000\000\000\000\003\143\003\0035\000\000\000\000\000\000\000\000\000\000\001\014\003\000\000\000\000\000\000\006\004\000\000\000\000\006\021\006\005\000\000\001\t\000\000\000\000\000\000\000\000\003\144\000\000\006\022\006\024\000\000\006\025\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\0036\000\000\001\002\000\000\002\002\006\026\000\000\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\0033\003\000\000\000\000\003_\n\149\006\006\000\000\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\002\002\000\000\000\000\003\0035\003`\000\000\000\000\000\000\000\000\000\000\001\t\000\000\000\000\006\007\003_\001\002\000\000\000\000\006\028\006\029\006\t\001\016\001\017\000\000\001\018\000\000\n\006u\000\000\000\000\000\000\000\000\000\000\000\000\003`\000\000\003\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\0036\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\003c\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\012\002\006v\000\000\000\000\000\000\001\r\006w\006\r\003i\000\000\000\000\000\000\001\002\000\000\000\000\n\023\001\023\004\001\016\001\017\003c\001\018\000\000\000\000\000\000\000\000\002\002\003T\000\000\002\003e\000\000\000\000\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\003_\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\r\003f\000\000\000\000\003T\000\000\000\000\003e\003`\000\000\004\001\023\004\000\000\000\000\000\000\002\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\002\001\014\001\026\002\002\003f\000\000\000\000\000\000\002\002\001\027\001#\003[\000\000\000\000\000\000\000\000\t\003_\000\000\003x\000\000\000\000\003U\003_\003Z\000\000\003T\000\000\000\000\000\000\000\000\000\000\000\000\003\128\003]\000\000\000\000\003`\000\000\000\000\000\000\003[\003c\003`\000\000\001\r\t\000\000\001\014\001\026\000\000\000\000\002\003\131\002\002\001\023\001\031\001\027\001#\000\000\000\000\000\000\003\128\003]\000\000\000\000\003\135\000\000\000\000\003_\000\000\003U\000\000\003Z\000\000\000\000\000\000\003^\000\000\003T\000\000\000\000\003e\000\000\000\000\000\000\000\000\000\000\000\000\003`\003[\000\000\000\000\000\000\003\137\000\000\003\135\000\000\003c\001 \000\000\000\000\000\000\000\000\003c\000\000\003f\003^\002\000\000\002\002\003\\\003]\002\000\000\000\000\002\002\000\000\001\014\001\026\003x\000\000\003\137\003U\003_\003Z\000\000\000\000\001\027\001#\000\000\003_\000\000\000\000\003T\000\000\000\000\003e\000\000\000\000\003T\000\000\003[\003e\003`\000\000\000\000\t\146\000\000\003c\000\000\003`\000\000\000\000\000\000\003^\000\000\000\000\000\000\002\000\000\003f\000\000\000\000\003\128\003]\000\000\003f\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\t\000\000\003x\000\000\000\000\003U\000\000\003Z\003x\000\000\000\000\003U\003T\003Z\000\000\003e\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\135\003[\000\000\000\000\000\000\000\000\tu\003[\003c\000\000\000\000\003^\t;\000\000\000\000\003c\003f\000\000\002\000\000\000\000\000\000\000\000\003\128\003]\002\000\000\000\000\003\137\003\128\003]\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003T\000\000\000\000\003e\001\001\000\000\003T\003[\001\002\003e\003\135\000\000\b\000\000\001\016\001\017\003\135\006R\000\000\003N\007%\003^\000\000\000\000\000\000\000\003f\003^\000\000\003\128\003]\000\000h\003f\001\012\001\020\000\000\000\000\003\137\003O\000\000\000\000\003x\000\000\003\137\003U\000\000\003Z\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\001\001\000\000\000\000\000\000\000\000\000\000\003\135\003[\000\000\000\000\000\000\000\000\b\000\000\003[\003N\000\000\003^\000\000\b\139\000\000\000\000\000\000\000\000\000\000\007&\000\000\000\000\000\000\003\128\003]\007'\b\000\000\000\003\137\003O\003\128\003]\000\000\000\000\003\021\000h\000\000\000\000\003\141\001\002\000\000\000\000\001\001\000\000\004\000\000\000\000\002\000\000\001\001\007@\007A\007B\000\000\000\000\003\135\003N\000\000\001\r\000\000\000\000h\003\135\001\012\003N\000\000\003^\000\000\000\000\000\000\000\000\000\000\000\000\003^\003*\000\000\003O\003\143\000\000\000\000\000\000\000\000\000\000\003\137\003O\000\000\000\000\000\000\000\000\003\141\003\137\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\003\144\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\025\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\000\000\007C\000\000\000\000\003*\000\000\000\000\003\143\001\001\000\000\001\014\001\026\000\000\000\000\003\141\0033\000\000\000\000\004\000\000\004q\000\000\003\141\003N\002\000\000\000\000\000\000\001\r\000\000\003\144\000\000\002\000\000\000\000\000\000\000\000\003\0035\000\000\000\000\000\000\000\000\003O\000\000\004\003\000\000\000\000\003+\000\000\0032\003*\000\000\000\000\003\143\000\000\000\000\000\000\000\000\003*\002\002\003\143\000\000\007D\000\000\000\000\0033\000\000\001\002\003\000\000\004N\000\000\000\000\004\003_\007E\003\144\007F\000\000\0036\000\000\000\000\000\000\000\000\003\144\000\000\000\000\003\0035\000\000\000\000h\003\001\012\003`\003+\003\0032\000\000\000\000\003\001\014\003\141\003+\000\000\0032\000\000\007%\000\000\000\000\000\000\000\000\002\000\000\0033\002\002\000\000\000\000\004M\000\000\003\0033\000\000\000\000\000\000\000\000\0041\000\000\000\000\000\000\003_\0036\000\000\000\000\000\003\0035\000\000\000\000\003*\002\002\003\143\003\0035\000\000\000\000\000\000\003\000\000\003`\000\000\000\000\000\000\000\000\003c\003_\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\003\144\000\000\007&\003\000\000\004\000\000\000\000\007'\007(\003`\003\000\000\000\000\0036\001\r\003\003\021\000h\003+\000\000\0032\0036\000\000\000\000\000\000\000\000\003T\002\002\003e\003\004\000\000\000\000\007@\007A\007B\0033\003\000\000\000\000\000\000\0040\003_\001\002\003c\000\000\000\000\000\000\000\000\004\000\000\000\000\003f\000\000\002\000\000\000\000\000\000\003\0035\000\000\000\000\003`\002\002\000\000\000\000h\003x\001\012\003c\003U\000\000\003Z\000\000\000\000\000\000\000\000\000\000\003_\002\000\000\003T\000\000\000\000\003e\000\000\000\000\000\000\001\014\003[\000\000\003\000\000\000\000\004\029\003\025\000\000\000\000\003`\000\000\000\000\000\000\0036\000\000\000\000\000\000\007C\003T\003f\000\000\003e\003\128\003]\000\000\000\000\000\000\002\002\000\000\003\000\000\000\000\000\000\003c\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\003_\002\003f\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\002\000\000\003\135\003[\004\000\000\000\000\003x\004\028\003`\003U\000\000\003Z\003^\001\r\003_\000\000\003c\003T\000\000\000\000\003e\000\000\000\000\000\000\003\128\003]\002\007D\003[\003\137\004\000\000\000\000\004\t\003`\000\000\000\000\000\000\000\000\000\000\007E\000\000\007F\000\000\003f\000\000\000\000\000\000\000\000\000\000\003\128\003]\002\002\003T\000\000\000\000\003e\003\135\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\003_\003^\003c\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\003f\003[\000\000\003\135\000\000\003\137\003z\003`\001\014\000\000\000\000\000\000\000\000\000\000\003^\003c\003x\000\000\000\000\003U\000\000\003Z\000\000\003\128\003]\002\000\000\003T\001\001\003e\003\137\000\000\000\000\000\000\001\001\000\000\003[\000\000\000\000\000\000\000\000\003|\003N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003T\003f\000\000\003e\003\135\000\000\000\000\003\128\003]\000\000\000\000\003O\000\000\000\000\000\000\003^\003c\003x\003\147\000\000\003U\000\000\003Z\000\000\000\000\000\000\002\003f\000\000\000\000\000\000\000\000\003\137\000\000\000\000\000\000\000\000\000\000\000\000\003[\000\000\003\135\000\000\003x\003~\000\000\003U\000\000\003Z\000\000\000\000\000\000\003^\000\000\003T\001\001\003e\000\000\000\000\000\000\003\128\003]\000\000\000\000\003[\000\000\000\000\000\000\003\137\003\136\003N\000\000\003\141\000\000\000\000\000\000\000\000\000\000\000\000\002\003f\000\000\002\000\000\000\000\000\000\003\128\003]\000\000\002\003O\001\001\000\000\003\135\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\003^\000\000\003N\000\000\000\000\003*\000\000\000\000\003\143\000\000\000\000\000\000\003*\003[\000\000\003\135\000\000\003\137\003\139\000\000\000\000\000\000\003O\000\000\000\000\000\000\003^\000\000\000\000\000\000\000\000\000\000\003\144\000\000\000\000\003\128\003]\000\000\000\000\003\149\001\001\000\000\003\137\000\000\000\000\000\000\003\141\003\000\000\000\000\003+\000\000\0032\000\000\000\000\003N\002\003+\000\000\0032\000\000\000\000\000\000\000\000\000\000\001\001\000\000\003\135\0033\000\000\000\000\000\000\000\000\003\003O\0033\000\000\000\000\003^\000\000\003N\000\000\003\141\003*\000\000\000\000\003\143\000\000\000\000\000\000\003\0035\002\000\000\000\000\003\137\000\000\0034\0035\000\000\003O\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\144\000\000\000\000\000\000\000\000\000\000\000\000\003N\000\000\000\000\003*\001\001\003\143\003\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\0036\003\141\003O\000\000\000\000\000\000\000\000\0036\000\000\000\000\000\000\002\003\144\0033\000\000\000\000\000\000\003\003\000\000\000\000\0031\0030\000\000\000\000\000\000\000\000\003\141\003\000\000\000\000\003+\000\000\0032\000\000\003\0035\002\000\000\003*\000\000\000\000\003\143\001\001\000\000\000\000\000\000\000\000\000\000\0033\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\003N\000\000\000\000\000\000\000\000\003\141\003*\003\144\000\000\003\143\003\000\000\000\000\003\0035\002\000\000\000\000\000\000\000\000\003O\0036\000\000\003\000\000\002\003+\000\000\0032\000\000\000\000\000\000\000\000\003\144\000\000\002\000\000\000\000\003\000\000\000\000\001\001\003*\000\000\0033\003\143\003\000\000\003\003\000\000\003+\000\000\0032\000\000\000\000\003N\0036\000\000\000\000\000\000\000\000\003*\000\000\000\000\000\000\003\0035\000\000\003\144\0033\000\000\000\000\000\000\003\003\003O\000\000\000\000\000\000\000\000\003\141\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\002\003\0035\000\000\000\000\000\000\001\001\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\0033\003+\000\000\0032\0036\003\003N\000\000\000\000\000\000\000\000\000\000\003*\000\000\000\000\003\143\001\001\000\000\003\0033\003\003\0035\000\000\000\000\003O\000\000\000\000\000\000\0036\003\141\003N\000\000\000\000\000\000\000\000\000\000\000\000\003\144\000\000\002\0034\0035\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\003O\000\000\000\000\003\003\000\000\003+\000\000\0032\000\000\000\000\000\000\000\000\000\000\000\000\0036\000\000\003*\001\001\003\143\000\000\000\000\000\000\000\000\0033\000\000\000\000\000\000\000\000\003\000\000\003\000\000\003N\0036\003\141\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\144\000\000\002\003\0035\000\000\000\000\000\000\000\000\000\000\003O\001\001\000\000\000\000\000\000\003\000\000\003\141\003+\000\000\0032\000\000\000\000\000\000\000\000\000\000\003N\002\000\000\003*\000\000\000\000\003\143\000\000\000\000\000\000\003\0033\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\003O\0036\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003*\003\144\000\000\003\143\003\0035\000\000\000\000\000\000\003\000\000\000\000\000\000\000\001\001\003\141\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\002\003\144\000\000\000\000\003N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\0033\000\000\000\000\000\000\003\003\000\000\003+\000\000\0032\0036\003O\000\000\000\000\003\141\003*\000\000\000\000\003\143\000\000\000\000\000\000\003\0035\002\000\000\0033\003\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\144\000\000\000\000\003N\000\000\000\000\003\0035\000\000\001\002\003*\000\000\000\000\003\143\003\004\003\000\000\000\000\003+\000\000\0032\000\000\003O\000\000\0036\000\000\000\000\000\000\000\000\000\000\003\141\000\000h\000\000\001\012\000\000\003\144\0033\000\000\003\002\003\003\000\000\000\000\001\001\000\000\000\000\000\000\0036\000\000\003\000\000\000\000\003+\000\000\0032\000\000\003\0035\003N\000\000\000\000\000\000\000\000\000\000\003\003*\000\000\000\000\003\143\000\000\000\000\0033\000\000\000\000\000\000\000\000\003\000\000\003O\001\001\003\141\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\002\003\144\003\0035\003N\000\000\000\000\000\000\000\000\000\000\0036\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\004\003+\000\000\0032\000\000\003O\000\000\000\000\003\003*\001\r\000\000\003\143\000\000\000\000\000\000\000\000\003\000\000\000\000\0033\000\000\000\000\001\001\003\000\000\004\0036\000\000\003\141\000\000\000\000\000\000\000\000\000\000\003\144\001\001\003N\002\000\000\003\0035\000\000\003\000\000\000\000\000\000\001\001\000\000\003\000\000\000\000\003+\000\000\0032\000\000\003O\000\000\000\000\000\000\000\000\000\000\003N\000\000\003\141\003*\000\000\000\000\003\143\003X\0030\0033\000\000\003\002\000\000\003\000\000\000\000\000\000\000\000\000\000\003O\001\014\0036\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\144\003\0035\000\000\000\000\000\000\000\000\000\000\000\000\003\003*\001\001\003\143\000\000\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\000\000\003\141\003N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\002\003\144\0033\000\000\002\000\000\000\000\003\000\000\000\000\0036\003O\000\000\000\000\002\002R\003\141\003\000\000\000\000\003+\000\000\0032\000\000\003\0035\002\003\003*\001\001\003\143\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0033\000\000\002S\003*\004:\003\003N\000\000\000\000\000\000\000\000\000\000\002U\000\000\000\000\003*\003\144\000\000\003\143\003\000\000\000\000\003\0035\000\000\000\000\003O\000\000\000\000\000\000\0036\000\000\003\000\000\003\141\003+\000\000\0032\000\000\000\000\000\000\000\000\003\144\000\000\002\000\000\000\000\003\000\000\003+\000\000\0032\000\000\000\000\0033\000\000\003\000\000\003\003\000\000\003+\000\000\0032\000\000\000\000\000\000\0036\0033\000\000\001\001\003*\002]\000\000\003\143\003\0035\000\000\000\000\0033\000\000\000\000\002^\003\003\003N\000\000\003\141\000\000\0034\0035\000\000\000\000\000\000\000\000\002_\002`\002\003\144\000\000\000\000\003\0035\000\000\000\000\003O\001\001\000\000\003\000\000\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\0036\000\000\003N\000\000\000\000\003*\000\000\000\000\003\143\000\000\000\000\000\000\000\000\000\000\0036\003\0033\003\000\000\000\000\000\000\003\003O\000\000\000\000\000\000\0036\006P\000\000\000\000\000\000\000\000\003\144\000\000\000\000\000\000\000\000\000\000\003\0035\001\001\000\000\003\001\001\000\000\003\141\003\000\000\000\000\003+\000\000\0032\000\000\002a\003N\002\000\000\000\000\003N\000\000\b\000\000\006V\000\000\000\000\000\000\000\000\000\000\0033\000\000\003\000\000\000\000\003\003O\002b\002X\000\000\003O\000\000\000\000\0036\003\141\003*\000\000\000\000\003\143\007%\000\000\000\000\003\0035\002\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\144\000\000\000\000\000\000\000\000\002c\002d\003N\000\000\000\000\003*\000\000\000\000\003\143\003\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\0036\003\141\003O\000\000\000\000\003\141\000\000\000\000\000\000\000\000\000\000\002\003\144\0033\007&\002\000\000\003\003\000\000\007'\007>\000\000\000\000\000\000\000\000\000\000\000\000\003\003\021\000h\003+\000\000\0032\000\000\003\0035\000\000\000\000\003*\000\000\000\000\003\143\003*\000\000\000\000\003\143\007@\007A\007B\0033\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\141\000\000\003\144\000\000\000\000\003\003\144\000\000\003\0035\002\000\000\001\001\000\000\000\000\0036\000\000\003\001\001\003+\003\0032\000\000\003+\000\000\0032\003N\000\000\000\000\000\000\000\000\003\000\000\003N\000\000\000\000\003*\000\000\0033\003\143\003\000\000\0033\003\003\025\000\000\003O\003\000\000\000\000\000\000\0036\000\000\003O\000\000\007C\000\000\000\000\000\000\000\000\003\0035\000\000\003\144\003\0035\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\002\002\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\000\000\000\000\003_\000\000\000\000\000\000\003\000\000\000\000\000\000\003\000\000\000\000\0033\000\000\000\000\000\000\0036\003\000\000\003\141\0036\003`\000\000\000\000\000\000\000\000\003\141\000\000\000\000\002\000\000\007D\000\000\003\003\0035\002\003\002\002\000\000\000\000\000\000\000\000\007E\000\000\007F\000\000\000\000\000\000\000\000\000\000\002R\000\000\003_\000\000\000\000\003*\000\000\000\000\003\143\000\000\000\000\000\000\003*\000\000\000\000\003\143\003\000\000\000\000\000\000\000\000\000\000\003`\000\000\000\000\000\000\002S\0036\004:\000\000\000\000\003c\003\144\000\000\000\000\000\000\002U\000\000\000\000\003\144\000\000\002\000\000\000\000\003\002\002\000\000\003\000\000\000\000\003+\000\000\0032\000\000\003\000\000\000\000\003+\000\000\0032\003_\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003T\0033\000\000\003e\000\000\000\000\003\000\000\0033\000\000\000\000\000\000\003`\003\000\000\003c\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\0035\002\000\000\003f\002]\000\000\003\0035\000\000\000\000\000\000\000\000\000\000\000\000\002^\000\000\000\000\000\000\000\000\003x\000\000\002R\003U\000\000\003Z\000\000\000\000\002_\002`\003T\000\000\000\000\003e\003\000\000\000\000\000\000\000\000\000\000\000\000\003\003[\000\000\000\000\0036\000\000\003\002S\000\000\002T\003c\0036\000\000\005\002\002\003f\002U\000\000\000\000\002\003\000\000\003\128\003]\000\000\002\002\003\000\000\003_\000\000\003x\000\000\000\000\003U\000\000\003Z\002Y\005\000\000\000\000\003_\000\000\000\000\000\000\000\000\000\000\003T\000\000\003`\003e\000\000\000\000\003[\000\000\000\000\003\135\000\000\003\000\000\000\000\003`\002\002\000\000\000\000\002a\003^\000\000\000\000\000\000\000\000\000\000\000\000\003f\003\128\003]\002[\003_\000\000\000\000\000\000\000\000\000\000\003\137\000\000\000\000\002^\002b\002X\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\003`\000\000\002_\002`\002e\006\014\000\000\000\000\000\000\000\000\000\000\003\135\000\000\003c\003[\000\000\000\000\002\002\003\000\000\000\000\003^\002\000\000\003c\000\000\000\000\000\000\000\000\002c\002d\000\000\003_\000\000\002\003\128\003]\000\000\003\137\000\000\000\000\000\000\000\000\n\137\n\139\007\000\000\007\000\000\000\000\003T\000\000\003`\003e\000\000\000\000\000\000\000\000\000\000\000\000\006\015\003c\003T\000\000\000\000\003e\000\000\000\000\000\000\003\135\000\000\002\000\000\000\000\000\000\000\000\000\000\003f\000\000\000\000\003^\002a\000\000\000\000\000\000\007\000\000\000\000\000\000\003f\007\000\000\000\000\003x\000\000\000\000\003U\003\137\003Z\003T\000\000\000\000\003e\002f\002X\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\003c\003[\000\000\000\000\002\002\003\000\000\000\000\000\000\002\007\003f\003[\000\000\000\000\002\002\003\000\000\003_\000\000\000\000\003\128\003]\000\000\000\000\000\000\003x\002c\002d\003U\003_\003Z\000\000\003\128\003]\000\000\003T\002j\003`\003e\000\000\007\000\000\007\007\007\000\000\000\000\003[\000\000\003`\000\000\000\000\003\000\000\003\135\000\000\000\000\000\000\007%\000\000\002\002\003f\000\000\000\000\003^\003\135\000\000\000\000\003\128\003]\000\000\000\000\000\000\007\000\000\003_\003^\003x\000\000\000\000\003U\003\137\003Z\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\137\000\000\003`\000\000\000\000\003c\003[\000\000\000\000\003\135\000\000\003\000\000\000\000\000\000\002\000\000\003c\002\002\003^\000\000\000\000\000\000\000\000\000\000\007&\002\003\128\003]\000\000\000\000\007'\007\144\003_\000\000\000\000\003\137\000\000\000\000\000\000\003\021\000h\003T\000\000\000\000\003e\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003`\003T\000\000\000\000\003e\007@\007A\007B\003\135\007\003c\000\000\000\000\000\000\000\000\000\000\003f\000\000\000\000\003^\002\000\000\002\002\000\000\000\000\000\000\000\000\003f\000\000\000\000\000\000\003x\000\000\000\000\003U\003\137\003Z\003_\000\000\000\000\000\000\000\000\000\000\003x\000\000\000\000\003U\003T\003Z\000\000\003e\000\000\000\000\003[\000\000\000\000\000\000\003`\003\000\000\000\000\003c\000\000\000\000\000\000\003[\000\000\003\025\000\000\000\000\003\002\001\001\003f\003\128\003]\000\000\007C\000\000\002\002\000\000\000\000\000\000\000\000\000\000\003\128\003]\000\000\003x\000\000\000\000\003U\000\000\003Z\003_\000\000\000\000\003T\000\000\000\000\003e\000\000\000\000\001\t\000\000\t\144\0030\003\135\000\000\000\000\003[\000\000\000\000\000\000\003`\003\000\000\003c\003^\003\135\000\000\000\000\000\000\000\000\003f\000\000\000\000\002\002\002\003^\000\000\003\128\003]\000\000\003\137\002\002\000\000\000\000\003x\007D\000\000\003U\003_\003Z\000\000\003\137\000\000\000\000\000\000\000\000\003_\000\000\007E\003T\007F\000\000\003e\000\000\000\000\000\000\003[\000\000\003`\000\000\003\135\003\002\000\000\000\000\000\000\003`\000\000\000\000\000\000\003c\003^\002\000\000\000\000\001\002\003f\000\000\003\128\003]\002\001\016\001\017\000\000\006\143\000\000\000\000\000\000\003\137\000\000\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000h\003*\001\012\001\020\000\000\000\000\000\000\000\000\000\000\003T\000\000\000\000\003e\003\135\000\000\003[\000\000\000\000\000\000\000\000\003\003c\000\000\000\000\003^\000\000\000\000\002\002\003c\000\000\002\000\000\000\000\000\000\000\000\003f\003\128\003]\002\000\000\003\137\000\000\003_\000\000\000\000\000\000\003+\000\000\0032\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\003T\000\000\000\000\003e\003`\002\002\0033\003T\000\000\000\000\003e\003\135\000\000\000\000\003[\000\000\002\002\000\000\003\003_\000\000\003^\000\000\001\001\003f\000\000\0034\0035\000\000\001\r\003_\000\000\003f\000\000\003\128\003]\000\000\003\137\003`\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\003x\000\000\003`\003U\000\000\003Z\000\000\000\000\000\000\000\000\n\127\000\000\000\000\000\000\003[\003c\000\000\000\000\000\000\003\003\135\000\000\003[\0036\000\000\002\000\000\004\000\000\000\000\000\000\000\003^\000\000\000\000\000\000\000\000\003\128\003]\000\000\000\000\000\000\000\000\000\000\000\000\003\128\003]\000\000\000\000\003\137\000\000\000\000\000\000\003c\003T\000\000\000\000\003e\001\014\001\026\000\000\000\000\000\000\002\000\000\003c\000\000\000\000\000\000\002\002\003\135\000\000\002\000\000\002\000\000\000\000\000\000\003\135\000\000\003f\003^\002\000\000\003_\000\000\000\000\000\000\000\000\003^\003T\000\000\000\000\003e\000\000\000\000\003x\000\000\003\137\003U\000\000\003Z\003T\000\000\003`\003e\003\137\000\000\000\000\000\000\003*\000\000\000\000\000\000\000\000\000\000\000\000\003f\003[\000\000\000\000\002\002\003\000\000\000\000\000\000\002\002\003f\000\000\000\000\000\000\003x\000\000\000\000\003U\003_\003Z\000\000\003\128\003]\000\003_\000\000\003x\000\000\000\000\003U\0012\003Z\000\000\000\000\000\000\000\000\003[\003+\003`\0032\000\000\004\002\000\000\000\000\003`\000\000\002R\003c\003[\000\000\000\000\000\000\000\000\004\004\000\000\003\135\0033\002\003\128\003]\002\002\0014\000\000\000\000\000\000\003^\000\000\000\000\000\000\003\128\003]\002S\000\000\004:\000\000\003_\000\000\0034\0035\000\000\000\000\002U\003\137\000\000\003T\000\000\000\000\003e\000\000\000\000\000\000\003\135\000\000\000\000\000\000\003`\000\000\000\000\000\000\003c\001\002\000\000\003^\003\135\000\000\003c\001\003\000\000\000\000\002\000\000\003f\001\004\000\000\003^\002\000\000\000\000\000\000\003\137\000\000\000\000\0036\000\000h\000\000\001\012\003x\000\000\000\000\003U\003\137\003Z\000\000\000\000\000\000\000\000\003T\000\000\000\000\003e\000\000\002]\003T\000\000\000\000\003e\000\000\000\000\003[\000\000\000\000\002^\000\000\004\006\000\000\000\000\003c\002\002\000\000\000\000\000\000\000\000\003f\002_\002`\002\000\000\001I\003f\003\128\003]\000\000\003_\000\000\000\000\000\000\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\003x\001\001\003U\000\000\003Z\000\000\000\000\003`\003T\000\000\000\000\003e\000\000\000\000\000\000\003[\003N\000\000\003\135\000\000\004\b\003[\000\000\000\000\000\000\000\000\004\r\000\000\001\r\003^\005\000\000\000\000\000\000\000\000\003f\003O\003\128\003]\000\000\000\000\000\000\000\000\003\128\003]\000\000\003\137\000\000\000\000\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\002a\000\000\001J\000\000\000\000\000\000\000\000\005\005/\005\000\000\003c\000\000\003\135\000\000\003[\000\000\000\000\000\000\003\135\004\015\002\002b\002X\003^\000\000h\000\000\001M\000\000\003^\000\000\002\002\000\000\000\000\000\000\003\128\003]\000\000\003\141\003\137\000\000\000\000\002\002\001\014\003\137\003_\003T\002\000\000\003e\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003_\000\000\002c\002d\000\000\000\000\000\000\000\000\003`\000\000\000\000\003\135\000\000\001\t\000\000\000\000\003f\000\000\003*\000\000\003`\003\143\003^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\003\137\000\000\000\000\000\000\000\000\000\000\003\144\000\000\0051\000\000\000\000\000\000\000\000\000\000\000\000\003[\000\000\000\000\001N\000\000\004\019\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\003c\000\000\000\000\000\000\0053\000\000\003\128\003]\000\000\000\000\002\000\000\003c\0033\000\000\000\000\001\001\004\021\000\000\000\000\001\002\002\000\000\000\000\000\000\001U\001\016\001\017\004Z\006\135\000\000\003N\000\000\000\000\003\0035\000\000\003T\000\000\003\135\003e\002\002\000\000h\000\000\001\012\001\020\000\000\003T\003^\003O\003e\000\000\000\000\000\000\000\000\003_\000\000\000\000\000\000\000\000\001O\000\000\003f\000\000\000\000\003\137\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003f\003`\000\000\0036\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\007%\000\000\000\000\000\000\003x\000\000\000\000\003U\003\003Z\000\000\000\000\000\000\000\000\003[\001J\000\000\001\001\004\024\000\000\001W\001X\000\000\001Y\003\141\003[\000\000\000\000\000\000\000\000\004\027\000\000\003N\000\000\002\003\128\003]\000\000h\000\000\001M\002\133\002\134\002\135\000\000\000\000\001\r\003\128\003]\000\000\003c\000\000\003O\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\007&\003*\001\001\003\143\000\000\007'\007\003\135\000\000\000\000\000\000\000\000\000\000\000\000\003\021\000h\000\000\003N\003^\003\135\000\000\000\000\000\000\000\000\000\000\000\000\003T\003\144\000\000\003e\003^\000\000\007@\007A\007B\003\137\000\000\003O\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\003+\003\137\0032\000\000\000\000\000\000\003\141\003f\000\000\000\000\000\000\000\000\000\000\000\000\001\014\001\026\002\000\000\000\000\0033\000\000\001N\000\000\003x\004!\000\000\003U\000\000\003Z\000\000\000\000\000\000\002\136\004[\000\000\000\000\000\000\000\000\001\001\000\000\003\0035\000\000\003*\003[\000\000\003\143\000\000\003\025\004#\000\000\000\000\003\141\003N\000\000\000\000\000\000\000\000\000\000\007C\000\000\000\000\002\001\001\000\000\003\128\003]\000\000\000\000\003\144\000\000\007%\003O\003\000\000\000\000\000\000\000\000\003N\000\000\000\000\000\000\000\000\000\000\0036\003\000\000\000\000\003+\003*\0032\000\000\003\143\000\000\000\000\001O\002\139\000\000\003O\003\135\000\000\003\000\000\000\000\000\000\002\140\002\147\0033\000\000\000\000\003^\000\000\004'\000\000\000\000\002R\003\144\000\000\000\000\000\000\000\000\000\000\000\000\007D\000\000\000\000\000\000\003\137\000\000\003\0035\000\000\003\007&\003\141\003+\007E\0032\007F\007'\007\002S\002g\002i\002\001\001\000\000\003\021\000h\000\000\002U\000\000\000\000\0033\000\000\000\000\000\000\000\000\004)\003\141\003N\000\000\003\000\000\000\000\007@\007A\007B\000\000\002\000\000\003*\001I\0036\003\143\003\0035\000\000\000\000\000\000\003O\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\001\001\000\000\000\000\000\000\000\000\003*\003\144\000\000\003\143\000\000\000\000\000\000\000\000\000\000\000\000\003N\000\000\003\000\000\002]\000\000\000\000\003\000\000\000\000\003+\000\000\0032\0036\002^\000\000\000\000\003\144\000\000\000\000\003O\003\025\000\000\000\000\000\000\000\000\000\000\002_\002`\0033\003\000\000\007C\003\004,\003\141\003+\000\000\0032\000\000\001I\000\000\000\000\001J\000\000\002\000\000\001\001\005/\000\000\003\0035\000\000\000\000\0033\000\000\000\000\000\000\000\000\004/\000\000\000\000\003N\000\000\000\000\000\000h\000\000\001M\000\000\000\000\000\000\003*\000\000\000\000\003\143\003\0035\001\001\000\000\003\141\003O\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\003N\0036\007D\000\000\000\000\003\144\000\000\000\000\000\000\000\000\000\000\000\000\002a\000\000\000\000\007E\003\007F\003\000\000\003O\003\000\000\001J\003+\003*\0032\0036\003\143\005/\000\000\000\000\000\000\000\000\002b\002X\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0033\003\000\000\000\000h\0049\001M\003\141\000\000\003\144\005:\000\000\000\000\000\000\000\000\000\000\000\000\002\001\001\001N\000\000\003\0035\000\000\003\000\000\000\000\003+\000\000\0032\002c\002d\000\000\003N\000\000\000\000\0053\000\000\003\141\000\000\000\000\000\000\001\001\003*\000\000\0033\003\143\002\000\000\000\000\004C\000\000\003O\000\000\003\000\000\000\000\003N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0036\001\t\003\0035\000\000\003\144\000\000\000\000\000\000\000\000\003*\000\000\003O\003\143\000\000\000\000\000\000\003\005A\000\000\000\000\003\000\000\000\000\003+\000\000\0032\000\000\001N\001O\000\000\000\000\000\000\000\000\000\000\000\000\003\003\144\000\000\000\000\000\000\000\000\000\0033\000\000\0053\000\0036\004E\003\141\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\002\001\t\000\000\000\000\000\000\003\003\0035\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\141\0033\000\000\0016\001(\001\002\004G\000\000\000\000\000\000\002\001\016\001\017\003*\001\018\000\000\003\143\000\000\000\000\000\000\000\000\000\000\000\000\003\0035\003\000\000\000\000\004\000h\001O\001\012\001\020\001\021\001\022\000\000\0036\001\t\003*\000\000\003\144\003\143\000\000\001\002\000\000\000\000\000\000\000\000\000\000\001\003\000\000\000\000\000\000\003\000\000\001\004\003\003\000\000\003+\000\000\0032\000\000\000\000\001\002\003\144\000\000h\0036\001\012\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\0033\000\000\000\000\003\000\000\004P\003+\003\0032\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\000\000\001\001\000\000\003\0035\000\000\0033\000\000\000\000\000\000\000\000\004\134\000\000\000\000\000\000\000\000\003N\000\000\001\002\000\000\000\000\000\000\000\000\001\r\001\016\001\017\000\000\001\018\003\0035\000\000\000\000\000\000\004\001\023\004\003O\003\000\000\000\000\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\0036\000\000\000\000\000\000\001\001\000\000\000\000\000\000\000\000\000\000\001\001\001\r\003\000\000\000\000\003\000\000\000\000\003N\000\000\000\000\000\000\000\000\0036\000\000\003N\000\000\000\000\000\000\000\000\000\000\000\000\001\r\000\000\000\000\000\000\000\000\000\000\003O\000\000\003\000\000\000\000\001\023\005\t\003O\002\006\000\000\003\141\001\014\001\026\000\000\000\000\005\012\000\000\000\000\000\000\000\000\002\001\027\001#\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\007\000\000\002\158\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\t\001\r\000\000\000\000\003*\001\014\000\000\003\143\000\000\000\000\000\000\000\000\001\023\005\000\000\000\000\000\000\000\000\003\141\000\000\000\000\005\001\001\000\000\003\141\001\014\001\026\002\001\001\003\144\000\000\000\000\000\000\002\001\027\001#\003N\000\000\000\000\000\000\000\000\000\000\000\000\003N\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\003*\000\000\003O\003\143\000\000\002\017\000\000\003*\000\000\003O\003\143\000\000\000\000\0033\000\000\002\018\000\000\000\000\005\000\000\000\000\001\014\001\026\000\000\000\000\002\002\003\144\002\021\002\022\000\000\001\027\001#\000\000\003\144\003\0035\000\000\000\000\000\000\000\000\003_\001I\003\000\000\000\000\003+\000\000\0032\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\000\000\000\000\003`\000\000\000\000\003\141\0033\000\000\000\000\000\000\003\005\003\141\0033\000\000\002\002\002\005\000\000\000\000\0036\002\000\000\002\002\000\000\000\000\003\0035\000\000\000\000\003_\000\000\000\000\003\0035\000\000\003\000\000\003_\000\000\000\000\003*\000\000\000\000\003\143\000\000\000\000\002\023\003*\000\000\003`\003\143\000\000\000\000\000\000\000\000\000\000\000\000\003`\001J\003\000\000\003c\000\000\000\000\005/\000\000\003\003\144\002\024\002\012\0036\002\000\000\000\000\003\144\000\000\000\000\0036\000\000\000\000\000\000\000\000h\003\001M\000\000\003+\003\0032\000\000\003\000\000\000\000\003+\003\0032\000\000\000\000\000\000\003T\000\000\000\000\003e\001\001\0033\000\000\000\000\002\025\002\026\005\003c\0033\000\000\000\000\000\000\000\000\005\000\000\003c\000\000\002\000\000\000\000\000\000\000\000\003f\003\0035\002\002\002\000\000\000\000\003\0035\000\000\000\000\000\000\ny\000\000\000\000\003x\000\000\000\000\003U\003_\003Z\000\000\003T\000\000\000\000\003e\000\000\000\000\002\002\003T\000\000\000\000\003e\003\000\000\005H\003[\000\000\003`\000\000\003\0061\000\000\003_\0036\001N\000\000\000\000\003f\000\000\000\000\0036\000\000\000\000\000\000\000\000\003f\000\000\003\128\003]\000\000\003\0053\003`\003x\000\000\000\000\003U\003\003Z\000\000\000\000\003x\002\000\000\003U\000\000\003Z\000\000\002\002\000\000\000\000\002\000\000\000\000\003[\000\000\000\000\000\000\000\000\0064\003\135\000\000\003[\003_\000\000\000\000\000\000\006=\003c\000\000\000\000\003^\000\000\000\000\000\000\000\000\003\128\003]\002\003*\000\000\000\000\000\000\003`\003\128\003]\000\000\000\000\003\137\001O\000\000\000\000\000\000\003c\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\002\002\003T\000\000\000\000\003e\003\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\135\001I\003_\003^\000\000\000\000\000\000\003+\000\000\0032\000\000\003^\000\000\003T\000\000\003f\003e\000\000\000\000\002R\003\137\000\000\003`\000\000\000\000\000\000\0033\003c\003\137\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\002\002\002\003f\000\000\000\000\000\000\000\000\002S\000\000\004:\0034\0035\000\000\000\000\000\000\003[\003_\002U\003x\000\000\006?\003U\000\000\003Z\000\000\000\000\000\000\003T\000\000\000\000\003e\000\000\000\000\000\000\000\000\000\000\003`\003\128\003]\000\000\003[\001J\000\000\000\000\000\000\006F\003c\005/\000\000\000\000\000\000\000\000\000\000\000\000\003f\0036\002\000\000\000\000\000\000\001\t\000\000\003\128\003]\000\000h\000\000\001M\000\000\000\000\003x\003\135\000\000\003U\000\000\003Z\000\000\000\000\002]\000\000\000\000\000\000\003^\000\000\003T\001\001\003e\002^\000\000\001\t\000\000\003[\000\000\000\000\000\000\003\135\006L\003c\003\137\000\000\002_\002`\000\000\000\000\002R\000\000\003^\002\000\000\000\000\003f\000\000\000\000\003\128\003]\000\000\000\000\000\000\002\002\003\147\000\000\000\000\003\137\000\000\000\000\003x\000\000\000\000\003U\002S\003Z\004:\000\000\003_\003T\000\000\001\002\003e\000\000\002U\000\000\000\000\001\016\001\017\005N\001\018\003\135\003[\000\000\000\000\000\000\005\006T\003`\001N\000\000\000\000\003^\000\000\000\000h\003f\001\012\001\020\001\021\001\022\001\002\000\000\000\000\003\128\003]\0053\001\016\001\017\003\137\001\018\000\000\003x\000\000\002a\003U\002\003Z\000\000\000\000\000\000\005\000\000\005\000\000h\002\001\012\001\020\001\021\001\022\000\000\002\002\003[\002]\002b\002X\003\135\006_\000\000\000\000\001I\000\000\000\000\002^\000\000\000\000\003_\003^\003c\000\000\000\000\000\000\003*\000\000\003\128\003]\002_\002`\002\000\000\000\000\000\000\000\000\001O\003\137\000\000\003`\002\002\000\000\000\000\000\000\000\000\000\000\002c\002d\000\000\000\000\000\000\003\148\000\000\000\000\000\000\003_\001\r\000\000\003T\000\000\003\135\003e\000\000\000\000\000\000\000\000\000\000\001\023\005\000\000\003+\003^\0032\000\000\000\000\003`\006i\000\000\000\000\000\000\005\000\000\000\000\000\000\000\000\003f\001\r\000\000\003\137\0033\001J\000\000\000\000\002\002\000\000\005/\001\023\006\000\000\003c\003x\000\000\000\000\003U\000\000\003Z\006\002a\003_\002\0034\0035\000\000h\005\001M\005\000\000\002\002\000\000\000\000\003[\000\000\000\000\000\000\000\000\007x\003`\002b\002X\001\014\001\026\000\000\003_\000\000\003c\003T\000\000\000\000\003e\001\027\001#\000\000\003\128\003]\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003`\0036\000\000\000\000\000\000\000\000\000\000\001\014\001\026\000\000\003f\000\000\000\000\000\000\000\000\002c\002d\001\027\001#\000\000\003T\001\001\003e\003\135\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\003^\003c\003N\000\000\000\000\005T\000\000\000\000\000\000\000\000\000\000\002\003f\003[\000\000\001N\000\000\003\137\007{\000\000\000\000\000\000\003O\000\000\000\000\000\000\002R\003c\003x\000\000\000\000\003U\0053\003Z\000\000\003\128\003]\002\000\000\003T\002\002\003e\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003[\000\000\002S\000\000\004:\b\127\003_\000\000\000\000\000\000\000\000\000\000\002U\000\000\000\000\003T\003f\000\000\003e\003\135\000\000\000\000\003\128\003]\000\000\001\002\003`\000\000\000\000\000\000\003^\004\003x\000\000\003\141\003U\000\000\003Z\000\000\000\000\000\000\001O\003f\000\000\002\000\000\000\000\003\137\000\000h\000\000\001\012\000\000\000\000\003[\000\000\003\135\000\000\003x\b\138\000\000\003U\000\000\003Z\000\000\000\000\000\000\003^\000\000\000\000\002\002\003*\002]\000\000\003\143\003\128\003]\000\000\000\000\003[\000\000\000\000\002^\003\137\b\143\003_\000\000\003c\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002_\002`\002\003\144\000\000\000\000\003\128\003]\000\000\000\000\003`\002\002\000\000\003\135\000\000\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\003^\000\000\003_\000\000\000\000\003T\000\000\000\000\003e\007\157\000\000\000\000\000\000\000\000\000\000\003\135\0033\003\137\000\000\001\r\000\000\b\150\003`\000\000\000\000\000\000\003^\005\000\000\000\000\000\000\000\000\003f\000\000\000\000\000\000\004\000\000\003\0035\001\001\000\000\003\137\002\002\000\000\003c\003x\000\000\000\000\003U\000\000\003Z\000\000\002a\003N\002\000\000\000\000\003_\000\000\005\000\000\005\000\000\000\000\000\000\000\000\000\000\003[\000\000\003\000\000\000\000\b\152\003O\002b\002X\000\000\003`\000\000\000\000\0036\003c\003T\000\000\000\000\003e\007%\000\000\000\000\003\128\003]\002\001\014\000\000\000\000\000\000\000\000\003\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003f\000\000\000\000\000\000\000\000\002c\002d\003_\000\000\000\000\003T\000\000\000\000\003e\003\135\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\003^\003\141\003`\000\000\000\000\003c\000\000\000\000\000\000\000\000\000\000\002\003f\003[\007&\002\000\000\003\137\b\154\000\000\007'\007\000\000\000\000\000\000\000\000\000\000\000\000\003x\003\021\000h\003U\000\000\003Z\000\000\003\128\003]\000\000\000\000\003*\000\000\000\000\003\143\003T\000\000\000\000\003e\007@\007A\007B\003[\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003c\000\000\003\144\000\000\000\000\003\135\003f\000\000\003\128\003]\002\000\000\002\002\000\000\000\000\003^\000\000\003\001\001\003+\003x\0032\000\000\003U\000\000\003Z\003_\000\000\000\000\000\000\000\000\003\137\000\000\003N\000\000\000\000\003T\000\000\0033\003e\003\135\000\000\003[\b\003\025\000\000\003`\b\000\000\000\000\000\000\003^\000\000\003O\000\000\007C\000\000\000\000\000\000\000\000\003\0035\000\000\003f\003\128\003]\000\000\000\000\003\137\000\000\000\000\000\000\000\000\000\000\001\001\000\000\000\000\000\000\003x\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\000\000\000\000\003N\000\000\000\000\000\000\003\001\001\000\000\003\135\000\000\000\000\003[\000\000\000\000\000\000\0036\b\000\000\003c\003^\003O\000\000\000\000\000\000\000\000\003\141\000\000\000\000\002\000\000\007D\000\000\003\003\128\003]\002\003\137\001\001\000\000\000\000\nr\000\000\007E\000\000\007F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003N\000\000\000\000\003T\000\000\000\000\003e\000\000\000\000\000\000\003*\000\000\000\000\003\143\003\135\000\000\000\000\000\000\000\000\000\000\003O\000\000\000\000\000\000\000\000\003^\000\000\000\000\000\000\003\141\003f\000\000\000\000\000\000\000\000\000\000\000\000\003\144\000\000\002\000\000\000\000\003\137\001\001\000\000\003x\000\000\000\000\003U\002\003Z\000\000\003\000\000\000\000\003+\000\000\0032\003N\002\000\000\000\000\000\000\000\000\000\000\000\000\003*\003[\000\000\003\143\000\000\000\000\t>\000\000\0033\000\000\000\000\000\000\003O\tA\000\000\003\141\000\000\000\000\000\000\000\000\000\000\003*\000\000\003\128\003]\002\000\000\003\144\000\000\000\000\003\0035\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\000\000\003*\000\000\000\000\003\143\003\135\000\000\000\000\001\t\000\000\000\000\000\000\003\0033\000\000\003+\003^\0032\tH\000\000\000\000\000\000\003\141\0036\000\000\000\000\001\001\003\144\000\000\000\000\000\000\002\003\137\0033\003\0035\000\000\000\000\000\000\003\000\000\003N\000\000\003\000\000\002R\003+\000\000\0032\000\000\000\000\000\000\000\000\001\t\000\000\0034\0035\000\000\000\000\003*\000\000\003O\003\143\000\000\000\000\0033\001\t\000\000\003\000\000\t\002S\000\000\004:\000\000\000\000\000\000\000\000\000\000\0036\000\000\002U\000\000\000\000\000\000\001\002\003\144\003\0035\000\000\000\000\001\016\001\017\000\000\001\018\000\000\003\000\000\000\000\000\000\0036\000\000\003\000\000\000\000\003+\000\000\0032\004\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\003\141\0033\n\144\000\000\000\000\000\000\t\000\000\001\002\0036\002\000\000\001U\000\000\001\016\001\017\000\000\001\018\000\000\002]\000\000\001\002\000\000\003\0035\000\000\003\001\016\001\017\002^\001\018\000\000h\000\000\001\012\001\020\001\021\001\022\003*\000\000\000\000\003\143\002_\002`\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\144\000\000\000\000\0036\000\000\000\000\001\t\000\000\000\000\002\006\000\000\000\000\001\r\000\000\000\000\000\000\003\000\000\000\000\003+\003\0032\n\023\001\023\004\001J\000\000\000\000\000\000\006P\000\000\001W\001X\000\000\001Y\002\007\000\000\002\016\0033\000\000\000\000\000\000\000\000\t\000\000\002\t\000\000\000\000\000\000h\000\000\001M\002\133\002\134\002\135\000\000\000\000\002a\001\r\000\000\003\0035\000\000\000\000\006U\000\000\006V\000\000\000\000\001\023\n\014\001\r\000\000\000\000\000\000\001\t\000\000\000\000\000\000\002b\002X\000\000\001\023\n\145\001\002\000\000\000\000\000\000\001\014\001\026\001\016\001\017\000\000\001\018\003\000\000\000\000\000\000\001\027\001#\001U\000\000\000\000\000\000\000\000\0036\002\017\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\002\018\000\000\000\000\002c\002d\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\002\021\002\022\000\000\000\000\000\000\001\014\001\026\001U\000\000\000\000\000\000\001N\000\000\000\000\000\000\001\027\001#\000\000\001\014\001\026\000\000\000\000\002\136\t\001\002\000\000\000\000\000\000\001\027\001#\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\001J\001\012\001\020\001\021\001\022\000\000\001W\001X\000\000\001Y\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\r\000\000\000\000h\000\000\001M\002\133\002\134\002\135\000\000\002\023\001\023\001\"\000\000\000\000\001J\000\000\001O\002\139\002\006\000\000\001W\001X\000\000\001Y\000\000\000\000\002\140\002\147\000\000\001U\000\000\002\024\002\012\000\000\000\000\000\000\000\000\000\000h\000\000\001M\002\133\002\134\002\135\002\007\000\000\002\030\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\t\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\r\000\000\000\000\002\025\002\026\000\000\000\000\001\014\001\026\000\000\000\000\001\023\002x\001U\000\000\000\000\000\000\001\027\001#\000\000\000\000\001\t\000\000\000\000\000\000\001N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\136\002\144\000\000\001J\000\000\000\000\000\000\000\000\000\000\001W\001X\002\017\001Y\000\000\000\000\000\000\000\000\000\000\000\000\001\t\000\000\002\018\000\000\000\000\000\000\001N\000\000h\000\000\001M\002\133\002\134\002\135\000\000\002\021\002\022\002\136\002\155\000\000\000\000\001\014\001\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\027\001#\000\000\000\000\000\000\001J\001\t\000\000\000\000\000\000\000\000\001W\001X\001\002\001Y\001O\002\139\000\000\000\000\001\016\001\017\000\000\001\018\000\000\000\000\002\140\002\147\000\000\000\000h\000\000\001M\002\133\002\134\002\135\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\000\000\000\000\001\002\000\000\000\000\000\000\001O\002\139\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\002\140\002\147\001\t\002\023\000\000\000\000\000\000\001N\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\002\136\004X\000\000\000\000\000\000\001\002\000\000\002\024\002\012\000\000\000\000\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\001\t\000\000\000\000\000\000\001N\000\000\000\000\000\000\000\000\000\002\025\002\026\001\r\000\000\000\000\002\136\004]\000\000\000\000\000\000\000\000\000\000\000\000\001\023\004i\001\002\000\000\000\000\001O\002\139\000\000\001\016\001\017\000\000\001\018\000\000\000\000\000\000\002\140\002\147\001\t\000\000\000\000\000\000\000\000\000\000\001\r\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\001\023\004n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\t\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\001O\002\139\000\000\001\r\001\016\001\017\001\002\001\018\001\014\001\026\002\140\002\147\004\000\000\001\023\004\000\000\000\000\001\027\001#\002R\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000h\000\000\001\012\000\000\000\000\000\000\000\000\000\000\001\002\000\000\000\000\000\000\001\014\001\026\001\016\001\017\002S\001\018\004:\000\000\000\000\000\000\001\027\001#\000\000\000\000\002U\000\000\000\000\000\000\001\r\000\000h\000\000\001\012\001\020\001\021\001\022\001\002\000\000\001\t\001\023\004\000\000\001\016\001\017\000\000\001\018\000\000\001\014\001\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\027\001#\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\000\000\001U\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\001\r\000\000\000\000\000\000\002]\000\000\000\000\000\000\001\r\000\000\000\000\001\023\004\000\000\002^\000\000\000\000\001U\000\000\000\000\000\000\000\000\000\000\001\014\001\026\004\000\000\002_\002`\000\000\000\000\000\000\000\000\001\027\001#\001\002\000\000\000\000\000\000\000\000\001\r\001\016\001\017\000\000\001\018\000\000\000\000\001\t\000\000\000\000\000\000\001\023\004\000\000\011\017\000\000\000\000\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\001J\000\000\000\000\000\000\000\000\001\r\001W\001X\000\000\001Y\000\000\001\014\001\026\000\000\011\018\001\t\001\023\005\011\000\000\001\014\000\000\001\027\001#\000\000h\000\000\001M\002\133\002\134\002\135\001J\000\000\000\000\000\000\000\000\000\000\001W\001X\000\000\001Y\000\000\000\000\002a\000\000\000\000\001U\000\000\000\000\000\000\000\000\000\000\001\014\001\026\000\000h\000\000\001M\002\133\002\134\002\135\001\002\001\027\001#\000\000\002b\002X\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\025\000\000\011\026\001\014\001\026\000\000h\001\r\001\012\001\020\001\021\001\022\000\000\001\027\001#\001\002\000\000\000\000\001\023\005\028\000\000\001\016\001\017\000\000\001\018\000\000\002c\002d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001N\000\000h\000\000\001\012\001\020\001\021\001\022\001J\000\000\000\000\002\136\005.\000\000\001W\001X\000\000\001Y\000\000\000\000\000\000\011\027\000\000\007%\001U\000\000\000\000\000\000\000\000\000\000\001N\000\000h\000\000\001M\002\133\002\134\002\135\000\000\001\002\000\000\002\136\0055\000\000\000\000\004\001\014\001\026\000\000\000\000\000\000\000\000\000\000\000\000\001U\000\000\001\027\001#\000\000\000\000\001\r\000\000\000\000h\000\000\001\012\000\000\000\000\000\000\000\000\000\000\001\023\005[\000\000\000\000\000\000\001O\002\139\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007&\002\140\002\147\000\000\000\000\000\000\007'\b\003\001\r\000\000\000\000\000\000\000\000\000\000\000\000\003\021\000h\001J\000\000\001\023\005h\001O\002\139\001W\001X\000\000\001Y\000\000\000\000\000\000\000\000\002\140\002\147\007@\007A\007B\000\000\000\000\001N\000\000\000\000h\000\000\001M\002\133\002\134\002\135\001J\000\000\002\136\005s\001\014\001\026\001W\001X\000\000\001Y\000\000\000\000\007\000\000\001\027\001#\001U\000\000\000\000\000\000\000\000\000\000\001\r\000\000h\000\000\001M\002\133\002\134\002\135\000\000\000\000\000\000\000\000\000\000\002R\000\000\001\014\001\026\004\000\000\000\000\000\000\000\000\000\000\000\000\001U\001\027\001#\003\025\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007C\002S\000\000\004:\000\000\000\000\000\000\001O\002\139\000\000\000\000\002U\000\000\000\000\000\000\000\000\000\000\002\140\002\147\001\t\000\000\000\000\000\000\000\000\000\000\001N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001J\000\000\002\136\005x\001\014\000\000\001W\001X\000\000\001Y\000\000\000\000\000\000\000\000\000\000\001\t\000\000\000\000\000\000\000\000\000\000\001N\000\000\000\000h\000\000\001M\002\133\002\134\002\135\001J\007D\002\136\005}\000\000\000\000\001W\001X\002]\001Y\000\000\000\000\000\000\000\000\007E\001\t\007F\000\000\002^\000\000\000\000\000\000\000\000\000\000h\000\000\001M\002\133\002\134\002\135\000\000\002_\002`\001\002\000\000\000\000\000\000\001O\002\139\001\016\001\017\000\000\001\018\000\000\000\000\001U\000\000\002\140\002\147\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\001\002\000\000\000\000\000\000\001O\002\139\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\002\140\002\147\000\000\000\000\000\000\000\000\b\144\000\000\001N\000\000h\000\000\001\012\001\020\001\021\001\022\001\002\000\000\000\000\002\136\005\137\000\000\001\016\001\017\000\000\001\018\000\000\000\000\b\147\000\000\000\000\000\000\000\000\000\000\002a\000\000\000\000\000\000\001N\000\000h\000\000\001\012\001\020\001\021\001\022\001J\000\000\001U\002\136\005\000\000\001W\001X\000\000\001Y\002b\002X\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\001\r\001M\002\133\002\134\002\135\000\000\000\000\001\t\000\000\000\000\000\000\001\023\005\001O\002\139\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\140\002\147\002c\002d\000\000\000\000\000\000\001\r\000\000\000\000\000\000\000\000\000\000\000\000\001\t\000\000\000\000\000\000\001\023\005\001O\002\139\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\140\002\147\001J\000\000\000\000\000\000\000\000\001\r\001W\001X\000\000\001Y\000\000\000\000\001U\000\000\000\000\000\000\001\023\005\000\000\000\000\000\000\001\014\001\026\000\000h\000\000\001M\002\133\002\134\002\135\001\002\001\027\001#\000\000\000\000\001N\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\000\000\001U\002\136\006#\000\000\000\000\000\000\001\014\001\026\000\000h\000\000\001\012\001\020\001\021\001\022\001\002\001\027\001#\000\000\000\000\000\000\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\000\000\001U\000\000\000\000\000\000\000\000\000\000\001\014\001\026\000\000h\000\000\001\012\001\020\001\021\001\022\001J\001\027\001#\000\000\000\000\000\000\001W\001X\000\000\001Y\000\000\000\000\000\000\000\000\000\000\000\000\000\002R\000\000\000\000\000\000\001O\002\139\000\000h\001N\001M\002\133\002\134\002\135\000\000\002\140\002\147\001J\000\000\000\000\002\136\006,\000\000\001W\001X\000\000\001Y\002S\000\000\002T\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002U\000\000\001\r\000\000h\000\000\001M\002\133\002\134\002\135\001J\000\000\000\000\001\023\006D\000\000\001W\001X\000\000\001Y\000\000\002n\000\000\000\000\000\000\007%\001\t\000\000\000\000\000\000\000\000\000\000\001\r\000\000h\000\000\001M\002\133\002\134\002\135\000\000\001\002\000\000\001\023\006I\000\000\000\000\004\001O\002\139\000\000\000\000\000\000\000\000\000\000\000\000\001\t\000\000\002\140\002\147\000\000\002[\001N\000\000\000\000h\000\000\001\012\000\000\000\000\000\000\002^\000\000\002\136\006\000\000\000\000\000\000\001\014\001\026\000\000\000\000\000\000\000\000\002_\002`\002e\b\015\001\027\001#\000\000\000\000\000\000\007'\b\018\001N\000\000\000\000\000\000\000\000\000\000\000\000\003\021\000h\001\002\000\000\002\136\006\001\014\001\026\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\001\027\001#\007@\007A\007B\000\000\000\000\001N\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\001\002\000\000\002\136\006\001O\002\139\001\016\001\017\000\000\001\018\000\000\000\000\007\000\000\002\140\002\147\001\t\000\000\000\000\000\000\000\000\000\000\001\r\000\000h\000\000\001\012\001\020\001\021\001\022\002a\000\000\000\000\000\000\000\000\002R\000\000\001O\002\139\004\000\000\000\000\000\000\000\000\000\000\000\000\001\t\002\140\002\147\003\025\000\000\000\000\002f\002X\000\000\000\000\000\000\000\000\000\000\000\000\007C\002S\000\000\004:\000\000\000\000\000\000\001O\002\139\000\000\000\000\002U\000\000\000\000\000\000\000\000\000\000\002\140\002\147\001\t\000\000\000\000\000\000\000\000\000\000\001\r\000\000\000\000\000\000\000\000\000\000\000\000\002c\002d\001\002\000\000\001\023\007.\001\014\000\000\001\016\001\017\002j\001\018\000\000\000\000\000\000\000\000\000\000\001\t\000\000\000\000\000\000\000\000\000\000\001\r\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\001\002\007D\001\023\0070\000\000\000\000\001\016\001\017\002]\001\018\000\000\000\000\000\000\000\000\007E\001\t\007F\000\000\002^\000\000\000\000\000\000\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\002_\002`\001\002\000\000\000\000\000\000\001\014\001\026\001\016\001\017\000\000\001\018\000\000\000\000\001U\000\000\001\027\001#\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\000\000\001\012\001\020\001\021\001\022\001\002\000\000\000\000\000\000\001\014\001\026\001\016\001\017\000\000\001\018\000\000\000\000\000\000\000\000\001\027\001#\000\000\000\000\000\000\000\000\b\144\000\000\001\r\000\000h\000\000\001\012\001\020\001\021\001\022\001\002\000\000\000\000\001\023\007L\000\000\001\016\001\017\000\000\001\018\000\000\000\b\146\000\000\000\000\000\000\000\000\000\002a\000\000\000\000\000\000\001\r\000\000h\000\000\001\012\001\020\001\021\001\022\001J\000\000\001\t\001\023\007v\000\000\001W\001X\000\000\001Y\002b\002X\000\000\000\000\000\000\000\000\002R\000\000\004\001(\000\000\000\000\000\000\000\000h\001\r\001M\002\133\002\134\002\135\000\000\000\000\000\000\000\000\000\000\000\000\001\023\007\149\001\014\001\026\000\000\000\000\002S\000\000\004:\000\000\000\000\002R\001\027\001#\002c\002d\002U\000\000\000\000\001\r\000\000\000\000\001\002\000\000\000\000\000\000\000\000\000\000\001\003\000\000\001\023\b\001\014\001\026\001\004\000\000\000\000\002S\004A\004:\000\000\000\000\001\027\001#\001\002\000\000h\002U\001\012\001\r\001\016\001\017\000\000\001\018\000\000\000\000\000\000\002R\000\000\000\000\001\023\b\000\000\000\000\000\000\001\014\001\026\000\000h\000\000\001\012\001\020\001\021\001\022\000\000\001\027\001#\002]\000\000\001N\000\000\000\000\000\000\002S\002R\002T\000\000\002^\000\000\000\000\002\136\n\027\000\000\002U\000\000\001\014\001\026\000\000\000\000\000\000\002_\002`\000\000\000\000\000\000\001\027\001#\000\000\002]\000\000\002S\000\000\004:\000\000\002\000\000\000\000\002\006\002^\000\000\002U\000\000\000\000\000\000\000\000\001\014\001\026\000\000\000\000\000\000\000\000\002_\002`\000\000\000\000\001\027\001#\001\r\000\000\000\000\000\000\000\000\000\000\002\007\004H\002\b\004J\000\000\000\000\000\000\000\000\000\000\004K\002\t\002[\001O\002\139\n\000\000\001\r\002\002\000\000\000\000\002^\002\140\002\147\000\000\000\000\000\000\001\023\n\000\000\000\000\002\000\000\000\000\002_\002`\002e\002a\002]\000\000\n\000\000\000\000\000\000\000\000\000\000\000\000\002R\002^\000\000\002R\006\b\000\000\003i\000\000\000\000\000\000\000\000\000\000\002b\002X\002_\002`\000\000\000\000\000\000\000\000\000\000\002a\000\000\001\014\002\015\000\000\002S\000\000\004:\002S\000\000\002T\000\000\000\000\002\018\000\000\002U\000\000\000\000\002U\n\000\000\000\000\002b\002X\001\014\001\026\002\021\002\022\002\027\000\000\000\000\002c\002d\000\000\001\027\001#\000\000\011\n\000\000\t\000\000\000\000\000\000\000\000\000\000\n\002a\002\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\002c\002d\000\000\000\000\000\000\000\000\002f\002X\000\000\000\000\000\000\002a\000\000\000\000\002]\000\000\000\000\002[\000\000\000\000\011\002\000\000\003\147\003T\002^\000\000\002\006\002^\000\000\000\000\000\000\011\t\000\000\002b\002X\000\000\000\000\002_\002`\000\000\002_\002`\002e\000\000\002\023\000\000\002c\002d\011\b\000\000\003t\000\000\002\007\000\000\002\b\000\000\002j\000\000\000\000\000\000\000\000\003w\002\t\003v\002R\000\000\002\028\002\012\000\000\003U\000\000\003Z\000\000\002c\002d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\t\002\000\000\000\000\000\000\003[\006P\002S\000\000\004:\000\000\002\000\000\000\000\000\000\000\000\002R\002U\000\000\000\000\000\000\011\t\000\000\002\025\002\026\002R\000\000\003\\\003]\000\000\000\000\000\000\000\000\002 \002a\000\000\000\000\002a\000\000\003*\002\015\b\002S\006V\004:\000\000\000\000\000\000\000\000\000\000\002\018\002S\002U\004:\000\000\000\000\002b\002X\000\000\002f\002X\002U\000\000\002\021\002\022\002\027\003\158\000\000\000\000\000\000\000\000\000\000\003^\007%\000\000\000\000\000\000\003\002]\003\002R\000\000\000\000\000\000\000\000\003+\000\000\0032\002^\001\t\000\000\000\000\002R\000\000\000\000\000\000\002c\002d\000\000\002c\002d\002_\002`\000\000\0033\000\000\002S\000\000\004:\002j\000\000\000\000\000\000\002]\000\000\000\000\002U\000\000\002S\000\000\004:\000\000\002]\002^\000\000\000\000\0034\0035\002U\000\000\000\000\000\000\002^\000\000\000\000\007&\002_\002`\000\000\000\000\000\000\007'\b5\002\023\000\000\002_\002`\000\000\000\000\000\000\003\021\000h\000\000\004;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\028\002\012\001\002\007@\007A\007B\0036\000\000\001\016\001\017\004>\006\002]\000\000\000\000\000\000\002a\000\000\000\000\000\000\000\000\000\000\002^\004;\002]\000\000h\000\000\001\012\001\020\000\000\000\000\004;\000\000\002^\002_\002`\000\000\002b\002X\002\025\002\026\000\000\000\000\000\000\004=\000\000\002_\002`\000\000\002 \002a\000\000\000\000\004<\000\000\000\000\000\000\000\000\006\002a\001\t\000\000\000\000\000\000\000\000\003\025\000\000\000\000\001\t\000\000\000\000\000\000\002b\002X\000\000\000\000\007C\002c\002d\000\000\000\000\002b\002X\000\000\000\000\000\000\004;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006P\000\000\000\000\000\000\000\000\000\000\002R\000\000\000\000\000\004L\000\000\000\000\000\000\002c\002d\002a\000\000\001\r\000\000\000\000\000\000\000\000\002c\002d\000\000\000\000\000\000\002a\000\000\001\t\000\000\002S\002R\004:\000\000\000\000\006W\002b\002X\001\002\000\000\002U\007D\000\000\000\000\001\016\001\017\001\002\006\002b\002X\000\000\000\000\001\016\001\017\007E\006\007F\002S\000\000\004:\006\000\000h\000\000\001\012\001\020\000\000\002U\000\000\000\000h\000\000\001\012\001\020\000\000\000\000\002c\002d\006\000\000\001\t\000\000\000\000\000\000\001\002\000\000\000\000\000\000\002c\002d\004\000\000\001\014\001\026\000\000\006\000\000\000\000\000\000\000\000\000\000\002]\000\000\006\000\000\000\000\001\002\000\000h\000\000\001\012\002^\001\016\001\017\006\006\137\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002_\002`\000\000\000\000\002]\000\000h\000\000\001\012\001\020\000\000\000\000\000\000\000\000\002^\000\000\006\000\000\000\000\000\000\000\000\006\006\b8\000\000\000\000\000\000\002_\002`\001\r\000\000\001\000h\000\000\001\002\000\000\000\000\001\r\000\000\006\139\001\016\001\017\007%\006\000\000\000\000\000\000\000\000\000\000\007\019\007\020\007\021\b\144\000\000\000\000\000\000\000\000\000\000h\000\000\001\012\001\020\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\b\145\001\r\000\000\000\000\000\000\b\144\002a\007\000\000\006\000\000\007%\000\000\000\000\007%\006\bD\006\004\000\000\000\000\000\000\000\000\001\r\001\000h\000\000\b\159\002b\002X\007&\001\014\001\026\002a\002R\000\000\007'\t\019\001\001\014\001\026\000\000\007\019\007\020\007\021\003\021\000h\000\000\000\000\007\022\000\000\001\001\006\000\000\002b\002X\000\000\000\000\000\000\002S\006\002\148\007@\007A\007B\000\000\n\002c\002d\002U\000\000\000\000\t0\000\000\001\r\007&\001\014\000\000\007'\b\018\000\000\007'\n\001\001\000\000\t\003\021\000h\000\000\003\021\000h\000\000\000\000\002c\002d\000\000\000\000\001\014\001\026\000\000\002R\000\000\000\000\001\007@\007A\007B\007@\007A\007B\000\000\000\000\007\023\000\000\007\022\002R\000\000\011\r\003\147\006\141\002R\000\000\000\000\000\000\003\025\007\024\002S\007\025\002\\\002]\000\000\000\000\000\000\000\000\000\000\007C\002U\000\000\000\000\002^\000\000\002S\000\000\002h\000\000\000\000\002S\002\002\001\014\001\026\002U\002_\002`\000\000\000\000\002U\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\025\000\000\000\000\003\025\006\002\002\000\000\000\000\000\000\000\000\007C\007\023\002\007C\000\000\001\001\003*\000\000\000\000\001\001\002\000\000\007\024\000\000\007\025\000\000\000\000\002]\000\000\000\000\007D\000\000\000\000\001\001\000\000\000\000\002^\t\000\000\000\000\000\000\002]\007E\000\000\007F\000\000\002]\003*\t\002_\002`\002^\000\000\t\134\000\000\000\000\002^\000\000\000\000\000\000\003+\002a\0032\000\000\002_\002`\000\000\000\000\tD\002_\002`\000\000\007D\000\000\003\007D\000\000\000\000\000\000\0033\000\000\000\000\000\000\002b\002X\007E\000\000\007F\007E\000\000\007F\000\000\000\000\003+\000\000\0032\000\000\000\000\000\000\002\000\000\0034\0035\000\000\000\000\000\000\000\000\001\001\002\002\000\000\0033\000\000\000\000\002\000\000\000\000\000\000\000\000\002\001\001\002c\002d\002\000\000\000\000\000\000\002a\002\000\000\000\000\000\000\0034\0035\000\000\003T\000\000\000\000\002\001\001\001\002a\000\000\0036\000\000\003*\002a\000\000\002b\002X\003*\002\002\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002b\002X\003*\000\000\000\000\002b\002X\000\000\000\000\000\000\000\000\002\000\000\0036\000\000\000\000\000\000\003U\000\000\003Z\000\000\000\000\000\000\000\000\b\002c\002d\000\000\003+\000\000\0032\000\000\000\000\003+\000\000\0032\003[\000\000\000\000\002\002c\002d\000\000\000\000\000\000\002c\002d\0033\003+\002\0032\000\000\0033\002\000\000\000\000\000\000\000\000\003\\\003]\000\000\000\000\000\000\002\000\000\002\002\0033\000\000\0034\0035\000\000\000\000\002\0034\0035\001\002\003*\000\000\002\002\000\000\004\002\000\000\000\000\002\000\000\000\000\0034\0035\003*\001\001\000\000\000\000\002\002\002\000\000h\002\001\012\003^\000\000\000\000\000\000\000\000\001\001\000\000\003*\001\001\0036\002\000\000\000\000\000\000\0036\000\000\000\000\000\000\003+\003T\0032\002\002\002\000\000\000\000\000\000\000\000\002\0036\000\000\000\000\003+\000\000\0032\000\000\000\000\0033\000\000\002\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0033\003+\000\000\0032\000\000\000\000\002\002\0034\0035\000\000\000\000\000\000\000\000\003U\000\000\003Z\002\000\000\000\000\0033\002\0034\0035\000\000\007\000\000\000\000\000\000\000\000\000\000\002\000\000\003[\002\001\r\000\000\000\000\000\000\002\000\000\000\000\0034\0035\002\003T\000\000\001\001\002\002\000\000\004\0036\002\003\\\003]\000\000\000\000\003T\002\000\000\000\000\000\000\002\001\001\0036\002\000\000\000\000\000\000\003*\000\000\000\000\000\000\000\000\003T\002\000\000\001\001\000\000\003)\000\000\000\000\000\000\0036\003*\000\000\000\000\003U\003*\003Z\001\001\000\000\000\000\000\000\000\000\003^\0038\000\000\000\000\000\000\003U\003T\003Z\000\000\000\000\003[\001\014\000\000\000\000\000\000\000\000\0039\000\000\003+\000\000\0032\000\000\000\000\003U\003[\003Z\000\000\000\000\000\000\000\000\003H\000\000\003\\\003]\003+\000\000\0032\0033\003+\000\000\0032\000\000\003[\000\000\000\000\002\003\\\003]\001\001\000\000\000\000\003U\0033\003Z\002\000\000\0033\000\000\0034\0035\000\000\000\000\002\003\\\003]\000\000\000\000\000\000\001\001\003[\000\000\002\000\000\0034\0035\003^\002\0034\0035\000\000\000\000\003*\003J\001\001\000\000\002\000\000\000\000\003^\002\003\\\003]\000\000\000\000\000\000\002\002\000\000\003*\002\000\000\0036\003K\000\000\000\000\000\000\003^\000\000\000\000\000\000\000\000\000\000\000\000\003*\000\000\002\002\0036\003M\000\000\000\000\0036\000\000\000\000\000\000\000\000\003+\003*\0032\000\000\000\000\003S\000\000\000\000\000\003^\000\000\000\000\000\000\000\000\000\000\000\000\000\002\003+\0033\0032\000\000\000\000\000\000\000\000\003d\000\000\002\000\000\000\000\000\000\000\000\000\000\003+\000\000\0032\000\000\0033\002\000\000\000\000\0034\0035\001\t\004\001(\000\000\003+\002\0032\000\000\000\000\0033\000\000\002\003*\000\000\000\000\000\000\0034\0035\000\000\000\000\000\000\002\000\000\0033\002\000\000\000\000\001\001\000\000\000\000\0034\0035\003*\002\001\001\000\000\001I\000\000\000\000\001\002\000\000\0036\002\0034\0035\001\003\000\000\003*\000\000\000\000\000\000\001\004\002\000\000\001\001\003+\000\000\0032\0036\003T\003\142\000\000h\000\000\001\012\000\000\000\000\000\000\0045\000\000\001\t\000\000\000\000\0036\0033\001\002\003+\000\000\0032\003T\000\000\001\016\001\017\000\000\006\000\000\000\000\0036\000\000\t\001\001\003+\000\000\0032\0033\0034\0035\000\000h\000\000\001\012\001\020\000\000\000\000\003U\000\000\003Z\001\t\000\000\000\000\0033\000\000\001J\000\000\000\000\000\000\0034\0035\005/\000\000\000\000\002\000\000\003[\003U\nu\003Z\000\000\000\000\002\000\000\002\0034\0035\000\000\000\000h\000\000\001M\002\0036\000\000\000\000\003[\000\000\003\\\003]\001\002\000\000\000\000\002\000\000\001\r\001\016\001\017\000\000\006\001I\000\000\003*\002\0036\002\002\000\000\003\\\003]\003*\000\000\000\000\000\000h\000\000\001\012\001\020\000\000\000\000\0036\000\000\001I\000\000\000\000\000\000\000\000\000\000\001\002\000\000\002\003*\001\r\003^\001\016\001\017\000\000\b\141\000\000\000\000\002\n\129\000\000\001I\000\000\000\000\000\000\001I\003+\000\000\0032\000\000h\003^\001\012\001\020\003+\000\000\0032\000\000\n \000\000\000\000\000\000\000\000\000\000\000\000\0033\003*\000\000\001N\001\014\000\000\000\000\000\000\0033\000\000\003+\001J\0032\000\000\000\000\000\000\000\000\005/\000\000\000\000\0053\000\000\0034\0035\000\000\000\000\001I\000\000\000\000\0033\0034\0035\000\000\001J\000\000h\002\001M\001\r\005/\001I\001\014\001\026\000\000\000\000\001I\002\003+\000\000\0032\000\000\0034\0035\000\000\001J\000\000\000\000h\001J\001M\005/\000\000\000\000\000\000\005/\000\000\0033\0036\000\000\000\000\000\000\000\000\000\000\001I\003T\0036\001\r\000\000h\001O\001M\000\000h\000\000\001M\000\000\000\000\000\000\0034\0035\000\000\000\000\001I\000\000\000\000\000\000\0036\000\000\000\000\000\000\000\000\000\000\000\000\001I\001J\000\000\000\000\000\000\000\000\000\000\005/\000\000\000\000\000\000\001\014\001\026\n%\000\000\001J\000\000\003U\000\000\003Z\001J\005/\000\000\001N\000\000h\005/\001M\000\000\000\000\0036\000\000\000\000\000\000\000\000\n)\003[\000\000\000\000h\0053\001M\000\000\000\000h\001N\001M\000\000\001J\001\014\001\026\000\000\000\000\000\000\005/\000\000\n,\000\000\003\\\003]\n/\000\000\0053\000\000\000\000\000\000\001N\001J\000\000\000\000\001N\000\000h\005/\001M\000\000\000\000\000\000\001J\000\000\000\000\000\000\000\000\0053\005/\000\000\000\000\0053\000\000\000\000\000\000h\000\000\001M\000\000\000\000\000\000\000\000\000\000\001O\000\000\000\000h\003^\001M\000\000\n3\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001N\000\000\000\000\000\000\n6\001O\000\000\000\000\000\000\n:\000\000\000\000\000\000\000\000\001N\000\000\000\000\0053\000\000\001N\000\000\000\000\000\000\000\000\000\000\000\000\001O\000\000\000\000\000\000\001O\0053\000\000\000\000\000\000\000\000\0053\n>\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nA\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0053\000\000\001N\nD\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001O\001N\000\000\000\000\000\000\000\000\000\000\0053\000\000\000\000\000\000\000\000\000\000\000\000\001O\000\000\000\000\000\000\0053\001O\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001O\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001O\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001O"))
  
  and semantic_action =
    [|
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =       (
        let core_type_loc = mklocation _startpos__3_ _endpos__3_ in
        let ct = only_core_type _3 core_type_loc in
        mkcty(Pcty_arrow(Optional _1, ct, _5))
       ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_type_loc in
        mkcty(Pcty_arrow(Labelled _1, ct, _4))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        mkcty(Pcty_arrow(Nolabel, ct, _3))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( mkclass(Pcl_apply(_1, List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( Cl.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                          (
      mkclass(Pcl_constr(_2, []))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _3 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                            (
      mkclass(Pcl_constr(_2, List.rev _3))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( mkclass(Pcl_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_structure) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                                      ( mkclass(Pcl_structure _1)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                                                (
    class_of_let_bindings _1 _3
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _5 in
        let _4 : (string option) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) =       ( mkcf_attrs (Pcf_inherit (_2, _3, _4)) _5 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) =       ( mkcf_attrs (Pcf_val _2) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Location.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) =       ( let (a, b) = _2 in mkcf_attrs (Pcf_method (a, Public, b)) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Location.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) =         ( let (a, b) = _2 in mkcf_attrs (Pcf_method (a, Private, b)) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) =       ( mkcf_attrs (Pcf_constraint _2) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) =       ( mkcf_attrs (Pcf_initializer _3) _4 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) =       ( mkcf_attrs (Pcf_extension _1) _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) =       ( mkcf (Pcf_attribute _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkcty(Pcty_constr (_1, [])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkcty(Pcty_constr (_1, List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_signature) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =       ( mkcty(Pcty_signature _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_signature) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_cty (with_txt _1 "{") (with_txt _3 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =       ( Cty.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =       ( mkcty(Pcty_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos__0_ in
        let _symbolstartpos = _endpos in
            (
    let loc = mklocation _symbolstartpos _endpos in
    mkpat (Ppat_var (mkloc "this" loc))
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) =       ( mkctf_attrs (Pctf_inherit _2) [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) =       ( mkctf_attrs (Pctf_inherit _2) (_3::_4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string * Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) =                                         (
      mkctf_attrs (Pctf_val _2) _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) =          (
          mkctf_attrs (Pctf_method (_3, Private, _2, _5)) _6
         ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) =        (
        mkctf_attrs (Pctf_method (_3, Public, _2, _5)) _6
       ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) =        ( mkctf_attrs (Pctf_constraint _2) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) =        ( mkctf_attrs (Pctf_extension _1) _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) =       ( mkctf(Pctf_attribute _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            ( mkclass(Pcl_constr(_1, [])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                                            ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            ( unclosed_cl (with_txt _1 "{") (with_txt _3 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( mkclass(Pcl_constraint(_2, _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_cl (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_cl (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( mkclass(Pcl_constraint(_4, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Core_type (mktyp(Ptyp_alias(ct, _4)))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (core_type_object) =       (
      match _2, _5 with
      | Core_type ct, Core_type ct2 -> Core_type (mktyp(Ptyp_arrow(Optional _1, ct, ct2)))
      | _ -> syntax_error()
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       (
      match _2, _4 with
      | Core_type ct, Core_type ct2 -> Core_type (mktyp(Ptyp_arrow(Labelled _1, ct, ct2)))
      | _ -> syntax_error()
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (core_type_object) =       (
      match _1, _3 with
            | Core_type ct, Core_type ct2 ->
                Core_type (mktyp(Ptyp_arrow(Nolabel, ct, ct2)))
            | _ -> syntax_error()
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         let (l, o, p) = _1 in mkexp ~loc (Pexp_fun(l, o, p, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( pexp_newtypes _3 _5 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp(Pexp_apply(_1, List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                        (
      let (l,o,p) = _2 in
      mkexp (Pexp_fun(l, o, p, _3))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (string list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( pexp_newtypes _4 _6 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_function(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_match(_2, List.rev _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_try(_2, List.rev _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( syntax_error_exp (mklocation _startpos__4_ _endpos__4_) "Invalid try with") in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            (
      if List.mem (string_of_longident _1.txt)
         built_in_explicit_arity_constructors then
        (* unboxing the inner tupple *)
        match _2 with
          | {pexp_desc=Pexp_tuple [inner]; pexp_loc; pexp_attributes} -> mkexp (Pexp_construct(_1, Some inner))
          | _ -> assert false
      else
        mkExplicitArityTupleExp (Pexp_construct(_1, Some _2))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =     (
      mkexp(Pexp_variant(_1, Some _2))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp(Pexp_ifthenelse(_2, _3, Some _5)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_ifthenelse(_2, _3, None)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_while(_2, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _7 in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.direction_flag) = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp(Pexp_for(_2, _4, _6, _5, _7)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc_colon = mklocation _startpos__2_ _endpos__2_ in
        let loc = mklocation _symbolstartpos _endpos in
        mkexp_cons loc_colon (mkexp ~ghost:true ~loc (Pexp_tuple[_5;_7])) loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : (string) = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( _1 )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : (string) = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( _1 )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : (string) = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( _1 )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : (string) = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( _1 )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "/>" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : (string) = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( _1 )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "+" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "+." )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "-" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "-." )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "*" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "<" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( ">" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "or" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "||" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "&" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "&&" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( ":=" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "+=" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "%" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _1 = _10 in
                                                          ( "<..>" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _20;
            MenhirLib.EngineTypes.startp = _startpos__20_;
            MenhirLib.EngineTypes.endp = _endpos__20_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _10;
              MenhirLib.EngineTypes.startp = _startpos__10_;
              MenhirLib.EngineTypes.endp = _endpos__10_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _20 : unit = Obj.magic _20 in
        let _10 : unit = Obj.magic _10 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _2 = _20 in
          let _1 = _10 in
                                                          ( ">>" )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       (
        mkuminus _1 _2
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       (
        mkuplus _1 _2
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_setfield(_1, _3, _5)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "Array" "set")),
                         [Nolabel,_1; Nolabel,_4; Nolabel,_7])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "String" "set")),
                         [Nolabel,_1; Nolabel,_4; Nolabel,_7])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        bigarray_set ~loc _1 _4 _7
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_setinstvar(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_assert _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_lazy _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                   (
      (* Should use ghost expressions, but not sure how that would work with source maps *)
      (* So ? will become true and : becomes false for now*)
      let loc_question = mklocation _startpos__2_ _endpos__2_ in
      let loc_colon = mklocation _startpos__4_ _endpos__4_ in
      let fauxTruePat =
        Pat.mk ~loc:loc_question (Ppat_construct({txt = Lident "true"; loc = loc_question}, None)) in
      let fauxFalsePat =
        Pat.mk ~loc:loc_colon (Ppat_construct({txt = Lident "false"; loc = loc_colon}, None)) in
      let fauxMatchCaseTrue = Exp.case fauxTruePat _3 in
      let fauxMatchCaseFalse = Exp.case fauxFalsePat _5 in
      mkexp (Pexp_match (_1, [fauxMatchCaseTrue; fauxMatchCaseFalse]))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( Exp.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =                                           (
      mkFunctorThatReturns _1 _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =                                                                         (
      let loc = mklocation _startpos__5_ _endpos__5_ in
      mkFunctorThatReturns _1 (mkmod ~loc (Pmod_constraint(_5, _3)))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkmty(Pmty_functor(_2, Some _4, _6)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =       ( mkmty(Pmty_functor(mkloc "*" (mklocation _startpos__1_ _endpos__1_), None, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( mkFunctorThatReturns _2 _4 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( mkmod (Pmod_apply(_1, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _3 in
        let x0 : unit = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _2 "(") (with_txt _4 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _4 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( Mod.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =                                       (
    (* See note above about why WITH constraints aren't considered
     * non-arrowed.
     * We might just consider unifying the syntax for record extension with
     * module extension/WITH constraints.
     *
     *    mod MyModule = {
     *       ModuleToInclude...
     *    };
     *
     *    let module CreateFactory
     *               (Spec: ContainerSpec)
     *               :{DescriptorFactoryIntf.S with
     *                  type props = Spec.props and type dependencies = Spec.props} =>
     *
     *)
    mkmty(Pmty_with(_1, List.rev _3))
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =                                                      (
    (* below_EQUALGREATER to prevent following shift reduce conflict:
     *  1158: shift/reduce conflict (shift 1285, reduce 75) on EQUALGREATER
     *  state 1158
     *    module_binding_body_functor : functor_args COLON non_arrowed_module_type . EQUALGREATER module_expr  (59)
     *    module_type : non_arrowed_module_type .  (75)
     *
     *    EQUALGREATER  shift 1285
     *    LBRACKETAT  reduce 75
     *    WITH  reduce 75
     *)
    _1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                                               (
    (* Why does this rule cause a conflict with core_type2? It has nothing to do
     * with it.
     *
     * Update: I'm guessing it has something to do with the fact that this isn't
     * parsed correctly because the => is considered part of "type dependenences" :
     *
     *    let module CreateFactory
     *               (Spec: ContainerSpec)
     *               :DescriptorFactoryIntf.S with
     *                  type props = Spec.props and type dependencies = Spec.props =>
     *)
      mkmty(Pmty_functor(_2, Some _4, _7))
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                  (
      (**
       * In OCaml, this is invalid:
       * module MyFunctor: functor MT -> (sig end) = functor MT -> (struct end);;
       *
       * Not only must curried functor args have annotations, but functor
       * annotations must include *names* for each argument in a functor type.
       *
       * module MyFunctor: functor (MT:MT) -> (sig end) = functor (MT:MT) -> (struct end)
       *
       * In Reason, we will parse the functor type:
       *
       *    (AB:MT) -> ReturnSig
       *
       * as in:
       *                   /----------------\
       * module MyFunctor: (A:B) => ReturnSig = functor (C:D) => {}
       *
       * But only for the sake of compatibility with existing OCaml code (the
       * ability to "view" OCaml code in Reason's syntax without loss of
       * information.) Do not write identifiers in functor argument type
       * positions - you wouldn't do it with functions, and they are
       * meaningless in functors.
       *
       *  But for sake of consistency (and for sake of a syntax that truly
       *  unifies functor syntax with function syntax, the following "sugars"
       *  will be parsed (and printed):
       *
       *   A => B => C
       *
       * Is parsed into:
       *
       * functor (_:A) -> functor (_:B) -> C
       *
       * And a dummy "_" is inserted into the parse tree where no name has been
       * provided.
       *
       *   {SomeSig} => {} => {}
       *
       * Is parsed into:
       *
       * (_:SomeSig) => (_:{}) => {}
       *
       *
       *)
      let loc = mklocation _symbolstartpos _endpos in
      mkmty(Pmty_functor(ghloc ~loc "_", Some _1, _3))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =                                          ( _2) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =                        (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =       ( mkmty(Pmty_typeof _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =       ( Mty.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (core_type_object) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Core_type (mktyp(Ptyp_constr(_1, List.rev _2))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _3 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (core_type_object) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Core_type (mktyp(Ptyp_class(_2, List.rev _3))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (core_type_object) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Core_type (Typ.attr ct _2)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (core_type_object) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        match _2 with
        | [] -> raise (Syntaxerr.Error(Syntaxerr.Applicative_path loc))
        | one::[] -> Core_type one
        | moreThanOne -> Core_type (mktyp(Ptyp_tuple(List.rev moreThanOne))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (core_type_object) =       ( Core_type (mktyp(Ptyp_var _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (core_type_object) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Core_type (mktyp(Ptyp_class(_2, []))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       ( Core_type (mktyp(Ptyp_any)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (core_type_object) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Core_type (mktyp(Ptyp_constr(_1, []))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list * object_record) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       (
        let (labels, object_record) = _1 in
        match object_record with
        | Record -> Record_type(only_labels labels)
        | Object_open -> (
          Core_type(mktyp(Ptyp_object (List.map (fun l -> let (label, attr) = l in if label.pld_mutable == Mutable then syntax_error(); label.pld_name.txt, attr, label.pld_type ) labels, Open)))
        )
        | Object_closed -> Core_type(mktyp(Ptyp_object (List.map (fun l -> let (label, attr) = l in if label.pld_mutable == Mutable then syntax_error(); label.pld_name.txt, attr, label.pld_type ) labels, Closed)))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant([_2], Closed, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(List.rev _3, Closed, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(_2 :: List.rev _4, Closed, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field list) = Obj.magic _3 in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(List.rev _3, Open, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant([], Open, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field list) = Obj.magic _3 in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(List.rev _3, Closed, Some []))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label list) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field list) = Obj.magic _3 in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(List.rev _3, Closed, Some (List.rev _5)))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_package _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_extension _1)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                 ( mktyp (Ptyp_var _2), Invariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                 ( mktyp (Ptyp_any), Invariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                 ( mktyp (Ptyp_var _3), Covariant) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                 ( mktyp (Ptyp_any), Covariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                 ( mktyp (Ptyp_var _3), Contravariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                 ( mktyp Ptyp_any, Contravariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =     ( mkpat(Ppat_or(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                                 (
    let core_loc = mklocation _startpos__3_ _endpos__3_ in
    let ct = only_core_type _3 core_loc in
    mkpat(Ppat_constraint(_1, ct))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x0 : (string) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_alias(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( expecting_pat (with_txt _3 "identifier") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
            (
      match is_pattern_list_single_any _2 with
        | Some singleAnyPat ->
            mkpat
              (Ppat_construct(_1, Some singleAnyPat))
        | None ->
          let loc = mklocation _symbolstartpos _endpos in
          let argPattern = simple_pattern_list_to_tuple ~loc _2 in
          mkExplicitArityTuplePat (Ppat_construct(_1, Some argPattern))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =     (
      mkpat (Ppat_variant(_1, Some _2))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _3 in
        let x0 : unit = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Location.raise_errorf ~loc:_2.loc ":: is not supported in Reason, please use [hd, ...tl] instead" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( expecting_pat (with_txt _3 "pattern") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc_coloncolon = mklocation _startpos__2_ _endpos__2_ in
         let loc = mklocation _symbolstartpos _endpos in
         mkpat_cons loc_coloncolon (mkpat ~ghost:true ~loc (Ppat_tuple[_5;_7])) loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = x0;
                        MenhirLib.EngineTypes.startp = _startpos_x0_;
                        MenhirLib.EngineTypes.endp = _endpos_x0_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _8 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "(") (with_txt _8 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_lazy _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_exception _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( Pat.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =           ( only_core_type _1 (mklocation _startpos__1_ _endpos__1_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =           ( mktyp(Ptyp_poly(List.rev _1, only_core_type _3 (mklocation _startpos__3_ _endpos__3_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs *
  string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                                       (
      extension_expression _1 _2
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                  (
      _1
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                                (
      expr_of_let_bindings _1 _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                  (
      let loc = mklocation _symbolstartpos _endpos in
      expr_of_let_bindings _1 @@ ghunit ~loc ()
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                         (
      let expr = _1 in
      let item_attrs = _2 in
      (* Final item in the sequence - just append item attributes to the
       * expression attributes *)
      {expr with pexp_attributes = item_attrs @ expr.pexp_attributes}
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                                                 (
      let item_attrs = _4 in
      mkexp ~attrs:item_attrs (Pexp_letmodule(_2, _3, _6))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _5 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (unit option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                                             (
      let item_attrs = _5 in
      mkexp ~attrs:item_attrs (Pexp_open(_3, _4, _7))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                                              (
      let item_attrs = _2 in
      mkexp ~attrs:item_attrs (Pexp_sequence(_1, _4))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _5 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
                                                                       (
        let loc = mklocation _symbolstartpos _endpos in
        let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
        mksig(Psig_value (Val.mk _2 (only_core_type _4 core_type_loc) ~attrs:_5 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _7 in
        let _6 : (string list) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                                        (
      let loc = mklocation _symbolstartpos _endpos in
      let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
      mksig(Psig_value (Val.mk _2 (only_core_type _4 core_type_loc) ~prim:_6 ~attrs:_7 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.type_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                            (
        let (nonrec_flag, tyl) = _1 in
        mksig(Psig_type (nonrec_flag, List.rev tyl))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                        (
      mksig(Psig_typext _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                               (
      mksig(Psig_exception _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                  (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_module (Md.mk _2 _3 ~attrs:_4 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x1;
            MenhirLib.EngineTypes.startp = _startpos_x1_;
            MenhirLib.EngineTypes.endp = _endpos_x1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _5 in
        let x1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x1 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos__4_ = _endpos_x1_ in
        let _startpos__4_ = _startpos_x1_ in
        let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                           (
      let loc = mklocation _symbolstartpos _endpos in
      let loc_mod = mklocation _startpos__4_ _endpos__4_ in
      mksig(
        Psig_module (
          Md.mk
            _2
            (Mty.alias ~loc:loc_mod _4)
            ~attrs:_5
            ~loc
        )
      )
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                                  (
      mksig(Psig_recmodule (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                           (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_modtype (Mtd.mk _3 ~attrs:_4 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
                                                                             (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_modtype (Mtd.mk _3 ~typ:_5 ~loc ~attrs:_6))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.open_description) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                    (
      mksig(Psig_open _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                     (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_include (Incl.mk _2 ~attrs:_3 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                             (
      mksig(Psig_class (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                                  (
      mksig(Psig_class_type (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                                         (
      mksig(Psig_extension (_1, _2))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                        (
      mksig(Psig_attribute _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp (Pexp_ident _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =              ( mkexp (Pexp_constant _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            (
      mkexp (Pexp_construct (_1, None))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_variant (_1, None)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =         ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                                                          (
      let entireLoc = mklocation _startpos__1_ _endpos__4_ in
      let (seq, ext_opt) = _4 in
      mktailexp_extension entireLoc (_2::seq) ext_opt
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                                    (
      let entireLoc = mklocation _startpos__1_ _endpos__3_ in
      mktailexp_extension entireLoc (_2::[]) None
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        ghexp_constraint loc _2 _3
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( syntax_error_exp _2.loc "SyntaxError in block" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp(Pexp_tuple(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_field(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_open(Fresh, _1, _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_open(Fresh, _1, mkexp(Pexp_tuple(List.rev _4)))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let pat = mkpat (Ppat_var (mkloc "this" loc)) in
        mkexp(Pexp_open (Fresh, _1,
                         mkexp(Pexp_object(Cstr.mk pat [])))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "Array" "get")),
                         [Nolabel,_1; Nolabel,_4])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "String" "get")),
                         [Nolabel,_1; Nolabel,_4])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "[") (with_txt _5 "]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        bigarray_get ~loc _1 _4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (unit) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let msg = "Record construction must have at least one field explicitly set" in
        syntax_error_exp loc msg
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( let (exten, fields) = _2 in mkexp (Pexp_record(fields, exten)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (exten, fields) = _2 in
        mkexp ~loc (Pexp_extension (mkloc ("bs.obj") loc,
               PStr [mkstrexp (mkexp ~loc (Pexp_record(fields, exten))) []]))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_structure) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_object _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_structure) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              ( let (exten, fields) = _4 in
        let loc = mklocation _symbolstartpos _endpos in
        let rec_exp = mkexp ~loc (Pexp_record (fields, exten)) in
        mkexp(Pexp_open(Fresh, _1, rec_exp)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "{") (with_txt _5 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_array(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "[|") (with_txt _4 "|]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_array []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (unit) = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let rec_exp = Exp.mk ~loc ~attrs:[] (Pexp_array(List.rev _4)) in
        mkexp(Pexp_open(Fresh, _1, rec_exp))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _5 : (unit) = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _6 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "[|") (with_txt _6 "|]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( let seq, ext_opt = _2 in
        let loc = mklocation _startpos__2_ _endpos__2_ in
        make_real_exp (mktailexp_extension loc seq ext_opt) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( let seq, ext_opt = _4 in
        let loc = mklocation _startpos__4_ _endpos__4_ in
        let list_exp = make_real_exp (mktailexp_extension loc seq ext_opt) in
        let list_exp = { list_exp with pexp_loc = loc } in
        mkexp (Pexp_open (Fresh, _1, list_exp)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       (
        mkexp(Pexp_apply(mkoperator _1 1, [Nolabel, _2]))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        mkexp(Pexp_apply(mkoperator "!" 1, [Nolabel,_2]))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp (Pexp_new _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_override(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "{<") (with_txt _4 ">}" ) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_override [])) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (unit) = Obj.magic _5 in
        let _4 : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let exp = Exp.mk ~loc ~attrs:[] (Pexp_override(List.rev _4)) in
        mkexp(Pexp_open(Fresh, _1, exp))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _5 : (unit) = Obj.magic _5 in
        let _4 : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _6 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "{<") (with_txt _6 ">}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp(Pexp_send(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfixop _1 (mkoperator_loc _2.txt _2.loc) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_pack _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _3),
                                mktyp ~ghost:true ~loc (Ptyp_package _5))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = x0;
                        MenhirLib.EngineTypes.startp = _startpos_x0_;
                        MenhirLib.EngineTypes.endp = _endpos_x0_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__8_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_open(Fresh, _1,
        mkexp ~loc (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _5),
                                     mktyp ~ghost:true ~loc (Ptyp_package _7))))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _7 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "(") (with_txt _7 ")")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( mkexp (Pexp_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkmod(Pmod_ident _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( mkmod(Pmod_structure(_2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( mkmod(Pmod_constraint(_2, _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( mkmod(Pmod_unpack _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod (Pmod_unpack(
               mkexp ~ghost:true ~loc (Pexp_constraint(_3, mktyp ~ghost:true ~loc (Ptyp_package _5))))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod (Pmod_unpack(
               mkexp ~ghost:true ~loc (Pexp_coerce(_3, Some(mktyp ~ghost:true ~loc (Ptyp_package _5)),
                                      mktyp ~ghost:true ~loc (Ptyp_package _7))))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod (Pmod_unpack(
               mkexp ~ghost:true ~loc (Pexp_coerce(_3, None, mktyp ~ghost:true ~loc (Ptyp_package _5))))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( mkmod (Pmod_structure []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( mkmod (Pmod_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mty (with_txt _1 "(") (with_txt _3 ")")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            ( mkmty(Pmty_ident _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Ast_404.Parsetree.signature) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =       ( mkmty(Pmty_signature _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Ast_404.Parsetree.signature) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mty (with_txt _1 "{") (with_txt _3 "}")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =       ( mkmty(Pmty_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                (
    mkexp (Pexp_tuple(List.rev _1))
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_var _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                              ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_any) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_constant _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_interval (_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_construct(_1, None)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_variant(_1, None)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_type (_2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern)
  list * Migrate_parsetree.OCaml_404.Ast.Asttypes.closed_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( let (fields, closed) = _2 in mkpat(Ppat_record(fields, closed)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern)
  list * Migrate_parsetree.OCaml_404.Ast.Asttypes.closed_flag) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "{") (with_txt _3 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( let seq, ext_opt = _2 in
        let loc_rbracket = mklocation _startpos__2_ _endpos__2_ in
        make_real_pat (mktailpat_extension loc_rbracket (List.rev seq) ext_opt) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern option) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "[") (with_txt _4 "]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_array(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_array []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "[|") (with_txt _4 "|]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_tuple(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_constraint(_2, only_core_type _4 (mklocation _startpos__4_ _endpos__4_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x0 : unit = Obj.magic x0 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( expecting_pat (with_txt _4 "type") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_unpack _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkpat(Ppat_constraint(mkpat ~ghost:true ~loc (Ppat_unpack _3),
                              mktyp ~ghost:true ~loc (Ptyp_package _5))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _6 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "(") (with_txt _6 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( mkpat(Ppat_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs *
  string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                                                                      (
    struct_item_extension _1 _2
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                                                 (
    _1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                  ( val_of_let_bindings _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                               (
      mkstrexp _1 _2
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _7 in
        let _6 : (string list) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                                        (
      let loc = mklocation _symbolstartpos _endpos in
      let core_loc = mklocation _startpos__4_ _endpos__4_ in
      mkstr
        (Pstr_primitive (Val.mk _2 (only_core_type _4 core_loc) ~prim:_6 ~attrs:_7 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.type_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                            (
      let (nonrec_flag, tyl) = _1 in
      mkstr(Pstr_type (nonrec_flag, List.rev tyl))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                        (
      mkstr(Pstr_typext _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                               (
      mkstr(Pstr_exception _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                (
      let (ident, body) = _2 in
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_module (Mb.mk ident body ~attrs:_3 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_binding list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                                   (
      mkstr(Pstr_recmodule(List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _5 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic x0 in
        let _3 : (unit option) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
                                                               (
      let item_attrs = _5 in
      let ident = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_modtype (Mtd.mk ident ~attrs:item_attrs ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _7 in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic x0 in
        let _3 : (unit option) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                 (
      let ident = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_modtype (Mtd.mk ident ~typ:_6 ~attrs:_7 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.open_description) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                    (
      mkstr(Pstr_open _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                             (
      (* Each declaration has their own preceeding post_item_attributes *)
      mkstr(Pstr_class (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                                  (
      (* Each declaration has their own preceeding post_item_attributes *)
      mkstr(Pstr_class_type (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                     (
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_include (Incl.mk _2 ~attrs:_3 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                                         (
    (* No sense in having item_extension_sugar for something that's already an
     * item_extension *)
    mkstr(Pstr_extension (_1, _2))
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =       ( mkstr(Pstr_attribute _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                         ( Ptop_def [_1]) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                         ( raise End_of_file) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                         ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =                                                 ( mktyp (Ptyp_var _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase list) =                                                    ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_404.Parsetree.toplevel_phrase list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase list) =                                                    ( Ptop_def[_1] :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_404.Parsetree.toplevel_phrase list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase list) =                                                    ( _1 :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase list) =                                                    ( [Ptop_def[_1]] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase list) =                                                    ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "+" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "+." ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        [ct]
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__3_ _endpos__3_ in
        let ct = only_core_type _3 core_type_loc in
        ct :: _1
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                             (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                               (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                  (
    let (ident, instance_type, virt, class_type_params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident instance_type ~virt:virt ~params:class_type_params ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (let_binding) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         mklb _2 _3 loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_declaration) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                    (
      let (ident, body) = _2 in
      let loc = mklocation _symbolstartpos _endpos in
      Md.mk ident body ~attrs:_3 ~loc
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_binding) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                     (
    let (ident, body) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Mb.mk ident body ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list * Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_declaration) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                              (
    let (ident, params, constraints, kind, priv, manifest) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.mk ident
      ~params:params ~cstrs:constraints
      ~kind ~priv ?manifest ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                   ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                       ( mkloc (_1 ^ "." ^ _3.txt) (mklocation _symbolstartpos _endpos) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) =                                       ( (_2, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) =                ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) =                          ( _1 :: _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =                                                                    (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _4 in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
       (_2, _4, _1, List.rev _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _4 in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            (
       (_2, _4, _1, List.rev _3)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            (
       (_2, _5, _1, List.rev _3)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                           (
    (_2, _5, _1, List.rev _3)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                                           (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                                                                       (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) =                                             (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                                                         (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                                                (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkclass ~loc (Pcl_constraint(_4, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =                                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field list) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_structure) =     ( Cstr.mk _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        only_core_type _2 core_type_loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = let _endpos = _endpos__0_ in
        let _symbolstartpos = _endpos in
              (
        let loc = mklocation _symbolstartpos _endpos in
        Typ.mk ~loc Ptyp_any
       ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field list) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_signature) =     ( Csig.mk _1 (List.rev _2 )) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) =                                                       (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field list) =                                         ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field list) =                   ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field list) =                                         ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                                                         (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                        (
      (_2, _5, _1, List.rev _3)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) =               ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) = Obj.magic _2 in
        let _1 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) =                                          (
      _2::_1
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string * char option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) =                  ( let (n, m) = _1 in Pconst_integer (n, m) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (char) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) =                  ( Pconst_char _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) =                  ( let (s, d) = _1 in Pconst_string (s, d) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string * char option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) =                  ( let (f, m) = _1 in Pconst_float (f, m) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident "[]" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident "()" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident "false" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident "true" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                      (
    let loc = mklocation _symbolstartpos _endpos in
    (only_core_type _1 (mklocation _startpos__1_ _endpos__1_), only_core_type _3 (mklocation _startpos__3_ _endpos__3_), loc)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =                                            ( only_core_type _1 (mklocation _startpos__1_ _endpos__1_), only_core_type _3 (mklocation _startpos__3_ _endpos__3_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) =                                                                                 (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list) =                                                 ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list) =                                                 ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments) =       (
        match _1 with
        | Core_type ct -> Pcstr_tuple [ct]
        | Record_type rt -> Pcstr_record rt
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Pcstr_tuple (ct :: List.rev _2)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _100 : (string) = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _200;
              MenhirLib.EngineTypes.startp = _startpos__200_;
              MenhirLib.EngineTypes.endp = _endpos__200_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _2 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "[]" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _200;
              MenhirLib.EngineTypes.startp = _startpos__200_;
              MenhirLib.EngineTypes.endp = _endpos__200_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _2 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "()" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "::" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "false" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "true" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _100 : (string) = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _200;
              MenhirLib.EngineTypes.startp = _startpos__200_;
              MenhirLib.EngineTypes.endp = _endpos__200_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _1 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "[]" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _200;
              MenhirLib.EngineTypes.startp = _startpos__200_;
              MenhirLib.EngineTypes.endp = _endpos__200_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _1 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "()" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "::" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "false" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "true" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) =                                                                                 ( List.rev _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) =                                                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) =                                                                                  ( _1 :: List.rev _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) =                                                                              ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) =                                                                              ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =                                           (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =                                             (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        [ct]
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__3_ _endpos__3_ in
        let ct = only_core_type _3 core_type_loc in
        ct :: _1
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (l, o, p) = _1 in
        mkexp ~loc (Pexp_fun(l, o, p, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        pexp_newtypes ~loc _3 _5
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                                                                (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =     (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_loc in
        ghexp_constraint loc _4 (Some ct, None)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.direction_flag) =                                                 ( Upto ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.direction_flag) =                                                 ( Downto ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) =       ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) =       ( [_3; _1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) =       ( _3::_1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) =       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option) =     ( ([], Some _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option) =     ( ([_1], None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option) =     ( let seq, ext = _3 in (_1::seq, ext) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                          ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                 (
      let loc = mklocation _symbolstartpos _endpos in
      ghexp_constraint loc _1 _2
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) =                                            ( (_2, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _100 : (string) = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _200;
              MenhirLib.EngineTypes.startp = _startpos__200_;
              MenhirLib.EngineTypes.endp = _endpos__200_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _1 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "[]" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _200;
              MenhirLib.EngineTypes.startp = _startpos__200_;
              MenhirLib.EngineTypes.endp = _endpos__200_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _1 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "()" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "::" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "false" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "true" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _100 : (string) = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _200;
                MenhirLib.EngineTypes.startp = _startpos__200_;
                MenhirLib.EngineTypes.endp = _endpos__200_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _100;
                  MenhirLib.EngineTypes.startp = _startpos__100_;
                  MenhirLib.EngineTypes.endp = _endpos__100_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "[]" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _200;
                MenhirLib.EngineTypes.startp = _startpos__200_;
                MenhirLib.EngineTypes.endp = _endpos__200_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _100;
                  MenhirLib.EngineTypes.startp = _startpos__100_;
                  MenhirLib.EngineTypes.endp = _endpos__100_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "()" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "::" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "false" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "true" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__1_ in
        let _symbolstartpos = _startpos__1_ in
            (
      let loc = mklocation _symbolstartpos _endpos in
      let lident_loc = mkloc _1 loc in
      let lident_lident_loc = mkloc (Lident _1) loc in
      (lident_loc, mkexp (Pexp_ident lident_lident_loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =      ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =       ( _3::_1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) =                                             ((_2, _3)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_loc in
        mkexp ~loc (Pexp_constraint(_4, ct))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let (l,o,p) = _1 in
       let loc = mklocation _symbolstartpos _endpos in
       mkexp ~ghost:true ~loc (Pexp_fun(l, o, p, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        pexp_newtypes ~loc _3 _5
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option) =  ( mkloc "*" (mklocation _startpos__2_ _endpos__2_), None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( _2, Some _4 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                ( "_" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option) = Obj.magic _2 in
        let _1 : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option)
  list) =       ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type option)
  list) =       ( [ _1 ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =                                                 ( (Pcstr_tuple [],None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments) = Obj.magic _2 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__2_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = let _1 =
                                                         (  )
        in
                                                  ( (_2, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments) = Obj.magic _2 in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = let _1 =
          let _1 = _10 in
                                                         (  )
        in
                                                  ( (_2, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments) = Obj.magic _2 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__2_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = let _1 =
                                                         (  )
        in
                                                        ( (_2,Some (only_core_type _4 (mklocation _startpos__4_ _endpos__4_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _10;
                MenhirLib.EngineTypes.startp = _startpos__10_;
                MenhirLib.EngineTypes.endp = _endpos__10_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments) = Obj.magic _2 in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = let _1 =
          let _1 = _10 in
                                                         (  )
        in
                                                        ( (_2,Some (only_core_type _4 (mklocation _startpos__4_ _endpos__4_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_arguments *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =                                                 ( (Pcstr_tuple [],Some (only_core_type _2 (mklocation _startpos__2_ _endpos__2_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast_404.Parsetree.structure) =                                          ( apply_mapper_chain_to_structure _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Ast_404.Parsetree.signature) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast_404.Parsetree.signature) =                                          ( apply_mapper_chain_to_signature _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) =                                         ( (_2, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension) =                                                   ( (_2, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs *
  string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) =                     (
      ([], _2)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                          (
    let loc = mklocation _symbolstartpos _endpos in
    let body = mktailexp_extension loc _2 None in
    makeFrag loc body
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
    Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
   list ->
   Migrate_parsetree.OCaml_404.Ast.Location.t ->
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) *
  Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                                (
    let (component, _) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    component [
      (Labelled "children", mktailexp_extension loc [] None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (string) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
    Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
   list ->
   Migrate_parsetree.OCaml_404.Ast.Location.t ->
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) *
  Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                  (
    let (component, start) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    (* TODO: Make this tag check simply a warning *)
    let endName = Longident.parse _4 in
    let _ = ensureTagsAreEqual start endName loc in
    let siblings = if List.length _3 > 0 then _3 else [] in
    component [
      (Labelled "children", mktailexp_extension loc siblings None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =               ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =       (
        (* a=?b *)
        [(Optional _1, _3)] @ _4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =       (
        (* a=b *)
        [(Labelled _1, _3)] @ _4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =       (
        (* a (punning) *)
        let loc_lident = mklocation _startpos__1_ _endpos__1_ in
        [(Labelled _1, mkexp (Pexp_ident {txt = Lident _1; loc = loc_lident}) ~loc:loc_lident)] @ _2
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
    Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
   list ->
   Migrate_parsetree.OCaml_404.Ast.Location.t ->
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) *
  Migrate_parsetree.OCaml_404.Ast.Longident.t) =                             (
    let name = Longident.parse _1 in
    (jsx_component name _2, name)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
    Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
   list ->
   Migrate_parsetree.OCaml_404.Ast.Location.t ->
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) *
  Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                 (
    (jsx_component _1 _2, _1)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                      (
    let loc = mklocation _symbolstartpos _endpos in
    let body = mktailexp_extension loc _2 None in
    makeFrag loc body
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
    Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
   list ->
   Migrate_parsetree.OCaml_404.Ast.Location.t ->
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) *
  Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                                                     (
    let (component, _) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    component [
      (Labelled "children", mktailexp_extension loc [] None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (string) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
    Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
   list ->
   Migrate_parsetree.OCaml_404.Ast.Location.t ->
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) *
  Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                                       (
    let (component, start) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    (* TODO: Make this tag check simply a warning *)
    let endName = Longident.parse _4 in
    let _ = ensureTagsAreEqual start endName loc in
    let siblings = if List.length _3 > 0 then _3 else [] in
    component [
      (Labelled "children", mktailexp_extension loc siblings None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              (
       let loc = mklocation _symbolstartpos _endpos in
       let ct = mkct _2 in
       (Type.field _2 ct ~mut:_1 ~loc, _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              (
       let loc = mklocation _symbolstartpos _endpos in
       (Type.field _2 _5 ~mut:_1 ~attrs:_6 ~loc, _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list) =                                                  ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__1_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        (Labelled _1, mkexp (Pexp_ident(mkloc (Lident _1) loc)) ~loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( (Labelled _1, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
       let loc = mklocation _symbolstartpos _endpos in
       (Optional (String.concat "" (Longident.flatten _3)), mkexp (Pexp_ident(mkloc _3 loc)) ~loc)
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( (Optional _1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( (Nolabel, _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       (
        let loc = mklocation _startpos__1_ _endpos__1_ in
        (Labelled _1, None, mkpat(Ppat_var (mkloc _1 loc)) ~loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        (Optional _1, None, mkpat(Ppat_var (mkloc _1 loc)) ~loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        (Optional _1, Some _3, mkpat(Ppat_var (mkloc _1 loc)) ~loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( (Labelled _1, None, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( (Optional _1, None, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( (Optional _1, Some _4, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =       ( (Nolabel, None, _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        (_1, exp_of_label _1)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =               ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =                                   ( _1 :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =                     ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =      ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =       ( _1::_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( (_1,_3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        (_1, pat_of_label _1)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern)
  list * Migrate_parsetree.OCaml_404.Ast.Asttypes.closed_flag) =                 ( [_1], Closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern)
  list * Migrate_parsetree.OCaml_404.Ast.Asttypes.closed_flag) =                       ( [_1], Closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (unit) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern)
  list * Migrate_parsetree.OCaml_404.Ast.Asttypes.closed_flag) =                                            ( [_1], Open ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern)
  list * Migrate_parsetree.OCaml_404.Ast.Asttypes.closed_flag) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern)
  list * Migrate_parsetree.OCaml_404.Ast.Asttypes.closed_flag) =       ( let (fields, closed) = _3 in _1 :: fields, closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case) =                                        (
      Exp.case _1 _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case) =       ( Exp.case _1 ~guard:_3 _5 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case) =       ( Exp.case _1 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case) =       ( Exp.case _1 ~guard:_3 _5 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case list) =                            ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case list) =                                                    ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case list) =                                             ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.case list) =                                                                                      ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =               (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) *
  Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (let_bindings) = let _endpos = _endpos__1_ in
        let _symbolstartpos = _startpos__1_ in
                             (
    let (rec_flag, body, item_attrs) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    mklbs ([], None) rec_flag (mklb body item_attrs loc) loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) *
  Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs *
  string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (let_bindings) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                                  (
      let (rec_flag, body, item_attrs) = _2 in
      let (ext_attrs, ext_id) = _1 in
      let loc = mklocation _symbolstartpos _endpos in
      mklbs (ext_attrs, Some ext_id) rec_flag (mklb body item_attrs loc) loc
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
              ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        (_1, ghexp_constraint loc _4 _2)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
              ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
        in
              ( (_1, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = x0;
                      MenhirLib.EngineTypes.startp = _startpos_x0_;
                      MenhirLib.EngineTypes.endp = _endpos_x0_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__7_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
              ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__5_ _endpos__5_ in
        (mkpat ~ghost:true ~loc (Ppat_constraint(_1, mktyp ~ghost:true (Ptyp_poly(List.rev _3, only_core_type _5 core_loc)))), _7)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = x0;
                        MenhirLib.EngineTypes.startp = _startpos_x0_;
                        MenhirLib.EngineTypes.endp = _endpos_x0_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _8 in
        let _7 : unit = Obj.magic _7 in
        let _6 : (core_type_object) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (string list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__8_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
              ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
             (
       let core_loc = mklocation _startpos__6_ _endpos__6_ in
       let exp, poly = wrap_type_annotation _4 (only_core_type _6 core_loc) _8 in
       let loc = mklocation _symbolstartpos _endpos in
       (mkpat ~ghost:true ~loc (Ppat_constraint(_1, poly)), exp)
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =       ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__3_ _endpos__3_ in
        (mkpat ~loc (Ppat_constraint(_1, only_core_type _3 core_loc)), _5)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) *
  Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) =                                                        (
      (_2, _3, _4)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (let_bindings) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (let_binding) = Obj.magic _2 in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (let_bindings) =                                                 ( addlb _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string list) =                                       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string list) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (string list) =                                       ( _1 :: _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                 (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    [Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc]
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) =                                                   (
    _2::_1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                 (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    [Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc]
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) =                                                   (
    _2 :: _1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                           (
    let (ident, instance_type, virt, class_type_params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    [Ci.mk ident instance_type ~virt:virt ~params:class_type_params ~attrs:_4 ~loc]
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_infos list) =                                                             (
    _2::_1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_declaration list) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                   (
      let (ident, body) = _3 in
      let loc = mklocation _symbolstartpos _endpos in
      [Md.mk ident body ~attrs:_4 ~loc]
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_declaration) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_declaration list) =                                                              (
      _2::_1
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_binding list) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                    (
    let (ident, body) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    [Mb.mk ident body ~attrs:_4 ~loc]
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_binding) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_binding list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_binding list) =                                                                (
    _2::_1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list * Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.type_declaration list) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                          (
   let (ident, params, constraints, kind, priv, manifest) = _3 in
   let loc = mklocation _symbolstartpos _endpos in
   let ty = Type.mk ident ~params:params ~cstrs:constraints
            ~kind ~priv ?manifest ~attrs:_4 ~loc
   in
   (_2, [ty])
   ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_declaration) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.type_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.type_declaration list) =                                                (
   let (nonrec_flag, tyl) = _1 in
   (nonrec_flag, _2 :: tyl)
   ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos_x_ _endpos_x_ then
          _startpos_x_
        else
          _endpos in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type_field) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos_x_ _endpos_x_ then
          _startpos_x_
        else
          _endpos in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with psig_loc = {x.psig_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (core_type_object) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (core_type_object) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (core_type_object) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (core_type_object) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (core_type_object) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (core_type_object) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (core_type_object) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (core_type_object) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Location.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( if _1 = Override then syntax_error ();
        _3, Cfk_virtual _5 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Location.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              ( _2,
        Cfk_concrete (_1, let loc = mklocation _symbolstartpos _endpos in mkexp ~ghost:true ~loc (Pexp_poly (_3, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Location.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              ( _2,
        Cfk_concrete (_1, let loc = mklocation _symbolstartpos _endpos in mkexp ~ghost:true ~loc (Pexp_poly(_6, Some _4))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Location.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              ( _2,
        Cfk_concrete (_1, let loc = mklocation _symbolstartpos _endpos in mkexp ~ghost:true ~loc (Pexp_poly(_4, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _9;
          MenhirLib.EngineTypes.startp = _startpos__9_;
          MenhirLib.EngineTypes.endp = _endpos__9_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _8;
            MenhirLib.EngineTypes.startp = _startpos__8_;
            MenhirLib.EngineTypes.endp = _endpos__8_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _7;
              MenhirLib.EngineTypes.startp = _startpos__7_;
              MenhirLib.EngineTypes.endp = _endpos__7_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _6;
                MenhirLib.EngineTypes.startp = _startpos__6_;
                MenhirLib.EngineTypes.endp = _endpos__6_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _5;
                  MenhirLib.EngineTypes.startp = _startpos__5_;
                  MenhirLib.EngineTypes.endp = _endpos__5_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _4;
                    MenhirLib.EngineTypes.startp = _startpos__4_;
                    MenhirLib.EngineTypes.endp = _endpos__4_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _3;
                      MenhirLib.EngineTypes.startp = _startpos__3_;
                      MenhirLib.EngineTypes.endp = _endpos__3_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.semv = x0;
                        MenhirLib.EngineTypes.startp = _startpos_x0_;
                        MenhirLib.EngineTypes.endp = _endpos_x0_;
                        MenhirLib.EngineTypes.next = {
                          MenhirLib.EngineTypes.state = _menhir_s;
                          MenhirLib.EngineTypes.semv = _1;
                          MenhirLib.EngineTypes.startp = _startpos__1_;
                          MenhirLib.EngineTypes.endp = _endpos__1_;
                          MenhirLib.EngineTypes.next = _menhir_stack;
                        };
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _9 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _9 in
        let _8 : unit = Obj.magic _8 in
        let _7 : (core_type_object) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (string list) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__9_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Location.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__9_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              (
        let core_type_loc = mklocation _startpos__7_ _endpos__7_ in
        (* For non, methods we'd create a pattern binding:
           ((Ppat_constraint(mkpatvar ..., Ptyp_poly (typeVars, poly_type_varified))),
            exp_with_newtypes_constrained_by_non_varified)

           For methods, we create:
           Pexp_poly (Pexp_constraint (methodFunWithNewtypes, non_varified), Some (Ptyp_poly newTypes varified))
         *)
        let (exp_with_newtypes_constrained_by_non_varified, poly_type_varified) =
          wrap_type_annotation _5 (only_core_type _7 core_type_loc) _9 in
        (
          _2,
          Cfk_concrete (
            _1,
            let loc = mklocation _symbolstartpos _endpos in
            mkexp ~ghost:true ~loc (Pexp_poly(exp_with_newtypes_constrained_by_non_varified, Some poly_type_varified))
          )
        )
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
                                                                          (
     lapply ( Ldot(_1, _3)) _5 _symbolstartpos _endpos
   ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                      ( lapply _1 _3 _symbolstartpos _endpos ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                    ( lapply (Lident(_1)) _3 _symbolstartpos _endpos ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =              ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =                              ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod ~loc (Pmod_constraint(_4, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =                                                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                             ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag) =                                                 ( Immutable ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag) =                                                 ( Mutable ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) =                                                 ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label list) =                                                 ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_type) =                                                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =     ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =     ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =                                                                      (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =                                                                                         (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =                                                                                 (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        [ct]
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_type_loc in
        ct :: _1
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (s, d) = _1 in
        let lident_lident_loc = mkloc (Lident s) loc in
        (lident_lident_loc, _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                              (
      (_1, _2)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag) =                                                 ( Recursive ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag) =                                                 ( Nonrecursive ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list * object_record) =       ( syntax_error () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list * object_record) =       ( [], Object_closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list * object_record) =       ( [], Object_open ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list * object_record) =       ( List.rev _2, Record ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list * object_record) =       ( List.rev _3, Object_closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list * object_record) =       ( List.rev _3, Object_open ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _4 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.open_description) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        Opn.mk _3 ~override:_2 ~attrs:_4 ~loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "!" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "/>" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "+" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "+." )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "-" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "-." )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "*" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "<" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( ">" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "or" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "||" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "&" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "&&" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( ":=" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "+=" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "%" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "<..>" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _20;
          MenhirLib.EngineTypes.startp = _startpos__20_;
          MenhirLib.EngineTypes.endp = _endpos__20_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _20 : unit = Obj.magic _20 in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__20_ in
        let _v : (string) = let _1 =
          let _2 = _20 in
          let _1 = _10 in
                                                          ( ">>" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (bool) =                                                 ( true ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (bool) =                                                 ( false ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (unit) =                  ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) =              ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit option) =     ( None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : unit = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (unit option) =     ( Some x ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit option) =     ( None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : unit = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (unit option) =     ( Some x ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) =                                                                          ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) = Obj.magic _2 in
        let _1 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) =                                                                          ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) =                                    ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) =                                    ( List.rev _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
                                                                                        (
      let first = fst x in
      let second = snd x in
      ({
        first with ptyp_loc = {
        first.ptyp_loc with
        loc_start = _symbolstartpos;
        loc_end = _endpos}}, second )
) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) =                                                 ( Fresh ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) =                                                 ( Override ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                  ( (_1, []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type)
  list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.package_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                          ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
        let ct = only_core_type _4 core_type_loc in
        (_2, ct)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type)
  list) =                       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type)
  list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type)
  list) =                                              ( _1::_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (string option) =           ( Some _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (string option) =           ( None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast_404.Parsetree.core_type) =       (
        let core_loc = mklocation _startpos__1_ _endpos__1_ in
        apply_mapper_chain_to_type (only_core_type _1 core_loc) (default_mapper_chain ())
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast_404.Parsetree.expression) =              ( apply_mapper_chain_to_expr _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast_404.Parsetree.pattern) =                 ( apply_mapper_chain_to_pattern _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) =                                                   ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern option) =                                                 ( [_1], None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern option) =                                                 ( (_1, Some _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern option) =                                                 ( (_3 :: _1, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                                                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) =     ( _3::_1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) =     ( [_3; _1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                                (
  _2
) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.payload) =               ( PStr _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.payload) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_type_loc in
        PTyp ct
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.payload) =                      ( PPat (_2, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.payload) =                                ( PPat (_2, Some _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =                                          (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) =                ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) =                                         ( _1 :: _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.lid *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) =                                   (
      let loc = mklocation _startpos__1_ _endpos__1_ in
      let lident_lident_loc = mkloc (Lident _1) loc in
      (lident_lident_loc, _2)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.lid *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                     ((_1, _2)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string list) =                                                 ( [fst _1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string list) = Obj.magic _2 in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (string list) =                                                 ( fst _1 :: _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag) =                                                 ( Public ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag) =                                             ( Private ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) =                  ( Concrete ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) =             ( Virtual ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag) =                                                 ( Nonrecursive ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag) =                                                 ( Recursive ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =                                                            ( (Some _2, _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =                                                            ( (None, _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =                                                                       ( (Some _2, _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression option *
  (Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =                                                                       ( (None, _1)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Rinherit ct
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field list) =                                                 ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field list) =                           ([]) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field list) =                           ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field list) =                                                     ( _1::_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                                                         (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                                                                 (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) =       (
        let ext = _2 in
        {ext with pext_attributes = ext.pext_attributes @ _3}
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) =                                                           ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) =       ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _8 in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) = Obj.magic _7 in
        let _6 : (unit) = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.lid *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_extension) =   (
    if _2 <> Recursive then not_expecting _startpos__2_ _endpos__2_ "nonrec flag";
    let (potentially_long_ident, optional_type_parameters) = _3 in
    Te.mk potentially_long_ident (List.rev _7)
          ~params:optional_type_parameters ~priv:_5 ~attrs:_8
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast_404.Parsetree.signature) =                          ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_404.Parsetree.signature) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Ast_404.Parsetree.signature) =                                   ( _1 :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.signature_item) =                                                    ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) =                  ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string * char option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) =                  ( let (n, m) = _2 in Pconst_integer("-" ^ n, m) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string * char option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) =                  ( let (f, m) = _2 in Pconst_float("-" ^ f, m) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string * char option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) =                  ( let (n, m) = _2 in Pconst_integer (n, m) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string * char option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constant) =                  ( let (f, m) = _2 in Pconst_float(f, m) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) =             ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) =                                 ( [_1] @ _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Asttypes.arg_label *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =       ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_expr) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.module_type) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) =       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression list) =       ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) =                                                                                                  (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                                                    (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) =     ( _2::_1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern list) =     ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.pattern) =                                                                        (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "and" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "as" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "assert" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =           ( "begin" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =           ( "class" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                ( "constraint" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "do" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "done" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "downto" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "else" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "end" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =               ( "exception" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =              ( "external" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =           ( "false" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "for" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "fun" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =              ( "function" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "functor" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "if" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "in" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "include" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "inherit" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                 ( "initializer" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "lazy" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "let" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "switch" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "module" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "mutable" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "new" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "nonrec" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "object" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "of" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "open" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "or" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "private" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "rec" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "sig" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "struct" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "then" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "to" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "true" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "try" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "type" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "val" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "virtual" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "when" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =           ( "while" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "with" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) =       (
        let ext = _2 in
        {ext with pext_attributes = ext.pext_attributes @ _3}
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) =       (
        let ext = _2 in
        {ext with pext_attributes = ext.pext_attributes @ _3}
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) =                                                           ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) =                                                           ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) =       ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) =       ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.attrs) = Obj.magic _8 in
        let _7 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.extension_constructor list) = Obj.magic _7 in
        let _6 : (unit) = Obj.magic _6 in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.lid *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.rec_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_extension) =   (
    if _2 <> Recursive then not_expecting _startpos__2_ _endpos__2_ "nonrec flag";
    let (potentially_long_ident, optional_type_parameters) = _3 in
    Te.mk potentially_long_ident (List.rev _7)
          ~params:optional_type_parameters ~priv:_5 ~attrs:_8
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (s, d) = _1 in
        let lident_lident_loc = mkloc (Lident s) loc in
        (lident_lident_loc, _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = let _endpos = _endpos__1_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (s, d) = _1 in
        let lident_lident_loc = mkloc (Lident s) loc in
        (lident_lident_loc, mkexp (Pexp_ident lident_lident_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =                          ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =                                                         ( _1 :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =                                ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =     ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t
  Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Migrate_parsetree.OCaml_404.Ast.Longident.t
   Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.expression)
  list) =     ( _1::_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) =                 ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                    (
    let menhirError = Syntax_util.findMenhirErrorMessage _1.loc in
    match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _2
      | _ -> (syntax_error_str _1.loc "Invalid statement") :: _2
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                         (
    let menhirError = Syntax_util.findMenhirErrorMessage _1.loc in
    match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _3
      | _ -> (syntax_error_str _1.loc "Invalid statement") :: _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) =                    ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                   (
    let menhirError = Syntax_util.findMenhirErrorMessage _1.loc in
    match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _3
      | _ -> (syntax_error_str _1.loc "Statement has to end with a semicolon") :: _3
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure) =                                   (
      let effective_loc = mklocation _startpos__1_ _endpos__2_ in
      set_structure_item_location _1 effective_loc :: _3
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                                                    (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.structure_item) =                                                                   (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "-" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "-." ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type list) = Obj.magic _4 in
        let _3 : (bool) = Obj.magic _3 in
        let _2 : (unit option) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field) =       ( Rtag (_1, _5, _3, List.rev _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.row_field) =       ( Rtag (_1, _2, true, []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_none) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string * string option) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_string (fst _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string * char option) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                 ( let (n, m) = _3 in
                                  Ptop_dir(_2, Pdir_int (n, m)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_ident _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_ident _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_bool false) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_bool true) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Ast_404.Parsetree.toplevel_phrase) =                                   (apply_mapper_chain_to_toplevel_phrase _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =                                                 ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =                                                 ( (None, Some (only_core_type _2 (mklocation _startpos__2_ _endpos__2_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =                                           ( (Some (only_core_type _1 (mklocation _startpos__1_ _endpos__1_)), None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =                                           ( (Some (only_core_type _1 (mklocation _startpos__1_ _endpos__1_)), Some (only_core_type _3 (mklocation _startpos__3_ _endpos__3_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list * Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Location.raise_errorf ~loc:_1.loc "A type's name need to begin with a lower-case letter or _" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list) = Obj.magic _4 in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _3 in
        let _2 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Ast_helper.str *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list *
  (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list * Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( let (kind, priv, manifest) = _3 in
        (_1, _2, List.rev _4, kind, priv, manifest)
       ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =       ( (Ptype_abstract, Public, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =       (
      match _2 with
      | Core_type ct -> (Ptype_abstract, Public, Some ct)
      | Record_type rt -> (Ptype_record rt, Public, None)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =                         (
      match _3 with
      | Core_type ct -> (Ptype_abstract, Private, Some ct)
      | Record_type rt -> (Ptype_record rt, Private, None)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =       ( (Ptype_variant(_2),  Public, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =       ( (Ptype_variant(_3), Private, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =       ( (Ptype_open, Public, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_variant(_4), Public,  Some (only_core_type _2 core_type_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.constructor_declaration list) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_variant(_5), Private, Some (only_core_type _2 core_type_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_open, Public, Some (only_core_type _2 core_type_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (unit) = Obj.magic _7 in
        let _6 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.label_declaration *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.attributes)
  list) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.type_kind *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_record(List.rev (only_labels _6)), _4, Some (only_core_type _2 core_type_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                   ( _2, _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =                                                  (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                 ( Invariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                 ( Covariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.variance) =                                                 ( Contravariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label list) =                                                 ( [_2] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.label list) =                                                 ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.toplevel_phrase list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Ast_404.Parsetree.toplevel_phrase list) =                     (apply_mapper_chain_to_use_file _1 (default_mapper_chain ())) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (string) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (string) =                                                 ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (core_type_object) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let x0 : (string) = Obj.magic x0 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos__4_ = _endpos_x0_ in
        let _startpos__4_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
                                                                        (
      let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
      if _1 = Override
      then not_expecting _symbolstartpos _endpos "members marked virtual may not also be marked overridden"
      else _4, Mutable, Cfk_virtual (only_core_type _6 core_type_loc)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : unit = Obj.magic _7 in
        let _6 : (core_type_object) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (string) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) =       ( not_expecting _startpos__7_ _endpos__7_ "not expecting equal - cannot specify value for virtual val" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        let core_type_loc = mklocation _startpos__5_ _endpos__5_ in
        _3, _2, Cfk_virtual (only_core_type _5 core_type_loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) =       ( not_expecting _startpos__6_ _endpos__6_ "not expecting equal - cannot specify value for virtual val" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( _3, _2, Cfk_concrete (_1, _5) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.expression) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type option) = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (string Migrate_parsetree.OCaml_404.Ast.Asttypes.loc *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.class_field_kind) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__3_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          if Pervasives.(!=) _startpos__2_ _endpos__2_ then
            _startpos__2_
          else
            _startpos__3_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let e = ghexp_constraint loc _6 _4 in
        _3, _2, Cfk_concrete (_1, e)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string * Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =       ( _3, _2, Virtual, only_core_type _5 (mklocation _startpos__5_ _endpos__5_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string * Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =       ( _3, Mutable, _2, only_core_type _5 (mklocation _startpos__5_ _endpos__5_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (string * Migrate_parsetree.OCaml_404.Ast.Asttypes.mutable_flag *
  Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag *
  Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type) =       ( _1, Immutable, Concrete, only_core_type _3 (mklocation _startpos__3_ _endpos__3_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) =                                                 ( Concrete ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.virtual_flag) =                                                 ( Virtual ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Ast_helper.loc)
  list) = Obj.magic _6 in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : (Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag) = Obj.magic _4 in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         let core_type_loc = mklocation _startpos__5_ _endpos__5_ in
         Pwith_type
          (_2,
           (Type.mk {_2 with txt=Longident.last _2.txt}
              ~params:_3
              ~cstrs:(List.rev _6)
              ~manifest:(only_core_type _5 core_type_loc)
              ~priv:_4
              ~loc)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Migrate_parsetree.OCaml_404.Ast.Parsetree.core_type *
   Migrate_parsetree.OCaml_404.Ast.Asttypes.variance)
  list) = Obj.magic _3 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos__2_ = _endpos_x0_ in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
            (
      let last = (
        match _2.txt with
            | Lident s -> s
            | _ -> not_expecting _startpos__2_ _endpos__2_ "Long type identifier"
      ) in
     let loc = mklocation _symbolstartpos _endpos in
     let core_type_loc = mklocation _startpos__5_ _endpos__5_ in
      Pwith_typesubst
          (Type.mk {_2 with txt=last}
             ~params:_3
             ~manifest:(only_core_type _5 core_type_loc)
             ~loc)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x1 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Pwith_module (_2, _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : (Migrate_parsetree.OCaml_404.Ast.Longident.t) = Obj.magic x1 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Pwith_modsubst (_2, _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Parsetree.with_constraint list) =                                                 ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag) =                    ( Public ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Migrate_parsetree.OCaml_404.Ast.Asttypes.private_flag) =                ( Private ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
    |]
  
  and trace =
    None
  
end

module MenhirInterpreter = struct
  
  module ET = MenhirLib.TableInterpreter.MakeEngineTable (Tables)
  
  module TI = MenhirLib.Engine.Make (ET)
  
  include TI
  
end

let use_file =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2890 lexer lexbuf) : (Ast_404.Parsetree.toplevel_phrase list))

and toplevel_phrase =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2714 lexer lexbuf) : (Ast_404.Parsetree.toplevel_phrase))

and parse_pattern =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2710 lexer lexbuf) : (Ast_404.Parsetree.pattern))

and parse_expression =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2706 lexer lexbuf) : (Ast_404.Parsetree.expression))

and parse_core_type =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2702 lexer lexbuf) : (Ast_404.Parsetree.core_type))

and interface =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2695 lexer lexbuf) : (Ast_404.Parsetree.signature))

and implementation =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 0 lexer lexbuf) : (Ast_404.Parsetree.structure))

module Incremental = struct
  
  let use_file =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2890 initial_position) : (Ast_404.Parsetree.toplevel_phrase list) MenhirInterpreter.checkpoint)
  
  and toplevel_phrase =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2714 initial_position) : (Ast_404.Parsetree.toplevel_phrase) MenhirInterpreter.checkpoint)
  
  and parse_pattern =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2710 initial_position) : (Ast_404.Parsetree.pattern) MenhirInterpreter.checkpoint)
  
  and parse_expression =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2706 initial_position) : (Ast_404.Parsetree.expression) MenhirInterpreter.checkpoint)
  
  and parse_core_type =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2702 initial_position) : (Ast_404.Parsetree.core_type) MenhirInterpreter.checkpoint)
  
  and interface =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2695 initial_position) : (Ast_404.Parsetree.signature) MenhirInterpreter.checkpoint)
  
  and implementation =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 0 initial_position) : (Ast_404.Parsetree.structure) MenhirInterpreter.checkpoint)
  
end
  
  


end
module Reason_lexer
= struct
#1 "reason_lexer.ml"
# 52 "src/reason_lexer.mll"
 
open Lexing
open Misc
open Reason_parser

type error =
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment of Location.t
  | Unterminated_string
  | Unterminated_string_in_comment of Location.t * Location.t
  | Keyword_as_label of string
  | Literal_overflow of string
  | Invalid_literal of string
;;

exception Error of error * Location.t;;

(* The table of keywords *)

let keyword_table =
  create_hashtable 149 [
    "and", AND;
    "as", AS;
    "assert", ASSERT;
    "begin", BEGIN;
    "class", CLASS;
    "constraint", CONSTRAINT;
    "do", DO;
    "done", DONE;
    "downto", DOWNTO;
    "else", ELSE;
    "end", END;
    "exception", EXCEPTION;
    "external", EXTERNAL;
    "false", FALSE;
    "for", FOR;
    "fun", FUN;
    "function", FUNCTION;
    "functor", FUNCTOR;
    "if", IF;
    "in", IN;
    "include", INCLUDE;
    "inherit", INHERIT;
    "initializer", INITIALIZER;
    "lazy", LAZY;
    "let", LET;
    "switch", SWITCH;
    "module", MODULE;
    "pub", PUB;
    "mutable", MUTABLE;
    "new", NEW;
    "nonrec", NONREC;
    "object", OBJECT;
    "of", OF;
    "open", OPEN;
    "or", OR;
(*  "parser", PARSER; *)
    "pri", PRI;
    "rec", REC;
    "sig", SIG;
    "struct", STRUCT;
    "then", THEN;
    "to", TO;
    "true", TRUE;
    "try", TRY;
    "type", TYPE;
    "val", VAL;
    "virtual", VIRTUAL;
    "when", WHEN;
    "while", WHILE;
    "with", WITH;

    "mod", INFIXOP3("mod");
    "land", INFIXOP3("land");
    "lor", INFIXOP3("lor");
    "lxor", INFIXOP3("lxor");
    "lsl", INFIXOP4("lsl");
    "lsr", INFIXOP4("lsr");
    "asr", INFIXOP4("asr")
]

(* To buffer string literals *)

let initial_string_buffer = Bytes.create 256
let string_buff = ref initial_string_buffer
let string_index = ref 0

let reset_string_buffer () =
  string_buff := initial_string_buffer;
  string_index := 0

let store_string_char c =
  if !string_index >= Bytes.length !string_buff then begin
    let new_buff = Bytes.create (Bytes.length (!string_buff) * 2) in
    Bytes.blit !string_buff 0 new_buff 0 (Bytes.length !string_buff);
    string_buff := new_buff
  end;
  Bytes.unsafe_set !string_buff !string_index c;
  incr string_index

let store_string s =
  for i = 0 to String.length s - 1 do
    store_string_char s.[i];
  done

let store_lexeme lexbuf =
  store_string (Lexing.lexeme lexbuf)

let get_stored_string () =
  let s = Bytes.sub_string !string_buff 0 !string_index in
  string_buff := initial_string_buffer;
  s

(* To store the position of the beginning of a string and comment *)
let string_start_loc = ref Location.none;;
let comment_start_loc = ref [];;
let in_comment () = !comment_start_loc <> [];;
let is_in_string = ref false
let in_string () = !is_in_string
let print_warnings = ref true

(* To translate escape sequences *)

let char_for_backslash = function
  | 'n' -> '\010'
  | 'r' -> '\013'
  | 'b' -> '\008'
  | 't' -> '\009'
  | c   -> c

let char_for_decimal_code lexbuf i =
  let c = 100 * (Char.code(Lexing.lexeme_char lexbuf i) - 48) +
           10 * (Char.code(Lexing.lexeme_char lexbuf (i+1)) - 48) +
                (Char.code(Lexing.lexeme_char lexbuf (i+2)) - 48) in
  if (c < 0 || c > 255) then
    if in_comment ()
    then 'x'
    else raise (Error(Illegal_escape (Lexing.lexeme lexbuf),
                      Location.curr lexbuf))
  else Char.chr c

let char_for_hexadecimal_code lexbuf i =
  let d1 = Char.code (Lexing.lexeme_char lexbuf i) in
  let val1 = if d1 >= 97 then d1 - 87
             else if d1 >= 65 then d1 - 55
             else d1 - 48
  in
  let d2 = Char.code (Lexing.lexeme_char lexbuf (i+1)) in
  let val2 = if d2 >= 97 then d2 - 87
             else if d2 >= 65 then d2 - 55
             else d2 - 48
  in
  Char.chr (val1 * 16 + val2)

(* To convert integer literals, allowing max_int + 1 (PR#4210) *)

let cvt_int_literal s =
  - int_of_string ("-" ^ s)
let cvt_int32_literal s =
  Int32.neg (Int32.of_string ("-" ^ String.sub s 0 (String.length s - 1)))
let cvt_int64_literal s =
  Int64.neg (Int64.of_string ("-" ^ String.sub s 0 (String.length s - 1)))
let cvt_nativeint_literal s =
  Nativeint.neg (Nativeint.of_string ("-" ^ String.sub s 0
                                                       (String.length s - 1)))

(* Remove underscores from float literals *)

let remove_underscores s =
  let l = String.length s in
  let b = Bytes.create l in
  let rec remove src dst =
    if src >= l then
      if dst >= l then s else Bytes.sub_string b 0 dst
    else
      match s.[src] with
        '_' -> remove (src + 1) dst
      |  c  -> Bytes.set b dst c; remove (src + 1) (dst + 1)
  in remove 0 0

(* Update the current location with file name and line number. *)

let update_loc lexbuf file line absolute chars =
  let pos = lexbuf.lex_curr_p in
  let new_file = match file with
                 | None -> pos.pos_fname
                 | Some s -> s
  in
  lexbuf.lex_curr_p <- { pos with
    pos_fname = new_file;
    pos_lnum = if absolute then line else pos.pos_lnum + line;
    pos_bol = pos.pos_cnum - chars;
  }
;;

let preprocessor = ref None

(* Warn about Latin-1 characters used in idents *)

let warn_latin1 lexbuf =
  Location.prerr_warning (Location.curr lexbuf)
    (Warnings.Deprecated "ISO-Latin1 characters in identifiers")
;;

(* Error report *)

open Format

let report_error ppf = function
  | Illegal_character c ->
      fprintf ppf "Illegal character (%s)" (Char.escaped c)
  | Illegal_escape s ->
      fprintf ppf "Illegal backslash escape in string or character (%s)" s
  | Unterminated_comment _ ->
      fprintf ppf "Comment not terminated"
  | Unterminated_string ->
      fprintf ppf "String literal not terminated"
  | Unterminated_string_in_comment (_, loc) ->
      fprintf ppf "This comment contains an unterminated string literal@.\
                   %aString literal begins here"
              Location.print_error loc
  | Keyword_as_label kwd ->
      fprintf ppf "`%s' is a keyword, it cannot be used as label name" kwd
  | Literal_overflow ty ->
      fprintf ppf "Integer literal exceeds the range of representable \
                   integers of type %s" ty
  | Invalid_literal s ->
      fprintf ppf "Invalid literal %s" s

let () =
  Location.register_error_of_exn
    (function
      | Error (err, loc) ->
          Some (Location.error_of_printer loc report_error err)
      | _ ->
          None
    )

# 242 "src/reason_lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\155\255\156\255\224\000\235\000\018\001\053\001\088\001\
    \188\255\123\001\158\001\195\255\091\000\225\001\068\000\083\000\
    \061\002\217\255\219\255\220\255\222\255\072\002\156\002\191\002\
    \226\002\008\001\000\003\237\255\084\003\168\003\252\003\204\004\
    \156\005\123\006\134\006\173\006\235\006\187\007\072\000\126\000\
    \254\255\001\000\177\008\190\008\227\008\006\009\041\009\076\009\
    \111\009\255\255\005\000\089\000\146\009\181\009\216\009\090\000\
    \251\009\097\000\030\010\098\000\065\010\099\000\100\010\100\000\
    \101\000\107\000\110\000\006\000\207\255\208\255\064\000\130\010\
    \092\000\251\255\216\000\220\010\231\010\054\011\138\011\222\011\
    \050\012\134\012\218\012\046\013\130\013\214\013\042\014\126\014\
    \175\001\210\014\038\015\122\015\206\015\034\016\185\001\193\255\
    \236\255\224\002\125\016\117\000\121\000\007\000\235\255\234\255\
    \230\255\071\004\089\002\148\000\233\255\119\002\149\000\232\255\
    \023\005\150\000\231\255\150\016\143\000\228\255\227\255\014\006\
    \247\002\191\016\217\000\225\255\011\000\010\001\023\001\179\001\
    \025\001\225\255\012\000\226\016\005\017\040\017\145\000\211\255\
    \205\255\075\017\110\017\040\007\140\017\230\017\170\255\007\018\
    \196\255\097\018\108\018\210\000\201\000\198\255\199\255\200\255\
    \202\000\182\255\184\255\190\255\147\018\187\255\182\018\217\018\
    \252\018\031\019\002\001\039\006\243\255\244\255\013\000\245\255\
    \062\001\215\007\253\255\228\000\241\000\255\255\254\255\252\255\
    \243\007\078\019\251\000\006\001\017\000\251\255\250\255\249\255\
    \112\019\001\003\007\001\248\255\094\004\009\001\247\255\151\019\
    \011\001\246\255\018\000\163\001\247\255\248\255\249\255\055\001\
    \222\019\255\255\250\255\000\020\104\004\253\255\061\001\056\001\
    \064\001\126\004\252\255\039\020\251\255\074\001\152\001\252\255\
    \047\020\254\255\255\255\075\001\094\001\253\255\076\020\017\001\
    \020\001\092\001\096\001\025\001\112\001\024\001\019\000\255\255\
    ";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\095\000\090\000\089\000\079\000\074\000\
    \255\255\066\000\063\000\255\255\054\000\051\000\049\000\042\000\
    \082\000\255\255\255\255\255\255\255\255\031\000\041\000\037\000\
    \097\000\034\000\061\000\255\255\013\000\013\000\012\000\011\000\
    \010\000\053\000\007\000\006\000\009\000\005\000\045\000\002\000\
    \255\255\100\000\100\000\098\000\097\000\096\000\091\000\255\255\
    \255\255\255\255\255\255\255\255\087\000\077\000\078\000\255\255\
    \088\000\255\255\096\000\255\255\093\000\255\255\094\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\046\000\003\000\
    \255\255\255\255\255\255\040\000\008\000\017\000\017\000\015\000\
    \014\000\017\000\014\000\014\000\013\000\015\000\014\000\015\000\
    \255\255\016\000\016\000\013\000\013\000\015\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\025\000\025\000\025\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\092\000\026\000\255\255\255\255\255\255\
    \255\255\029\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\032\000\083\000\039\000\043\000\255\255\
    \255\255\089\000\084\000\255\255\058\000\052\000\255\255\255\255\
    \255\255\089\000\086\000\070\000\069\000\255\255\255\255\255\255\
    \072\000\255\255\255\255\255\255\064\000\255\255\075\000\076\000\
    \081\000\080\000\255\255\255\255\255\255\255\255\012\000\255\255\
    \012\000\012\000\255\255\012\000\012\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\008\000\
    \008\000\255\255\255\255\005\000\005\000\255\255\001\000\005\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \003\000\255\255\255\255\003\000\255\255\255\255\255\255\002\000\
    \255\255\255\255\001\000\255\255\255\255\255\255\255\255\255\255\
    ";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\255\255\255\255\255\255\
    \255\255\099\000\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\255\255\255\255\
    \255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
    \000\000\255\255\104\000\255\255\255\255\255\255\000\000\000\000\
    \000\000\255\255\255\255\255\255\000\000\255\255\255\255\000\000\
    \255\255\255\255\000\000\255\255\255\255\000\000\000\000\125\000\
    \255\255\255\255\255\255\000\000\255\255\125\000\126\000\125\000\
    \128\000\000\000\255\255\255\255\255\255\255\255\255\255\000\000\
    \000\000\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
    \000\000\255\255\255\255\255\255\255\255\000\000\000\000\000\000\
    \255\255\000\000\000\000\000\000\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\164\000\000\000\000\000\255\255\000\000\
    \178\000\255\255\000\000\255\255\255\255\000\000\000\000\000\000\
    \255\255\255\255\255\255\255\255\255\255\000\000\000\000\000\000\
    \255\255\255\255\255\255\000\000\255\255\255\255\000\000\255\255\
    \255\255\000\000\255\255\196\000\000\000\000\000\000\000\255\255\
    \202\000\000\000\000\000\255\255\255\255\000\000\255\255\255\255\
    \255\255\255\255\000\000\255\255\000\000\255\255\215\000\000\000\
    \255\255\000\000\000\000\255\255\255\255\000\000\255\255\255\255\
    \255\255\225\000\228\000\255\255\228\000\255\255\255\255\000\000\
    ";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\039\000\040\000\040\000\039\000\041\000\067\000\049\000\
    \040\000\100\000\050\000\067\000\101\000\123\000\129\000\165\000\
    \124\000\130\000\194\000\179\000\165\000\231\000\180\000\194\000\
    \039\000\007\000\027\000\022\000\005\000\003\000\021\000\025\000\
    \019\000\018\000\023\000\006\000\017\000\016\000\015\000\024\000\
    \029\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\038\000\014\000\013\000\033\000\009\000\034\000\
    \004\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\012\000\042\000\011\000\004\000\037\000\
    \020\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\026\000\010\000\008\000\035\000\136\000\
    \147\000\134\000\070\000\052\000\056\000\069\000\068\000\039\000\
    \052\000\056\000\039\000\046\000\062\000\060\000\062\000\058\000\
    \046\000\058\000\060\000\062\000\058\000\044\000\073\000\150\000\
    \043\000\149\000\044\000\148\000\103\000\043\000\039\000\071\000\
    \102\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\108\000\111\000\114\000\117\000\135\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\151\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\154\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \002\000\043\000\005\000\121\000\043\000\043\000\043\000\005\000\
    \121\000\152\000\153\000\043\000\004\000\043\000\043\000\004\000\
    \004\000\004\000\100\000\174\000\123\000\101\000\004\000\124\000\
    \004\000\004\000\043\000\173\000\043\000\043\000\043\000\043\000\
    \043\000\123\000\183\000\129\000\124\000\004\000\130\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\182\000\187\000\255\255\
    \190\000\004\000\193\000\005\000\224\000\225\000\005\000\005\000\
    \005\000\128\000\229\000\230\000\066\000\005\000\043\000\005\000\
    \005\000\198\000\206\000\000\000\213\000\208\000\206\000\162\000\
    \179\000\004\000\206\000\180\000\005\000\208\000\005\000\005\000\
    \005\000\005\000\005\000\000\000\198\000\218\000\046\000\213\000\
    \220\000\046\000\046\000\046\000\043\000\206\000\043\000\000\000\
    \046\000\000\000\046\000\161\000\098\000\181\000\226\000\004\000\
    \218\000\004\000\227\000\220\000\000\000\000\000\074\000\046\000\
    \005\000\046\000\160\000\046\000\046\000\046\000\000\000\000\000\
    \000\000\052\000\227\000\000\000\052\000\052\000\052\000\000\000\
    \000\000\000\000\000\000\052\000\000\000\052\000\052\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\005\000\000\000\
    \005\000\057\000\052\000\046\000\052\000\158\000\052\000\052\000\
    \052\000\000\000\177\000\000\000\005\000\000\000\000\000\005\000\
    \005\000\005\000\218\000\000\000\000\000\219\000\005\000\000\000\
    \005\000\005\000\000\000\000\000\000\000\198\000\000\000\000\000\
    \199\000\046\000\000\000\046\000\051\000\005\000\052\000\005\000\
    \005\000\005\000\005\000\005\000\127\000\123\000\000\000\005\000\
    \124\000\000\000\005\000\005\000\005\000\201\000\000\000\000\000\
    \000\000\005\000\000\000\005\000\005\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\127\000\052\000\126\000\052\000\074\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\000\000\000\000\000\000\000\000\005\000\
    \157\000\005\000\074\000\155\000\005\000\000\000\000\000\200\000\
    \000\000\000\000\005\000\000\000\000\000\005\000\005\000\005\000\
    \255\255\000\000\255\255\000\000\005\000\000\000\141\000\137\000\
    \139\000\000\000\000\000\000\000\216\000\000\000\000\000\255\255\
    \000\000\255\255\156\000\005\000\005\000\005\000\005\000\138\000\
    \005\000\005\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\000\000\074\000\255\255\005\000\
    \140\000\000\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\255\255\005\000\046\000\005\000\
    \255\255\046\000\046\000\046\000\000\000\000\000\000\000\000\000\
    \046\000\005\000\046\000\132\000\005\000\005\000\131\000\000\000\
    \255\255\000\000\000\000\005\000\000\000\005\000\005\000\046\000\
    \000\000\046\000\046\000\133\000\046\000\046\000\000\000\000\000\
    \000\000\000\000\005\000\000\000\005\000\005\000\005\000\005\000\
    \005\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\000\000\000\000\000\000\000\000\000\000\
    \217\000\057\000\000\000\046\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\197\000\074\000\120\000\005\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\000\000\000\000\255\255\000\000\000\000\000\000\000\000\
    \000\000\046\000\000\000\046\000\120\000\121\000\000\000\121\000\
    \121\000\121\000\121\000\000\000\005\000\000\000\005\000\121\000\
    \000\000\121\000\121\000\000\000\119\000\119\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\121\000\000\000\
    \121\000\121\000\121\000\121\000\121\000\000\000\000\000\000\000\
    \058\000\000\000\000\000\058\000\058\000\058\000\000\000\000\000\
    \000\000\060\000\058\000\000\000\058\000\058\000\118\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \122\000\058\000\121\000\058\000\058\000\058\000\058\000\058\000\
    \120\000\000\000\000\000\044\000\000\000\000\000\044\000\044\000\
    \044\000\000\000\000\000\000\000\116\000\044\000\000\000\044\000\
    \044\000\000\000\000\000\000\000\000\000\000\000\000\000\120\000\
    \121\000\000\000\121\000\059\000\044\000\058\000\044\000\044\000\
    \115\000\044\000\044\000\000\000\000\000\000\000\000\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \119\000\188\000\188\000\188\000\188\000\188\000\188\000\188\000\
    \188\000\188\000\188\000\058\000\095\000\058\000\065\000\097\000\
    \044\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\000\000\096\000\000\000\044\000\097\000\
    \044\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\077\000\096\000\000\000\000\000\000\000\
    \000\000\000\000\079\000\000\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\077\000\077\000\077\000\
    \077\000\078\000\077\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\000\000\
    \000\000\000\000\000\000\028\000\000\000\077\000\077\000\077\000\
    \077\000\078\000\077\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\077\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\079\000\000\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\077\000\081\000\077\000\077\000\078\000\077\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\082\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \083\000\080\000\080\000\000\000\000\000\000\000\000\000\028\000\
    \000\000\077\000\081\000\077\000\077\000\078\000\077\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\082\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \083\000\080\000\080\000\030\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\000\000\
    \000\000\000\000\000\000\030\000\000\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\112\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\112\000\112\000\
    \112\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\189\000\189\000\
    \189\000\189\000\189\000\189\000\189\000\189\000\189\000\189\000\
    \209\000\209\000\209\000\209\000\209\000\209\000\209\000\209\000\
    \209\000\209\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\210\000\210\000\
    \210\000\210\000\210\000\210\000\210\000\210\000\210\000\210\000\
    \000\000\000\000\000\000\000\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\000\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\031\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\000\000\
    \000\000\000\000\000\000\031\000\000\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\113\000\
    \113\000\113\000\113\000\113\000\113\000\113\000\113\000\113\000\
    \113\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \113\000\113\000\113\000\113\000\113\000\113\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \113\000\113\000\113\000\113\000\113\000\113\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\000\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\032\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\000\000\
    \000\000\000\000\000\000\032\000\000\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\127\000\
    \123\000\000\000\000\000\124\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\
    \126\000\165\000\000\000\000\000\166\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \000\000\170\000\000\000\000\000\000\000\000\000\168\000\000\000\
    \000\000\171\000\000\000\000\000\000\000\000\000\172\000\000\000\
    \000\000\000\000\000\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\005\000\000\000\000\000\005\000\
    \005\000\005\000\169\000\000\000\000\000\000\000\005\000\056\000\
    \005\000\005\000\056\000\056\000\056\000\000\000\000\000\000\000\
    \000\000\056\000\000\000\056\000\056\000\005\000\000\000\005\000\
    \005\000\075\000\076\000\005\000\000\000\000\000\000\000\000\000\
    \056\000\000\000\056\000\056\000\056\000\056\000\056\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\056\000\000\000\
    \000\000\056\000\056\000\056\000\000\000\000\000\000\000\074\000\
    \056\000\005\000\056\000\056\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\055\000\000\000\056\000\000\000\000\000\056\000\
    \000\000\056\000\056\000\056\000\056\000\056\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\
    \000\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\056\000\000\000\056\000\000\000\000\000\000\000\
    \000\000\055\000\000\000\056\000\000\000\000\000\255\255\000\000\
    \000\000\000\000\036\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\072\000\000\000\167\000\
    \000\000\056\000\000\000\056\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\000\000\000\000\
    \000\000\000\000\036\000\000\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\142\000\000\000\
    \000\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\000\000\000\000\000\000\000\000\143\000\
    \000\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\000\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\036\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\072\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\000\000\000\000\
    \000\000\000\000\036\000\000\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\176\000\000\000\
    \176\000\176\000\176\000\176\000\176\000\176\000\176\000\176\000\
    \176\000\176\000\176\000\176\000\176\000\176\000\176\000\176\000\
    \176\000\176\000\176\000\176\000\176\000\176\000\176\000\176\000\
    \176\000\176\000\176\000\175\000\176\000\176\000\176\000\176\000\
    \176\000\176\000\176\000\176\000\176\000\176\000\176\000\176\000\
    \176\000\176\000\176\000\176\000\176\000\176\000\176\000\176\000\
    \176\000\176\000\176\000\176\000\176\000\176\000\000\000\175\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\000\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\000\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\049\000\000\000\000\000\050\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\048\000\000\000\000\000\005\000\043\000\005\000\
    \000\000\000\000\000\000\045\000\046\000\000\000\046\000\043\000\
    \044\000\000\000\043\000\043\000\043\000\000\000\000\000\000\000\
    \000\000\043\000\000\000\043\000\043\000\005\000\005\000\005\000\
    \047\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \043\000\000\000\043\000\043\000\043\000\043\000\043\000\000\000\
    \000\000\000\000\000\000\000\000\044\000\000\000\000\000\044\000\
    \044\000\044\000\000\000\000\000\000\000\000\000\044\000\004\000\
    \044\000\044\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\066\000\000\000\043\000\044\000\000\000\044\000\
    \044\000\044\000\044\000\044\000\000\000\000\000\000\000\058\000\
    \000\000\000\000\058\000\058\000\058\000\005\000\000\000\047\000\
    \060\000\058\000\000\000\058\000\058\000\000\000\000\000\000\000\
    \000\000\000\000\043\000\000\000\043\000\000\000\000\000\065\000\
    \058\000\044\000\058\000\058\000\058\000\058\000\058\000\000\000\
    \000\000\000\000\046\000\000\000\000\000\046\000\046\000\046\000\
    \000\000\000\000\000\000\000\000\046\000\000\000\046\000\046\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\044\000\
    \000\000\044\000\059\000\046\000\058\000\046\000\046\000\046\000\
    \046\000\046\000\000\000\000\000\000\000\056\000\000\000\000\000\
    \056\000\056\000\056\000\000\000\000\000\000\000\000\000\056\000\
    \000\000\056\000\056\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\058\000\000\000\058\000\057\000\056\000\046\000\
    \056\000\056\000\056\000\056\000\056\000\000\000\000\000\000\000\
    \052\000\000\000\000\000\052\000\052\000\052\000\000\000\000\000\
    \000\000\000\000\052\000\000\000\052\000\052\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\046\000\000\000\046\000\
    \055\000\052\000\056\000\052\000\053\000\052\000\052\000\052\000\
    \000\000\000\000\000\000\052\000\000\000\000\000\052\000\052\000\
    \052\000\000\000\000\000\000\000\000\000\052\000\000\000\052\000\
    \052\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \056\000\000\000\056\000\051\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\000\000\000\000\000\000\052\000\000\000\
    \000\000\052\000\052\000\052\000\000\000\000\000\000\000\000\000\
    \052\000\000\000\052\000\052\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\052\000\000\000\052\000\051\000\052\000\
    \052\000\052\000\054\000\052\000\052\000\052\000\000\000\000\000\
    \000\000\052\000\000\000\000\000\052\000\052\000\052\000\000\000\
    \000\000\000\000\000\000\052\000\000\000\052\000\052\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\052\000\000\000\
    \052\000\051\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\000\000\000\000\000\000\056\000\000\000\000\000\056\000\
    \056\000\056\000\000\000\000\000\000\000\000\000\056\000\000\000\
    \056\000\056\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\052\000\000\000\052\000\051\000\056\000\052\000\056\000\
    \056\000\056\000\056\000\056\000\000\000\000\000\000\000\058\000\
    \000\000\000\000\058\000\058\000\058\000\000\000\000\000\000\000\
    \000\000\058\000\000\000\058\000\058\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\052\000\000\000\052\000\055\000\
    \058\000\056\000\058\000\058\000\058\000\058\000\058\000\000\000\
    \000\000\000\000\060\000\000\000\000\000\060\000\060\000\060\000\
    \000\000\000\000\000\000\000\000\060\000\000\000\060\000\060\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\056\000\
    \000\000\056\000\064\000\060\000\058\000\060\000\060\000\060\000\
    \060\000\060\000\000\000\000\000\000\000\062\000\000\000\000\000\
    \062\000\062\000\062\000\000\000\000\000\000\000\000\000\062\000\
    \000\000\062\000\062\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\058\000\000\000\058\000\061\000\062\000\060\000\
    \062\000\062\000\062\000\062\000\062\000\000\000\000\000\000\000\
    \000\000\071\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\000\000\060\000\000\000\060\000\
    \063\000\000\000\062\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\000\000\000\000\000\000\
    \062\000\071\000\062\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\005\000\000\000\000\000\
    \005\000\005\000\005\000\000\000\000\000\000\000\000\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\000\000\000\000\
    \000\000\000\000\005\000\000\000\005\000\005\000\005\000\000\000\
    \005\000\005\000\005\000\005\000\005\000\000\000\000\000\000\000\
    \000\000\005\000\000\000\005\000\005\000\005\000\005\000\005\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \074\000\000\000\005\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\074\000\000\000\005\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \005\000\000\000\005\000\000\000\000\000\077\000\000\000\000\000\
    \000\000\000\000\000\000\005\000\000\000\005\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\000\000\000\000\000\000\000\000\077\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\000\000\000\000\000\000\094\000\000\000\094\000\
    \000\000\000\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\000\000\000\000\000\000\
    \000\000\077\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\000\
    \077\000\077\000\077\000\078\000\077\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\000\000\000\000\000\000\000\000\079\000\000\000\077\000\
    \077\000\077\000\077\000\078\000\077\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\077\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\000\000\000\000\000\000\
    \000\000\077\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\092\000\092\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\000\000\000\000\000\000\000\000\077\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\077\000\077\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\000\000\000\000\000\000\
    \000\000\077\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\000\000\000\000\000\000\000\000\077\000\000\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \085\000\000\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\086\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\000\000\000\000\000\000\
    \000\000\084\000\000\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\086\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\077\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\090\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\000\000\000\000\000\000\000\000\085\000\000\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\090\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\077\000\000\000\000\000\000\000\088\000\000\000\088\000\
    \000\000\000\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\000\000\000\000\000\000\
    \000\000\077\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\000\000\000\000\000\000\000\000\087\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\077\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\000\000\000\000\000\000\
    \000\000\077\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\000\000\000\000\
    \000\000\088\000\000\000\088\000\000\000\000\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\000\000\000\000\000\000\000\000\077\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\077\000\077\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\000\000\000\000\000\000\
    \000\000\091\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\077\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\092\000\092\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\000\000\000\000\000\000\000\000\092\000\000\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\077\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\000\000\000\000\000\000\
    \000\000\093\000\000\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\107\000\000\000\107\000\
    \000\000\000\000\000\000\000\000\107\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\044\000\
    \000\000\000\000\044\000\044\000\044\000\000\000\000\000\000\000\
    \000\000\044\000\000\000\044\000\044\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \044\000\000\000\044\000\044\000\044\000\044\000\044\000\000\000\
    \000\000\107\000\000\000\000\000\000\000\000\000\000\000\107\000\
    \121\000\000\000\121\000\121\000\121\000\121\000\000\000\000\000\
    \000\000\000\000\121\000\107\000\121\000\121\000\000\000\107\000\
    \000\000\107\000\065\000\000\000\044\000\105\000\000\000\000\000\
    \000\000\121\000\000\000\121\000\121\000\121\000\121\000\121\000\
    \000\000\000\000\000\000\005\000\000\000\000\000\005\000\005\000\
    \005\000\000\000\000\000\000\000\000\000\005\000\000\000\005\000\
    \005\000\000\000\044\000\000\000\044\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\122\000\005\000\121\000\005\000\005\000\
    \005\000\005\000\005\000\000\000\000\000\000\000\046\000\000\000\
    \000\000\046\000\046\000\046\000\000\000\000\000\000\000\000\000\
    \046\000\000\000\046\000\046\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\121\000\000\000\121\000\074\000\046\000\
    \005\000\046\000\046\000\046\000\046\000\046\000\000\000\000\000\
    \000\000\046\000\000\000\000\000\046\000\046\000\046\000\000\000\
    \000\000\000\000\000\000\046\000\000\000\046\000\046\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\005\000\000\000\
    \005\000\057\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\000\000\000\000\000\000\005\000\000\000\000\000\005\000\
    \005\000\005\000\000\000\000\000\000\000\000\000\005\000\000\000\
    \005\000\145\000\000\000\000\000\000\000\255\255\000\000\000\000\
    \000\000\046\000\000\000\046\000\057\000\005\000\046\000\005\000\
    \005\000\005\000\005\000\005\000\000\000\000\000\000\000\005\000\
    \000\000\000\000\005\000\005\000\005\000\000\000\000\000\000\000\
    \000\000\005\000\000\000\005\000\005\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\046\000\000\000\046\000\074\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\000\000\
    \000\000\000\000\000\000\140\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\140\000\000\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\000\000\005\000\
    \000\000\005\000\074\000\000\000\005\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\000\000\
    \000\000\000\000\005\000\140\000\005\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\005\000\
    \000\000\000\000\005\000\005\000\005\000\000\000\000\000\000\000\
    \000\000\005\000\000\000\005\000\005\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \005\000\000\000\005\000\005\000\005\000\005\000\005\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\143\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\143\000\000\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\000\000\074\000\000\000\005\000\144\000\000\000\000\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\005\000\000\000\005\000\000\000\143\000\000\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\005\000\000\000\000\000\005\000\005\000\005\000\
    \000\000\000\000\000\000\000\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\000\000\000\000\000\000\000\000\005\000\
    \000\000\005\000\005\000\005\000\000\000\005\000\005\000\146\000\
    \005\000\005\000\000\000\000\000\000\000\000\000\005\000\000\000\
    \005\000\005\000\005\000\005\000\005\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\005\000\000\000\000\000\005\000\
    \005\000\005\000\000\000\000\000\000\000\074\000\005\000\005\000\
    \005\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \074\000\000\000\005\000\000\000\000\000\005\000\000\000\005\000\
    \005\000\005\000\005\000\005\000\000\000\000\000\000\000\052\000\
    \000\000\000\000\052\000\052\000\052\000\005\000\000\000\005\000\
    \000\000\052\000\000\000\052\000\052\000\000\000\000\000\000\000\
    \005\000\000\000\005\000\000\000\000\000\000\000\000\000\074\000\
    \052\000\005\000\052\000\159\000\052\000\052\000\052\000\000\000\
    \000\000\000\000\052\000\000\000\000\000\052\000\052\000\052\000\
    \000\000\000\000\000\000\000\000\052\000\000\000\052\000\052\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\
    \000\000\005\000\051\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\000\000\000\000\000\000\046\000\000\000\000\000\
    \046\000\046\000\046\000\000\000\000\000\000\000\000\000\046\000\
    \000\000\046\000\046\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\052\000\000\000\052\000\051\000\046\000\052\000\
    \046\000\046\000\046\000\046\000\046\000\000\000\000\000\000\000\
    \046\000\000\000\000\000\046\000\046\000\046\000\000\000\000\000\
    \000\000\000\000\046\000\000\000\046\000\046\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\052\000\000\000\052\000\
    \057\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\186\000\000\000\
    \186\000\000\000\000\000\000\000\000\000\186\000\000\000\000\000\
    \046\000\000\000\046\000\057\000\000\000\046\000\185\000\185\000\
    \185\000\185\000\185\000\185\000\185\000\185\000\185\000\185\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\046\000\000\000\046\000\000\000\000\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\186\000\000\000\000\000\000\000\000\000\000\000\
    \186\000\191\000\191\000\191\000\191\000\191\000\191\000\000\000\
    \000\000\000\000\000\000\000\000\186\000\000\000\000\000\000\000\
    \186\000\000\000\186\000\000\000\000\000\000\000\184\000\192\000\
    \192\000\192\000\192\000\192\000\192\000\192\000\192\000\192\000\
    \192\000\191\000\191\000\191\000\191\000\191\000\191\000\000\000\
    \192\000\192\000\192\000\192\000\192\000\192\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \206\000\000\000\000\000\207\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \192\000\192\000\192\000\192\000\192\000\192\000\205\000\000\000\
    \205\000\000\000\000\000\000\000\000\000\205\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \211\000\211\000\211\000\211\000\211\000\211\000\211\000\211\000\
    \211\000\211\000\205\000\000\000\000\000\000\000\000\000\000\000\
    \205\000\211\000\211\000\211\000\211\000\211\000\211\000\000\000\
    \000\000\000\000\000\000\000\000\205\000\000\000\000\000\000\000\
    \205\000\000\000\205\000\000\000\000\000\000\000\203\000\212\000\
    \212\000\212\000\212\000\212\000\212\000\212\000\212\000\212\000\
    \212\000\211\000\211\000\211\000\211\000\211\000\211\000\000\000\
    \212\000\212\000\212\000\212\000\212\000\212\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \212\000\212\000\212\000\212\000\212\000\212\000\222\000\000\000\
    \222\000\222\000\222\000\222\000\222\000\222\000\222\000\222\000\
    \222\000\222\000\222\000\222\000\222\000\222\000\222\000\222\000\
    \222\000\222\000\222\000\222\000\222\000\222\000\222\000\222\000\
    \222\000\222\000\000\000\222\000\221\000\222\000\222\000\222\000\
    \222\000\222\000\222\000\222\000\222\000\222\000\222\000\222\000\
    \222\000\222\000\222\000\222\000\222\000\222\000\222\000\222\000\
    \222\000\222\000\222\000\222\000\222\000\222\000\222\000\000\000\
    \000\000\221\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\041\000\000\000\000\000\041\000\050\000\
    \067\000\101\000\050\000\067\000\101\000\124\000\130\000\166\000\
    \124\000\130\000\166\000\180\000\194\000\230\000\180\000\194\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\000\
    \012\000\015\000\038\000\051\000\055\000\038\000\038\000\039\000\
    \051\000\055\000\039\000\057\000\059\000\061\000\063\000\064\000\
    \057\000\059\000\061\000\063\000\064\000\065\000\072\000\012\000\
    \066\000\012\000\065\000\012\000\099\000\066\000\039\000\070\000\
    \100\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\107\000\110\000\113\000\116\000\134\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\147\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\003\000\074\000\122\000\003\000\003\000\003\000\074\000\
    \122\000\148\000\152\000\003\000\004\000\003\000\003\000\004\000\
    \004\000\004\000\025\000\171\000\125\000\025\000\004\000\125\000\
    \004\000\004\000\003\000\172\000\003\000\003\000\003\000\003\000\
    \003\000\126\000\178\000\128\000\126\000\004\000\128\000\004\000\
    \004\000\004\000\004\000\004\000\162\000\179\000\186\000\025\000\
    \189\000\162\000\192\000\005\000\223\000\224\000\005\000\005\000\
    \005\000\126\000\227\000\229\000\003\000\005\000\003\000\005\000\
    \005\000\199\000\207\000\255\255\199\000\207\000\206\000\004\000\
    \168\000\004\000\208\000\168\000\005\000\208\000\005\000\005\000\
    \005\000\005\000\005\000\255\255\213\000\219\000\006\000\213\000\
    \219\000\006\000\006\000\006\000\003\000\206\000\003\000\255\255\
    \006\000\255\255\006\000\006\000\025\000\168\000\225\000\004\000\
    \220\000\004\000\226\000\220\000\255\255\255\255\005\000\006\000\
    \005\000\006\000\006\000\006\000\006\000\006\000\255\255\255\255\
    \255\255\007\000\228\000\255\255\007\000\007\000\007\000\255\255\
    \255\255\255\255\255\255\007\000\255\255\007\000\007\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\005\000\255\255\
    \005\000\006\000\007\000\006\000\007\000\007\000\007\000\007\000\
    \007\000\255\255\168\000\255\255\009\000\255\255\255\255\009\000\
    \009\000\009\000\214\000\255\255\255\255\214\000\009\000\255\255\
    \009\000\009\000\255\255\255\255\255\255\195\000\255\255\255\255\
    \195\000\006\000\255\255\006\000\007\000\009\000\007\000\009\000\
    \009\000\009\000\009\000\009\000\127\000\127\000\255\255\010\000\
    \127\000\255\255\010\000\010\000\010\000\195\000\255\255\255\255\
    \255\255\010\000\255\255\010\000\010\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\127\000\007\000\127\000\007\000\009\000\
    \010\000\009\000\010\000\010\000\010\000\010\000\010\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\094\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\094\000\094\000\255\255\255\255\255\255\255\255\009\000\
    \009\000\009\000\010\000\010\000\010\000\255\255\255\255\195\000\
    \255\255\255\255\013\000\255\255\255\255\013\000\013\000\013\000\
    \025\000\255\255\125\000\255\255\013\000\255\255\013\000\013\000\
    \013\000\255\255\255\255\255\255\214\000\255\255\255\255\126\000\
    \255\255\128\000\010\000\013\000\010\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\255\255\013\000\168\000\013\000\
    \013\000\255\255\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\225\000\013\000\016\000\013\000\
    \226\000\016\000\016\000\016\000\255\255\255\255\255\255\255\255\
    \016\000\021\000\016\000\016\000\021\000\021\000\021\000\255\255\
    \228\000\255\255\255\255\021\000\255\255\021\000\021\000\016\000\
    \255\255\016\000\016\000\016\000\016\000\016\000\255\255\255\255\
    \255\255\255\255\021\000\255\255\021\000\021\000\021\000\021\000\
    \021\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\255\255\255\255\255\255\255\255\255\255\
    \214\000\016\000\255\255\016\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\195\000\021\000\022\000\021\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\255\255\255\255\127\000\255\255\255\255\255\255\255\255\
    \255\255\016\000\255\255\016\000\022\000\022\000\255\255\022\000\
    \022\000\022\000\022\000\255\255\021\000\255\255\021\000\022\000\
    \255\255\022\000\022\000\255\255\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\255\255\
    \022\000\022\000\022\000\022\000\022\000\255\255\255\255\255\255\
    \023\000\255\255\255\255\023\000\023\000\023\000\255\255\255\255\
    \255\255\023\000\023\000\255\255\023\000\023\000\023\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \022\000\023\000\022\000\023\000\023\000\023\000\023\000\023\000\
    \120\000\255\255\255\255\024\000\255\255\255\255\024\000\024\000\
    \024\000\255\255\255\255\255\255\024\000\024\000\255\255\024\000\
    \024\000\255\255\255\255\255\255\255\255\255\255\255\255\120\000\
    \022\000\255\255\022\000\023\000\024\000\023\000\024\000\024\000\
    \024\000\024\000\024\000\255\255\255\255\255\255\255\255\120\000\
    \120\000\120\000\120\000\120\000\120\000\120\000\120\000\120\000\
    \120\000\185\000\185\000\185\000\185\000\185\000\185\000\185\000\
    \185\000\185\000\185\000\023\000\026\000\023\000\024\000\097\000\
    \024\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\255\255\097\000\255\255\024\000\026\000\
    \024\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\028\000\026\000\255\255\255\255\255\255\
    \255\255\255\255\028\000\255\255\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\255\255\
    \255\255\255\255\255\255\028\000\255\255\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\029\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\029\000\255\255\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\255\255\255\255\255\255\255\255\029\000\
    \255\255\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\030\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\255\255\
    \255\255\255\255\255\255\030\000\255\255\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \105\000\105\000\105\000\105\000\105\000\105\000\188\000\188\000\
    \188\000\188\000\188\000\188\000\188\000\188\000\188\000\188\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \105\000\105\000\105\000\105\000\105\000\105\000\209\000\209\000\
    \209\000\209\000\209\000\209\000\209\000\209\000\209\000\209\000\
    \255\255\255\255\255\255\255\255\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\255\255\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\031\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\255\255\
    \255\255\255\255\255\255\031\000\255\255\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\112\000\
    \112\000\112\000\112\000\112\000\112\000\112\000\112\000\112\000\
    \112\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \112\000\112\000\112\000\112\000\112\000\112\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \112\000\112\000\112\000\112\000\112\000\112\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\255\255\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\032\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\255\255\
    \255\255\255\255\255\255\032\000\255\255\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\119\000\
    \119\000\255\255\255\255\119\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\119\000\255\255\
    \119\000\163\000\255\255\255\255\163\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\119\000\119\000\
    \119\000\119\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \255\255\163\000\255\255\255\255\255\255\255\255\163\000\255\255\
    \255\255\163\000\255\255\255\255\255\255\255\255\163\000\255\255\
    \255\255\255\255\255\255\255\255\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\255\255\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\255\255\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\033\000\255\255\255\255\033\000\
    \033\000\033\000\163\000\255\255\255\255\255\255\033\000\034\000\
    \033\000\033\000\034\000\034\000\034\000\255\255\255\255\255\255\
    \255\255\034\000\255\255\034\000\034\000\033\000\255\255\033\000\
    \033\000\033\000\033\000\033\000\255\255\255\255\255\255\255\255\
    \034\000\255\255\034\000\034\000\034\000\034\000\034\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\035\000\255\255\
    \255\255\035\000\035\000\035\000\255\255\255\255\255\255\033\000\
    \035\000\033\000\035\000\035\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\034\000\255\255\034\000\255\255\255\255\035\000\
    \255\255\035\000\035\000\035\000\035\000\035\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\033\000\
    \255\255\033\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\034\000\255\255\034\000\255\255\255\255\255\255\
    \255\255\035\000\255\255\035\000\255\255\255\255\119\000\255\255\
    \255\255\255\255\036\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\255\255\163\000\
    \255\255\035\000\255\255\035\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\255\255\255\255\
    \255\255\255\255\036\000\255\255\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\139\000\255\255\
    \255\255\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\255\255\255\255\255\255\255\255\139\000\
    \255\255\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\255\255\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\037\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\255\255\255\255\
    \255\255\255\255\037\000\255\255\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\169\000\255\255\
    \169\000\169\000\169\000\169\000\169\000\169\000\169\000\169\000\
    \169\000\169\000\169\000\169\000\169\000\169\000\169\000\169\000\
    \169\000\169\000\169\000\169\000\169\000\169\000\169\000\169\000\
    \169\000\169\000\176\000\169\000\176\000\176\000\176\000\176\000\
    \176\000\176\000\176\000\176\000\176\000\176\000\176\000\176\000\
    \176\000\176\000\176\000\176\000\176\000\176\000\176\000\176\000\
    \176\000\176\000\176\000\176\000\176\000\176\000\255\255\176\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\255\255\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\255\255\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\042\000\255\255\255\255\042\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\042\000\255\255\255\255\042\000\042\000\042\000\
    \255\255\255\255\255\255\042\000\042\000\255\255\042\000\043\000\
    \042\000\255\255\043\000\043\000\043\000\255\255\255\255\255\255\
    \255\255\043\000\255\255\043\000\043\000\042\000\042\000\042\000\
    \042\000\042\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \043\000\255\255\043\000\043\000\043\000\043\000\043\000\255\255\
    \255\255\255\255\255\255\255\255\044\000\255\255\255\255\044\000\
    \044\000\044\000\255\255\255\255\255\255\255\255\044\000\042\000\
    \044\000\044\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\043\000\255\255\043\000\044\000\255\255\044\000\
    \044\000\044\000\044\000\044\000\255\255\255\255\255\255\045\000\
    \255\255\255\255\045\000\045\000\045\000\042\000\255\255\042\000\
    \045\000\045\000\255\255\045\000\045\000\255\255\255\255\255\255\
    \255\255\255\255\043\000\255\255\043\000\255\255\255\255\044\000\
    \045\000\044\000\045\000\045\000\045\000\045\000\045\000\255\255\
    \255\255\255\255\046\000\255\255\255\255\046\000\046\000\046\000\
    \255\255\255\255\255\255\255\255\046\000\255\255\046\000\046\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\044\000\
    \255\255\044\000\045\000\046\000\045\000\046\000\046\000\046\000\
    \046\000\046\000\255\255\255\255\255\255\047\000\255\255\255\255\
    \047\000\047\000\047\000\255\255\255\255\255\255\255\255\047\000\
    \255\255\047\000\047\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\045\000\255\255\045\000\046\000\047\000\046\000\
    \047\000\047\000\047\000\047\000\047\000\255\255\255\255\255\255\
    \048\000\255\255\255\255\048\000\048\000\048\000\255\255\255\255\
    \255\255\255\255\048\000\255\255\048\000\048\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\046\000\255\255\046\000\
    \047\000\048\000\047\000\048\000\048\000\048\000\048\000\048\000\
    \255\255\255\255\255\255\052\000\255\255\255\255\052\000\052\000\
    \052\000\255\255\255\255\255\255\255\255\052\000\255\255\052\000\
    \052\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \047\000\255\255\047\000\048\000\052\000\048\000\052\000\052\000\
    \052\000\052\000\052\000\255\255\255\255\255\255\053\000\255\255\
    \255\255\053\000\053\000\053\000\255\255\255\255\255\255\255\255\
    \053\000\255\255\053\000\053\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\048\000\255\255\048\000\052\000\053\000\
    \052\000\053\000\053\000\053\000\053\000\053\000\255\255\255\255\
    \255\255\054\000\255\255\255\255\054\000\054\000\054\000\255\255\
    \255\255\255\255\255\255\054\000\255\255\054\000\054\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\052\000\255\255\
    \052\000\053\000\054\000\053\000\054\000\054\000\054\000\054\000\
    \054\000\255\255\255\255\255\255\056\000\255\255\255\255\056\000\
    \056\000\056\000\255\255\255\255\255\255\255\255\056\000\255\255\
    \056\000\056\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\053\000\255\255\053\000\054\000\056\000\054\000\056\000\
    \056\000\056\000\056\000\056\000\255\255\255\255\255\255\058\000\
    \255\255\255\255\058\000\058\000\058\000\255\255\255\255\255\255\
    \255\255\058\000\255\255\058\000\058\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\054\000\255\255\054\000\056\000\
    \058\000\056\000\058\000\058\000\058\000\058\000\058\000\255\255\
    \255\255\255\255\060\000\255\255\255\255\060\000\060\000\060\000\
    \255\255\255\255\255\255\255\255\060\000\255\255\060\000\060\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\056\000\
    \255\255\056\000\058\000\060\000\058\000\060\000\060\000\060\000\
    \060\000\060\000\255\255\255\255\255\255\062\000\255\255\255\255\
    \062\000\062\000\062\000\255\255\255\255\255\255\255\255\062\000\
    \255\255\062\000\062\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\058\000\255\255\058\000\060\000\062\000\060\000\
    \062\000\062\000\062\000\062\000\062\000\255\255\255\255\255\255\
    \255\255\071\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\255\255\060\000\255\255\060\000\
    \062\000\255\255\062\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\255\255\255\255\255\255\
    \062\000\071\000\062\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\075\000\255\255\255\255\
    \075\000\075\000\075\000\255\255\255\255\255\255\255\255\075\000\
    \076\000\075\000\075\000\076\000\076\000\076\000\255\255\255\255\
    \255\255\255\255\076\000\255\255\076\000\076\000\075\000\255\255\
    \075\000\075\000\075\000\075\000\075\000\255\255\255\255\255\255\
    \255\255\076\000\255\255\076\000\076\000\076\000\076\000\076\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \075\000\255\255\075\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\076\000\255\255\076\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \075\000\255\255\075\000\255\255\255\255\077\000\255\255\255\255\
    \255\255\255\255\255\255\076\000\255\255\076\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\255\255\255\255\255\255\255\255\077\000\255\255\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\078\000\255\255\255\255\255\255\078\000\255\255\078\000\
    \255\255\255\255\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\255\255\255\255\255\255\
    \255\255\078\000\255\255\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\079\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\255\255\255\255\255\255\255\255\079\000\255\255\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\080\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\255\255\255\255\255\255\
    \255\255\080\000\255\255\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\081\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\255\255\255\255\255\255\255\255\081\000\255\255\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\082\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\255\255\255\255\255\255\
    \255\255\082\000\255\255\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\082\000\083\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\255\255\255\255\255\255\255\255\083\000\255\255\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\084\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \084\000\255\255\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\255\255\255\255\255\255\
    \255\255\084\000\255\255\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\085\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\255\255\255\255\255\255\255\255\085\000\255\255\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\086\000\255\255\255\255\255\255\086\000\255\255\086\000\
    \255\255\255\255\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\255\255\255\255\255\255\
    \255\255\086\000\255\255\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\087\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\255\255\255\255\255\255\255\255\087\000\255\255\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\089\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\255\255\255\255\255\255\
    \255\255\089\000\255\255\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\089\000\090\000\255\255\255\255\
    \255\255\090\000\255\255\090\000\255\255\255\255\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\255\255\255\255\255\255\255\255\090\000\255\255\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\091\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\255\255\255\255\255\255\
    \255\255\091\000\255\255\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\091\000\091\000\091\000\
    \091\000\091\000\091\000\091\000\091\000\092\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\255\255\255\255\255\255\255\255\092\000\255\255\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\093\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\255\255\255\255\255\255\
    \255\255\093\000\255\255\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\093\000\098\000\255\255\098\000\
    \255\255\255\255\255\255\255\255\098\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\098\000\098\000\098\000\
    \098\000\098\000\098\000\098\000\098\000\098\000\098\000\115\000\
    \255\255\255\255\115\000\115\000\115\000\255\255\255\255\255\255\
    \255\255\115\000\255\255\115\000\115\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \115\000\255\255\115\000\115\000\115\000\115\000\115\000\255\255\
    \255\255\098\000\255\255\255\255\255\255\255\255\255\255\098\000\
    \121\000\255\255\121\000\121\000\121\000\121\000\255\255\255\255\
    \255\255\255\255\121\000\098\000\121\000\121\000\255\255\098\000\
    \255\255\098\000\115\000\255\255\115\000\098\000\255\255\255\255\
    \255\255\121\000\255\255\121\000\121\000\121\000\121\000\121\000\
    \255\255\255\255\255\255\131\000\255\255\255\255\131\000\131\000\
    \131\000\255\255\255\255\255\255\255\255\131\000\255\255\131\000\
    \131\000\255\255\115\000\255\255\115\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\121\000\131\000\121\000\131\000\131\000\
    \131\000\131\000\131\000\255\255\255\255\255\255\132\000\255\255\
    \255\255\132\000\132\000\132\000\255\255\255\255\255\255\255\255\
    \132\000\255\255\132\000\132\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\121\000\255\255\121\000\131\000\132\000\
    \131\000\132\000\132\000\132\000\132\000\132\000\255\255\255\255\
    \255\255\133\000\255\255\255\255\133\000\133\000\133\000\255\255\
    \255\255\255\255\255\255\133\000\255\255\133\000\133\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\131\000\255\255\
    \131\000\132\000\133\000\132\000\133\000\133\000\133\000\133\000\
    \133\000\255\255\255\255\255\255\137\000\255\255\255\255\137\000\
    \137\000\137\000\255\255\255\255\255\255\255\255\137\000\255\255\
    \137\000\137\000\255\255\255\255\255\255\098\000\255\255\255\255\
    \255\255\132\000\255\255\132\000\133\000\137\000\133\000\137\000\
    \137\000\137\000\137\000\137\000\255\255\255\255\255\255\138\000\
    \255\255\255\255\138\000\138\000\138\000\255\255\255\255\255\255\
    \255\255\138\000\255\255\138\000\138\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\133\000\255\255\133\000\137\000\
    \138\000\137\000\138\000\138\000\138\000\138\000\138\000\255\255\
    \255\255\255\255\255\255\140\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\140\000\255\255\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\255\255\137\000\
    \255\255\137\000\138\000\255\255\138\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\255\255\
    \255\255\255\255\138\000\140\000\138\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\141\000\
    \255\255\255\255\141\000\141\000\141\000\255\255\255\255\255\255\
    \255\255\141\000\255\255\141\000\141\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \141\000\255\255\141\000\141\000\141\000\141\000\141\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\143\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\143\000\255\255\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\255\255\141\000\255\255\141\000\143\000\255\255\255\255\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\141\000\255\255\141\000\255\255\143\000\255\255\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\145\000\255\255\255\255\145\000\145\000\145\000\
    \255\255\255\255\255\255\255\255\145\000\146\000\145\000\145\000\
    \146\000\146\000\146\000\255\255\255\255\255\255\255\255\146\000\
    \255\255\146\000\146\000\145\000\255\255\145\000\145\000\145\000\
    \145\000\145\000\255\255\255\255\255\255\255\255\146\000\255\255\
    \146\000\146\000\146\000\146\000\146\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\156\000\255\255\255\255\156\000\
    \156\000\156\000\255\255\255\255\255\255\145\000\156\000\145\000\
    \156\000\156\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \146\000\255\255\146\000\255\255\255\255\156\000\255\255\156\000\
    \156\000\156\000\156\000\156\000\255\255\255\255\255\255\158\000\
    \255\255\255\255\158\000\158\000\158\000\145\000\255\255\145\000\
    \255\255\158\000\255\255\158\000\158\000\255\255\255\255\255\255\
    \146\000\255\255\146\000\255\255\255\255\255\255\255\255\156\000\
    \158\000\156\000\158\000\158\000\158\000\158\000\158\000\255\255\
    \255\255\255\255\159\000\255\255\255\255\159\000\159\000\159\000\
    \255\255\255\255\255\255\255\255\159\000\255\255\159\000\159\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\156\000\
    \255\255\156\000\158\000\159\000\158\000\159\000\159\000\159\000\
    \159\000\159\000\255\255\255\255\255\255\160\000\255\255\255\255\
    \160\000\160\000\160\000\255\255\255\255\255\255\255\255\160\000\
    \255\255\160\000\160\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\158\000\255\255\158\000\159\000\160\000\159\000\
    \160\000\160\000\160\000\160\000\160\000\255\255\255\255\255\255\
    \161\000\255\255\255\255\161\000\161\000\161\000\255\255\255\255\
    \255\255\255\255\161\000\255\255\161\000\161\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\159\000\255\255\159\000\
    \160\000\161\000\160\000\161\000\161\000\161\000\161\000\161\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\177\000\255\255\
    \177\000\255\255\255\255\255\255\255\255\177\000\255\255\255\255\
    \160\000\255\255\160\000\161\000\255\255\161\000\177\000\177\000\
    \177\000\177\000\177\000\177\000\177\000\177\000\177\000\177\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\161\000\255\255\161\000\255\255\255\255\
    \184\000\184\000\184\000\184\000\184\000\184\000\184\000\184\000\
    \184\000\184\000\177\000\255\255\255\255\255\255\255\255\255\255\
    \177\000\184\000\184\000\184\000\184\000\184\000\184\000\255\255\
    \255\255\255\255\255\255\255\255\177\000\255\255\255\255\255\255\
    \177\000\255\255\177\000\255\255\255\255\255\255\177\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\184\000\184\000\184\000\184\000\184\000\184\000\255\255\
    \191\000\191\000\191\000\191\000\191\000\191\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \200\000\255\255\255\255\200\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \191\000\191\000\191\000\191\000\191\000\191\000\200\000\255\255\
    \200\000\255\255\255\255\255\255\255\255\200\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\200\000\200\000\
    \200\000\200\000\200\000\200\000\200\000\200\000\200\000\200\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \203\000\203\000\203\000\203\000\203\000\203\000\203\000\203\000\
    \203\000\203\000\200\000\255\255\255\255\255\255\255\255\255\255\
    \200\000\203\000\203\000\203\000\203\000\203\000\203\000\255\255\
    \255\255\255\255\255\255\255\255\200\000\255\255\255\255\255\255\
    \200\000\255\255\200\000\255\255\255\255\255\255\200\000\211\000\
    \211\000\211\000\211\000\211\000\211\000\211\000\211\000\211\000\
    \211\000\203\000\203\000\203\000\203\000\203\000\203\000\255\255\
    \211\000\211\000\211\000\211\000\211\000\211\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \211\000\211\000\211\000\211\000\211\000\211\000\216\000\255\255\
    \216\000\216\000\216\000\216\000\216\000\216\000\216\000\216\000\
    \216\000\216\000\216\000\216\000\216\000\216\000\216\000\216\000\
    \216\000\216\000\216\000\216\000\216\000\216\000\216\000\216\000\
    \216\000\216\000\255\255\222\000\216\000\222\000\222\000\222\000\
    \222\000\222\000\222\000\222\000\222\000\222\000\222\000\222\000\
    \222\000\222\000\222\000\222\000\222\000\222\000\222\000\222\000\
    \222\000\222\000\222\000\222\000\222\000\222\000\222\000\255\255\
    \255\255\222\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\200\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_base_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\010\000\
    \036\000\000\000\000\000\012\000\000\000\000\000\000\000\002\000\
    \000\000\027\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\
    \004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
  Lexing.lex_backtrk_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\039\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
  Lexing.lex_default_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\019\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
  Lexing.lex_trans_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\000\000\036\000\036\000\000\000\036\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\000\000\000\000\001\000\022\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\007\000\001\000\000\000\000\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\001\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check_code = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\022\000\126\000\200\000\207\000\126\000\208\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \022\000\255\255\126\000\000\000\127\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\119\000\120\000\255\255\255\255\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\119\000\119\000\119\000\119\000\119\000\119\000\
    \119\000\119\000\119\000\119\000\120\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\120\000\120\000\120\000\120\000\
    \120\000\120\000\120\000\120\000\120\000\120\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \126\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_code = 
   "\255\004\255\255\005\255\255\007\255\006\255\255\003\255\000\004\
    \001\005\255\007\255\255\006\255\007\255\255\000\004\001\005\003\
    \006\002\007\255\001\255\255\000\001\255";
}

let rec token lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 8 (-1) ;   __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 336 "src/reason_lexer.mll"
                 (
      match !preprocessor with
      | None ->
        raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf))
      | Some _ ->
        update_loc lexbuf None 1 false 0;
        token lexbuf )
# 1892 "src/reason_lexer.ml"

  | 1 ->
# 345 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        match !preprocessor with
        | None -> token lexbuf
        | Some _ -> EOL
      )
# 1901 "src/reason_lexer.ml"

  | 2 ->
# 351 "src/reason_lexer.mll"
      ( token lexbuf )
# 1906 "src/reason_lexer.ml"

  | 3 ->
# 353 "src/reason_lexer.mll"
      (
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 2 (String.length delim - 2) in
        COLONCOLONLIDENT delim
      )
# 1915 "src/reason_lexer.ml"

  | 4 ->
# 359 "src/reason_lexer.mll"
      (
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 0 (String.length delim - 2) in
        LIDENTCOLONCOLON delim
      )
# 1924 "src/reason_lexer.ml"

  | 5 ->
# 365 "src/reason_lexer.mll"
      ( UNDERSCORE )
# 1929 "src/reason_lexer.ml"

  | 6 ->
# 367 "src/reason_lexer.mll"
      ( TILDE )
# 1934 "src/reason_lexer.ml"

  | 7 ->
# 369 "src/reason_lexer.mll"
      ( QUESTION )
# 1939 "src/reason_lexer.ml"

  | 8 ->
# 372 "src/reason_lexer.mll"
      ( OPTIONAL_NO_DEFAULT )
# 1944 "src/reason_lexer.ml"

  | 9 ->
# 374 "src/reason_lexer.mll"
      ( let s = Lexing.lexeme lexbuf in
        try Hashtbl.find keyword_table s
        with Not_found -> LIDENT s )
# 1951 "src/reason_lexer.ml"

  | 10 ->
# 378 "src/reason_lexer.mll"
      ( warn_latin1 lexbuf; LIDENT (Lexing.lexeme lexbuf) )
# 1956 "src/reason_lexer.ml"

  | 11 ->
# 380 "src/reason_lexer.mll"
      ( UIDENT(Lexing.lexeme lexbuf) )
# 1961 "src/reason_lexer.ml"

  | 12 ->
# 382 "src/reason_lexer.mll"
      ( warn_latin1 lexbuf; UIDENT(Lexing.lexeme lexbuf) )
# 1966 "src/reason_lexer.ml"

  | 13 ->
# 383 "src/reason_lexer.mll"
                ( INT (Lexing.lexeme lexbuf, None) )
# 1971 "src/reason_lexer.ml"

  | 14 ->
let
# 384 "src/reason_lexer.mll"
                    lit
# 1977 "src/reason_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos (lexbuf.Lexing.lex_curr_pos + -1)
and
# 384 "src/reason_lexer.mll"
                                              modif
# 1982 "src/reason_lexer.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_curr_pos + -1) in
# 385 "src/reason_lexer.mll"
      ( INT (lit, Some modif) )
# 1986 "src/reason_lexer.ml"

  | 15 ->
# 387 "src/reason_lexer.mll"
      ( FLOAT (Lexing.lexeme lexbuf, None) )
# 1991 "src/reason_lexer.ml"

  | 16 ->
let
# 388 "src/reason_lexer.mll"
                                            lit
# 1997 "src/reason_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos (lexbuf.Lexing.lex_curr_pos + -1)
and
# 388 "src/reason_lexer.mll"
                                                                      modif
# 2002 "src/reason_lexer.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_curr_pos + -1) in
# 389 "src/reason_lexer.mll"
      ( FLOAT (lit, Some modif) )
# 2006 "src/reason_lexer.ml"

  | 17 ->
# 391 "src/reason_lexer.mll"
      ( raise (Error(Invalid_literal (Lexing.lexeme lexbuf),
                     Location.curr lexbuf)) )
# 2012 "src/reason_lexer.ml"

  | 18 ->
# 394 "src/reason_lexer.mll"
      ( reset_string_buffer();
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        string lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), None) )
# 2024 "src/reason_lexer.ml"

  | 19 ->
# 403 "src/reason_lexer.mll"
      ( reset_string_buffer();
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        quoted_string delim lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), Some delim) )
# 2038 "src/reason_lexer.ml"

  | 20 ->
# 414 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 1;
        CHAR (Lexing.lexeme_char lexbuf 1) )
# 2044 "src/reason_lexer.ml"

  | 21 ->
# 417 "src/reason_lexer.mll"
      ( CHAR(Lexing.lexeme_char lexbuf 1) )
# 2049 "src/reason_lexer.ml"

  | 22 ->
# 419 "src/reason_lexer.mll"
      ( CHAR(char_for_backslash (Lexing.lexeme_char lexbuf 2)) )
# 2054 "src/reason_lexer.ml"

  | 23 ->
# 421 "src/reason_lexer.mll"
      ( CHAR(char_for_decimal_code lexbuf 2) )
# 2059 "src/reason_lexer.ml"

  | 24 ->
# 423 "src/reason_lexer.mll"
      ( CHAR(char_for_hexadecimal_code lexbuf 3) )
# 2064 "src/reason_lexer.ml"

  | 25 ->
# 425 "src/reason_lexer.mll"
      ( let l = Lexing.lexeme lexbuf in
        let esc = String.sub l 1 (String.length l - 1) in
        raise (Error(Illegal_escape esc, Location.curr lexbuf))
      )
# 2072 "src/reason_lexer.ml"

  | 26 ->
# 430 "src/reason_lexer.mll"
      ( let start_loc = Location.curr lexbuf  in
        comment_start_loc := [start_loc];
        reset_string_buffer ();
        let end_loc = comment lexbuf in
        let s = get_stored_string () in
        reset_string_buffer ();
        COMMENT (s, { start_loc with
                      Location.loc_end = end_loc.Location.loc_end })
      )
# 2085 "src/reason_lexer.ml"

  | 27 ->
# 440 "src/reason_lexer.mll"
      ( let loc = Location.curr lexbuf  in
        if !print_warnings then
          Location.prerr_warning loc Warnings.Comment_start;
        comment_start_loc := [loc];
        reset_string_buffer ();
        let end_loc = comment lexbuf in
        let s = get_stored_string () in
        reset_string_buffer ();
        COMMENT (s, { loc with Location.loc_end = end_loc.Location.loc_end })
      )
# 2099 "src/reason_lexer.ml"

  | 28 ->
# 451 "src/reason_lexer.mll"
      ( let loc = Location.curr lexbuf in
        Location.prerr_warning loc Warnings.Comment_not_end;
        lexbuf.Lexing.lex_curr_pos <- lexbuf.Lexing.lex_curr_pos - 1;
        let curpos = lexbuf.lex_curr_p in
        lexbuf.lex_curr_p <- { curpos with pos_cnum = curpos.pos_cnum - 1 };
        STAR
      )
# 2110 "src/reason_lexer.ml"

  | 29 ->
# 459 "src/reason_lexer.mll"
      ( SHARPOP(Lexing.lexeme lexbuf) )
# 2115 "src/reason_lexer.ml"

  | 30 ->
let
# 460 "src/reason_lexer.mll"
                                   num
# 2121 "src/reason_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_mem.(1)
and
# 461 "src/reason_lexer.mll"
                                           name
# 2126 "src/reason_lexer.ml"
= Lexing.sub_lexeme_opt lexbuf lexbuf.Lexing.lex_mem.(3) lexbuf.Lexing.lex_mem.(2) in
# 463 "src/reason_lexer.mll"
      ( update_loc lexbuf name (int_of_string num) true 0;
        token lexbuf
      )
# 2132 "src/reason_lexer.ml"

  | 31 ->
# 466 "src/reason_lexer.mll"
         ( AMPERSAND )
# 2137 "src/reason_lexer.ml"

  | 32 ->
# 467 "src/reason_lexer.mll"
         ( AMPERAMPER )
# 2142 "src/reason_lexer.ml"

  | 33 ->
# 468 "src/reason_lexer.mll"
         ( BACKQUOTE )
# 2147 "src/reason_lexer.ml"

  | 34 ->
# 469 "src/reason_lexer.mll"
         ( QUOTE )
# 2152 "src/reason_lexer.ml"

  | 35 ->
# 470 "src/reason_lexer.mll"
         ( LPAREN )
# 2157 "src/reason_lexer.ml"

  | 36 ->
# 471 "src/reason_lexer.mll"
         ( RPAREN )
# 2162 "src/reason_lexer.ml"

  | 37 ->
# 472 "src/reason_lexer.mll"
         ( STAR )
# 2167 "src/reason_lexer.ml"

  | 38 ->
# 473 "src/reason_lexer.mll"
         ( COMMA )
# 2172 "src/reason_lexer.ml"

  | 39 ->
# 474 "src/reason_lexer.mll"
         ( MINUSGREATER )
# 2177 "src/reason_lexer.ml"

  | 40 ->
# 475 "src/reason_lexer.mll"
         ( EQUALGREATER )
# 2182 "src/reason_lexer.ml"

  | 41 ->
# 476 "src/reason_lexer.mll"
         ( SHARP )
# 2187 "src/reason_lexer.ml"

  | 42 ->
# 477 "src/reason_lexer.mll"
         ( DOT )
# 2192 "src/reason_lexer.ml"

  | 43 ->
# 478 "src/reason_lexer.mll"
         ( DOTDOT )
# 2197 "src/reason_lexer.ml"

  | 44 ->
# 479 "src/reason_lexer.mll"
         ( DOTDOTDOT )
# 2202 "src/reason_lexer.ml"

  | 45 ->
# 480 "src/reason_lexer.mll"
         ( COLON )
# 2207 "src/reason_lexer.ml"

  | 46 ->
# 481 "src/reason_lexer.mll"
         ( COLONCOLON )
# 2212 "src/reason_lexer.ml"

  | 47 ->
# 482 "src/reason_lexer.mll"
         ( COLONEQUAL )
# 2217 "src/reason_lexer.ml"

  | 48 ->
# 483 "src/reason_lexer.mll"
         ( COLONGREATER )
# 2222 "src/reason_lexer.ml"

  | 49 ->
# 484 "src/reason_lexer.mll"
         ( SEMI )
# 2227 "src/reason_lexer.ml"

  | 50 ->
# 485 "src/reason_lexer.mll"
         ( SEMISEMI )
# 2232 "src/reason_lexer.ml"

  | 51 ->
# 486 "src/reason_lexer.mll"
         ( LESS )
# 2237 "src/reason_lexer.ml"

  | 52 ->
# 487 "src/reason_lexer.mll"
         ( LESSMINUS )
# 2242 "src/reason_lexer.ml"

  | 53 ->
# 488 "src/reason_lexer.mll"
         ( EQUAL )
# 2247 "src/reason_lexer.ml"

  | 54 ->
# 489 "src/reason_lexer.mll"
         ( LBRACKET )
# 2252 "src/reason_lexer.ml"

  | 55 ->
# 490 "src/reason_lexer.mll"
         ( LBRACKETBAR )
# 2257 "src/reason_lexer.ml"

  | 56 ->
# 491 "src/reason_lexer.mll"
         ( LBRACKETLESS )
# 2262 "src/reason_lexer.ml"

  | 57 ->
# 492 "src/reason_lexer.mll"
         ( LBRACKETGREATER )
# 2267 "src/reason_lexer.ml"

  | 58 ->
# 493 "src/reason_lexer.mll"
                                                   (
    let buf = Lexing.lexeme lexbuf in
    LESSIDENT (String.sub buf 1 (String.length buf - 1))
  )
# 2275 "src/reason_lexer.ml"

  | 59 ->
# 497 "src/reason_lexer.mll"
                                                        (
    let buf = Lexing.lexeme lexbuf in
    LESSSLASHIDENTGREATER (String.sub buf 2 (String.length buf - 2 - 1))
  )
# 2283 "src/reason_lexer.ml"

  | 60 ->
# 501 "src/reason_lexer.mll"
         ( RBRACKET )
# 2288 "src/reason_lexer.ml"

  | 61 ->
# 502 "src/reason_lexer.mll"
         ( LBRACE )
# 2293 "src/reason_lexer.ml"

  | 62 ->
# 503 "src/reason_lexer.mll"
         ( LBRACELESS )
# 2298 "src/reason_lexer.ml"

  | 63 ->
# 504 "src/reason_lexer.mll"
         ( BAR )
# 2303 "src/reason_lexer.ml"

  | 64 ->
# 505 "src/reason_lexer.mll"
         ( BARBAR )
# 2308 "src/reason_lexer.ml"

  | 65 ->
# 506 "src/reason_lexer.mll"
         ( BARRBRACKET )
# 2313 "src/reason_lexer.ml"

  | 66 ->
# 507 "src/reason_lexer.mll"
         ( GREATER )
# 2318 "src/reason_lexer.ml"

  | 67 ->
# 513 "src/reason_lexer.mll"
         ( RBRACE )
# 2323 "src/reason_lexer.ml"

  | 68 ->
# 514 "src/reason_lexer.mll"
         ( GREATERRBRACE )
# 2328 "src/reason_lexer.ml"

  | 69 ->
# 515 "src/reason_lexer.mll"
         ( LBRACKETAT )
# 2333 "src/reason_lexer.ml"

  | 70 ->
# 516 "src/reason_lexer.mll"
         ( LBRACKETPERCENT )
# 2338 "src/reason_lexer.ml"

  | 71 ->
# 517 "src/reason_lexer.mll"
          ( LBRACKETPERCENTPERCENT )
# 2343 "src/reason_lexer.ml"

  | 72 ->
# 518 "src/reason_lexer.mll"
          ( LBRACKETATAT )
# 2348 "src/reason_lexer.ml"

  | 73 ->
# 519 "src/reason_lexer.mll"
           ( LBRACKETATATAT )
# 2353 "src/reason_lexer.ml"

  | 74 ->
# 520 "src/reason_lexer.mll"
         ( BANG )
# 2358 "src/reason_lexer.ml"

  | 75 ->
# 521 "src/reason_lexer.mll"
         ( INFIXOP0 "!=" )
# 2363 "src/reason_lexer.ml"

  | 76 ->
# 522 "src/reason_lexer.mll"
          ( INFIXOP0 "!==" )
# 2368 "src/reason_lexer.ml"

  | 77 ->
# 523 "src/reason_lexer.mll"
           ( INFIXOP0 "!=" )
# 2373 "src/reason_lexer.ml"

  | 78 ->
# 524 "src/reason_lexer.mll"
            ( INFIXOP0 "!==" )
# 2378 "src/reason_lexer.ml"

  | 79 ->
# 525 "src/reason_lexer.mll"
         ( PLUS )
# 2383 "src/reason_lexer.ml"

  | 80 ->
# 526 "src/reason_lexer.mll"
         ( PLUSDOT )
# 2388 "src/reason_lexer.ml"

  | 81 ->
# 527 "src/reason_lexer.mll"
         ( PLUSEQ )
# 2393 "src/reason_lexer.ml"

  | 82 ->
# 528 "src/reason_lexer.mll"
         ( MINUS )
# 2398 "src/reason_lexer.ml"

  | 83 ->
# 529 "src/reason_lexer.mll"
         ( MINUSDOT )
# 2403 "src/reason_lexer.ml"

  | 84 ->
# 530 "src/reason_lexer.mll"
         ( LESSGREATER )
# 2408 "src/reason_lexer.ml"

  | 85 ->
# 531 "src/reason_lexer.mll"
          ( LESSSLASHGREATER )
# 2413 "src/reason_lexer.ml"

  | 86 ->
# 532 "src/reason_lexer.mll"
           ( LESSDOTDOTGREATER )
# 2418 "src/reason_lexer.ml"

  | 87 ->
# 534 "src/reason_lexer.mll"
            ( PREFIXOP(Lexing.lexeme lexbuf) )
# 2423 "src/reason_lexer.ml"

  | 88 ->
# 536 "src/reason_lexer.mll"
            ( PREFIXOP(Lexing.lexeme lexbuf) )
# 2428 "src/reason_lexer.ml"

  | 89 ->
# 538 "src/reason_lexer.mll"
            ( INFIXOP0(Lexing.lexeme lexbuf) )
# 2433 "src/reason_lexer.ml"

  | 90 ->
# 540 "src/reason_lexer.mll"
            ( INFIXOP1(Lexing.lexeme lexbuf) )
# 2438 "src/reason_lexer.ml"

  | 91 ->
# 542 "src/reason_lexer.mll"
            ( INFIXOP2(Lexing.lexeme lexbuf) )
# 2443 "src/reason_lexer.ml"

  | 92 ->
# 544 "src/reason_lexer.mll"
         ( SLASHGREATER )
# 2448 "src/reason_lexer.ml"

  | 93 ->
# 555 "src/reason_lexer.mll"
            ( INFIXOP4(Lexing.lexeme lexbuf))
# 2453 "src/reason_lexer.ml"

  | 94 ->
# 557 "src/reason_lexer.mll"
            ( INFIXOP4(Lexing.lexeme lexbuf))
# 2458 "src/reason_lexer.ml"

  | 95 ->
# 558 "src/reason_lexer.mll"
            ( PERCENT )
# 2463 "src/reason_lexer.ml"

  | 96 ->
# 560 "src/reason_lexer.mll"
            ( INFIXOP3(Lexing.lexeme lexbuf) )
# 2468 "src/reason_lexer.ml"

  | 97 ->
# 562 "src/reason_lexer.mll"
            ( INFIXOP3(Lexing.lexeme lexbuf))
# 2473 "src/reason_lexer.ml"

  | 98 ->
# 564 "src/reason_lexer.mll"
            ( INFIXOP3(Lexing.lexeme lexbuf) )
# 2478 "src/reason_lexer.ml"

  | 99 ->
# 565 "src/reason_lexer.mll"
        ( EOF )
# 2483 "src/reason_lexer.ml"

  | 100 ->
# 567 "src/reason_lexer.mll"
      ( raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf))
      )
# 2490 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and comment lexbuf =
    __ocaml_lex_comment_rec lexbuf 163
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 573 "src/reason_lexer.mll"
      ( comment_start_loc := (Location.curr lexbuf) :: !comment_start_loc;
        store_lexeme lexbuf;
        comment lexbuf;
      )
# 2505 "src/reason_lexer.ml"

  | 1 ->
# 578 "src/reason_lexer.mll"
      ( match !comment_start_loc with
        | [] -> assert false
        | [_] -> comment_start_loc := []; Location.curr lexbuf
        | _ :: l -> comment_start_loc := l;
                  store_lexeme lexbuf;
                  comment lexbuf;
       )
# 2516 "src/reason_lexer.ml"

  | 2 ->
# 586 "src/reason_lexer.mll"
      (
        string_start_loc := Location.curr lexbuf;
        store_string_char '"';
        is_in_string := true;
        begin try string lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '"';
        comment lexbuf )
# 2537 "src/reason_lexer.ml"

  | 3 ->
# 604 "src/reason_lexer.mll"
      (
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        string_start_loc := Location.curr lexbuf;
        store_lexeme lexbuf;
        is_in_string := true;
        begin try quoted_string delim lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '|';
        store_string delim;
        store_string_char '}';
        comment lexbuf )
# 2562 "src/reason_lexer.ml"

  | 4 ->
# 627 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2567 "src/reason_lexer.ml"

  | 5 ->
# 629 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 1;
        store_lexeme lexbuf;
        comment lexbuf
      )
# 2575 "src/reason_lexer.ml"

  | 6 ->
# 634 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2580 "src/reason_lexer.ml"

  | 7 ->
# 636 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2585 "src/reason_lexer.ml"

  | 8 ->
# 638 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2590 "src/reason_lexer.ml"

  | 9 ->
# 640 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2595 "src/reason_lexer.ml"

  | 10 ->
# 642 "src/reason_lexer.mll"
      ( match !comment_start_loc with
        | [] -> assert false
        | loc :: _ ->
          let start = List.hd (List.rev !comment_start_loc) in
          comment_start_loc := [];
          raise (Error (Unterminated_comment start, loc))
      )
# 2606 "src/reason_lexer.ml"

  | 11 ->
# 650 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        comment lexbuf
      )
# 2614 "src/reason_lexer.ml"

  | 12 ->
# 655 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2619 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

and string lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 2 (-1) ;   __ocaml_lex_string_rec lexbuf 195
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 659 "src/reason_lexer.mll"
      ( () )
# 2631 "src/reason_lexer.ml"

  | 1 ->
let
# 660 "src/reason_lexer.mll"
                                  space
# 2637 "src/reason_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_curr_pos in
# 661 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false (String.length space);
        if in_comment () then store_lexeme lexbuf;
        string lexbuf
      )
# 2644 "src/reason_lexer.ml"

  | 2 ->
# 666 "src/reason_lexer.mll"
      ( if in_comment () then store_lexeme lexbuf
        else store_string_char(char_for_backslash(Lexing.lexeme_char lexbuf 1));
        string lexbuf )
# 2651 "src/reason_lexer.ml"

  | 3 ->
# 670 "src/reason_lexer.mll"
      ( if in_comment () then store_lexeme lexbuf
        else store_string_char(char_for_decimal_code lexbuf 1);
        string lexbuf )
# 2658 "src/reason_lexer.ml"

  | 4 ->
# 674 "src/reason_lexer.mll"
      ( if in_comment () then store_lexeme lexbuf
        else store_string_char(char_for_hexadecimal_code lexbuf 2);
        string lexbuf )
# 2665 "src/reason_lexer.ml"

  | 5 ->
# 678 "src/reason_lexer.mll"
      ( if in_comment ()
        then string lexbuf
        else begin
(*  Should be an error, but we are very lax.
          raise (Error (Illegal_escape (Lexing.lexeme lexbuf),
                        Location.curr lexbuf))
*)
          let loc = Location.curr lexbuf in
          Location.prerr_warning loc Warnings.Illegal_backslash;
          store_string_char (Lexing.lexeme_char lexbuf 0);
          store_string_char (Lexing.lexeme_char lexbuf 1);
          string lexbuf
        end
      )
# 2683 "src/reason_lexer.ml"

  | 6 ->
# 693 "src/reason_lexer.mll"
      ( if not (in_comment ()) then
          Location.prerr_warning (Location.curr lexbuf) Warnings.Eol_in_string;
        update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        string lexbuf
      )
# 2693 "src/reason_lexer.ml"

  | 7 ->
# 700 "src/reason_lexer.mll"
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
# 2699 "src/reason_lexer.ml"

  | 8 ->
# 703 "src/reason_lexer.mll"
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        string lexbuf )
# 2705 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_string_rec lexbuf __ocaml_lex_state

and quoted_string delim lexbuf =
    __ocaml_lex_quoted_string_rec delim lexbuf 214
and __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 708 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        quoted_string delim lexbuf
      )
# 2720 "src/reason_lexer.ml"

  | 1 ->
# 713 "src/reason_lexer.mll"
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
# 2726 "src/reason_lexer.ml"

  | 2 ->
# 716 "src/reason_lexer.mll"
      (
        let edelim = Lexing.lexeme lexbuf in
        let edelim = String.sub edelim 1 (String.length edelim - 2) in
        if delim = edelim then ()
        else (store_lexeme lexbuf; quoted_string delim lexbuf)
      )
# 2736 "src/reason_lexer.ml"

  | 3 ->
# 723 "src/reason_lexer.mll"
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        quoted_string delim lexbuf )
# 2742 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state

and skip_sharp_bang lexbuf =
    __ocaml_lex_skip_sharp_bang_rec lexbuf 223
and __ocaml_lex_skip_sharp_bang_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 728 "src/reason_lexer.mll"
       ( update_loc lexbuf None 3 false 0 )
# 2754 "src/reason_lexer.ml"

  | 1 ->
# 730 "src/reason_lexer.mll"
       ( update_loc lexbuf None 1 false 0 )
# 2759 "src/reason_lexer.ml"

  | 2 ->
# 731 "src/reason_lexer.mll"
       ( () )
# 2764 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_skip_sharp_bang_rec lexbuf __ocaml_lex_state

;;

# 733 "src/reason_lexer.mll"
 

  let token_with_comments lexbuf =
    match !preprocessor with
    | None -> token lexbuf
    | Some (_init, preprocess) -> preprocess token lexbuf

  let last_comments = ref []
  let rec token lexbuf =
    match token_with_comments lexbuf with
        COMMENT (s, comment_loc) ->
          last_comments := (s, comment_loc) :: !last_comments;
          token lexbuf
      | tok -> tok
  let comments () = List.rev !last_comments

  let init () =
    is_in_string := false;
    last_comments := [];
    comment_start_loc := [];
    match !preprocessor with
    | None -> ()
    | Some (init, _preprocess) -> init ()

  let set_preprocessor init preprocess =
    preprocessor := Some (init, preprocess)


# 2800 "src/reason_lexer.ml"

end
module Reason_parser_message
= struct
#1 "reason_parser_message.ml"

(* This file was auto-generated based on "src/reason_parser.messages". *)

(* Please note that the function [message] can raise [Not_found]. *)

let message =
  fun s ->
    match s with
    | 0 ->
        "<SYNTAX ERROR>\n"
    | 733 ->
        "Expecting one of the following:\n  - an identifier to access a member of an object\n  - \"[\" + expression + \"]\" to access an element of a list\n  - \"(\" + expression + \")\"\n  - \"{\" + expression + \"}\"\n"
    | 734 ->
        "Expecting an expression\n"
    | 2208 ->
        "Expecting one of the following:\n  - an infix operation to connect two expressions\n  - \")\" to close the block\n"
    | 2210 ->
        "Expecting an expression\n"
    | 2211 ->
        "Expecting one of the following:\n  - an infix operation to connect two expressions\n  - \"}\" to close the block\n"
    | 2213 ->
        "Expecting an expression\n"
    | 2214 ->
        "Expecting one of the following:\n  - an infix operation to connect two expressions\n  - \"}\" to close the block\n"
    | 890 ->
        "Expecting an expression\n"
    | 738 ->
        "Expecting an identifier\n"
    | 2074 ->
        "Expecting a structure item\n"
    | 2692 ->
        "Invalid token\n"
    | 907 ->
        "Expecting an expression\n"
    | 991 ->
        "Expecting one of the following:\n  - The continuation of the previous expression\n  - \":\" to start the next expression\n"
    | 992 ->
        "Expecting an expression\n"
    | 994 ->
        "Expecting an expression\n"
    | 1000 ->
        "Expecting an expression\n"
    | 1002 ->
        "Expecting an expression\n"
    | 996 ->
        "Expecting an expression\n"
    | 1004 ->
        "Expecting an expression\n"
    | 1006 ->
        "Expecting an expression\n"
    | 1008 ->
        "Expecting an expression\n"
    | 172 ->
        "Expecting one of the following:\n  - \")\" to form a unit value \"()\"\n  - \"module\" to start a module expression\n  - an expression\n  - an operator to denote the prefix form of an operator\n"
    | 178 ->
        "Expecting an expression\n"
    | 1010 ->
        "Expecting an expression\n"
    | 1016 ->
        "Expecting an expression\n"
    | 2461 ->
        "Expecting \"]\"\n"
    | 406 ->
        "Expecting an attributed id\n"
    | 2464 ->
        "Expecting \"]\"\n"
    | 345 ->
        "Expecting an attribute id\n"
    | 892 ->
        "Expecting an expression\n"
    | 998 ->
        "Expecting an expression\n"
    | 1012 ->
        "Expecting an expression\n"
    | 1014 ->
        "Expecting an expression\n"
    | 1018 ->
        "Expecting an expression\n"
    | 1020 ->
        "Expecting an expression\n"
    | 763 ->
        "<SYNTAX ERROR>\n"
    | 764 ->
        "<SYNTAX ERROR>\n"
    | 2128 ->
        "<SYNTAX ERROR>\n"
    | 765 ->
        "<SYNTAX ERROR>\n"
    | 2123 ->
        "<SYNTAX ERROR>\n"
    | 2124 ->
        "<SYNTAX ERROR>\n"
    | 2126 ->
        "<SYNTAX ERROR>\n"
    | 2140 ->
        "<SYNTAX ERROR>\n"
    | 2142 ->
        "<SYNTAX ERROR>\n"
    | 2148 ->
        "<SYNTAX ERROR>\n"
    | 2158 ->
        "<SYNTAX ERROR>\n"
    | 2163 ->
        "<SYNTAX ERROR>\n"
    | 2183 ->
        "<SYNTAX ERROR>\n"
    | 1030 ->
        "<SYNTAX ERROR>\n"
    | 1024 ->
        "<SYNTAX ERROR>\n"
    | 1026 ->
        "<SYNTAX ERROR>\n"
    | 1028 ->
        "<SYNTAX ERROR>\n"
    | 79 ->
        "<SYNTAX ERROR>\n"
    | 108 ->
        "Variant constructors need to begin with an uppercase character\n"
    | 2090 ->
        "<SYNTAX ERROR>\n"
    | 2655 ->
        "Expecting one of the following:\n  - \"=\" to start the body of the type declaration\n  - \"constraint\" to add constraints to the type declaration\n  - \";\" to finish type declaratoin\n  - \"+=\" to form a string type extension\n  - \"and\" to declare another type\n"
    | 82 ->
        "<SYNTAX ERROR>\n"
    | 2659 ->
        "<SYNTAX ERROR>\n"
    | 2663 ->
        "<SYNTAX ERROR>\n"
    | 2660 ->
        "<SYNTAX ERROR>\n"
    | 2661 ->
        "<SYNTAX ERROR>\n"
    | 86 ->
        "<SYNTAX ERROR>\n"
    | 88 ->
        "<SYNTAX ERROR>\n"
    | 90 ->
        "<SYNTAX ERROR>\n"
    | 92 ->
        "<SYNTAX ERROR>\n"
    | 1877 ->
        "<SYNTAX ERROR>\n"
    | 109 ->
        "<SYNTAX ERROR>\n"
    | 2637 ->
        "<SYNTAX ERROR>\n"
    | 2638 ->
        "<SYNTAX ERROR>\n"
    | 2633 ->
        "<SYNTAX ERROR>\n"
    | 2640 ->
        "<SYNTAX ERROR>\n"
    | 2646 ->
        "<SYNTAX ERROR>\n"
    | 2647 ->
        "<SYNTAX ERROR>\n"
    | 2608 ->
        "Variant constructors need to begin with an uppercase character\n"
    | 111 ->
        "<SYNTAX ERROR>\n"
    | 2593 ->
        "<SYNTAX ERROR>\n"
    | 2594 ->
        "<SYNTAX ERROR>\n"
    | 311 ->
        "Expecting at least one type field definition in the form of:\n  <field name> : <type>\n"
    | 159 ->
        "Expecting a type field definition in the form of:\n  <field name> : <type>\n"
    | 2547 ->
        "Expecting \":\"\n"
    | 2548 ->
        "Expecting a type name describing this field\n"
    | 324 ->
        "Expecting one of the following:\n  - \",\" to finish current type field\n  - \"}\" to finish type definition\n"
    | 1886 ->
        "<SYNTAX ERROR>\n"
    | 2630 ->
        "<SYNTAX ERROR>\n"
    | 1777 ->
        "<SYNTAX ERROR>\n"
    | 1778 ->
        "<SYNTAX ERROR>\n"
    | 1779 ->
        "<SYNTAX ERROR>\n"
    | 1878 ->
        "<SYNTAX ERROR>\n"
    | 1884 ->
        "<SYNTAX ERROR>\n"
    | 16 ->
        "<SYNTAX ERROR>\n"
    | 2681 ->
        "<SYNTAX ERROR>\n"
    | 2680 ->
        "<SYNTAX ERROR>\n"
    | 2676 ->
        "This is a reserved keyword. Consider using a different one. For BuckleScript, add an underscore at the end (http://bucklescript.github.io/bucklescript/Manual.html#_object_label_translation_convention).\n"
    | 2683 ->
        "<SYNTAX ERROR>\n"
    | 2374 ->
        "<SYNTAX ERROR>\n"
    | 2375 ->
        "<SYNTAX ERROR>\n"
    | 2376 ->
        "Expecting a sequence item\n"
    | 1087 ->
        "Expecting one of the following:\n  - \"|\" to open the next pattern\n  - \"=>\" to start the body of the matched pattern\n  - \"when\" to start a contitional guard for the previous pattern\n"
    | 2408 ->
        "Expecting the body of the matched pattern\n"
    | 2684 ->
        "Expecting one of the following:\n  - \"}\" to finish the block\n  - \"|\" to start another pattern matching case\n"
    | 2398 ->
        "<SYNTAX ERROR>\n"
    | 2377 ->
        "<SYNTAX ERROR>\n"
    | 2381 ->
        "<SYNTAX ERROR>\n"
    | 2384 ->
        "<SYNTAX ERROR>\n"
    | 2385 ->
        "<SYNTAX ERROR>\n"
    | 2382 ->
        "<SYNTAX ERROR>\n"
    | 2387 ->
        "<SYNTAX ERROR>\n"
    | 2388 ->
        "<SYNTAX ERROR>\n"
    | 2391 ->
        "<SYNTAX ERROR>\n"
    | 794 ->
        "<SYNTAX ERROR>\n"
    | 1086 ->
        "Expecting a match case\n"
    | 864 ->
        "<SYNTAX ERROR>\n"
    | 487 ->
        "<SYNTAX ERROR>\n"
    | 488 ->
        "<SYNTAX ERROR>\n"
    | 865 ->
        "<SYNTAX ERROR>\n"
    | 1032 ->
        "<SYNTAX ERROR>\n"
    | 1035 ->
        "<SYNTAX ERROR>\n"
    | 1049 ->
        "<SYNTAX ERROR>\n"
    | 1037 ->
        "<SYNTAX ERROR>\n"
    | 1038 ->
        "<SYNTAX ERROR>\n"
    | 1041 ->
        "<SYNTAX ERROR>\n"
    | 1043 ->
        "<SYNTAX ERROR>\n"
    | 1044 ->
        "<SYNTAX ERROR>\n"
    | 1046 ->
        "<SYNTAX ERROR>\n"
    | 164 ->
        "<SYNTAX ERROR>\n"
    | 2541 ->
        "<SYNTAX ERROR>\n"
    | 2542 ->
        "<SYNTAX ERROR>\n"
    | 2543 ->
        "The switch expression isn't closed.\n"
    | 1742 ->
        "Incomplete statement. Did you forget a \";\"?\n"
    | 871 ->
        "<SYNTAX ERROR>\n"
    | 870 ->
        "<SYNTAX ERROR>\n"
    | 398 ->
        "<SYNTAX ERROR>\n"
    | 399 ->
        "<SYNTAX ERROR>\n"
    | 347 ->
        "<SYNTAX ERROR>\n"
    | 402 ->
        "<SYNTAX ERROR>\n"
    | 404 ->
        "<SYNTAX ERROR>\n"
    | 1107 ->
        "<SYNTAX ERROR>\n"
    | 1120 ->
        "<SYNTAX ERROR>\n"
    | 1127 ->
        "<SYNTAX ERROR>\n"
    | 1106 ->
        "<SYNTAX ERROR>\n"
    | 1129 ->
        "<SYNTAX ERROR>\n"
    | 1132 ->
        "<SYNTAX ERROR>\n"
    | 558 ->
        "<SYNTAX ERROR>\n"
    | 176 ->
        "<SYNTAX ERROR>\n"
    | 190 ->
        "<SYNTAX ERROR>\n"
    | 191 ->
        "<SYNTAX ERROR>\n"
    | 170 ->
        "<SYNTAX ERROR>\n"
    | 114 ->
        "<SYNTAX ERROR>\n"
    | 115 ->
        "<SYNTAX ERROR>\n"
    | 2498 ->
        "<SYNTAX ERROR>\n"
    | 2500 ->
        "<SYNTAX ERROR>\n"
    | 801 ->
        "<SYNTAX ERROR>\n"
    | 802 ->
        "<SYNTAX ERROR>\n"
    | 188 ->
        "Expecting one of the following:\n  - \")\" to form a unit value \"()\"\n  - \"module\" to start a module expression\n  - an expression\n  - an operator to denote the prefix form of an operator\n"
    | 2509 ->
        "<SYNTAX ERROR>\n"
    | 194 ->
        "Expecting a module expression\n"
    | 2496 ->
        "<SYNTAX ERROR>\n"
    | 2502 ->
        "<SYNTAX ERROR>\n"
    | 2503 ->
        "<SYNTAX ERROR>\n"
    | 2504 ->
        "<SYNTAX ERROR>\n"
    | 2505 ->
        "<SYNTAX ERROR>\n"
    | 2506 ->
        "<SYNTAX ERROR>\n"
    | 2507 ->
        "<SYNTAX ERROR>\n"
    | 888 ->
        "<SYNTAX ERROR>\n"
    | 2486 ->
        "<SYNTAX ERROR>\n"
    | 198 ->
        "<SYNTAX ERROR>\n"
    | 429 ->
        "<SYNTAX ERROR>\n"
    | 2416 ->
        "<SYNTAX ERROR>\n"
    | 2153 ->
        "<SYNTAX ERROR>\n"
    | 2150 ->
        "<SYNTAX ERROR>\n"
    | 444 ->
        "<SYNTAX ERROR>\n"
    | 453 ->
        "<SYNTAX ERROR>\n"
    | 726 ->
        "<SYNTAX ERROR>\n"
    | 735 ->
        "<SYNTAX ERROR>\n"
    | 736 ->
        "<SYNTAX ERROR>\n"
    | 741 ->
        "<SYNTAX ERROR>\n"
    | 742 ->
        "<SYNTAX ERROR>\n"
    | 2205 ->
        "<SYNTAX ERROR>\n"
    | 2191 ->
        "<SYNTAX ERROR>\n"
    | 747 ->
        "<SYNTAX ERROR>\n"
    | 748 ->
        "<SYNTAX ERROR>\n"
    | 750 ->
        "<SYNTAX ERROR>\n"
    | 751 ->
        "<SYNTAX ERROR>\n"
    | 2186 ->
        "<SYNTAX ERROR>\n"
    | 743 ->
        "<SYNTAX ERROR>\n"
    | 744 ->
        "<SYNTAX ERROR>\n"
    | 746 ->
        "<SYNTAX ERROR>\n"
    | 2196 ->
        "<SYNTAX ERROR>\n"
    | 2197 ->
        "<SYNTAX ERROR>\n"
    | 2198 ->
        "<SYNTAX ERROR>\n"
    | 2199 ->
        "<SYNTAX ERROR>\n"
    | 2200 ->
        "<SYNTAX ERROR>\n"
    | 2201 ->
        "<SYNTAX ERROR>\n"
    | 752 ->
        "<SYNTAX ERROR>\n"
    | 754 ->
        "<SYNTAX ERROR>\n"
    | 755 ->
        "<SYNTAX ERROR>\n"
    | 758 ->
        "<SYNTAX ERROR>\n"
    | 1105 ->
        "<SYNTAX ERROR>\n"
    | 515 ->
        "<SYNTAX ERROR>\n"
    | 849 ->
        "<SYNTAX ERROR>\n"
    | 721 ->
        "Incomplete let binding\n"
    | 1907 ->
        "<SYNTAX ERROR>\n"
    | 1913 ->
        "<SYNTAX ERROR>\n"
    | 1908 ->
        "<SYNTAX ERROR>\n"
    | 1909 ->
        "<SYNTAX ERROR>\n"
    | 1910 ->
        "<SYNTAX ERROR>\n"
    | 1912 ->
        "<SYNTAX ERROR>\n"
    | 459 ->
        "<SYNTAX ERROR>\n"
    | 1747 ->
        "<SYNTAX ERROR>\n"
    | 1748 ->
        "<SYNTAX ERROR>\n"
    | 2058 ->
        "<SYNTAX ERROR>\n"
    | 2059 ->
        "<SYNTAX ERROR>\n"
    | 2060 ->
        "<SYNTAX ERROR>\n"
    | 2061 ->
        "<SYNTAX ERROR>\n"
    | 2065 ->
        "<SYNTAX ERROR>\n"
    | 2062 ->
        "<SYNTAX ERROR>\n"
    | 2063 ->
        "<SYNTAX ERROR>\n"
    | 2064 ->
        "<SYNTAX ERROR>\n"
    | 1749 ->
        "<SYNTAX ERROR>\n"
    | 1750 ->
        "<SYNTAX ERROR>\n"
    | 1759 ->
        "<SYNTAX ERROR>\n"
    | 2051 ->
        "<SYNTAX ERROR>\n"
    | 2052 ->
        "<SYNTAX ERROR>\n"
    | 2053 ->
        "<SYNTAX ERROR>\n"
    | 2069 ->
        "<SYNTAX ERROR>\n"
    | 1890 ->
        "<SYNTAX ERROR>\n"
    | 1891 ->
        "<SYNTAX ERROR>\n"
    | 696 ->
        "<SYNTAX ERROR>\n"
    | 2278 ->
        "Defining a function?\nExpecting one of the following:\n  - \"=>\" to start the function body\n  - an identifier to add a function parameter\n  - \":\" to specify the return type\n"
    | 1615 ->
        "<SYNTAX ERROR>\n"
    | 703 ->
        "<SYNTAX ERROR>\n"
    | 704 ->
        "<SYNTAX ERROR>\n"
    | 706 ->
        "<SYNTAX ERROR>\n"
    | 1595 ->
        "Expecting an expression as function body\n"
    | 1616 ->
        "<SYNTAX ERROR>\n"
    | 1617 ->
        "Defining a function?\nExpecting \"=>\" to start the function body\n"
    | 1618 ->
        "<SYNTAX ERROR>\n"
    | 1619 ->
        "<SYNTAX ERROR>\n"
    | 697 ->
        "<SYNTAX ERROR>\n"
    | 698 ->
        "<SYNTAX ERROR>\n"
    | 702 ->
        "<SYNTAX ERROR>\n"
    | 2274 ->
        "<SYNTAX ERROR>\n"
    | 2275 ->
        "<SYNTAX ERROR>\n"
    | 2261 ->
        "<SYNTAX ERROR>\n"
    | 2262 ->
        "<SYNTAX ERROR>\n"
    | 699 ->
        "<SYNTAX ERROR>\n"
    | 2264 ->
        "<SYNTAX ERROR>\n"
    | 2265 ->
        "<SYNTAX ERROR>\n"
    | 2266 ->
        "<SYNTAX ERROR>\n"
    | 2269 ->
        "<SYNTAX ERROR>\n"
    | 2270 ->
        "<SYNTAX ERROR>\n"
    | 2271 ->
        "<SYNTAX ERROR>\n"
    | 2272 ->
        "<SYNTAX ERROR>\n"
    | 2268 ->
        "<SYNTAX ERROR>\n"
    | 1906 ->
        "<SYNTAX ERROR>\n"
    | 73 ->
        "<SYNTAX ERROR>\n"
    | 2220 ->
        "<SYNTAX ERROR>\n"
    | 200 ->
        "<SYNTAX ERROR>\n"
    | 2484 ->
        "<SYNTAX ERROR>\n"
    | 2485 ->
        "<SYNTAX ERROR>\n"
    | 2483 ->
        "<SYNTAX ERROR>\n"
    | 74 ->
        "<SYNTAX ERROR>\n"
    | 1369 ->
        "<SYNTAX ERROR>\n"
    | 722 ->
        "<SYNTAX ERROR>\n"
    | 2143 ->
        "<SYNTAX ERROR>\n"
    | 1110 ->
        "<SYNTAX ERROR>\n"
    | 1112 ->
        "<SYNTAX ERROR>\n"
    | 1115 ->
        "Expecting a type name\n"
    | 169 ->
        "Expecting an expression\n"
    | 902 ->
        "Expecting an expression\n"
    | 862 ->
        "Expecting an expression\n"
    | 727 ->
        "<SYNTAX ERROR>\n"
    | 2218 ->
        "Expecting \"]\" to finish current floating attribute\n"
    | 724 ->
        "<SYNTAX ERROR>\n"
    | 430 ->
        "Expecting one of the following:\n  - an list item\n  - \"]\" to finish this list\n"
    | 2152 ->
        "Expecting one of the following:\n  - \",\" to separate two items in a list\n  - \"]\" to finish this list\n"
    | 2149 ->
        "<SYNTAX ERROR>\n"
    | 182 ->
        "<SYNTAX ERROR>\n"
    | 447 ->
        "<SYNTAX ERROR>\n"
    | 183 ->
        "<SYNTAX ERROR>\n"
    | 2518 ->
        "<SYNTAX ERROR>\n"
    | 1565 ->
        "<SYNTAX ERROR>\n"
    | 1566 ->
        "<SYNTAX ERROR>\n"
    | 1567 ->
        "<SYNTAX ERROR>\n"
    | 1568 ->
        "<SYNTAX ERROR>\n"
    | 1569 ->
        "<SYNTAX ERROR>\n"
    | 1570 ->
        "<SYNTAX ERROR>\n"
    | 1575 ->
        "<SYNTAX ERROR>\n"
    | 1576 ->
        "<SYNTAX ERROR>\n"
    | 1577 ->
        "<SYNTAX ERROR>\n"
    | 1578 ->
        "<SYNTAX ERROR>\n"
    | 1579 ->
        "<SYNTAX ERROR>\n"
    | 1582 ->
        "<SYNTAX ERROR>\n"
    | 1583 ->
        "<SYNTAX ERROR>\n"
    | 1584 ->
        "<SYNTAX ERROR>\n"
    | 1585 ->
        "<SYNTAX ERROR>\n"
    | 1586 ->
        "<SYNTAX ERROR>\n"
    | 1587 ->
        "<SYNTAX ERROR>\n"
    | 1574 ->
        "<SYNTAX ERROR>\n"
    | 2357 ->
        "<SYNTAX ERROR>\n"
    | 2336 ->
        "<SYNTAX ERROR>\n"
    | 1588 ->
        "<SYNTAX ERROR>\n"
    | 1410 ->
        "<SYNTAX ERROR>\n"
    | 1412 ->
        "<SYNTAX ERROR>\n"
    | 1415 ->
        "<SYNTAX ERROR>\n"
    | 1625 ->
        "<SYNTAX ERROR>\n"
    | 1590 ->
        "<SYNTAX ERROR>\n"
    | 1591 ->
        "<SYNTAX ERROR>\n"
    | 1592 ->
        "<SYNTAX ERROR>\n"
    | 1647 ->
        "<SYNTAX ERROR>\n"
    | 1597 ->
        "<SYNTAX ERROR>\n"
    | 1598 ->
        "<SYNTAX ERROR>\n"
    | 1599 ->
        "<SYNTAX ERROR>\n"
    | 1609 ->
        "<SYNTAX ERROR>\n"
    | 1610 ->
        "<SYNTAX ERROR>\n"
    | 1611 ->
        "<SYNTAX ERROR>\n"
    | 1600 ->
        "<SYNTAX ERROR>\n"
    | 1602 ->
        "<SYNTAX ERROR>\n"
    | 1603 ->
        "<SYNTAX ERROR>\n"
    | 1604 ->
        "<SYNTAX ERROR>\n"
    | 1605 ->
        "<SYNTAX ERROR>\n"
    | 1589 ->
        "<SYNTAX ERROR>\n"
    | 2181 ->
        "<SYNTAX ERROR>\n"
    | 2172 ->
        "<SYNTAX ERROR>\n"
    | 2170 ->
        "<SYNTAX ERROR>\n"
    | 2173 ->
        "<SYNTAX ERROR>\n"
    | 2174 ->
        "<SYNTAX ERROR>\n"
    | 2184 ->
        "<SYNTAX ERROR>\n"
    | 2185 ->
        "<SYNTAX ERROR>\n"
    | 456 ->
        "<SYNTAX ERROR>\n"
    | 2311 ->
        "<SYNTAX ERROR>\n"
    | 2314 ->
        "<SYNTAX ERROR>\n"
    | 2315 ->
        "<SYNTAX ERROR>\n"
    | 2312 ->
        "<SYNTAX ERROR>\n"
    | 2317 ->
        "<SYNTAX ERROR>\n"
    | 2318 ->
        "<SYNTAX ERROR>\n"
    | 2329 ->
        "<SYNTAX ERROR>\n"
    | 2301 ->
        "Expecting \"}\" to finish the block\n"
    | 1628 ->
        "<SYNTAX ERROR>\n"
    | 1629 ->
        "<SYNTAX ERROR>\n"
    | 1632 ->
        "<SYNTAX ERROR>\n"
    | 1473 ->
        "<SYNTAX ERROR>\n"
    | 1662 ->
        "<SYNTAX ERROR>\n"
    | 1665 ->
        "<SYNTAX ERROR>\n"
    | 1673 ->
        "<SYNTAX ERROR>\n"
    | 1666 ->
        "<SYNTAX ERROR>\n"
    | 1429 ->
        "<SYNTAX ERROR>\n"
    | 1430 ->
        "<SYNTAX ERROR>\n"
    | 1434 ->
        "<SYNTAX ERROR>\n"
    | 1435 ->
        "<SYNTAX ERROR>\n"
    | 1667 ->
        "<SYNTAX ERROR>\n"
    | 1381 ->
        "<SYNTAX ERROR>\n"
    | 1672 ->
        "<SYNTAX ERROR>\n"
    | 1669 ->
        "<SYNTAX ERROR>\n"
    | 1670 ->
        "<SYNTAX ERROR>\n"
    | 1671 ->
        "<SYNTAX ERROR>\n"
    | 1668 ->
        "<SYNTAX ERROR>\n"
    | 1678 ->
        "<SYNTAX ERROR>\n"
    | 1679 ->
        "<SYNTAX ERROR>\n"
    | 1542 ->
        "<SYNTAX ERROR>\n"
    | 1543 ->
        "<SYNTAX ERROR>\n"
    | 1648 ->
        "<SYNTAX ERROR>\n"
    | 1634 ->
        "<SYNTAX ERROR>\n"
    | 1635 ->
        "<SYNTAX ERROR>\n"
    | 1474 ->
        "<SYNTAX ERROR>\n"
    | 1561 ->
        "<SYNTAX ERROR>\n"
    | 1652 ->
        "<SYNTAX ERROR>\n"
    | 1475 ->
        "<SYNTAX ERROR>\n"
    | 1557 ->
        "<SYNTAX ERROR>\n"
    | 1558 ->
        "<SYNTAX ERROR>\n"
    | 1532 ->
        "<SYNTAX ERROR>\n"
    | 1534 ->
        "<SYNTAX ERROR>\n"
    | 1535 ->
        "<SYNTAX ERROR>\n"
    | 1545 ->
        "<SYNTAX ERROR>\n"
    | 1536 ->
        "<SYNTAX ERROR>\n"
    | 1537 ->
        "<SYNTAX ERROR>\n"
    | 1538 ->
        "<SYNTAX ERROR>\n"
    | 1633 ->
        "<SYNTAX ERROR>\n"
    | 2284 ->
        "<SYNTAX ERROR>\n"
    | 2285 ->
        "<SYNTAX ERROR>\n"
    | 2286 ->
        "<SYNTAX ERROR>\n"
    | 1639 ->
        "<SYNTAX ERROR>\n"
    | 1442 ->
        "<SYNTAX ERROR>\n"
    | 1443 ->
        "<SYNTAX ERROR>\n"
    | 1552 ->
        "<SYNTAX ERROR>\n"
    | 1553 ->
        "<SYNTAX ERROR>\n"
    | 1564 ->
        "<SYNTAX ERROR>\n"
    | 1149 ->
        "<SYNTAX ERROR>\n"
    | 1752 ->
        "<SYNTAX ERROR>\n"
    | 1155 ->
        "<SYNTAX ERROR>\n"
    | 1156 ->
        "<SYNTAX ERROR>\n"
    | 1157 ->
        "<SYNTAX ERROR>\n"
    | 1159 ->
        "<SYNTAX ERROR>\n"
    | 1162 ->
        "<SYNTAX ERROR>\n"
    | 1169 ->
        "<SYNTAX ERROR>\n"
    | 1148 ->
        "<SYNTAX ERROR>\n"
    | 2109 ->
        "<SYNTAX ERROR>\n"
    | 416 ->
        "<SYNTAX ERROR>\n"
    | 417 ->
        "<SYNTAX ERROR>\n"
    | 2449 ->
        "<SYNTAX ERROR>\n"
    | 2451 ->
        "<SYNTAX ERROR>\n"
    | 1160 ->
        "<SYNTAX ERROR>\n"
    | 2453 ->
        "<SYNTAX ERROR>\n"
    | 1165 ->
        "<SYNTAX ERROR>\n"
    | 1166 ->
        "<SYNTAX ERROR>\n"
    | 2455 ->
        "<SYNTAX ERROR>\n"
    | 1172 ->
        "<SYNTAX ERROR>\n"
    | 2104 ->
        "<SYNTAX ERROR>\n"
    | 1150 ->
        "<SYNTAX ERROR>\n"
    | 1151 ->
        "<SYNTAX ERROR>\n"
    | 1152 ->
        "<SYNTAX ERROR>\n"
    | 1154 ->
        "<SYNTAX ERROR>\n"
    | 408 ->
        "A module's name needs to begin with a upper-case letter\n"
    | 409 ->
        "<SYNTAX ERROR>\n"
    | 412 ->
        "<SYNTAX ERROR>\n"
    | 1304 ->
        "<SYNTAX ERROR>\n"
    | 1305 ->
        "<SYNTAX ERROR>\n"
    | 1306 ->
        "<SYNTAX ERROR>\n"
    | 1307 ->
        "<SYNTAX ERROR>\n"
    | 1308 ->
        "<SYNTAX ERROR>\n"
    | 1309 ->
        "<SYNTAX ERROR>\n"
    | 1315 ->
        "<SYNTAX ERROR>\n"
    | 1316 ->
        "<SYNTAX ERROR>\n"
    | 1326 ->
        "<SYNTAX ERROR>\n"
    | 1331 ->
        "<SYNTAX ERROR>\n"
    | 1317 ->
        "<SYNTAX ERROR>\n"
    | 1318 ->
        "<SYNTAX ERROR>\n"
    | 1319 ->
        "<SYNTAX ERROR>\n"
    | 1324 ->
        "<SYNTAX ERROR>\n"
    | 1339 ->
        "<SYNTAX ERROR>\n"
    | 1371 ->
        "<SYNTAX ERROR>\n"
    | 1467 ->
        "<SYNTAX ERROR>\n"
    | 1373 ->
        "<SYNTAX ERROR>\n"
    | 1374 ->
        "<SYNTAX ERROR>\n"
    | 1376 ->
        "<SYNTAX ERROR>\n"
    | 1379 ->
        "<SYNTAX ERROR>\n"
    | 1457 ->
        "<SYNTAX ERROR>\n"
    | 1895 ->
        "<SYNTAX ERROR>\n"
    | 1896 ->
        "<SYNTAX ERROR>\n"
    | 1469 ->
        "<SYNTAX ERROR>\n"
    | 1720 ->
        "<SYNTAX ERROR>\n"
    | 1721 ->
        "<SYNTAX ERROR>\n"
    | 1722 ->
        "<SYNTAX ERROR>\n"
    | 1723 ->
        "<SYNTAX ERROR>\n"
    | 1727 ->
        "<SYNTAX ERROR>\n"
    | 1728 ->
        "<SYNTAX ERROR>\n"
    | 1729 ->
        "<SYNTAX ERROR>\n"
    | 1472 ->
        "<SYNTAX ERROR>\n"
    | 1684 ->
        "<SYNTAX ERROR>\n"
    | 1900 ->
        "<SYNTAX ERROR>\n"
    | 1901 ->
        "<SYNTAX ERROR>\n"
    | 1685 ->
        "<SYNTAX ERROR>\n"
    | 1715 ->
        "<SYNTAX ERROR>\n"
    | 1716 ->
        "<SYNTAX ERROR>\n"
    | 1717 ->
        "<SYNTAX ERROR>\n"
    | 767 ->
        "<SYNTAX ERROR>\n"
    | 771 ->
        "<SYNTAX ERROR>\n"
    | 772 ->
        "<SYNTAX ERROR>\n"
    | 2118 ->
        "<SYNTAX ERROR>\n"
    | 707 ->
        "<SYNTAX ERROR>\n"
    | 708 ->
        "<SYNTAX ERROR>\n"
    | 710 ->
        "<SYNTAX ERROR>\n"
    | 711 ->
        "<SYNTAX ERROR>\n"
    | 753 ->
        "<SYNTAX ERROR>\n"
    | 759 ->
        "<SYNTAX ERROR>\n"
    | 1692 ->
        "<SYNTAX ERROR>\n"
    | 1693 ->
        "<SYNTAX ERROR>\n"
    | 1724 ->
        "<SYNTAX ERROR>\n"
    | 1725 ->
        "<SYNTAX ERROR>\n"
    | 1697 ->
        "<SYNTAX ERROR>\n"
    | 1698 ->
        "<SYNTAX ERROR>\n"
    | 1731 ->
        "<SYNTAX ERROR>\n"
    | 1688 ->
        "<SYNTAX ERROR>\n"
    | 1389 ->
        "<SYNTAX ERROR>\n"
    | 1390 ->
        "<SYNTAX ERROR>\n"
    | 1391 ->
        "<SYNTAX ERROR>\n"
    | 1392 ->
        "<SYNTAX ERROR>\n"
    | 1393 ->
        "<SYNTAX ERROR>\n"
    | 1395 ->
        "<SYNTAX ERROR>\n"
    | 1396 ->
        "<SYNTAX ERROR>\n"
    | 1397 ->
        "<SYNTAX ERROR>\n"
    | 1398 ->
        "<SYNTAX ERROR>\n"
    | 1402 ->
        "<SYNTAX ERROR>\n"
    | 1403 ->
        "<SYNTAX ERROR>\n"
    | 1405 ->
        "<SYNTAX ERROR>\n"
    | 1407 ->
        "<SYNTAX ERROR>\n"
    | 1423 ->
        "<SYNTAX ERROR>\n"
    | 1422 ->
        "<SYNTAX ERROR>\n"
    | 1408 ->
        "<SYNTAX ERROR>\n"
    | 1409 ->
        "<SYNTAX ERROR>\n"
    | 1689 ->
        "<SYNTAX ERROR>\n"
    | 1428 ->
        "<SYNTAX ERROR>\n"
    | 1436 ->
        "<SYNTAX ERROR>\n"
    | 1441 ->
        "<SYNTAX ERROR>\n"
    | 1382 ->
        "<SYNTAX ERROR>\n"
    | 1383 ->
        "<SYNTAX ERROR>\n"
    | 1388 ->
        "<SYNTAX ERROR>\n"
    | 1459 ->
        "<SYNTAX ERROR>\n"
    | 1470 ->
        "<SYNTAX ERROR>\n"
    | 1471 ->
        "<SYNTAX ERROR>\n"
    | 1707 ->
        "<SYNTAX ERROR>\n"
    | 1686 ->
        "<SYNTAX ERROR>\n"
    | 1706 ->
        "<SYNTAX ERROR>\n"
    | 1703 ->
        "<SYNTAX ERROR>\n"
    | 1704 ->
        "<SYNTAX ERROR>\n"
    | 1705 ->
        "<SYNTAX ERROR>\n"
    | 1702 ->
        "<SYNTAX ERROR>\n"
    | 1713 ->
        "<SYNTAX ERROR>\n"
    | 2695 ->
        "<SYNTAX ERROR>\n"
    | 2079 ->
        "<SYNTAX ERROR>\n"
    | 1177 ->
        "<SYNTAX ERROR>\n"
    | 2697 ->
        "<SYNTAX ERROR>\n"
    | 1296 ->
        "<SYNTAX ERROR>\n"
    | 2080 ->
        "<SYNTAX ERROR>\n"
    | 2085 ->
        "<SYNTAX ERROR>\n"
    | 2082 ->
        "<SYNTAX ERROR>\n"
    | 2083 ->
        "<SYNTAX ERROR>\n"
    | 2696 ->
        "<SYNTAX ERROR>\n"
    | 1824 ->
        "<SYNTAX ERROR>\n"
    | 1825 ->
        "<SYNTAX ERROR>\n"
    | 1827 ->
        "<SYNTAX ERROR>\n"
    | 1864 ->
        "<SYNTAX ERROR>\n"
    | 1990 ->
        "<SYNTAX ERROR>\n"
    | 1991 ->
        "<SYNTAX ERROR>\n"
    | 1992 ->
        "<SYNTAX ERROR>\n"
    | 1993 ->
        "<SYNTAX ERROR>\n"
    | 1994 ->
        "<SYNTAX ERROR>\n"
    | 1995 ->
        "<SYNTAX ERROR>\n"
    | 1996 ->
        "<SYNTAX ERROR>\n"
    | 2002 ->
        "<SYNTAX ERROR>\n"
    | 2004 ->
        "<SYNTAX ERROR>\n"
    | 1997 ->
        "<SYNTAX ERROR>\n"
    | 1998 ->
        "<SYNTAX ERROR>\n"
    | 2009 ->
        "<SYNTAX ERROR>\n"
    | 2010 ->
        "<SYNTAX ERROR>\n"
    | 2011 ->
        "<SYNTAX ERROR>\n"
    | 2012 ->
        "<SYNTAX ERROR>\n"
    | 2025 ->
        "<SYNTAX ERROR>\n"
    | 2026 ->
        "<SYNTAX ERROR>\n"
    | 624 ->
        "<SYNTAX ERROR>\n"
    | 1865 ->
        "<SYNTAX ERROR>\n"
    | 1866 ->
        "<SYNTAX ERROR>\n"
    | 1934 ->
        "<SYNTAX ERROR>\n"
    | 1832 ->
        "<SYNTAX ERROR>\n"
    | 1833 ->
        "<SYNTAX ERROR>\n"
    | 1835 ->
        "<SYNTAX ERROR>\n"
    | 1770 ->
        "<SYNTAX ERROR>\n"
    | 1840 ->
        "<SYNTAX ERROR>\n"
    | 1838 ->
        "<SYNTAX ERROR>\n"
    | 1836 ->
        "<SYNTAX ERROR>\n"
    | 1848 ->
        "<SYNTAX ERROR>\n"
    | 1849 ->
        "<SYNTAX ERROR>\n"
    | 1841 ->
        "<SYNTAX ERROR>\n"
    | 1842 ->
        "<SYNTAX ERROR>\n"
    | 1846 ->
        "<SYNTAX ERROR>\n"
    | 95 ->
        "<SYNTAX ERROR>\n"
    | 1845 ->
        "<SYNTAX ERROR>\n"
    | 1843 ->
        "<SYNTAX ERROR>\n"
    | 133 ->
        "<SYNTAX ERROR>\n"
    | 788 ->
        "<SYNTAX ERROR>\n"
    | 1852 ->
        "<SYNTAX ERROR>\n"
    | 1853 ->
        "<SYNTAX ERROR>\n"
    | 789 ->
        "<SYNTAX ERROR>\n"
    | 790 ->
        "<SYNTAX ERROR>\n"
    | 773 ->
        "<SYNTAX ERROR>\n"
    | 774 ->
        "<SYNTAX ERROR>\n"
    | 1760 ->
        "<SYNTAX ERROR>\n"
    | 1817 ->
        "<SYNTAX ERROR>\n"
    | 1818 ->
        "<SYNTAX ERROR>\n"
    | 2047 ->
        "<SYNTAX ERROR>\n"
    | 2048 ->
        "<SYNTAX ERROR>\n"
    | 2049 ->
        "<SYNTAX ERROR>\n"
    | 2050 ->
        "<SYNTAX ERROR>\n"
    | 1766 ->
        "<SYNTAX ERROR>\n"
    | 1767 ->
        "<SYNTAX ERROR>\n"
    | 1769 ->
        "<SYNTAX ERROR>\n"
    | 1776 ->
        "<SYNTAX ERROR>\n"
    | 1774 ->
        "<SYNTAX ERROR>\n"
    | 1772 ->
        "<SYNTAX ERROR>\n"
    | 1802 ->
        "<SYNTAX ERROR>\n"
    | 1803 ->
        "<SYNTAX ERROR>\n"
    | 1782 ->
        "<SYNTAX ERROR>\n"
    | 1783 ->
        "<SYNTAX ERROR>\n"
    | 1800 ->
        "<SYNTAX ERROR>\n"
    | 1785 ->
        "<SYNTAX ERROR>\n"
    | 1799 ->
        "<SYNTAX ERROR>\n"
    | 1784 ->
        "<SYNTAX ERROR>\n"
    | 1786 ->
        "<SYNTAX ERROR>\n"
    | 1787 ->
        "<SYNTAX ERROR>\n"
    | 1790 ->
        "<SYNTAX ERROR>\n"
    | 1174 ->
        "<SYNTAX ERROR>\n"
    | 473 ->
        "<SYNTAX ERROR>\n"
    | 1807 ->
        "<SYNTAX ERROR>\n"
    | 1808 ->
        "<SYNTAX ERROR>\n"
    | 474 ->
        "<SYNTAX ERROR>\n"
    | 475 ->
        "<SYNTAX ERROR>\n"
    | 413 ->
        "<SYNTAX ERROR>\n"
    | 414 ->
        "<SYNTAX ERROR>\n"
    | 1173 ->
        "<SYNTAX ERROR>\n"
    | 2098 ->
        "<SYNTAX ERROR>\n"
    | 2099 ->
        "<SYNTAX ERROR>\n"
    | 2100 ->
        "<SYNTAX ERROR>\n"
    | 2101 ->
        "<SYNTAX ERROR>\n"
    | 2102 ->
        "<SYNTAX ERROR>\n"
    | 2103 ->
        "<SYNTAX ERROR>\n"
    | 2095 ->
        "<SYNTAX ERROR>\n"
    | 1764 ->
        "<SYNTAX ERROR>\n"
    | 1175 ->
        "<SYNTAX ERROR>\n"
    | 1819 ->
        "<SYNTAX ERROR>\n"
    | 1986 ->
        "<SYNTAX ERROR>\n"
    | 1985 ->
        "<SYNTAX ERROR>\n"
    | 1937 ->
        "<SYNTAX ERROR>\n"
    | 1938 ->
        "<SYNTAX ERROR>\n"
    | 1939 ->
        "<SYNTAX ERROR>\n"
    | 1940 ->
        "<SYNTAX ERROR>\n"
    | 1941 ->
        "<SYNTAX ERROR>\n"
    | 1946 ->
        "<SYNTAX ERROR>\n"
    | 1947 ->
        "<SYNTAX ERROR>\n"
    | 1969 ->
        "<SYNTAX ERROR>\n"
    | 1978 ->
        "<SYNTAX ERROR>\n"
    | 1980 ->
        "<SYNTAX ERROR>\n"
    | 1458 ->
        "<SYNTAX ERROR>\n"
    | 1981 ->
        "<SYNTAX ERROR>\n"
    | 2035 ->
        "<SYNTAX ERROR>\n"
    | 2036 ->
        "<SYNTAX ERROR>\n"
    | 2702 ->
        "<SYNTAX ERROR>\n"
    | 2704 ->
        "<SYNTAX ERROR>\n"
    | 279 ->
        "<SYNTAX ERROR>\n"
    | 283 ->
        "<SYNTAX ERROR>\n"
    | 284 ->
        "<SYNTAX ERROR>\n"
    | 204 ->
        "<SYNTAX ERROR>\n"
    | 94 ->
        "<SYNTAX ERROR>\n"
    | 96 ->
        "<SYNTAX ERROR>\n"
    | 98 ->
        "<SYNTAX ERROR>\n"
    | 205 ->
        "<SYNTAX ERROR>\n"
    | 123 ->
        "<SYNTAX ERROR>\n"
    | 9 ->
        "<SYNTAX ERROR>\n"
    | 10 ->
        "<SYNTAX ERROR>\n"
    | 2578 ->
        "<SYNTAX ERROR>\n"
    | 127 ->
        "<SYNTAX ERROR>\n"
    | 1202 ->
        "Expecting one of the following:\n  - \",\" to start the type in the tuple\n  - \")\" to finish the tuple type definition\n"
    | 1204 ->
        "<SYNTAX ERROR>\n"
    | 132 ->
        "<SYNTAX ERROR>\n"
    | 137 ->
        "<SYNTAX ERROR>\n"
    | 138 ->
        "<SYNTAX ERROR>\n"
    | 143 ->
        "<SYNTAX ERROR>\n"
    | 144 ->
        "<SYNTAX ERROR>\n"
    | 2575 ->
        "<SYNTAX ERROR>\n"
    | 2576 ->
        "<SYNTAX ERROR>\n"
    | 136 ->
        "<SYNTAX ERROR>\n"
    | 134 ->
        "<SYNTAX ERROR>\n"
    | 265 ->
        "<SYNTAX ERROR>\n"
    | 125 ->
        "<SYNTAX ERROR>\n"
    | 154 ->
        "<SYNTAX ERROR>\n"
    | 2557 ->
        "<SYNTAX ERROR>\n"
    | 1505 ->
        "<SYNTAX ERROR>\n"
    | 1413 ->
        "<SYNTAX ERROR>\n"
    | 1606 ->
        "<SYNTAX ERROR>\n"
    | 1607 ->
        "<SYNTAX ERROR>\n"
    | 325 ->
        "<SYNTAX ERROR>\n"
    | 157 ->
        "<SYNTAX ERROR>\n"
    | 147 ->
        "<SYNTAX ERROR>\n"
    | 2562 ->
        "<SYNTAX ERROR>\n"
    | 2564 ->
        "<SYNTAX ERROR>\n"
    | 2565 ->
        "<SYNTAX ERROR>\n"
    | 255 ->
        "<SYNTAX ERROR>\n"
    | 149 ->
        "<SYNTAX ERROR>\n"
    | 150 ->
        "<SYNTAX ERROR>\n"
    | 2560 ->
        "<SYNTAX ERROR>\n"
    | 152 ->
        "<SYNTAX ERROR>\n"
    | 153 ->
        "<SYNTAX ERROR>\n"
    | 1231 ->
        "<SYNTAX ERROR>\n"
    | 1232 ->
        "<SYNTAX ERROR>\n"
    | 1233 ->
        "<SYNTAX ERROR>\n"
    | 1226 ->
        "<SYNTAX ERROR>\n"
    | 1227 ->
        "<SYNTAX ERROR>\n"
    | 1229 ->
        "<SYNTAX ERROR>\n"
    | 288 ->
        "<SYNTAX ERROR>\n"
    | 263 ->
        "<SYNTAX ERROR>\n"
    | 2706 ->
        "<SYNTAX ERROR>\n"
    | 2708 ->
        "<SYNTAX ERROR>\n"
    | 2710 ->
        "<SYNTAX ERROR>\n"
    | 2711 ->
        "<SYNTAX ERROR>\n"
    | 632 ->
        "<SYNTAX ERROR>\n"
    | 614 ->
        "<SYNTAX ERROR>\n"
    | 587 ->
        "<SYNTAX ERROR>\n"
    | 420 ->
        "<SYNTAX ERROR>\n"
    | 597 ->
        "<SYNTAX ERROR>\n"
    | 202 ->
        "<SYNTAX ERROR>\n"
    | 207 ->
        "<SYNTAX ERROR>\n"
    | 210 ->
        "<SYNTAX ERROR>\n"
    | 213 ->
        "<SYNTAX ERROR>\n"
    | 590 ->
        "<SYNTAX ERROR>\n"
    | 591 ->
        "<SYNTAX ERROR>\n"
    | 588 ->
        "<SYNTAX ERROR>\n"
    | 630 ->
        "<SYNTAX ERROR>\n"
    | 563 ->
        "<SYNTAX ERROR>\n"
    | 642 ->
        "<SYNTAX ERROR>\n"
    | 648 ->
        "<SYNTAX ERROR>\n"
    | 652 ->
        "<SYNTAX ERROR>\n"
    | 653 ->
        "<SYNTAX ERROR>\n"
    | 240 ->
        "<SYNTAX ERROR>\n"
    | 330 ->
        "<SYNTAX ERROR>\n"
    | 118 ->
        "<SYNTAX ERROR>\n"
    | 2582 ->
        "<SYNTAX ERROR>\n"
    | 2579 ->
        "<SYNTAX ERROR>\n"
    | 2580 ->
        "<SYNTAX ERROR>\n"
    | 341 ->
        "<SYNTAX ERROR>\n"
    | 112 ->
        "<SYNTAX ERROR>\n"
    | 313 ->
        "<SYNTAX ERROR>\n"
    | 242 ->
        "<SYNTAX ERROR>\n"
    | 248 ->
        "<SYNTAX ERROR>\n"
    | 250 ->
        "<SYNTAX ERROR>\n"
    | 251 ->
        "<SYNTAX ERROR>\n"
    | 243 ->
        "<SYNTAX ERROR>\n"
    | 296 ->
        "<SYNTAX ERROR>\n"
    | 299 ->
        "<SYNTAX ERROR>\n"
    | 298 ->
        "<SYNTAX ERROR>\n"
    | 301 ->
        "<SYNTAX ERROR>\n"
    | 307 ->
        "<SYNTAX ERROR>\n"
    | 308 ->
        "<SYNTAX ERROR>\n"
    | 309 ->
        "<SYNTAX ERROR>\n"
    | 302 ->
        "<SYNTAX ERROR>\n"
    | 303 ->
        "<SYNTAX ERROR>\n"
    | 305 ->
        "<SYNTAX ERROR>\n"
    | 575 ->
        "<SYNTAX ERROR>\n"
    | 540 ->
        "<SYNTAX ERROR>\n"
    | 502 ->
        "<SYNTAX ERROR>\n"
    | 530 ->
        "<SYNTAX ERROR>\n"
    | 521 ->
        "<SYNTAX ERROR>\n"
    | 215 ->
        "<SYNTAX ERROR>\n"
    | 218 ->
        "<SYNTAX ERROR>\n"
    | 219 ->
        "<SYNTAX ERROR>\n"
    | 224 ->
        "<SYNTAX ERROR>\n"
    | 227 ->
        "<SYNTAX ERROR>\n"
    | 228 ->
        "<SYNTAX ERROR>\n"
    | 230 ->
        "<SYNTAX ERROR>\n"
    | 236 ->
        "<SYNTAX ERROR>\n"
    | 237 ->
        "<SYNTAX ERROR>\n"
    | 238 ->
        "<SYNTAX ERROR>\n"
    | 239 ->
        "<SYNTAX ERROR>\n"
    | 2472 ->
        "<SYNTAX ERROR>\n"
    | 2473 ->
        "<SYNTAX ERROR>\n"
    | 231 ->
        "<SYNTAX ERROR>\n"
    | 235 ->
        "<SYNTAX ERROR>\n"
    | 479 ->
        "<SYNTAX ERROR>\n"
    | 465 ->
        "<SYNTAX ERROR>\n"
    | 561 ->
        "<SYNTAX ERROR>\n"
    | 664 ->
        "<SYNTAX ERROR>\n"
    | 466 ->
        "<SYNTAX ERROR>\n"
    | 467 ->
        "<SYNTAX ERROR>\n"
    | 469 ->
        "<SYNTAX ERROR>\n"
    | 683 ->
        "<SYNTAX ERROR>\n"
    | 684 ->
        "<SYNTAX ERROR>\n"
    | 685 ->
        "<SYNTAX ERROR>\n"
    | 686 ->
        "<SYNTAX ERROR>\n"
    | 687 ->
        "<SYNTAX ERROR>\n"
    | 688 ->
        "<SYNTAX ERROR>\n"
    | 482 ->
        "<SYNTAX ERROR>\n"
    | 679 ->
        "<SYNTAX ERROR>\n"
    | 483 ->
        "<SYNTAX ERROR>\n"
    | 672 ->
        "<SYNTAX ERROR>\n"
    | 485 ->
        "<SYNTAX ERROR>\n"
    | 490 ->
        "<SYNTAX ERROR>\n"
    | 501 ->
        "<SYNTAX ERROR>\n"
    | 513 ->
        "<SYNTAX ERROR>\n"
    | 2475 ->
        "<SYNTAX ERROR>\n"
    | 2476 ->
        "<SYNTAX ERROR>\n"
    | 2477 ->
        "<SYNTAX ERROR>\n"
    | 2478 ->
        "<SYNTAX ERROR>\n"
    | 2479 ->
        "<SYNTAX ERROR>\n"
    | 2480 ->
        "<SYNTAX ERROR>\n"
    | 460 ->
        "<SYNTAX ERROR>\n"
    | 693 ->
        "<SYNTAX ERROR>\n"
    | 682 ->
        "<SYNTAX ERROR>\n"
    | 677 ->
        "<SYNTAX ERROR>\n"
    | 678 ->
        "<SYNTAX ERROR>\n"
    | 461 ->
        "<SYNTAX ERROR>\n"
    | 462 ->
        "<SYNTAX ERROR>\n"
    | 564 ->
        "<SYNTAX ERROR>\n"
    | 568 ->
        "<SYNTAX ERROR>\n"
    | 581 ->
        "<SYNTAX ERROR>\n"
    | 572 ->
        "<SYNTAX ERROR>\n"
    | 580 ->
        "<SYNTAX ERROR>\n"
    | 573 ->
        "Expecting a valid list identifier\n"
    | 574 ->
        "<SYNTAX ERROR>\n"
    | 582 ->
        "<SYNTAX ERROR>\n"
    | 499 ->
        "<SYNTAX ERROR>\n"
    | 494 ->
        "<SYNTAX ERROR>\n"
    | 495 ->
        "<SYNTAX ERROR>\n"
    | 583 ->
        "<SYNTAX ERROR>\n"
    | 500 ->
        "<SYNTAX ERROR>\n"
    | 670 ->
        "<SYNTAX ERROR>\n"
    | 586 ->
        "<SYNTAX ERROR>\n"
    | 592 ->
        "<SYNTAX ERROR>\n"
    | 2714 ->
        "<SYNTAX ERROR>\n"
    | 2852 ->
        "<SYNTAX ERROR>\n"
    | 2756 ->
        "<SYNTAX ERROR>\n"
    | 2757 ->
        "<SYNTAX ERROR>\n"
    | 2763 ->
        "<SYNTAX ERROR>\n"
    | 922 ->
        "<SYNTAX ERROR>\n"
    | 2849 ->
        "<SYNTAX ERROR>\n"
    | 2890 ->
        "<SYNTAX ERROR>\n"
    | 2897 ->
        "<SYNTAX ERROR>\n"
    | 2896 ->
        "<SYNTAX ERROR>\n"
    | 2893 ->
        "<SYNTAX ERROR>\n"
    | 2894 ->
        "<SYNTAX ERROR>\n"
    | _ ->
        raise Not_found

end
module Reason_toolchain
= struct
#1 "reason_toolchain.ml"
(***********************************************************************)
(*                                                                     *)
(*                                Reason                               *)
(*                                                                     *)
(***********************************************************************)
(* Portions Copyright (c) 2015-present, Facebook, Inc. All rights reserved. *)


(* Entry points in the parser *)

(**
 * Provides a simple interface to the most common parsing entrypoints required
 * by editor/IDE toolchains, preprocessors, and pretty printers.
 *
 * The form of this entrypoint includes more than what the standard OCaml
 * toolchain (oprof/ocamldoc) expects, but is still compatible.
 *
 * [implementation_with_comments] and [interface_with_comments] includes
 * additional information (about comments) suitable for building pretty
 * printers, editor, IDE and VCS integration.
 *
 * The comments include the full text of the comment (typically in between the
 * "(*" and the "*)", as well as location information for that comment.
 *
 * WARNING: The "end" location is one greater than the actual final position!
 * (for both [associatedTextLoc] and [commentLoc]).
 *
 * Currently, the location information for comments is of the form:
 *
 *  (associatedTextLoc)
 *
 * But we should quickly change it to be of the form:
 *
 *  (associatedTextLoc, commentLoc)
 *
 * Where the [commentLoc] is the actual original location of the comment,
 * and the [associatedTextLoc] records the location in the file that the
 * comment is attached to. If [associatedTextLoc] and [commentLoc] are the
 * same, then the comment is "free floating" in that it only attaches to itself.
 * The [Reason] pretty printer will try its best to interleave those comments
 * in the containing list etc. But if [associatedTextLoc] expands beyond
 * the [commentLoc] it means the comment and the AST that is captured by
 * the [associatedTextLoc] are related - where "related" is something
 * this [reason_toolchain] decides (but in short it handles "end of line
 * comments"). Various pretty printers can decide how to preserve this
 * relatedness. Ideally, it would preserve end of line comments, but in the
 * short term, it might merely use that relatedness to correctly attach
 * end of line comments to the "top" of the AST node.
 *
 *    let lst = [
 *
 *    ];   (*    Comment    *)
 *         ----commentLoc-----
 *    ---associatedTextLoc----
 *
 *
 * Ideally that would be formatted as:
 *
 *    let lst = [
 *
 *    ];   (*    Comment    *)
 *
 * Or:
 *
 *    let lst = [ ];   (*    Comment    *)
 *
 *
 * But a shorter term solution would use that [associatedTextLoc] to at least
 * correctly attach the comment to the correct node, even if not "end of line".
 *
 *   (*    Comment    *)
 *   let lst = [ ];
 *)

open Migrate_parsetree
open Ast_404

open Location
open Lexing

module From_current = Convert(OCaml_current)(OCaml_404)
module To_current = Convert(OCaml_404)(OCaml_current)

module S = MenhirLib.General (* Streams *)

let invalidLex = "invalidCharacter.orComment.orString"
let syntax_error_str err loc =
    if !Reason_config.recoverable = false then
      raise err
    else
      match err with
      | Location.Error err ->
        [
          Ast_helper.Str.mk ~loc:err.loc (Parsetree.Pstr_extension (Syntax_util.syntax_error_extension_node err.loc err.msg, []))
        ]
      | _ ->
        let menhirError = Syntax_util.findMenhirErrorMessage loc in
        match menhirError with
          | Syntax_util.MenhirMessagesError errMessage ->
              [Ast_helper.Str.mk ~loc:errMessage.Syntax_util.loc (Parsetree.Pstr_extension (Syntax_util.syntax_error_extension_node errMessage.Syntax_util.loc errMessage.Syntax_util.msg, []))]
          | _ ->
              [Ast_helper.Str.mk ~loc:loc (Parsetree.Pstr_extension (Syntax_util.syntax_error_extension_node loc invalidLex, []))]

let syntax_error_core_type err loc =
  if !Reason_config.recoverable = false then
    raise err
  else
    match err with
    | Location.Error err ->
      Ast_helper.Typ.mk ~loc:err.loc (Parsetree.Ptyp_extension (Syntax_util.syntax_error_extension_node err.loc err.msg))
    | _ ->
      Ast_helper.Typ.mk ~loc:loc (Parsetree.Ptyp_extension (Syntax_util.syntax_error_extension_node loc invalidLex))

let syntax_error_sig err loc =
  if !Reason_config.recoverable = false then
    raise err
  else
    match err with
    | Location.Error err ->
      [Ast_helper.Sig.mk ~loc:err.loc (Parsetree.Psig_extension (Syntax_util.syntax_error_extension_node err.loc err.msg, []))]
    | _ ->
      [Ast_helper.Sig.mk ~loc:loc (Parsetree.Psig_extension (Syntax_util.syntax_error_extension_node loc invalidLex, []))]


let chan_input = ref ""

(* replaces Lexing.from_channel so we can keep track of the input for comment modification *)
let keep_from_chan chan =
  Lexing.from_function (fun buf n -> (
    (* keep input from chan in memory so that it can be used to reformat comment tokens *)
    let nchar = input chan buf 0 n in
    chan_input := !chan_input ^ Bytes.sub_string buf 0 nchar;
    nchar
  ))

let setup_lexbuf use_stdin filename =
  (* Use custom method of lexing from the channel to keep track of the input so that we can
     reformat tokens in the toolchain*)
  let lexbuf =
    match use_stdin with
      | true ->
        keep_from_chan stdin
      | false ->
        let file_chan = open_in filename in
        seek_in file_chan 0;
        keep_from_chan file_chan
  in
  Location.init lexbuf filename;
  lexbuf


module type Toolchain = sig
  (* Parsing *)
  val canonical_core_type_with_comments: Lexing.lexbuf -> (Parsetree.core_type * Reason_pprint_ast.commentWithCategory)
  val canonical_implementation_with_comments: Lexing.lexbuf -> (Parsetree.structure * Reason_pprint_ast.commentWithCategory)
  val canonical_interface_with_comments: Lexing.lexbuf -> (Parsetree.signature * Reason_pprint_ast.commentWithCategory)

  val canonical_core_type: Lexing.lexbuf -> Parsetree.core_type
  val canonical_implementation: Lexing.lexbuf -> Parsetree.structure
  val canonical_interface: Lexing.lexbuf -> Parsetree.signature
  val canonical_toplevel_phrase: Lexing.lexbuf -> Parsetree.toplevel_phrase
  val canonical_use_file: Lexing.lexbuf -> Parsetree.toplevel_phrase list

  (* Printing *)
  val print_canonical_interface_with_comments: Format.formatter -> (Parsetree.signature * Reason_pprint_ast.commentWithCategory) -> unit
  val print_canonical_implementation_with_comments: Format.formatter -> (Parsetree.structure * Reason_pprint_ast.commentWithCategory) -> unit

end

module type Toolchain_spec = sig
  val safeguard_parsing: Lexing.lexbuf ->
    (unit -> ('a * Reason_pprint_ast.commentWithCategory)) -> ('a * Reason_pprint_ast.commentWithCategory)

  module rec Lexer_impl: sig
    val init: unit -> unit
    val token: Lexing.lexbuf -> Parser_impl.token
    val comments: unit -> (String.t * Location.t) list
  end

  and Parser_impl: sig
    type token
  end

  val core_type: Lexing.lexbuf -> Parsetree.core_type
  val implementation: Lexing.lexbuf -> Parsetree.structure
  val interface: Lexing.lexbuf -> Parsetree.signature
  val toplevel_phrase: Lexing.lexbuf -> Parsetree.toplevel_phrase
  val use_file: Lexing.lexbuf -> Parsetree.toplevel_phrase list

  val format_interface_with_comments: (Parsetree.signature * Reason_pprint_ast.commentWithCategory) -> Format.formatter -> unit
  val format_implementation_with_comments: (Parsetree.structure * Reason_pprint_ast.commentWithCategory) -> Format.formatter -> unit
end

let rec left_expand_comment should_scan_prev_line source loc_start =
  if loc_start = 0 then
    (String.unsafe_get source 0, true, 0)
  else
    let c = String.unsafe_get source (loc_start - 1) in
    match c with
    | '\t' | ' ' -> left_expand_comment should_scan_prev_line source (loc_start - 1)
    | '\n' when should_scan_prev_line -> left_expand_comment should_scan_prev_line source (loc_start - 1)
    | '\n' -> (c, true, loc_start)
    | _ -> (c, false, loc_start)

let rec right_expand_comment should_scan_next_line source loc_start =
  if loc_start = String.length source then
    (String.unsafe_get source (String.length source - 1), true, String.length source)
  else
    let c = String.unsafe_get source loc_start in
    match c with
    | '\t' | ' ' -> right_expand_comment should_scan_next_line source (loc_start + 1)
    | '\n' when should_scan_next_line -> right_expand_comment should_scan_next_line source (loc_start + 1)
    | '\n' -> (c, true, loc_start)
    | _ -> (c, false, loc_start)


module Create_parse_entrypoint (Toolchain_impl: Toolchain_spec) :Toolchain = struct
  let wrap_with_comments parsing_fun lexbuf =
    Toolchain_impl.safeguard_parsing lexbuf (fun () ->
      let _ = Toolchain_impl.Lexer_impl.init () in
      let ast = parsing_fun lexbuf in
      let unmodified_comments = Toolchain_impl.Lexer_impl.comments() in
      match !chan_input with
        | "" ->
          let _  = Parsing.clear_parser() in
          (ast, unmodified_comments |> List.map (fun (txt, phys_loc) -> (txt, Reason_pprint_ast.Regular, phys_loc)))
        | _ ->
          let modified_and_comment_with_category =
            List.map (fun (str, physical_loc) ->
              (* When searching for "^" regexp, returns location of newline + 1 *)
              let (stop_char, eol_start, virtual_start_pos) = left_expand_comment false !chan_input physical_loc.loc_start.pos_cnum in
              let one_char_before_stop_char =
                if virtual_start_pos <= 1 then
                  ' '
                else
                  String.unsafe_get !chan_input (virtual_start_pos - 2)
              in
              (*
               *
               * The following logic are designed for cases like:
               * | (* comment *)
               *   X => 1
               * we want to extend the comment to the next line so it can be
               * correctly attached to X
               *
               * But we don't want it to extend to next line in this case:
               *
               * true || (* comment *)
               *   fasle
               *
               *)
              let should_scan_next_line = stop_char = '|' &&
                                          (one_char_before_stop_char = ' ' ||
                                          one_char_before_stop_char = '\n' ||
                                          one_char_before_stop_char = '\t' ) in
              let (stop_char, eol_end, virtual_end_pos) = right_expand_comment should_scan_next_line !chan_input physical_loc.loc_end.pos_cnum in
              let end_pos_plus_one = physical_loc.loc_end.pos_cnum in
              let comment_length = (end_pos_plus_one - physical_loc.loc_start.pos_cnum - 4) in
              let original_comment_contents = String.sub !chan_input (physical_loc.loc_start.pos_cnum + 2) comment_length in
              let t = match (eol_start, eol_end) with
              | (true, true) -> Reason_pprint_ast.SingleLine
              | (false, true) -> Reason_pprint_ast.EndOfLine
              | _ -> Reason_pprint_ast.Regular
              in
              let start_pos = virtual_start_pos in
              (original_comment_contents, t,
               {physical_loc with loc_start = {physical_loc.loc_start with pos_cnum = start_pos};
                                  loc_end = {physical_loc.loc_end with pos_cnum = virtual_end_pos}})
            )
            unmodified_comments
          in
          let _  = Parsing.clear_parser() in
          (ast, modified_and_comment_with_category)
    )

  (*
   * The canonical interface/implementations (with comments) are used with
   * recovering mode for IDE integration. The parser itself likely
   * implements its own recovery, but we need to recover in the event
   * that the file couldn't even lex.
   * Note, the location reported here is broken for some lexing errors
   * (nested comments or unbalanced strings in comments) but at least we don't
   * crash the process. TODO: Report more accurate location in those cases.
   *)
  let canonical_implementation_with_comments lexbuf =
    try wrap_with_comments Toolchain_impl.implementation lexbuf with
    | err -> (syntax_error_str err (Location.curr lexbuf), [])

  let canonical_core_type_with_comments lexbuf =
    try wrap_with_comments Toolchain_impl.core_type lexbuf with
    | err -> (syntax_error_core_type err (Location.curr lexbuf), [])

  let canonical_interface_with_comments lexbuf =
    try wrap_with_comments Toolchain_impl.interface lexbuf with
    | err -> (syntax_error_sig err (Location.curr lexbuf), [])

  let canonical_toplevel_phrase_with_comments lexbuf =
    wrap_with_comments Toolchain_impl.toplevel_phrase lexbuf

  let canonical_use_file_with_comments lexbuf =
    wrap_with_comments Toolchain_impl.use_file lexbuf

  (** [ast_only] wraps a function to return only the ast component
   *)
  let ast_only f =
    (fun lexbuf -> lexbuf |> f |> fst)

  let canonical_implementation = ast_only canonical_implementation_with_comments

  let canonical_core_type = ast_only canonical_core_type_with_comments

  let canonical_interface = ast_only canonical_interface_with_comments

  let canonical_toplevel_phrase = ast_only canonical_toplevel_phrase_with_comments

  let canonical_use_file = ast_only canonical_use_file_with_comments

  (* Printing *)
  let print_canonical_interface_with_comments formatter interface =
    Toolchain_impl.format_interface_with_comments interface formatter

  let print_canonical_implementation_with_comments formatter implementation =
    Toolchain_impl.format_implementation_with_comments implementation formatter
end

module OCaml_syntax = struct
  open Migrate_parsetree
  module Lexer_impl = Lexer
  module Parser_impl = Parser

  (* OCaml parser parses into compiler-libs version of Ast.
     Parsetrees are converted to Reason version on the fly. *)

  let implementation lexbuf =
    From_current.copy_structure (Parser.implementation Lexer.token lexbuf)

  let core_type lexbuf =
    From_current.copy_core_type
      (Parser.parse_core_type Lexer.token lexbuf)

  let interface lexbuf =
    From_current.copy_signature
      (Parser.interface Lexer.token lexbuf)

  let toplevel_phrase lexbuf =
    From_current.copy_toplevel_phrase
      (Parser.toplevel_phrase Lexer.token lexbuf)

  let use_file lexbuf =
    List.map
      From_current.copy_toplevel_phrase
      (Parser.use_file Lexer.token lexbuf)

  (* Skip tokens to the end of the phrase *)
  (* TODO: consolidate these copy-paste skip/trys into something that works for
   * every syntax (also see [syntax_util]). *)
  let rec skip_phrase lexbuf =
    try
      match Lexer_impl.token lexbuf with
        Parser_impl.SEMISEMI | Parser_impl.EOF -> ()
      | _ -> skip_phrase lexbuf
    with
      | Lexer_impl.Error (Lexer_impl.Unterminated_comment _, _)
      | Lexer_impl.Error (Lexer_impl.Unterminated_string, _)
      | Lexer_impl.Error (Lexer_impl.Unterminated_string_in_comment _, _)
      | Lexer_impl.Error (Lexer_impl.Illegal_character _, _) ->
          skip_phrase lexbuf

  let maybe_skip_phrase lexbuf =
    if Parsing.is_current_lookahead Parser_impl.SEMISEMI
    || Parsing.is_current_lookahead Parser_impl.EOF
    then ()
    else skip_phrase lexbuf

  let safeguard_parsing lexbuf fn =
    try fn ()
    with
    | Lexer_impl.Error(Lexer_impl.Illegal_character _, _) as err
      when !Location.input_name = "//toplevel//"->
        skip_phrase lexbuf;
        raise err
    | Syntaxerr.Error _ as err
      when !Location.input_name = "//toplevel//" ->
        maybe_skip_phrase lexbuf;
        raise err
    | Parsing.Parse_error | Syntaxerr.Escape_error ->
        let loc = Location.curr lexbuf in
        if !Location.input_name = "//toplevel//"
        then maybe_skip_phrase lexbuf;
        raise(Syntaxerr.Error(Syntaxerr.Other loc))

  (* Unfortunately we drop the comments because there doesn't exist an ML
   * printer that formats comments *and* line wrapping! (yet) *)
  let format_interface_with_comments (signature, _) formatter =
    Pprintast.signature formatter
      (To_current.copy_signature signature)
  let format_implementation_with_comments (structure, _) formatter =
    Pprintast.structure formatter
      (To_current.copy_structure structure)
end

module JS_syntax = struct
  module I = Reason_parser.MenhirInterpreter
  module Lexer_impl = Reason_lexer
  module Parser_impl = Reason_parser

  let initial_checkpoint constructor lexbuf =
    (constructor lexbuf.lex_curr_p)

  (* [tracking_supplier] is a supplier that tracks the last token read *)
  type tracking_supplier = {
      (* The last token that was obtained from the lexer, together with its start
     and end positions. Warning: before the first call to the lexer has taken
     place, a None value is stored here. *)

      mutable last_token: (Reason_parser.token * Lexing.position * Lexing.position) option;

      (* A supplier function that returns one token at a time*)
      get_token: unit -> (Reason_parser.token * Lexing.position * Lexing.position)
    }

  (* [lexbuf_to_supplier] returns a supplier to be feed into Menhir's incremental API.
   * Each time the supplier is called, a new token in the lexbuf is returned.
   * If the supplier is called after an EOF is already returned, a syntax error will be raised.
   *
   * This makes sure at most one EOF token is returned by supplier, which
   * is the default behavior of ocamlyacc.
   *)
  let lexbuf_to_supplier lexbuf =
    let s = I.lexer_lexbuf_to_supplier Reason_lexer.token lexbuf in
    let eof_met = ref false in
    let get_token = fun () ->
      let (token, s, e) = s () in
      if token = Reason_parser.EOF then
        if not !eof_met then
          let _ = eof_met := true in
          (token, s, e)
        else
          raise(Syntaxerr.Error(Syntaxerr.Other (Location.curr lexbuf)))
      else
        (token, s, e)
    in
    let last_token = None in
    {last_token; get_token}

  let read supplier =
    let t = supplier.get_token () in
    supplier.last_token <- Some t;
    t

  (* read last token's location from a supplier *)
  let last_token_loc supplier =
    match supplier.last_token with
    | Some (_, s, e) ->
       {
         loc_start = s;
         loc_end = e;
         loc_ghost = false;
       }
    | None -> assert false

  (* get the stack of a checkpoint *)
  let stack checkpoint =
    match checkpoint with
    | I.HandlingError env ->
       I.stack env
    | _ ->
       assert false

  (* get state number of a checkpoint *)
  let state checkpoint : int =
    match Lazy.force (stack checkpoint) with
    | S.Nil ->
       0
    | S.Cons (I.Element (s, _, _, _), _) ->
             I.number s

  (* [loop_handle_yacc] mimic yacc's error handling mechanism in menhir.
     When it hits an error state, it pops up the stack until it finds a
     state when the error can be shifted or reduced.

     This is similar to Menhir's default behavior for error handling, with
     one subtle difference:
     When loop_handle_yacc recovers from the error, unlike Menhir, it doesn't
     discard the input token immediately. Instead, it restarts the parsing
     from recovered state with the original lookahead token that caused the
     error. If there is still an error, the look ahead token is then discarded.

     yacc's behavior gives us a chance to recover the following code :
     ```
     {
       let a = 1;
       Js.
     }
     ```
     , where "}" is the lookahead token that triggers an error state. With
     yacc's behavior, "}" will still be shifted once we recover from "Js.",
     giving the parser the ability to reduce the whole program to a sequence
     expression.
  *)

  let rec loop_handle_yacc supplier in_error checkpoint =

    match checkpoint with
    | I.InputNeeded _ ->
       if in_error then
         begin
           match supplier.last_token with
           | None -> assert false
           | Some triple ->
              (* We just recovered from the error state, try the original token again *)
              let checkpoint_with_previous_token = I.offer checkpoint triple in
              match I.shifts checkpoint_with_previous_token with
              | None ->
                (* The original token still fail to be parsed, discard *)
                loop_handle_yacc supplier false checkpoint
              | Some env ->
                loop_handle_yacc supplier false checkpoint_with_previous_token
         end
       else
         let triple = read supplier in
         let checkpoint = I.offer checkpoint triple in
         loop_handle_yacc supplier false checkpoint
    | I.Shifting _
      | I.AboutToReduce _ ->
       let checkpoint = I.resume checkpoint in
       loop_handle_yacc supplier in_error checkpoint
    | I.HandlingError env ->
       if !Reason_config.recoverable then
         (
         let loc = last_token_loc supplier in
         (match Syntax_util.findMenhirErrorMessage loc with
         | Syntax_util.MenhirMessagesError err -> ()
         | Syntax_util.NoMenhirMessagesError -> (
           let state = state checkpoint in
           let msg = try
             Reason_parser_message.message state
           with
             | Not_found -> "<SYNTAX ERROR>\n"
           in
           Syntax_util.add_error_message Syntax_util.{loc = loc; msg = msg};
         ));
         let checkpoint = I.resume checkpoint in
         (* Enter error recovery state *)
         loop_handle_yacc supplier true checkpoint)
       else
         (* If not in a recoverable state, fail early by raising a
          * customized Error object
          *)
         let loc = last_token_loc supplier in
         let state = state checkpoint in
         (* Check the error database to see what's the error message
          * associated with the current parser state
          *)
         let msg =
           try
             Reason_parser_message.message state
           with
             | Not_found -> "<UNKNOWN SYNTAX ERROR>"
         in
         let msg_with_state = Printf.sprintf "%d: %s" state msg in
         raise (Syntax_util.Error (loc, (Syntax_util.Syntax_error msg_with_state)))
    | I.Rejected ->
       begin
         let loc = last_token_loc supplier in
         raise Syntaxerr.(Error(Syntaxerr.Other loc))
       end
    | I.Accepted v ->
       (* The parser has succeeded and produced a semantic value. *)
       v

  let implementation lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.implementation lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  let interface lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.interface lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  let core_type lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.parse_core_type lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  let toplevel_phrase lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.toplevel_phrase lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  let use_file lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.use_file lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  (* Skip tokens to the end of the phrase *)
  let rec skip_phrase lexbuf =
    try
      match Lexer_impl.token lexbuf with
        Parser_impl.SEMI | Parser_impl.EOF -> ()
      | _ -> skip_phrase lexbuf
    with
      | Lexer_impl.Error (Lexer_impl.Unterminated_comment _, _)
      | Lexer_impl.Error (Lexer_impl.Unterminated_string, _)
      | Lexer_impl.Error (Lexer_impl.Unterminated_string_in_comment _, _)
      | Lexer_impl.Error (Lexer_impl.Illegal_character _, _) -> skip_phrase lexbuf

  let maybe_skip_phrase lexbuf =
    if Parsing.is_current_lookahead Parser_impl.SEMI
    || Parsing.is_current_lookahead Parser_impl.EOF
    then ()
    else skip_phrase lexbuf

  let safeguard_parsing lexbuf fn =
    try fn ()
    with
    | Lexer_impl.Error(Lexer_impl.Illegal_character _, _) as err
      when !Location.input_name = "//toplevel//"->
        skip_phrase lexbuf;
        raise err
    | Syntaxerr.Error _ as err
      when !Location.input_name = "//toplevel//" ->
        maybe_skip_phrase lexbuf;
        raise err
    | Parsing.Parse_error | Syntaxerr.Escape_error ->
        let loc = Location.curr lexbuf in
        if !Location.input_name = "//toplevel//"
        then maybe_skip_phrase lexbuf;
        raise(Syntaxerr.Error(Syntaxerr.Other loc))
    | Error _ as x ->
       let loc = Location.curr lexbuf in
       if !Location.input_name = "//toplevel//"
       then
         let _ = maybe_skip_phrase lexbuf in
         raise(Syntaxerr.Error(Syntaxerr.Other loc))
       else
         raise x
    | x -> raise x

  let format_interface_with_comments (signature, comments) formatter =
    let reason_formatter = Reason_pprint_ast.createFormatter () in
    reason_formatter#signature comments formatter signature
  let format_implementation_with_comments (implementation, comments) formatter =
    let reason_formatter = Reason_pprint_ast.createFormatter () in
    reason_formatter#structure comments formatter implementation
end

module ML = Create_parse_entrypoint (OCaml_syntax)
module JS = Create_parse_entrypoint (JS_syntax)

end
module Reason_implementation_printer
= struct
#1 "reason_implementation_printer.ml"
open Migrate_parsetree
open Ast_404

module Reason_implementation_printer : Printer_maker.PRINTER =
    struct
        type q = Parsetree.structure_item
        type t = Parsetree.structure
        let err = Printer_maker.err

        (* Note: filename should only be used with .ml files. See reason_toolchain. *)
        let defaultImplementationParserFor use_stdin filename =
          let open Reason_toolchain in
          let (theParser, parsedAsML) =
            if Filename.check_suffix filename ".re"
            then (JS.canonical_implementation_with_comments, false)
            else if Filename.check_suffix filename ".ml"
            then (ML.canonical_implementation_with_comments, true)
            else err ("Cannot determine default implementation parser for filename '" ^ filename ^ "'.")
          in
          theParser (setup_lexbuf use_stdin filename), parsedAsML, false

        let ppx_deriving_runtime =
          let open Asttypes in
          let open Parsetree in
          let open Longident in
          let open Ast_helper in
          let open Location in
          let mktypealias (name, params, types) =
            let manifest = Typ.constr (mknoloc (Lident name)) types in
            Str.type_ Nonrecursive [Type.mk ~params ~kind:Ptype_abstract ~manifest (mknoloc name)]
          in
          let mkmodulealias name =
            Str.module_ (Mb.mk (mknoloc name) (Mod.ident (mknoloc (Lident name))))
          in
          let mkmoduleinclude name =
            Str.include_ (Incl.mk (Mod.ident (mknoloc (Lident name))))
          in
          let type_aliases =
            let n s = (s, [], []) in
            let a s = (s, [(Typ.var "a"), Invariant], [Typ.var "a"]) in
            List.map mktypealias [n "int"; n "char"; n "string"; n "float"; n "bool";
                                  n "unit"; n "exn"; a "array"; a "list"; a "option";
                                  n "nativeint"; n "int32"; n "int64"; a "lazy_t";
                                  n "bytes"]
          in
          let module_aliases = List.map mkmodulealias ["Pervasives"; "Char"; "String";
            "Printexc"; "Array"; "List"; "Nativeint"; "Int32"; "Int64"; "Lazy";
            "Bytes"; "Hashtbl"; "Queue"; "Stack"; "Set"; "Weak"; "Printf"; "Format";
            "Buffer"]
          in
          let module_includes = List.map mkmoduleinclude ["Pervasives"]
          in
          let structure_items = type_aliases @ module_aliases @ module_includes in
          Str.module_ (Mb.mk (mknoloc "Ppx_deriving_runtime")
                             (Mod.structure structure_items))

        let parse ~add_runtime ~use_stdin filetype filename =
            let ((ast, comments), parsedAsML, parsedAsInterface) =
            (match filetype with
            | `Auto -> defaultImplementationParserFor use_stdin filename
            | `BinaryReason -> Printer_maker.reasonBinaryParser use_stdin filename
            | `Binary -> Printer_maker.ocamlBinaryParser use_stdin filename
            | `ML ->
                    let lexbuf = Reason_toolchain.setup_lexbuf use_stdin filename in
                    let impl = Reason_toolchain.ML.canonical_implementation_with_comments in
                    (impl lexbuf, true, false)
            | `Reason ->
                    let lexbuf = Reason_toolchain.setup_lexbuf use_stdin filename in
                    let impl = Reason_toolchain.JS.canonical_implementation_with_comments in
                    (impl lexbuf, false, false))
            in
            if parsedAsInterface then
              err "The file parsed does not appear to be an implementation file."
            else if add_runtime then
              (* NB: Not idempotent. *)
              ((ppx_deriving_runtime::ast, comments), parsedAsML)
            else
              ((ast, comments), parsedAsML)

        let print printtype filename parsedAsML output_chan output_formatter =
            match printtype with
            | `BinaryReason -> fun (ast, comments) -> (
              (* Our special format for interchange between reason should keep the
               * comments separate.  This is not compatible for input into the
               * ocaml compiler - only for input into another version of Reason. We
               * also store whether or not the binary was originally *parsed* as an
               * interface file.
               *)
              output_value output_chan (
                Config.ast_impl_magic_number, filename, ast, comments, parsedAsML, false
              );
            )
            | `Binary -> fun (ast, comments) -> (
               Ast_io.to_channel output_chan filename
                 (Ast_io.Impl ((module OCaml_current),
                               Reason_toolchain.To_current.copy_structure ast))
            )
            | `AST -> fun (ast, comments) -> (
              Printast.implementation output_formatter
                (Reason_toolchain.To_current.copy_structure ast)
            )
            (* If you don't wrap the function in parens, it's a totally different
             * meaning #thanksOCaml *)
            | `None -> (fun (ast, comments) -> ())
            | `ML -> Reason_toolchain.ML.print_canonical_implementation_with_comments output_formatter
            | `Reason -> Reason_toolchain.JS.print_canonical_implementation_with_comments output_formatter
    end;;

end
module Reason_interface_printer
= struct
#1 "reason_interface_printer.ml"
open Migrate_parsetree
open Ast_404

module Reason_interface_printer : Printer_maker.PRINTER =
    struct
        type q = Parsetree.signature_item
        type t = Parsetree.signature
        let err = Printer_maker.err

        (* Note: filename should only be used with .mli files. See reason_toolchain. *)
        let defaultInterfaceParserFor use_stdin filename =
          let open Reason_toolchain in
          let (theParser, parsedAsML) =
            if Filename.check_suffix filename ".rei"
            then (JS.canonical_interface_with_comments, false)
            else if Filename.check_suffix filename ".mli"
            then (ML.canonical_interface_with_comments, true)
            else err ("Cannot determine default interface parser for filename '" ^ filename ^ "'.")
          in
          theParser (setup_lexbuf use_stdin filename), parsedAsML, true

        let ppx_deriving_runtime =
          let open Asttypes in
          let open Parsetree in
          let open Longident in
          let open Ast_helper in
          let open Location in
          let mkstr = mknoloc in
          let mklid x = mknoloc (Longident.parse x) in
          let mktypealias (name, params, types) =
            let manifest = Typ.constr (mklid name) types in
            Sig.type_ Nonrecursive [Type.mk ~params ~kind:Ptype_abstract ~manifest (mknoloc name)]
          in
          let type_aliases =
            let n s = (s, [], []) in
            let a s = (s, [(Typ.var "a"), Invariant], [Typ.var "a"]) in
            List.map mktypealias [n "int"; n "char"; n "string"; n "float"; n "bool";
                                  n "unit"; n "exn"; a "array"; a "list"; a "option";
                                  n "nativeint"; n "int32"; n "int64"; a "lazy_t";
                                  n "bytes"]
          in
          let module_aliases =
            let module_with_types n types =
              let mktysubst ty =
                let manifest = Typ.constr (mklid (n ^ "." ^ ty)) [] in
                Pwith_typesubst (Type.mk (mkstr ty) ~manifest)
              in
              Sig.module_ (Md.mk (mkstr n)
                                 (Mty.with_ (Mty.typeof_ (Mod.ident (mklid n)))
                                 (List.map mktysubst types)))
            in [
              module_with_types "Format" ["formatter_out_functions";
                                          "formatter_tag_functions";
                                          "formatter"];
              ]
          in
          let structure_items = type_aliases @ module_aliases in
          Sig.module_ (Md.mk (mknoloc "Ppx_deriving_runtime")
                             (Mty.signature structure_items))

        let parse ~add_runtime ~use_stdin filetype filename =
            let ((ast, comments), parsedAsML, parsedAsInterface) =
            (match filetype with
            | `Auto -> defaultInterfaceParserFor use_stdin filename
            | `BinaryReason -> Printer_maker.reasonBinaryParser use_stdin filename
            | `Binary -> Printer_maker.ocamlBinaryParser use_stdin filename
            | `ML ->
                    let lexbuf = Reason_toolchain.setup_lexbuf use_stdin filename in
                    let intf = Reason_toolchain.ML.canonical_interface_with_comments in
                    ((intf lexbuf), true, true)
            | `Reason ->
                    let lexbuf = Reason_toolchain.setup_lexbuf use_stdin filename in
                    let intf = Reason_toolchain.JS.canonical_interface_with_comments in
                    ((intf lexbuf), false, true))
            in
            if not parsedAsInterface then
              err "The file parsed does not appear to be an interface file."
            else if add_runtime then
              (* NB: Not idempotent. *)
              ((ppx_deriving_runtime::ast, comments), parsedAsML)
            else ((ast, comments), parsedAsML)

        let print printtype filename parsedAsML output_chan output_formatter =
            match printtype with
                    | `BinaryReason -> fun (ast, comments) -> (
                      (* Our special format for interchange between reason should keep the
                       * comments separate.  This is not compatible for input into the
                       * ocaml compiler - only for input into another version of Reason. We
                       * also store whether or not the binary was originally *parsed* as an
                       * interface file.
                       *)
                      output_value output_chan (
                        Config.ast_intf_magic_number, filename, ast, comments, parsedAsML, true
                      );
                    )
                    | `Binary -> fun (ast, comments) -> (
                        Ast_io.to_channel output_chan filename
                          (Ast_io.Intf ((module OCaml_current),
                                        Reason_toolchain.To_current.copy_signature ast))
                    )
                    | `AST -> fun (ast, comments) -> (
                        Printast.interface output_formatter
                          (Reason_toolchain.To_current.copy_signature ast)
                    )
                    (* If you don't wrap the function in parens, it's a totally different
                     * meaning #thanksOCaml *)
                    | `None -> (fun (ast, comments) -> ())
                    | `ML -> Reason_toolchain.ML.print_canonical_interface_with_comments output_formatter
                    | `Reason -> Reason_toolchain.JS.print_canonical_interface_with_comments output_formatter
    end;;

end
module Refmt_args
= struct
#1 "refmt_args.ml"
open Cmdliner

let interface =
  let doc = "parse AST as an interface" in
  Arg.(value & opt (bool) false & info ["i"; "interface"] ~doc)

let recoverable =
  let doc = "enable recoverable parser" in
  Arg.(value & flag & info ["r"; "recoverable"] ~doc)

let explicit_arity =
  let doc =
    "if a constructor's argument is a tuple, always interpret it as \
     multiple arguments"
  in
  Arg.(value & flag & info ["e"; "assume-explicit-arity"] ~doc)

let parse_ast =
  let docv = "FORM" in
  let doc = "parse AST in FORM, which is one of: (ml | re | \
             binary (for compiler input) | \
             binary_reason (for interchange between Reason versions))"
  in
  let opts = Arg.enum ["ml", `ML; "re", `Reason;
                       "binary_reason", `BinaryReason; "auto", `Auto]
  in
  Arg.(value & opt (some opts) None & info ["parse"] ~docv ~doc)

let print =
  let docv = "FORM" in
  let doc = "print AST in FORM, which is one of: (ml | re (default) | \
             binary (for compiler input) | \
             binary_reason (for interchange between Reason versions) | \
             ast (print human readable AST directly) | none)"
  in
  let opts = Arg.enum ["ml", `ML; "re", `Reason; "binary", `Binary;
                       "binary_reason", `BinaryReason; "ast", `AST;
                       "none", `None]
  in
  Arg.(value & opt opts `Reason & info ["p"; "print"] ~docv ~doc)

let print_width =
  let docv = "COLS" in
  let doc = "wrapping width for printing the AST" in
  Arg.(value & opt (int) (100) & info ["w"; "print-width"] ~docv ~doc)

let heuristics_file =
  let doc =
    "load path as a heuristics file to specify which constructors are defined with \
     multi-arguments. Mostly used in removing [@implicit_arity] introduced from \
     OCaml conversion.\n\t\texample.txt:\n\t\tConstructor1\n\t\tConstructor2"
  in
  Arg.(value & opt (some file) None & info ["h"; "heuristics-file"] ~doc)

let in_place =
  let doc = "reformat a file in-place" in
  Arg.(value & flag & info ["in-place"] ~doc)

let add_printers =
  let doc = "add auto-printers to user-defined types" in
  Arg.(value & flag & info ["add-printers"] ~doc)

let add_runtime =
  let doc = "add runtime for auto-printers" in
  Arg.(value & flag & info ["add-runtime"] ~doc)

let input =
  let docv = "FILENAMES" in
  let doc = "input files; if empty, assume stdin" in
  Arg.(value & (pos_all non_dir_file []) & info [] ~docv ~doc)

(* DEPRECATED *)

let is_interface_pp =
  let doc = "is-interface-pp is DEPRECATED; use -i or --interface instead" in
  Arg.(value & flag & info ["is-interface-pp"] ~doc)

let use_stdin =
  let doc = "use-stdin is DEPRECATED; usage is assumed if not specifying a \
             filename"
  in
  Arg.(value & flag & info ["use-stdin"] ~doc)

end
module Refmt_impl
= struct
#1 "refmt_impl.ml"
(* Portions Copyright (c) 2015-present, Facebook, Inc. All rights reserved. *)

open Lexing
open Cmdliner

exception Invalid_config = Printer_maker.Invalid_config
let err = Printer_maker.err

let read_lines file =
  let list = ref [] in
  let chan = open_in file in
  try
    while true do
      list := input_line chan :: !list
    done;
    []
  with End_of_file ->
    close_in chan;
    List.rev !list

let warn s =
  let red s = "\027[31m" ^ s ^ "\x1b[m" in
  prerr_endline (red "WARNING:" ^ " " ^ s)


let refmt
    interface
    is_recoverable
    explicit_arity
    parse_ast
    print
    print_width
    h_file
    in_place
    input_files
    add_printers
    add_runtime
    is_interface_pp
    use_stdin
  =
  let refmt_single input_file =
    let () =
      if is_interface_pp then err "--is-interface-pp is deprecated."
      else if use_stdin then err "--use-stdin is deprecated."
    in
    let (use_stdin, input_file) = match input_file with
      | Some name -> (false, name)
      | None -> (true, "")
    in
    let parse_ast = match parse_ast, use_stdin with
      | (Some x, _) -> x
      | (None, false) -> `Auto
      | (None, true) -> `Reason (* default *)
    in
    let constructorLists = match h_file with
      | Some f_name -> read_lines f_name
      | None -> []
    in
    let interface = match interface with
      | true -> true
      | false -> (Filename.check_suffix input_file ".rei" || Filename.check_suffix input_file ".mli")
    in
    let output_file =
      match in_place, use_stdin with
      | (true, true) -> err "Cannot write in place to stdin."
      | (true,    _) -> Some input_file
      | (false,   _) -> None
    in
    let (module Printer : Printer_maker.PRINTER) =
      if interface then (module Reason_interface_printer.Reason_interface_printer)
      else (module Reason_implementation_printer.Reason_implementation_printer)
    in
    Reason_config.configure ~r:is_recoverable ~ap:add_printers;
    Location.input_name := input_file;
    let _ = Reason_pprint_ast.configure
        ~width: print_width
        ~assumeExplicitArity: explicit_arity
        ~constructorLists
    in
    let (ast, parsedAsML) =
      Printer.parse ~add_runtime ~use_stdin parse_ast input_file
    in
    let output_chan = Printer_maker.prepare_output_file output_file in
    (* If you run into trouble with this (or need to use std_formatter by
       itself at the same time for some reason), try breaking this out so that
       it's not possible to call Format.formatter_of_out_channel on stdout. *)
    let output_formatter = Format.formatter_of_out_channel output_chan in
    (
      Printer.print print input_file parsedAsML output_chan output_formatter ast;
      (* Also closes all open boxes. *)
      Format.pp_print_flush output_formatter ();
      flush output_chan;
      Printer_maker.close_output_file output_file output_chan;
    )
  in
  try
    match input_files with
    | [] -> `Ok (refmt_single None)
    | ls -> `Ok (List.iter (fun file -> refmt_single (Some file)) input_files)
  with
  | Invalid_config msg -> `Error (true, msg)
  | exn ->
          Location.report_exception Format.err_formatter exn;
          exit 1

let top_level_info =
  let doc = "Meta language utility" in
  let man = [`S "DESCRIPTION"; `P "refmt is a parser and pretty-printer"] in
  let version = "Reason " ^ Package.version ^ " @ " ^ Package.git_short_version
  in
  Term.info "refmt" ~version ~doc ~man

let refmt_t =
  let open Term in
  let open Refmt_args in
  const refmt $ interface
              $ recoverable
              $ explicit_arity
              $ parse_ast
              $ print
              $ print_width
              $ heuristics_file
              $ in_place
              $ input
              $ add_printers
              $ add_runtime
              $ is_interface_pp
              $ use_stdin

let () =
  match Term.eval ((Term.ret refmt_t), top_level_info) with
  | `Error s -> exit 1
  | _ -> exit 0

end
