module Cmdliner : sig 
#1 "cmdliner.mli"
(*---------------------------------------------------------------------------
   Copyright (c) 2011 Daniel C. B端nzli. All rights reserved.
   Distributed under a BSD3 license, see license at the end of the file.
   cmdliner release 0.9.8
  ---------------------------------------------------------------------------*)

(** Declarative definition of command line interfaces.

    [Cmdliner] provides a simple and compositional mechanism
    to convert command line arguments to OCaml values and pass them to
    your functions. The module automatically handles syntax errors,
    help messages and UNIX man page generation. It supports programs
    with single or multiple commands
    (like [darcs] or [git]) and respect most of the
    {{:http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html}
    POSIX} and
    {{:http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html}
    GNU} conventions.

    Consult the {{!basics}basics}, details about the supported
    {{!cmdline}command line syntax} and {{!examples} examples} of
    use. Open the module to use it, it defines only three modules in
    your scope.

    {e Release 0.9.8 - Daniel B端nzli <daniel.buenzl i\@erratique.ch> } *)

(** {1:top Interface} *)

(** Man page specification.

    Man page generation is automatically handled by [Cmdliner]. The
    {!block} type is used to define a man page's content.

    The {!print} function can be useful if the client wants to define
    other man pages (e.g. to implement a help command). *)
module Manpage : sig

  (** {1:man Man pages} *)

  type block =
    [ `S of string | `P of string | `Pre of string | `I of string * string
    | `Noblank ]
  (** The type for a block of man page text.

      {ul
      {- [`S s] introduces a new section [s].}
      {- [`P t] is a new paragraph with text [t].}
      {- [`Pre t] is a new preformatted paragraph with text [t].}
      {- [`I (l,t)] is an indented paragraph with label
      [l] and text [t].}
      {- [`Noblank] suppresses the blank line introduced between two blocks.}}

      Except in [`Pre], whitespace and newlines are not significant
      and are all collapsed to a single space. In labels [l] and text
      strings [t], the syntax ["$(i,italic text)"] and ["$(b,bold
      text)"] can be used to respectively produce italic and bold
      text. *)

  type title = string * int * string * string * string
  (** The type for man page titles. Describes the man page
      [title], [section], [center_footer], [left_footer], [center_header]. *)

  type t = title * block list
  (** The type for a man page. A title and the page text as a list of blocks. *)

  val print : ?subst:(string -> string) ->
    [`Pager | `Plain | `Groff ] -> Format.formatter -> t -> unit
  (** [print ~subst fmt ppf page] prints [page] on [ppf] in the format [fmt].
      If [fmt] is [`Pager] the function tries to write the formatted
      result in a pager, if that fails the format [`Plain] is written
      on [ppf]. [subst] can be used to perform variable substitution,
      see {!Buffer.add_substitute} (defaults to the identity). *)
end

(** Terms.

    A term is evaluated by a program to produce a {{!result}result}.
    A term made of terms referring to {{!Arg}command line arguments}
    implicitly defines a command line syntax. *)
module Term : sig

  (** {1:terms Terms} *)

  type +'a t
  (** The type for terms evaluating to values of type 'a. *)

  val const : 'a -> 'a t
  (** [const v] is a term that evaluates to [v]. *)

  (**/**)
  val pure : 'a -> 'a t
  (** @deprecated use {!const} instead. *)
  (**/**)

  val ( $ ) : ('a -> 'b) t -> 'a t -> 'b t
  (** [f $ v] is a term that evaluates to the result of applying
      the evaluation of [v] to the one of [f]. *)

  val app : ('a -> 'b) t -> 'a t -> 'b t
  (** [app] is {!($)}. *)

  type 'a ret =
    [ `Help of [`Pager | `Plain | `Groff] * string option
    | `Error of (bool * string)
    | `Ok of 'a ]
  (** The type for command return values. See {!ret}. *)

  val ret : 'a ret t -> 'a t
  (** [ret v] is a term whose evaluation depends on the case
      to which [v] evaluates. With :
      {ul
      {- [`Ok r], it evaluates to [r].}
      {- [`Error (usage,e)], the evaluation fails and [Cmdliner] prints
         the error [e] and the term's usage if [usage] is [true].}
      {- [`Help (format, name)], the evaluation fails and [Cmdliner] prints the
         term's man page in the given [format] (or the man page for a
         specific [name] term in case of multiple term evaluation).}}   *)

  val main_name : string t
  (** [main_name] is a term that evaluates to the "main" term's name. *)

  val choice_names : string list t
  (** [choice_names] is a term that evaluates to the names of the terms
      to choose from. *)

  val man_format : [`Pager | `Plain | `Groff] t
  (** [man_format] is a term that defines a [--man-format] option and
      evaluates to a value that can be used with {!Manpage.print}. *)

  (** {1:tinfo Term information}

      Term information defines the name and man page of a term.
      For simple evaluation this is the name of the program and its
      man page. For multiple term evaluation, this is
      the name of a command and its man page. *)

  type info
  (** The type for term information. *)

  val info : ?sdocs:string -> ?man:Manpage.block list ->
    ?docs:string -> ?doc:string -> ?version:string -> string -> info
  (** [info sdocs man docs doc version name] is a term information
      such that:
      {ul
      {- [name] is the name of the program or the command.}
      {- [version] is the version string of the program, ignored
         for commands.}
      {- [doc] is a one line description of the program or command used
         for the [NAME] section of the term's man page. For commands this
         description is also used in the list of commands of the main
         term's man page.}
      {- [docs], only for commands, the title of the section of the main
         term's man page where it should be listed (defaults to ["COMMANDS"]).}
      {- [man] is the text of the man page for the term. In the text,
         the variables ["$(tname)"] and ["$(mname)"] can respectively be
         used to refer to the value of [name] and the main term's name.
      }
      {- [sdocs] defines the title of the section in which the
         standard [--help] and [--version] arguments are listed.}} *)

  val name : info -> string
  (** [name ti] is the name of the term information. *)

 (** {1:evaluation Evaluation} *)

  type 'a result = [
    | `Ok of 'a | `Error of [`Parse | `Term | `Exn ] | `Version | `Help ]
  (** The type for evaluation results.
      {ul
      {- [`Ok v], the term evaluated successfully and [v] is the result.}
      {- [`Version], the version string of the main term was printed
       on the help formatter.}
      {- [`Help], man page about the term was printed on the help formatter.}
      {- [`Error `Parse], a command line parse error occured and was
         reported on the error formatter.}
      {- [`Error `Term], a term evaluation error occured and was reported
         on the error formatter (see {!Term.ret}).}
      {- [`Error `Exn], an exception [e] was caught and reported
         on the error formatter (see the [~catch] parameter of {!eval}).}} *)

  val eval : ?help:Format.formatter ->
    ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) ->
    ?argv:string array -> ('a t * info) -> 'a result
  (** [eval help err catch argv (t,i)]  is the evaluation result
      of [t] with command line arguments [argv] (defaults to {!Sys.argv}).

      If [catch] is [true] (default) uncaught exeptions
      are intercepted and their stack trace is written to the [err]
      formatter.

      [help] is the formatter used to print help or version messages
      (defaults to {!Format.std_formatter}). [err] is the formatter
      used to print error messages (defaults to {!Format.err_formatter}).

      [env] is used for environment variable lookup, the default
      uses {!Sys.getenv}. *)

  val eval_choice : ?help:Format.formatter ->
    ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) ->
    ?argv:string array -> 'a t * info -> ('a t * info) list ->
    'a result
  (** [eval_choice help err catch argv default (t,i) choices] is like {!eval}
      except that if the first argument on the command line is not an option
      name it will look in [choices] for a term whose information has this
      name and evaluate it.

      If the command name is unknown an error is reported. If the name
      is unspecified the "main" term [t] is evaluated. [i] defines the
      name and man page of the program. *)

  val eval_peek_opts : ?version_opt:bool ->
    ?env:(string -> string option) ->
    ?argv:string array -> 'a t ->
    'a option * 'a result
  (** [eval_peek_opts version_opt argv t] evaluates [t], a term made
      of optional arguments only, with the command line [argv]
      (defaults to {!Sys.argv}). In this evaluation, unknown optional
      arguments and positional arguments are ignored.

      The evaluation returns a pair. The first component is
      the result of parsing the command line [argv] stripped from
      any help and version option if [version_opt] is [true] (defaults
      to [false]). It results in:
      {ul
      {- [Some _] if the command line would be parsed correctly given the
         {e partial} knowledge in [t].}
      {- [None] if a parse error would occur on the options of [t]}}

      The second component is the result of parsing the command line
      [argv] without stripping the help and version options. It
      indicates what the evaluation would result in on [argv] given
      the partial knowledge in [t] (for example it would return
      [`Help] if there's a help option in [argv]). However in
      contrasts to {!eval} and {!eval_choice} no side effects like
      error reporting or help output occurs.

      {b Note.} Positional arguments can't be peeked without the full
      specification of the command line: we can't tell apart a
      positional argument from the value of an unknown optional
      argument.  *)
end

(** Terms for command line arguments.

    This module provides functions to define terms that evaluate
    to the arguments provided on the command line.

    Basic constraints, like the argument type or repeatability, are
    specified by defining a value of type {!t}. Further contraints can
    be specified during the {{!argterms}conversion} to a term. *)
module Arg : sig

(** {1:argconv Argument converters}

    An argument converter transforms a string argument of the command
    line to an OCaml value. {{!converters}Predefined converters}
    are provided for many types of the standard library. *)

  type 'a parser = string -> [ `Ok of 'a | `Error of string ]
  (** The type for argument parsers. *)

  type 'a printer = Format.formatter -> 'a -> unit
  (** The type for converted argument printers. *)

  type 'a converter = 'a parser * 'a printer
  (** The type for argument converters. *)

  val some : ?none:string -> 'a converter -> 'a option converter
  (** [some none c] is like the converter [c] except it returns
      [Some] value. It is used for command line arguments
      that default to [None] when absent. [none] is what to print to
      document the absence (defaults to [""]). *)

(** {1:arginfo Arguments and their information}

    Argument information defines the man page information of an
    argument and, for optional arguments, its names. An environment
    variable can also be specified to read the argument value from
    if the argument is absent from the command line and the variable
    is defined. *)

  type env
  (** The type for environment variables and their documentation. *)

  val env_var : ?docs:string -> ?doc:string -> string -> env
  (** [env_var docs doc var] is an environment variables [var]. [doc]
      is the man page information of the environment variable; the
      variables mentioned in {!info} can be used in this documentation
      string. [doc] defaults to ["See option $(opt)."]. [docs] is the
      title of the man page section in which the environment variable
      will be listed, it defaults to ["ENVIRONMENT VARIABLES"]. *)

  type 'a t
  (** The type for arguments holding data of type ['a]. *)

  type info
  (** The type for information about command line arguments. *)

  val info : ?docs:string -> ?docv:string -> ?doc:string -> ?env:env ->
    string list -> info
  (** [info docs docv doc env names] defines information for
      an argument.

      [names] defines the names under which an optional argument
      can be referred to. Strings of length [1] (["c"]) define short
      option names (["-c"]), longer strings (["count"]) define long
      option names (["--count"]). [names] must be empty for positional
      arguments.

      [env] defines the name of an environment variable which is
      looked up for defining the argument if it is absent from the
      command line. See {{!envlookup}environment variables} for
      details.
      {ul
      {- [doc] is the man page information of the argument. The
         variable ["$(docv)"] can be used to refer to the value of
         [docv] (see below). The variable ["$(opt)"] will refer to a
         long option of [names] or a short one if there is no long
         option. The variable ["$(env)"] will refer to the environment
         variable specified by [env] (if any).  {{!doc_helpers}These
         functions} can help with formatting argument values.}
      {- [docv] is for positional and non-flag optional arguments.
         It is a variable name used in the man page to stand for their value.}
      {- [docs] is the title of the man page section in which the argument
         will be listed. For optional arguments this defaults
         to ["OPTIONS"]. For positional arguments this defaults
         to ["ARGUMENTS"]. However a positional argument is only listed
         if it has both a [doc] and [docv] specified.}} *)

  val ( & ) : ('a -> 'b) -> 'a -> 'b
  (** [f & v] is [f v], a right associative composition operator for
      specifying argument terms. *)

(** {1:optargs Optional arguments}

    The information of an optional argument must have at least
    one name or [Invalid_argument] is raised. *)

  val flag : info -> bool t
  (** [flag i] is a [bool] argument defined by an optional flag
      that may appear {e at most} once on the command line under one of
      the names specified by [i]. The argument holds [true] if the
      flag is present on the command line and [false] otherwise. *)

  val flag_all : info -> bool list t
  (** [flag_all] is like {!flag} except the flag may appear more than
      once. The argument holds a list that contains one [true] value per
      occurence of the flag. It holds the empty list if the flag
      is absent from the command line. *)

  val vflag : 'a -> ('a * info) list -> 'a t
  (** [vflag v \[v]{_0}[,i]{_0}[;...\]] is an ['a] argument defined
      by an optional flag that may appear {e at most} once on
      the command line under one of the names specified in the [i]{_k}
      values. The argument holds [v] if the flag is absent from the
      command line and the value [v]{_k} if the name under which it appears
      is in [i]{_k}.

      {b Note.} Environment variable lookup is unsupported for
      for these arguments. *)

  val vflag_all : 'a list -> ('a * info) list -> 'a list t
  (** [vflag_all v l] is like {!vflag} except the flag may appear more
      than once. The argument holds the list [v] if the flag is absent
      from the command line. Otherwise it holds a list that contains one
      corresponding value per occurence of the flag, in the order found on
      the command line.

      {b Note.} Environment variable lookup is unsupported for
      for these arguments. *)

  val opt : ?vopt:'a -> 'a converter -> 'a -> info -> 'a t
  (** [opt vopt c v i] is an ['a] argument defined by the value of
      an optional argument that may appear {e at most} once on the command
      line under one of the names specified by [i]. The argument holds
      [v] if the option is absent from the command line. Otherwise
      it has the value of the option as converted by [c].

      If [vopt] is provided the value of the optional argument is itself
      optional, taking the value [vopt] if unspecified on the command line. *)

  val opt_all : ?vopt:'a -> 'a converter -> 'a list -> info -> 'a list t
  (** [opt_all vopt c v i] is like {!opt} except the optional argument may
      appear more than once. The argument holds a list that contains one value
      per occurence of the flag in the order found on the command line.
      It holds the list [v] if the flag is absent from the command line. *)

  (** {1:posargs Positional arguments}

      The information of a positional argument must have no name
      or [Invalid_argument] is raised. Positional arguments indexing
      is zero-based. *)

  val pos : ?rev:bool -> int -> 'a converter -> 'a -> info -> 'a t
  (** [pos rev n c v i] is an ['a] argument defined by the [n]th
      positional argument of the command line as converted by [c].
      If the positional argument is absent from the command line
      the argument is [v].

      If [rev] is [true] (defaults to [false]), the computed
      position is [max-n] where [max] is the position of
      the last positional argument present on the command line. *)

  val pos_all : 'a converter -> 'a list -> info -> 'a list t
  (** [pos_all c v i] is an ['a list] argument that holds
      all the positional arguments of the command line as converted
      by [c] or [v] if there are none. *)

  val pos_left : ?rev:bool -> int -> 'a converter -> 'a list -> info ->
    'a list t
  (** [pos_left rev n c v i] is an ['a list] argument that holds
      all the positional arguments as converted by [c] found on the left
      of the [n]th positional argument or [v] if there are none.

      If [rev] is [true] (defaults to [false]), the computed
      position is [max-n] where [max] is the position of
      the last positional argument present on the command line. *)

  val pos_right : ?rev:bool -> int -> 'a converter -> 'a list -> info ->
    'a list t
  (** [pos_right] is like {!pos_left} except it holds all the positional
      arguments found on the right of the specified positional argument. *)

  (** {1:argterms Arguments as terms} *)

  val value : 'a t -> 'a Term.t
  (** [value a] is a term that evaluates to [a]'s value. *)

  val required : 'a option t -> 'a Term.t
  (** [required a] is a term that fails if [a]'s value is [None] and
      evaluates to the value of [Some] otherwise. Use this for required
      positional arguments (it can also be used for defining required
      optional arguments, but from a user interface perspective this
      shouldn't be done, it is a contradiction in terms). *)

  val non_empty : 'a list t -> 'a list Term.t
  (** [non_empty a] is term that fails if [a]'s list is empty and
      evaluates to [a]'s list otherwise. Use this for non empty lists
      of positional arguments. *)

  val last : 'a list t -> 'a Term.t
  (** [last a] is a term that fails if [a]'s list is empty and evaluates
      to the value of the last element of the list otherwise. Use this
      for lists of flags or options where the last occurence takes precedence
      over the others. *)

  (** {1:converters Predefined converters} *)

  val bool : bool converter
  (** [bool] converts values with {!bool_of_string}. *)

  val char : char converter
  (** [char] converts values by ensuring the argument has a single char. *)

  val int : int converter
  (** [int] converts values with {!int_of_string}. *)

  val nativeint : nativeint converter
  (** [nativeint] converts values with {!Nativeint.of_string}. *)

  val int32 : int32 converter
  (** [int32] converts values with {!Int32.of_string}. *)

  val int64 : int64 converter
  (** [int64] converts values with {!Int64.of_string}. *)

  val float : float converter
  (** [float] converts values with {!float_of_string}. *)

  val string : string converter
  (** [string] converts values with the identity function. *)

  val enum : (string * 'a) list -> 'a converter
  (** [enum l p] converts values such that unambiguous prefixes of string names
      in [l] map to the corresponding value of type ['a].

      {b Warning.} The type ['a] must be comparable with {!Pervasives.compare}.

      @raise Invalid_argument if [l] is empty. *)

  val file : string converter
  (** [file] converts a value with the identity function and
      checks with {!Sys.file_exists} that a file with that name exists. *)

  val dir : string converter
  (** [dir] converts a value with the identity function and checks
      with {!Sys.file_exists} and {!Sys.is_directory}
      that a directory with that name exists. *)

  val non_dir_file : string converter
  (** [non_dir_file] converts a value with the identity function and checks
      with {!Sys.file_exists} and {!Sys.is_directory}
      that a non directory file with that name exists. *)

  val list : ?sep:char -> 'a converter -> 'a list converter
  (** [list sep c] splits the argument at each [sep] (defaults to [','])
      character and converts each substrings with [c]. *)

  val array : ?sep:char -> 'a converter -> 'a array converter
  (** [array sep c] splits the argument at each [sep] (defaults to [','])
      character and converts each substring with [c]. *)

  val pair : ?sep:char -> 'a converter -> 'b converter -> ('a * 'b) converter
  (** [pair sep c0 c1] splits the argument at the {e first} [sep] character
      (defaults to [',']) and respectively converts the substrings with
      [c0] and [c1]. *)

  val t2 : ?sep:char -> 'a converter -> 'b converter -> ('a * 'b) converter
  (** {!t2} is {!pair}. *)

  val t3 : ?sep:char -> 'a converter ->'b converter -> 'c converter ->
    ('a * 'b * 'c) converter
  (** [t3 sep c0 c1 c2] splits the argument at the {e first} two [sep]
      characters (defaults to [',']) and respectively converts the
      substrings with [c0], [c1] and [c2]. *)

  val t4 : ?sep:char -> 'a converter ->'b converter -> 'c converter ->
    'd converter -> ('a * 'b * 'c * 'd) converter
  (** [t4 sep c0 c1 c2 c3] splits the argument at the {e first} three [sep]
      characters (defaults to [',']) respectively converts the substrings
      with [c0], [c1], [c2] and [c3]. *)

  (** {1:doc_helpers Documentation formatting helpers} *)

  val doc_quote : string -> string
  (** [doc_quote s] quotes the string [s]. *)

  val doc_alts : ?quoted:bool -> string list -> string
  (** [doc_alts alts] documents the alternative tokens [alts] according
      the number of alternatives. If [quoted] is [true] (default)
      the tokens are quoted. The resulting string can be used in
      sentences of the form ["$(docv) must be %s"].

      @raise Invalid_argument if [alts] is the empty string.  *)

  val doc_alts_enum : ?quoted:bool -> (string * 'a) list -> string
  (** [doc_alts_enum quoted alts] is [doc_alts quoted (List.map fst alts)]. *)
end

(**
    {1:basics Basics}

    With [Cmdliner] your program evaluates a term. A {e term}
    is a value of type {!Term.t}. The type parameter indicates
    the type of the result of the evaluation.

    One way to create terms is by lifting regular OCaml values with
    {!Term.const}. Terms can be applied to terms evaluating to
    functional values with {!Term.( $ )}. For example for the function:
{[let revolt () = print_endline "Revolt!"]}
    the term :
{[
open Cmdliner;;

let revolt_t = Term.(const revolt $ const ())]}
    is a term that evaluates to the result (and effect) of the [revolt]
    function.
    Terms are evaluated with {!Term.eval}:
{[let () = match Term.eval (revolt_t, Term.info "revolt") with
| `Error _ -> exit 1 | _ -> exit 0]}
    This defines a command line program named ["revolt"], without command line
    arguments arguments, that just prints ["Revolt!"] on [stdout].
{[> ./revolt
Revolt!]}
    The combinators in the {!Arg} module allow to extract command
    line argument data as terms. These terms can then be applied to
    lifted OCaml functions to be evaluated by the program.

    Terms corresponding to command line argument data that are part of
    a term evaluation implicitly define a command line syntax.  We
    show this on an concrete example.

    Consider the [chorus] function that prints repeatedly a
    given message :
{[let chorus count msg =
  for i = 1 to count do print_endline msg done]}
    we want to make it available from the command line
    with the synopsis:
{[chorus [-c COUNT | --count=COUNT] [MSG]]}
    where [COUNT] defaults to [10] and [MSG] defaults to ["Revolt!"].
    We first define a term corresponding to the [--count]
    option:
{[
let count =
  let doc = "Repeat the message $(docv) times." in
  Arg.(value & opt int 10 & info ["c"; "count"] ~docv:"COUNT" ~doc)
]}
    This says that [count] is a term that evaluates to the
    value of an optional argument of type [int] that
    defaults to [10] if unspecified and whose option name is
    either [-c] or [--count]. The arguments [doc] and [docv] are used to
    generate the option's man page information.

    The term for the positional argument [MSG] is:
{[
let msg =
  let doc = "Overrides the default message to print."
  let env = Arg.env "CHORUS_MSG" ~doc in
  let doc = "The message to print." in
  Arg.(value & pos 0 string "Revolt!" & info [] ~env ~docv:"MSG" ~doc)
]}
    which says that [msg] is a term whose value is the positional
    argument at index [0] of type [string] and defaults to ["Revolt!"]
    or the value of the environment variable [CHORUS_MSG] if the
    argument is unspecified on the command line. Here again [doc] and
    [docv] are used for the man page information.

    The term for executing [chorus] with these command line arguments
    is :
{[
let chorus_t = Term.(const chorus $ count $ msg)
]}
    and we are now ready to define our program:
{[
let info =
  let doc = "print a customizable message repeatedly" in
  let man = [ `S "BUGS"; `P "Email bug reports to <hehey at example.org>.";] in
  Term.info "chorus" ~version:"1.6.1" ~doc ~man

let () = match Term.eval (chorus_t, info) with `Error _ -> exit 1 | _ -> exit 0
]}
    The [info] value created with {!Term.info} gives more information
    about the term we execute and is used to generate the program's
    man page. Since we provided a [~version] string, the program will
    automatically respond to the [--version] option by printing this
    string.

    A program using {!Term.eval} always responds to the
    [--help] option by showing the man page about the program generated
    using the information you provided with {!Term.info} and {!Arg.info}.
    Here is the output generated by our example :
{v > ./chorus --help
NAME
       chorus - print a customizable message repeatedly

SYNOPSIS
       chorus [OPTION]... [MSG]

ARGUMENTS
       MSG (absent=Revolt! or CHORUS_MSG env)
           The message to print.

OPTIONS
       -c COUNT, --count=COUNT (absent=10)
           Repeat the message COUNT times.

       --help[=FMT] (default=pager)
           Show this help in format FMT (pager, plain or groff).

       --version
           Show version information.

BUGS
       Email bug reports to <hehey at example.org>.
v}

    If a pager is available, this output is written to a pager.
    This help is also available in plain text or in the
    {{:http://www.gnu.org/software/groff/groff.html}groff} man page format by
    invoking the program with the option [--help=plain] or [--help=groff].

    For examples of more complex command line definitions look and
    run the {{!examples}examples}.

    {2:multiterms Multiple terms}

    [Cmdliner] also provides support for programs like [darcs] or
    [git] that have multiple commands each with their own syntax:
    {[prog COMMAND [OPTION]... ARG...]}
    A command is defined by coupling a term with
    {{!Term.tinfo}term information}. The term information defines the
    command name and its man page. Given a list of commands the function
    {!Term.eval_choice} will execute the term corresponding to the
    [COMMAND] argument or or a specific "main" term if there is
    no [COMMAND] argument.

    {2:manual Manual}

    Man page sections are printed in the order specified by
    {!Term.info}. The man page information of an argument is listed in
    alphabetical order at the end of the text of the section specified
    by its {{!Arg.info}argument information}. Positional arguments are
    also listed iff both the [docv] and [doc] string is specified in
    their argument information.

    If an argument information mentions a section not specified in
    {!Term.info}, an empty section is created for it. This section is
    inserted just after the ["SYNOPSIS"] section or after a section
    named ["DESCRIPTION"] if there is one.

    The ["SYNOPSIS"] section of a man page is generated automatically
    from a term's information and its arguments. To substitute your
    own instead, start the term's information man page with
    a ["SYNOPSIS"] section.

    Ideally all manual strings should be UTF-8 encoded. However at the
    moment Groff (at least [1.19.2]) doesn't seem to cope with UTF-8
    input and UTF-8 characters beyond the ASCII set will look garbled.
    Regarding UTF-8 output, generating the man page with [-Tutf8] maps
    the hyphen-minus [U+002D] to the minus sign [U+2212] which makes it
    difficult to search it in the pager, so [-Tascii] is used for now.
    Conclusion is that it may be better to stick to the ASCII set for now.
    Please contact the author if something seems wrong in this reasoning
    or if you know a work around this.

    {2:misc Miscellaneous}

    {ul
    {- The option name [--help], (and [--version] if you specify a
       version string) is reserved by the module. Using it as a term or
       option name may result in undefined behaviour.}
    {- The evaluation of a term in which the same option name is defined
       by more than one argument is undefined.}}

    {1:cmdline Command line syntax}

    For programs evaluating a single term the most general form of invocation
    is:
    {ul{- [prog [OPTION]... [ARG]...]}}
    The program automatically reponds to the [--help] option by
    printing the help. If a version string is provided in
    the {{!Term.tinfo}term information}, it also automatically responds
    to the [--version] option by printing this string.

    Command line arguments are either {{!optargs}{e optional}} or
    {{!posargs}{e positional}}. Both can be freely interleaved but
    since [Cmdliner] accepts many optional forms this may result in
    ambiguities. The special {{!posargs} token [--]} can be used to resolve
    them.

    Programs evaluating multiple terms also add this form of invocation:
    {ul{- [prog COMMAND [OPTION]... [ARG]...]}}
    Commands automatically respond to the [--help] option
    by printing their help. The [COMMAND] string must
    be the first string following the program name and may be specified
    by a prefix as long as it is not ambiguous.

    {2:optargs Optional arguments}

    An optional argument is specified on the command line by a {e
    name} possibly followed by a {e value}.

    The name of an option can be short or long.
    {ul
    {- A {e short} name is a dash followed by a single alphanumeric
       character: ["-h"], ["-q"], ["-I"].}
    {- A {e long} name is two dashes followed by alphanumeric
       characters and dashes: ["--help"], ["--silent"], ["--ignore-case"].}}

    More than one name may refer to the same optional argument.  For
    example in a given program the names ["-q"], ["--quiet"] and
    ["--silent"] may all stand for the same boolean argument
    indicating the program to be quiet.  Long names
    can be specified by any non ambiguous prefix.

    The value of an option can be specified in three different ways.
    {ul
    {- As the next token on the command line: ["-o a.out"],
       ["--output a.out"].}
    {- Glued to a short name: ["-oa.out"].}
    {- Glued to a long name after an equal character:
    ["--output=a.out"].}}
    Glued forms are especially useful if
    the value itself starts with a dash as is the case for negative numbers,
    ["--min=-10"].

    An optional argument without a value is either a {e flag}
    (see {!Arg.flag}, {!Arg.vflag}) or an optional argument with an optional
    value (see the [~vopt] argument of {!Arg.opt}).

    Short flags can be grouped together to share a single dash and the group
    can end with a short option. For example assuming ["-v"] and ["-x"]
    are flags and ["-f"] is a short option:
    {ul
      {- ["-vx"] will be parsed as ["-v -x"].}
      {- ["-vxfopt"] will be parsed as ["-v -x -fopt"].}
      {- ["-vxf opt"] will be parsed as ["-v -x -fopt"].}
      {- ["-fvx"] will be parsed as ["-f=vx"].}}

    {2:posargs Positional arguments}

    Positional arguments are tokens on the command line that are not
    option names and are not the value of an optional argument. They
    are numbered from left to right starting with zero.

    Since positional arguments may be mistaken as the optional value
    of an optional argument or they may need to look like option
    names, anything that follows the special token ["--"] on the command
    line is considered to be a positional argument.

    {2:envlookup Environment variables}

    Non-required command line arguments can be backed up by an environment
    variable.  If the argument is absent from the command line and
    that the environment variable is defined, its value is parsed
    using the argument converter and defines the value of the
    argument.

    For {!Arg.flag} and {!Arg.flag_all} that do not have an argument
    converter a boolean is parsed from the lowercased variable value
    as follows:
    {ul
    {- [""], ["false"], ["no"], ["n"] or ["0"] is [false].}
    {- ["true"], ["yes"], ["y"] or ["1"] is [true].}
    {- Any other string is an error.}}

    Note that environment variables are not supported for {!Arg.vflag}
    and {!Arg.vflag_all}.

    {1:examples Examples}

    These examples are in the [test] directory of the distribution.

 {2:exrm A [rm] command}

    We define the command line interface of a
    [rm] command with the synopsis:
{[
rm [OPTION]... FILE...
]}
    The [-f], [-i] and [-I] flags define the prompt behaviour of [rm],
    represented in our program by the [prompt] type. If more than one
    of these flags is present on the command line the last one takes
    precedence.

    To implement this behaviour we map the presence of these flags
    to values of the [prompt] type by using {!Arg.vflag_all}.  This
    argument will contain all occurences of the flag on the command
    line and we just take the {!Arg.last} one to define our term value
    (if there's no occurence the last value of the default list [[Always]] is
    taken, i.e. the default is [Always]).
{[
(* Implementation of the command, we just print the args. *)

type prompt = Always | Once | Never
let prompt_str = function
| Always -> "always" | Once -> "once" | Never -> "never"

let rm prompt recurse files =
  Printf.printf "prompt = %s\nrecurse = %b\nfiles = %s\n"
    (prompt_str prompt) recurse (String.concat ", " files)

(* Command line interface *)

open Cmdliner;;

let files = Arg.(non_empty & pos_all file [] & info [] ~docv:"FILE")
let prompt =
  let doc = "Prompt before every removal." in
  let always = Always, Arg.info ["i"] ~doc in
  let doc = "Ignore nonexistent files and never prompt." in
  let never = Never, Arg.info ["f"; "force"] ~doc in
  let doc = "Prompt once before removing more than three files, or when
             removing recursively. Less intrusive than $(b,-i), while
             still giving protection against most mistakes."
  in
  let once = Once, Arg.info ["I"] ~doc in
  Arg.(last & vflag_all [Always] [always; never; once])

let recursive =
  let doc = "Remove directories and their contents recursively." in
  Arg.(value & flag & info ["r"; "R"; "recursive"] ~doc)

let cmd =
  let doc = "remove files or directories" in
  let man = [
    `S "DESCRIPTION";
    `P "$(tname) removes each specified $(i,FILE). By default it does not
        remove directories, to also remove them and their contents, use the
        option $(b,--recursive) ($(b,-r) or $(b,-R)).";
    `P "To remove a file whose name starts with a `-', for example
        `-foo', use one of these commands:";
    `P "rm -- -foo"; `Noblank;
    `P "rm ./-foo";
    `P "$(tname) removes symbolic links, not the files referenced by the
        links.";
    `S "BUGS"; `P "Report bugs to <hehey at example.org>.";
    `S "SEE ALSO"; `P "$(b,rmdir)(1), $(b,unlink)(2)" ]
  in
  Term.(const rm $ prompt $ recursive $ files),
  Term.info "rm" ~version:"1.6.1" ~doc ~man

let () = match Term.eval cmd with `Error _ -> exit 1 | _ -> exit 0
]}
    {2:excp A [cp] command}

    We define the command line interface of a
    [cp] command with the synopsis:
{[cp [OPTION]... SOURCE... DEST ]}
    The [DEST] argument must be a directory if there is more than
    one [SOURCE]. This constraint is too complex to be expressed by the
    combinators of {!Arg}. Hence we just give it the {!Arg.string} type
    and verify the constraint at the beginning of the [cp]
    implementation. If unsatisfied we return an [`Error] and
    by using {!Term.ret} on the lifted result [cp_t] of [cp],
    [Cmdliner] handles the error reporting.
{[
(* Implementation, we check the dest argument and print the args *)

let cp verbose recurse force srcs dest =
  if List.length srcs > 1 &&
  (not (Sys.file_exists dest) || not (Sys.is_directory dest))
  then
    `Error (false, dest ^ " is not a directory")
  else
    `Ok (Printf.printf
     "verbose = %b\nrecurse = %b\nforce = %b\nsrcs = %s\ndest = %s\n"
      verbose recurse force (String.concat ", " srcs) dest)

(* Command line interface *)

open Cmdliner;;

let verbose =
  let doc = "Print file names as they are copied." in
  Arg.(value & flag & info ["v"; "verbose"] ~doc)

let recurse =
  let doc = "Copy directories recursively." in
  Arg.(value & flag & info ["r"; "R"; "recursive"] ~doc)

let force =
  let doc = "If a destination file cannot be opened, remove it and try again."in
  Arg.(value & flag & info ["f"; "force"] ~doc)

let srcs =
  let doc = "Source file(s) to copy." in
  Arg.(non_empty & pos_left ~rev:true 0 file [] & info [] ~docv:"SOURCE" ~doc)

let dest =
  let doc = "Destination of the copy. Must be a directory if there is more
             than one $(i,SOURCE)." in
  Arg.(required & pos ~rev:true 0 (some string) None & info [] ~docv:"DEST"
         ~doc)

let cmd =
  let doc = "copy files" in
  let man = [
    `S "BUGS";
    `P "Email them to <hehey at example.org>.";
    `S "SEE ALSO";
    `P "$(b,mv)(1), $(b,scp)(1), $(b,umask)(2), $(b,symlink)(7)" ]
  in
  Term.(ret (const cp $ verbose $ recurse $ force $ srcs $ dest)),
  Term.info "cp" ~version:"1.6.1" ~doc ~man

let () = match Term.eval cmd with `Error _ -> exit 1 | _ -> exit 0
]}

{2:extail A [tail] command}

We define the command line interface of a [tail] command with the
synopsis:
{[tail [OPTION]... [FILE]...]}

The [--lines] option whose value specifies the number of last lines to
print has a special syntax where a [+] prefix indicates to start
printing from that line number. In the program this is represented by
the [loc] type. We define a custom [loc] {{!Arg.argconv}argument converter}
for this option.

The [--follow] option has an optional enumerated value. The argument
converter [follow], created with {!Arg.enum} parses the option value
into the enumeration. By using {!Arg.some} and the [~vopt] argument of
{!Arg.opt}, the term corresponding to the option [--follow] evaluates to
[None] if [--follow] is absent from the command line, to [Some Descriptor]
if present but without a value and to [Some v] if present with a value
[v] specified.

{[
(* Implementation of the command, we just print the args. *)

type loc = bool * int
type verb = Verbose | Quiet
type follow = Name | Descriptor

let str = Printf.sprintf
let opt_str sv = function None -> "None" | Some v -> str "Some(%s)" (sv v)
let loc_str (rev, k) = if rev then str "%d" k else str "+%d" k
let follow_str = function Name -> "name" | Descriptor -> "descriptor"
let verb_str = function Verbose -> "verbose" | Quiet -> "quiet"

let tail lines follow verb pid files =
  Printf.printf "lines = %s\nfollow = %s\nverb = %s\npid = %s\nfiles = %s\n"
    (loc_str lines) (opt_str follow_str follow) (verb_str verb)
    (opt_str string_of_int pid) (String.concat ", " files)

(* Command line interface *)

open Cmdliner;;

let lines =
  let loc =
    let parse s = try
      if s <> "" && s.[0] <> '+' then `Ok (true, int_of_string s) else
      `Ok (false, int_of_string (String.sub s 1 (String.length s - 1)))
    with Failure _ -> `Error "unable to parse integer"
    in
    parse, fun ppf p -> Format.fprintf ppf "%s" (loc_str p)
  in
  Arg.(value & opt loc (true, 10) & info ["n"; "lines"] ~docv:"N"
   ~doc:"Output the last $(docv) lines or use $(i,+)$(docv) to start
         output after the $(i,N)-1th line.")
let follow =
  let doc = "Output appended data as the file grows. $(docv) specifies how the
             file should be tracked, by its `name' or by its `descriptor'." in
  let follow = Arg.enum ["name", Name; "descriptor", Descriptor] in
  Arg.(value & opt (some follow) ~vopt:(Some Descriptor) None &
       info ["f"; "follow"] ~docv:"ID" ~doc)

let verb =
  let doc = "Never output headers giving file names." in
  let quiet = Quiet, Arg.info ["q"; "quiet"; "silent"] ~doc in
  let doc = "Always output headers giving file names." in
  let verbose = Verbose, Arg.info ["v"; "verbose"] ~doc in
  Arg.(last & vflag_all [Quiet] [quiet; verbose])

let pid =
  let doc = "With -f, terminate after process $(docv) dies." in
  Arg.(value & opt (some int) None & info ["pid"] ~docv:"PID" ~doc)

let files = Arg.(value & (pos_all non_dir_file []) & info [] ~docv:"FILE")

let cmd =
  let doc = "display the last part of a file" in
  let man = [
    `S "DESCRIPTION";
    `P "$(tname) prints the last lines of each $(i,FILE) to standard output. If
        no file is specified reads standard input. The number of printed
        lines can be  specified with the $(b,-n) option.";
    `S "BUGS";
    `P "Report them to <hehey at example.org>.";
    `S "SEE ALSO";
    `P "$(b,cat)(1), $(b,head)(1)" ]
  in
  Term.(const tail $ lines $ follow $ verb $ pid $ files),
  Term.info "tail" ~version:"1.6.1" ~doc ~man

let () = match Term.eval cmd with `Error _ -> exit 1 | _ -> exit 0
]}

{2:exdarcs A [darcs] command}

We define the command line interface of a [darcs] command with the synopsis:
{[darcs [COMMAND] ...]}

The [--debug], [-q], [-v] and [--prehook] options are available in
each command.  To avoid having to pass them individually to each
command we gather them in a record of type [copts]. By lifting the
record constructor [copts] into the term [copts_t] we now have a term
that we can pass to the commands to stand for an argument of type
[copts]. These options are documented in a section called [COMMON
OPTIONS], since we also want to put [--help] and [--version] in this
section, the term information of commands makes a judicious use of the
[sdocs] parameter of {!Term.info}.

The [help] command shows help about commands or other topics. The help
shown for commands is generated by [Cmdliner] by making an approriate
use of {!Term.ret} on the lifted [help] function.

If the program is invoked without a command we just want to show the
help of the program as printed by [Cmdliner] with [--help]. This is
done by the [no_cmd] term.

{[
(* Implementations, just print the args. *)

type verb = Normal | Quiet | Verbose
type copts = { debug : bool; verb : verb; prehook : string option }

let str = Printf.sprintf
let opt_str sv = function None -> "None" | Some v -> str "Some(%s)" (sv v)
let opt_str_str = opt_str (fun s -> s)
let verb_str = function
  | Normal -> "normal" | Quiet -> "quiet" | Verbose -> "verbose"

let pr_copts oc copts = Printf.fprintf oc
    "debug = %b\nverbosity = %s\nprehook = %s\n"
    copts.debug (verb_str copts.verb) (opt_str_str copts.prehook)

let initialize copts repodir = Printf.printf
    "%arepodir = %s\n" pr_copts copts repodir

let record copts name email all ask_deps files = Printf.printf
    "%aname = %s\nemail = %s\nall = %b\nask-deps = %b\nfiles = %s\n"
    pr_copts copts (opt_str_str name) (opt_str_str email) all ask_deps
    (String.concat ", " files)

let help copts man_format cmds topic = match topic with
| None -> `Help (`Pager, None) (* help about the program. *)
| Some topic ->
    let topics = "topics" :: "patterns" :: "environment" :: cmds in
    let conv, _ = Cmdliner.Arg.enum (List.rev_map (fun s -> (s, s)) topics) in
    match conv topic with
    | `Error e -> `Error (false, e)
    | `Ok t when t = "topics" -> List.iter print_endline topics; `Ok ()
    | `Ok t when List.mem t cmds -> `Help (man_format, Some t)
    | `Ok t ->
        let page = (topic, 7, "", "", ""), [`S topic; `P "Say something";] in
        `Ok (Cmdliner.Manpage.print man_format Format.std_formatter page)

open Cmdliner;;

(* Help sections common to all commands *)

let copts_sect = "COMMON OPTIONS"
let help_secs = [
 `S copts_sect;
 `P "These options are common to all commands.";
 `S "MORE HELP";
 `P "Use `$(mname) $(i,COMMAND) --help' for help on a single command.";`Noblank;
 `P "Use `$(mname) help patterns' for help on patch matching."; `Noblank;
 `P "Use `$(mname) help environment' for help on environment variables.";
 `S "BUGS"; `P "Check bug reports at http://bugs.example.org.";]

(* Options common to all commands *)

let copts debug verb prehook = { debug; verb; prehook }
let copts_t =
  let docs = copts_sect in
  let debug =
    let doc = "Give only debug output." in
    Arg.(value & flag & info ["debug"] ~docs ~doc)
  in
  let verb =
    let doc = "Suppress informational output." in
    let quiet = Quiet, Arg.info ["q"; "quiet"] ~docs ~doc in
    let doc = "Give verbose output." in
    let verbose = Verbose, Arg.info ["v"; "verbose"] ~docs ~doc in
    Arg.(last & vflag_all [Normal] [quiet; verbose])
  in
  let prehook =
    let doc = "Specify command to run before this $(mname) command." in
    Arg.(value & opt (some string) None & info ["prehook"] ~docs ~doc)
  in
  Term.(const copts $ debug $ verb $ prehook)

(* Commands *)

let initialize_cmd =
  let repodir =
    let doc = "Run the program in repository directory $(docv)." in
    Arg.(value & opt file Filename.current_dir_name & info ["repodir"]
           ~docv:"DIR" ~doc)
  in
  let doc = "make the current directory a repository" in
  let man = [
    `S "DESCRIPTION";
    `P "Turns the current directory into a Darcs repository. Any
       existing files and subdirectories become ..."] @ help_secs
  in
  Term.(const initialize $ copts_t $ repodir),
  Term.info "initialize" ~sdocs:copts_sect ~doc ~man

let record_cmd =
  let pname =
    let doc = "Name of the patch." in
    Arg.(value & opt (some string) None & info ["m"; "patch-name"] ~docv:"NAME"
         ~doc)
  in
  let author =
    let doc = "Specifies the author's identity." in
    Arg.(value & opt (some string) None & info ["A"; "author"] ~docv:"EMAIL"
         ~doc)
  in
  let all =
    let doc = "Answer yes to all patches." in
    Arg.(value & flag & info ["a"; "all"] ~doc)
  in
  let ask_deps =
    let doc = "Ask for extra dependencies." in
    Arg.(value & flag & info ["ask-deps"] ~doc)
  in
  let files = Arg.(value & (pos_all file) [] & info [] ~docv:"FILE or DIR") in
  let doc = "create a patch from unrecorded changes" in
  let man =
    [`S "DESCRIPTION";
     `P "Creates a patch from changes in the working tree. If you specify
      a set of files ..."] @ help_secs
  in
  Term.(const record $ copts_t $ pname $ author $ all $ ask_deps $ files),
  Term.info "record" ~doc ~sdocs:copts_sect ~man

let help_cmd =
  let topic =
    let doc = "The topic to get help on. `topics' lists the topics." in
    Arg.(value & pos 0 (some string) None & info [] ~docv:"TOPIC" ~doc)
  in
  let doc = "display help about darcs and darcs commands" in
  let man =
    [`S "DESCRIPTION";
     `P "Prints help about darcs commands and other subjects..."] @ help_secs
  in
  Term.(ret
          (const help $ copts_t $ Term.man_format $ Term.choice_names $topic)),
  Term.info "help" ~doc ~man

let default_cmd =
  let doc = "a revision control system" in
  let man = help_secs in
  Term.(ret (const (fun _ -> `Help (`Pager, None)) $ copts_t)),
  Term.info "darcs" ~version:"1.6.1" ~sdocs:copts_sect ~doc ~man

let cmds = [initialize_cmd; record_cmd; help_cmd]

let () = match Term.eval_choice default_cmd cmds with
| `Error _ -> exit 1 | _ -> exit 0
]}
*)

(*---------------------------------------------------------------------------
   Copyright (c) 2011 Daniel C. B端nzli
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

   3. Neither the name of Daniel C. B端nzli nor the names of
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  ---------------------------------------------------------------------------*)

end = struct
#1 "cmdliner.ml"
(*---------------------------------------------------------------------------
   Copyright (c) 2011 Daniel C. B端nzli. All rights reserved.
   Distributed under a BSD3 license, see license at the end of the file.
   cmdliner release 0.9.8
  ---------------------------------------------------------------------------*)

let str = Printf.sprintf

(* Invalid_arg strings *)

let err_argv = "argv array must have at least one element"
let err_not_opt = "Option argument without name"
let err_not_pos = "Positional argument with a name"
let err_help s = "Term error, help requested for unknown command " ^ s
let err_empty_list = "Empty list"
let err_incomplete_enum = "Incomplete enumeration for the type"
let err_doc_string s =
  str "Variable substitution failed on documentation fragment `%s'" s

(* A few useful definitions. *)

let rev_compare n n' = compare n' n
let pr = Format.fprintf
let pr_str = Format.pp_print_string
let pr_char = Format.pp_print_char
let str_of_pp pp v = pp Format.str_formatter v; Format.flush_str_formatter ()
let quote s = str "`%s'" s
let alts_str ?(quoted = true) alts =
  let quote = if quoted then quote else (fun s -> s) in
  match alts with
  | [] -> invalid_arg err_empty_list
  | [a] -> (quote a)
  | [a; b] -> str "either %s or %s" (quote a) (quote b)
  | alts ->
      let rev_alts = List.rev alts in
      str "one of %s or %s"
        (String.concat ", " (List.rev_map quote (List.tl rev_alts)))
        (quote (List.hd rev_alts))

let pr_white_str spaces ppf s =  (* spaces and new lines with Format's funs *)
  let left = ref 0 and right = ref 0 and len = String.length s in
  let flush () =
    Format.pp_print_string ppf (String.sub s !left (!right - !left));
    incr right; left := !right;
  in
  while (!right <> len) do
    if s.[!right] = '\n' then (flush (); Format.pp_force_newline ppf ()) else
    if spaces && s.[!right] = ' ' then (flush (); Format.pp_print_space ppf ())
    else incr right;
  done;
  if !left <> len then flush ()

let pr_text = pr_white_str true
let pr_lines = pr_white_str false
let pr_to_temp_file pr v = try
  let exec = Filename.basename Sys.argv.(0) in
  let file, oc = Filename.open_temp_file exec "out" in
  let ppf = Format.formatter_of_out_channel oc in
  pr ppf v; Format.pp_print_flush ppf (); close_out oc;
  at_exit (fun () -> try Sys.remove file with Sys_error e -> ());
  Some file
with Sys_error _ -> None

(* Levenshtein distance, for making spelling suggestions in case of error. *)

let levenshtein_distance s t =
  (* As found here http://rosettacode.org/wiki/Levenshtein_distance#OCaml *)
  let minimum a b c = min a (min b c) in
  let m = String.length s in
  let n = String.length t in
  (* for all i and j, d.(i).(j) will hold the Levenshtein distance between
     the first i characters of s and the first j characters of t *)
  let d = Array.make_matrix (m+1) (n+1) 0 in
  for i = 0 to m do d.(i).(0) <- i done;
  for j = 0 to n do d.(0).(j) <- j done;
  for j = 1 to n do
    for i = 1 to m do
      if s.[i-1] = t.[j-1] then
        d.(i).(j) <- d.(i-1).(j-1)  (* no operation required *)
      else
        d.(i).(j) <- minimum
            (d.(i-1).(j) + 1)   (* a deletion *)
            (d.(i).(j-1) + 1)   (* an insertion *)
            (d.(i-1).(j-1) + 1) (* a substitution *)
    done;
  done;
  d.(m).(n)

let suggest s candidates =
  let add (min, acc) name =
    let d = levenshtein_distance s name in
    if d = min then min, (name :: acc) else
    if d < min then d, [name] else
    min, acc
  in
  let dist, suggs = List.fold_left add (max_int, []) candidates in
  if dist < 3 (* suggest only if not too far *) then suggs else []

(* Tries. This implementation also maps any non ambiguous prefix of a
   key to its value. *)

module Trie : sig
  type 'a t
  val empty : 'a t
  val is_empty : 'a t -> bool
  val add : 'a t -> string -> 'a -> 'a t
  val find : 'a t -> string -> [ `Ok of 'a | `Ambiguous | `Not_found ]
  val ambiguities : 'a t -> string -> string list
  val of_list : (string * 'a) list -> 'a t
end = struct
  module Cmap = Map.Make (Char)                           (* character maps. *)
  type 'a value =                         (* type for holding a bound value. *)
    | Pre of 'a                    (* value is bound by the prefix of a key. *)
    | Key of 'a                          (* value is bound by an entire key. *)
    | Amb                     (* no value bound because of ambiguous prefix. *)
    | Nil                            (* not bound (only for the empty trie). *)

  type 'a t = { v : 'a value; succs : 'a t Cmap.t }
  let empty = { v = Nil; succs = Cmap.empty }
  let is_empty t = t = empty

  (* N.B. If we replace a non-ambiguous key, it becomes ambiguous but it's
     not important for our use. Also the following is not tail recursive but
     the stack is bounded by key length. *)
  let add t k d =
    let rec aux t k len i d pre_d =
      if i = len then { v = Key d; succs = t.succs } else
      let v = match t.v with
      | Amb | Pre _ -> Amb | Key _ as v -> v | Nil -> pre_d
      in
      let succs =
        let t' = try Cmap.find k.[i] t.succs with Not_found -> empty in
        Cmap.add k.[i] (aux t' k len (i + 1) d pre_d) t.succs
      in
      { v; succs }
    in
    aux t k (String.length k) 0 d (Pre d (* allocate less *))

  let find_node t k =
    let rec aux t k len i =
      if i = len then t else
      aux (Cmap.find k.[i] t.succs) k len (i + 1)
    in
    aux t k (String.length k) 0

  let find t k =
    try match (find_node t k).v with
    | Key v | Pre v -> `Ok v | Amb -> `Ambiguous | Nil -> `Not_found
    with Not_found -> `Not_found

  let ambiguities t p =                        (* ambiguities of [p] in [t]. *)
    try
      let t = find_node t p in
      match t.v with
      | Key _ | Pre _ | Nil -> []
      | Amb ->
          let add_char s c = s ^ (String.make 1 c) in
          let rem_char s = String.sub s 0 ((String.length s) - 1) in
          let to_list m = Cmap.fold (fun k t acc -> (k,t) :: acc) m [] in
          let rec aux acc p = function
          | ((c, t) :: succs) :: rest ->
              let p' = add_char p c in
              let acc' = match t.v with
              | Pre _ | Amb -> acc
              | Key _ -> (p' :: acc)
              | Nil -> assert false
              in
              aux acc' p' ((to_list t.succs) :: succs :: rest)
          | [] :: [] -> acc
          | [] :: rest -> aux acc (rem_char p) rest
          | [] -> assert false
          in
          aux [] p (to_list t.succs :: [])
    with Not_found -> []

  let of_list l = List.fold_left (fun t (s, v) -> add t s v) empty l
end

(* The following types keep untyped information about arguments and
   terms. This data is used to parse the command line, report errors
   and format man page information. *)

type env_info =                (* information about an environment variable. *)
  { env_var : string;                                       (* the variable. *)
    env_doc : string;                                               (* help. *)
    env_docs : string; }              (* title of help section where listed. *)

type absence =        (* what happens if the argument is absent from the cl. *)
  | Error                                           (* an error is reported. *)
  | Val of string Lazy.t         (* if <> "", takes the given default value. *)

type opt_kind =                              (* kinds of optional arguments. *)
  | Flag                                      (* just a flag, without value. *)
  | Opt                                                (* value is required. *)
  | Opt_vopt of string     (* option value is optional, takes given default. *)

type pos_kind =                            (* kinds of positional arguments. *)
  | All                                         (* all positional arguments. *)
  | Nth of bool * int                                  (* specific position. *)
  | Left of bool * int                (* all args on the left of a position. *)
  | Right of bool * int              (* all args on the right of a position. *)

type arg_info =                (* information about a command line argument. *)
  { id : int;                               (* unique id for the argument. *)
    absent : absence;                              (* behaviour if absent. *)
    env_info : env_info option;                   (* environment variable. *)
    doc : string;                                                 (* help. *)
    docv : string;              (* variable name for the argument in help. *)
    docs : string;                  (* title of help section where listed. *)
    p_kind : pos_kind;                             (* positional arg kind. *)
    o_kind : opt_kind;                               (* optional arg kind. *)
    o_names : string list;                        (* names (for opt args). *)
    o_all : bool; }                          (* repeatable (for opt args). *)

let arg_id =        (* thread-safe UIDs, Oo.id (object end) was used before. *)
  let c = ref 0 in
  fun () ->
    let id = !c in
    incr c; if id > !c then assert false (* too many ids *) else id

let is_opt a = a.o_names <> []
let is_pos a = a.o_names = []

module Amap = Map.Make                                     (* arg info maps. *)
    (struct type t = arg_info let compare a a' = compare a.id a'.id end)

type arg =        (* unconverted argument data as found on the command line. *)
  | O of (int * string * (string option)) list (* (pos, name, value) of opt. *)
  | P of string list

type cmdline = arg Amap.t      (* command line, maps arg_infos to arg value. *)

type man_block = [                                 (* block of manpage text. *)
  | `S of string | `P of string | `Pre of string | `I of string * string
  | `Noblank ]

type term_info =
  { name : string;                                    (* name of the term. *)
    version : string option;                   (* version (for --version). *)
    tdoc : string;                        (* one line description of term. *)
    tdocs : string;       (* title of man section where listed (commands). *)
    sdocs : string;    (* standard options, title of section where listed. *)
    man : man_block list; }                              (* man page text. *)

type eval_info =                 (* informatin about the evaluation context. *)
  { term : term_info * arg_info list;               (* term being evaluated. *)
    main : term_info * arg_info list;                          (* main term. *)
    choices : (term_info * arg_info list) list;         (* all term choices. *)
    env : string -> string option }          (* environment variable lookup. *)

let eval_kind ei =                       (* evaluation with multiple terms ? *)
  if ei.choices = [] then `Simple else
  if (fst ei.term) == (fst ei.main) then `M_main else `M_choice

module Manpage = struct
  type title = string * int * string * string * string
  type block = man_block
  type t = title * block list

  let p_indent = 7                                  (* paragraph indentation. *)
  let l_indent = 4                                      (* label indentation. *)
  let escape subst esc buf s =
    let subst s =
      let len = String.length s in
      if not (len > 1 && s.[1] = ',') then (subst s) else
      if len = 2 then "" else
      esc s.[0] (String.sub s 2 (len - 2))
    in
    try
      Buffer.clear buf; Buffer.add_substitute buf subst s;
      let s = Buffer.contents buf in (* twice for $(i,$(mname)). *)
      Buffer.clear buf; Buffer.add_substitute buf subst s;
      Buffer.contents buf
    with Not_found -> invalid_arg (err_doc_string s)

  let pr_tokens ?(groff = false) ppf s =
    let is_space = function ' ' | '\n' | '\r' | '\t' -> true | _ -> false in
    let len = String.length s in
    let i = ref 0 in
    try while (true) do
        while (!i < len && is_space s.[!i]) do incr i done;
        let start = !i in
        if start = len then raise Exit;
        while (!i < len && not (is_space s.[!i]) && not (s.[!i] = '-')) do
          incr i
        done;
        pr_str ppf (String.sub s start (!i - start));
        if !i = len then raise Exit;
        if s.[!i] = '-' then
          (incr i; if groff then pr_str ppf "\\-" else pr_char ppf '-');
        if (!i < len && is_space s.[!i]) then
          (if groff then pr_char ppf ' ' else Format.pp_print_space ppf ())
      done with Exit -> ()

  (* Plain text output *)

  let plain_esc c s = match c with 'g' -> "" (* groff specific *) | _ ->  s
  let pr_indent ppf c = for i = 1 to c do pr_char ppf ' ' done
  let pr_plain_blocks subst ppf ts =
    let buf = Buffer.create 1024 in
    let escape t = escape subst plain_esc buf t in
    let pr_tokens ppf t = pr_tokens ppf (escape t) in
    let rec aux = function
    | [] -> ()
    | t :: ts ->
        begin match t with
        | `Noblank -> ()
        | `P s -> pr ppf "%a@[%a@]@," pr_indent p_indent pr_tokens s
        | `S s -> pr ppf "@[%a@]" pr_tokens s
        | `Pre s -> pr ppf "%a@[%a@]@," pr_indent p_indent pr_lines (escape s)
        | `I (label, s) ->
            let label = escape label in
            let ll = String.length label in
            pr ppf "@[%a@[%a@]" pr_indent p_indent pr_tokens label;
            if s = "" then () else
            if ll < l_indent then
              pr ppf "%a@[%a@]@]@," pr_indent (l_indent - ll) pr_tokens s
            else
            pr ppf "@\n%a@[%a@]@]@,"
              pr_indent (p_indent + l_indent) pr_tokens s
        end;
        begin match ts with
        | `Noblank :: ts -> aux ts
        | ts -> Format.pp_print_cut ppf (); aux ts
        end
    in
    aux ts

  let pr_plain_page subst ppf (_, text) =
    pr ppf "@[<v>%a@]" (pr_plain_blocks subst) text

  (* Groff output *)

  let groff_esc c s = match c with
  | 'i' -> (str "\\fI%s\\fR" s)
  | 'b' -> (str "\\fB%s\\fR" s)
  | 'p' -> "" (* plain text specific *)
  | _ -> s

  let pr_groff_lines ppf s =
    let left = ref 0 and right = ref 0 and len = String.length s in
    let flush () =
      Format.pp_print_string ppf (String.sub s !left (!right - !left));
      incr right; left := !right;
    in
    while (!right <> len) do
      if s.[!right] = '\n' then (flush (); Format.pp_force_newline ppf ()) else
      if s.[!right] = '-' then (flush (); pr_str ppf "\\-") else
      incr right;
    done;
    if !left <> len then flush ()

  let pr_groff_blocks subst ppf text =
    let buf = Buffer.create 1024 in
    let escape t = escape subst groff_esc buf t in
    let pr_tokens ppf t = pr_tokens ~groff:true ppf (escape t) in
    let pr_block = function
    | `P s -> pr ppf "@\n.P@\n%a" pr_tokens s
    | `Pre s -> pr ppf "@\n.P@\n.nf@\n%a@\n.fi" pr_groff_lines (escape s)
    | `S s -> pr ppf "@\n.SH %a" pr_tokens s
    | `Noblank -> pr ppf "@\n.sp -1"
    | `I (l, s) -> pr ppf "@\n.TP 4@\n%a@\n%a" pr_tokens l pr_tokens s
    in
    List.iter pr_block text

  let pr_groff_page subst ppf ((n, s, a1, a2, a3), t) =
    pr ppf ".\\\" Pipe this output to groff -man -Tutf8 | less@\n\
            .\\\"@\n\
            .TH \"%s\" %d \"%s\" \"%s\" \"%s\"@\n\
            .\\\" Disable hyphenation and ragged-right@\n\
            .nh@\n\
      .ad l\
      %a@?"
      n s a1 a2 a3 (pr_groff_blocks subst) t

  (* Printing to a pager *)

  let find_cmd cmds =
    let test, null = match Sys.os_type with
    | "Win32" -> "where", " NUL"
    | _ -> "type", "/dev/null"
    in
    let cmd c = Sys.command (str "%s %s 1>%s 2>%s" test c null null) = 0 in
    try Some (List.find cmd cmds) with Not_found -> None

  let pr_to_pager print ppf v =
    let pager =
      let cmds = ["less"; "more"] in
      let cmds = try (Sys.getenv "PAGER") :: cmds with Not_found -> cmds in
      let cmds = try (Sys.getenv "MANPAGER") :: cmds with Not_found -> cmds in
      find_cmd cmds
    in
    match pager with
    | None -> print `Plain ppf v
    | Some pager ->
        let cmd = match (find_cmd ["groff"; "nroff"]) with
        | None ->
            begin match pr_to_temp_file (print `Plain) v with
            | None -> None
            | Some f -> Some (str "%s < %s" pager f)
            end
        | Some c ->
            begin match pr_to_temp_file (print `Groff) v with
            | None -> None
            | Some f ->
                (* TODO use -Tutf8, but annoyingly maps U+002D to U+2212. *)
                let xroff = if c = "groff" then c ^ " -Tascii -P-c" else c in
                Some (str "%s -man < %s | %s" xroff f pager)
            end
        in
        match cmd with
        | None -> print `Plain ppf v
        | Some cmd -> if (Sys.command cmd) <> 0 then print `Plain ppf v

  let rec print ?(subst = fun x -> x) fmt ppf page = match fmt with
  | `Pager -> pr_to_pager (print ~subst) ppf page
  | `Plain -> pr_plain_page subst ppf page
  | `Groff -> pr_groff_page subst ppf page
end

module Help = struct
  let invocation ?(sep = ' ') ei = match eval_kind ei with
  | `Simple | `M_main -> (fst ei.main).name
  | `M_choice -> str "%s%c%s" (fst ei.main).name sep (fst ei.term).name

  let title ei =
    let prog = String.capitalize (fst ei.main).name in
    let name = String.uppercase (invocation ~sep:'-' ei) in
    let left_footer = prog ^ match (fst ei.main).version with
      | None -> "" | Some v -> str " %s" v
    in
    let center_header = str "%s Manual" prog in
    name, 1, "", left_footer, center_header

  let name_section ei =
    let tdoc d = if d = "" then "" else (str " - %s" d) in
    [`S "NAME"; `P (str "%s%s" (invocation ~sep:'-' ei)
                      (tdoc (fst ei.term).tdoc)); ]

  let synopsis ei = match eval_kind ei with
  | `M_main -> str "$(b,%s) $(i,COMMAND) ..." (invocation ei)
  | `Simple | `M_choice ->
      let rev_cmp (p, _) (p', _) = match p', p with        (* best effort. *)
      | p, All -> -1 | All, p -> 1
      | Left _, Right _ -> -1 | Right _, Left _ -> 1
      | Left (false, k), Nth (false, k')
      | Nth (false, k), Nth (false, k')
      | Nth (false, k), Right (false, k') -> if k <= k' then -1 else 1
      | Nth (false, k), Left (false, k')
      | Right (false, k), Nth (false, k') -> if k >= k' then 1 else -1
      | Left (true, k), Nth (true, k')
      | Nth (true, k), Nth (true, k')
      | Nth (true, k), Right (true, k') -> if k >= k' then -1 else 1
      | Nth (true, k), Left (true, k')
      | Right (true, k), Nth (true, k') -> if k <= k' then 1 else -1
      | p, p' -> compare p p'
      in
      let rec format_pos acc = function
      | a :: al ->
          if is_opt a then format_pos acc al else
          let v = if a.docv = "" then "$(i,ARG)" else str "$(i,%s)" a.docv in
          let v = if a.absent = Error then str "%s" v else str "[%s]" v in
          let v = v ^ match a.p_kind with Nth _ -> "" | _ -> "..." in
          format_pos ((a.p_kind, v) :: acc) al
      | [] -> acc
      in
      let args = List.sort rev_cmp (format_pos [] (snd ei.term)) in
      let args = String.concat " " (List.rev_map snd args) in
      str "$(b,%s) [$(i,OPTION)]... %s" (invocation ei) args

  let get_synopsis_section ei =
    let rec extract_synopsis syn = function
    | `S _ :: _ as man -> List.rev syn, man
    |  block :: rest -> extract_synopsis (block :: syn) rest
    | [] -> List.rev syn, []
    in
    match (fst ei.term).man with
    | `S "SYNOPSIS" as s :: rest -> extract_synopsis [s] rest (* user-defined *)
    | man -> [ `S "SYNOPSIS"; `P (synopsis ei); ], man           (* automatic *)

  let or_env a = match a.env_info with
  | None -> ""
  | Some v -> str " or $(i,%s) env" v.env_var

  let make_arg_label a =
    if is_pos a then str "$(i,%s)" a.docv else
    let fmt_name var = match a.o_kind with
    | Flag -> fun n -> str "$(b,%s)%s" n (or_env a)
    | Opt ->
        fun n ->
          if String.length n > 2 then str "$(b,%s)=$(i,%s)" n var else
          str "$(b,%s) $(i,%s)" n var
    | Opt_vopt _ ->
        fun n ->
          if String.length n > 2 then str "$(b,%s)[=$(i,%s)]" n var else
          str "$(b,%s) [$(i,%s)]" n var
    in
    let var = if a.docv = "" then "VAL" else a.docv in
    let names = List.sort compare a.o_names in
    let s = String.concat ", " (List.rev_map (fmt_name var) names) in
    s

  let arg_info_substs ~buf a doc =
    let subst = function
    | "docv" -> str "$(i,%s)" a.docv
    | "opt" when is_opt a ->
        let k = String.lowercase (List.hd (List.sort compare a.o_names)) in
        str "$(b,%s)" k
    | "env" when a.env_info <> None ->
        begin match a.env_info with
        | None -> assert false
        | Some v -> str "$(i,%s)" v.env_var
        end
    | s -> str "$(%s)" s in
    try
      Buffer.clear buf;
      Buffer.add_substitute buf subst doc;
      Buffer.contents buf
    with Not_found -> invalid_arg (err_doc_string doc)

  let make_arg_items ei =
    let buf = Buffer.create 200 in
    let cmp a a' =
      let c = compare a.docs a'.docs in
      if c <> 0 then c else
      match is_opt a, is_opt a' with
      | true, true ->
          let key names =
            let k = String.lowercase (List.hd (List.sort rev_compare names)) in
            if k.[1] = '-' then String.sub k 1 (String.length k - 1) else k
          in
          compare (key a.o_names) (key a'.o_names)
      | false, false ->
          compare (String.lowercase a.docv) (String.lowercase a'.docv)
      | true, false -> -1
      | false, true -> 1
    in
    let format a =
      let absent = match a.absent with
      | Error -> ""
      | Val v -> match Lazy.force v with
      | "" -> ""
      | v -> str "absent=%s%s" v (or_env a)
      in
      let optvopt = match a.o_kind with
      | Opt_vopt v -> str "default=%s" v
      | _ -> ""
      in
      let argvdoc = match optvopt, absent with
      | "", "" -> ""
      | s, "" | "", s -> str " (%s)" s
      | s, s' -> str " (%s) (%s)" s s'
      in
      (a.docs, `I (make_arg_label a ^ argvdoc, (arg_info_substs ~buf a a.doc)))
    in
    let is_arg_item a = not (is_pos a && (a.docv = "" || a.doc = "")) in
    let l = List.sort cmp (List.filter is_arg_item (snd ei.term)) in
    List.rev_map format l

  let make_env_items_rev ei =
    let buf = Buffer.create 200 in
    let cmp a a' =
      let e' = match a'.env_info with None -> assert false | Some a' -> a' in
      let e = match a.env_info with None -> assert false | Some a -> a in
      let c = compare e.env_docs e'.env_docs in
      if c <> 0 then c else
      compare e.env_var e'.env_var
    in
    let format a =
      let e = match a.env_info with None -> assert false | Some a -> a in
      (e.env_docs,
       `I (str "$(i,%s)" e.env_var, arg_info_substs ~buf a e.env_doc))
    in
    let is_env_item a = a.env_info <> None in
    let l = List.sort cmp (List.filter is_env_item (snd ei.term)) in
    List.rev_map format l

  let make_cmd_items ei = match eval_kind ei with
  | `Simple | `M_choice -> []
  | `M_main ->
      let add_cmd acc (ti, _) =
        (ti.tdocs, `I ((str "$(b,%s)" ti.name), ti.tdoc)) :: acc
      in
      List.sort rev_compare (List.fold_left add_cmd [] ei.choices)

  let text ei =                  (* man that code is particulary unreadable. *)
    let rec merge_items acc to_insert mark il = function
    | `S s as sec :: ts ->
        let acc = List.rev_append to_insert acc in
        let acc = if mark then sec :: `Orphan_mark :: acc else sec :: acc in
        let to_insert, il = List.partition (fun (n, _) -> n = s) il in
        let to_insert = List.rev_map (fun (_, i) -> i) to_insert in
        let to_insert = (to_insert :> [ `Orphan_mark | Manpage.block] list) in
        merge_items acc to_insert (s = "DESCRIPTION") il ts
    | t :: ts ->
        let t = (t :> [`Orphan_mark | Manpage.block]) in
        merge_items (t :: acc) to_insert mark il ts
    | [] ->
        let acc = List.rev_append to_insert acc in
        (if mark then `Orphan_mark :: acc else acc), il
    in
    let rec merge_orphans acc orphans = function
    | `Orphan_mark :: ts ->
        let rec merge acc s = function
        | [] -> (`S s) :: acc
        | (s', i) :: ss ->
            let i = (i :> Manpage.block) in
            if s = s' then merge (i :: acc) s ss else
            merge (i :: (`S s) :: acc) s' ss
        in
        let acc = match orphans with
        | [] -> acc | (s, _) :: _ -> merge acc s orphans
        in
        merge_orphans acc [] ts
    | (#Manpage.block as e) :: ts -> merge_orphans (e :: acc) orphans ts
    | [] -> acc
    in
    let cmds = make_cmd_items ei in
    let args = make_arg_items ei in
    let envs_rev = make_env_items_rev ei in
    let items_rev = List.rev_append cmds (List.rev_append args envs_rev) in
    let cmp (s, _) (s', _) = match s, s with
    | "ENVIRONMENT VARIABLES", _ -> 1  (* Put env vars at the end. *)
    | s, "ENVIRONMENT VARIABLES" -> -1
    | s, s' -> compare s s' (* other predefined sec. names order correctly *)
    in
    let items = List.rev (List.stable_sort cmp items_rev) in
    let synopsis, man = get_synopsis_section ei in
    let rev_text, orphans = merge_items [`Orphan_mark] [] false items man in
    synopsis @ merge_orphans [] orphans rev_text

  let ei_subst ei = function
  | "tname" -> (fst ei.term).name
  | "mname" -> (fst ei.main).name
  | s -> str "$(%s)" s

  let man ei =
    title ei, (name_section ei) @ (text ei)

  let print fmt ppf ei = Manpage.print ~subst:(ei_subst ei) fmt ppf (man ei)
  let pr_synopsis ppf ei =
    pr ppf "@[%s@]"
      (Manpage.escape (ei_subst ei)
         Manpage.plain_esc (Buffer.create 100) (synopsis ei))

  let pr_version ppf ei = match (fst ei.main).version with
  | None -> assert false
  | Some v -> pr ppf "@[%a@]@." pr_text v
end

(* Errors for the command line user *)

module Err = struct
  let invalid kind s exp = str "invalid %s %s, %s" kind (quote s) exp
  let invalid_val = invalid "value"
  let no kind s = str "no %s %s" (quote s) kind
  let not_dir s = str "%s is not a directory" (quote s)
  let is_dir s = str "%s is a directory" (quote s)
  let element kind s exp = str "invalid element in %s (`%s'): %s" kind s exp
  let sep_miss sep s = invalid_val s (str "missing a `%c' separator" sep)
  let unknown kind ?(hints = []) v =
    let did_you_mean s = str ", did you mean %s ?" s in
    let hints = match hints with [] -> "." | hs -> did_you_mean (alts_str hs) in
    str "unknown %s %s%s" kind (quote v) hints

  let ambiguous kind s ambs =
    str "%s %s ambiguous and could be %s" kind (quote s) (alts_str ambs)

  let pos_excess excess =
    str "too many arguments, don't know what to do with %s"
      (String.concat ", " (List.map quote excess))

  let flag_value f v =
    str "option %s is a flag, it cannot take the argument %s"
      (quote f) (quote v)

  let opt_value_missing f = str "option %s needs an argument" (quote f)
  let opt_parse_value f e = str "option %s: %s" (quote f) e
  let env_parse_value var e = str "environment variable %s: %s" (quote var) e
  let opt_repeated f f' =
    if f = f' then str "option %s cannot be repeated" (quote f) else
    str "options %s and %s cannot be present at the same time" (quote f)
      (quote f')

  let pos_parse_value a e =
    if a.docv = "" then e else match a.p_kind with
    | Nth _ -> str "%s argument: %s" a.docv e
    | _ -> str "%s... arguments: %s" a.docv e

  let arg_missing a =
    if is_opt a then
      let rec long_name = function
      | n :: l -> if (String.length n) > 2 || l = [] then n else long_name l
      | [] -> assert false
      in
      str "required option %s is missing" (long_name a.o_names)
    else
    if a.docv = "" then str "a required argument is missing" else
    str "required argument %s is missing" a.docv

  (* Error printers *)

  let print ppf ei e = pr ppf "%s: @[%a@]@." (fst ei.main).name pr_text e
  let pr_backtrace err ei e bt =
    let bt =
      let len = String.length bt in
      if len > 0 then String.sub bt 0 (len - 1) (* remove final '\n' *) else bt
    in
    pr err
      "%s: @[internal error, uncaught exception:@\n%a@]@."
      (fst ei.main).name pr_lines (str "%s\n%s" (Printexc.to_string e) bt)

  let pr_try_help ppf ei =
    let exec = Help.invocation ei in
    let main = (fst ei.main).name in
    if exec = main then
      pr ppf "@[<2>Try `%s --help' for more information.@]" exec
    else
    pr ppf "@[<2>Try `%s --help' or `%s --help' for more information.@]"
      exec main

  let pr_usage ppf ei e =
    pr ppf "@[<v>%s: @[%a@]@,@[Usage: @[%a@]@]@,%a@]@."
      (fst ei.main).name pr_text e Help.pr_synopsis ei pr_try_help ei
end

(* Command lines. A command line stores pre-parsed information about
   the command line's arguments in a more structured way. Given the
   [arg_info] values mentionned in a term and Sys.argv (whithout exec
   name) we parse the command line into a map of [arg_info] values to
   [arg] values. This map is used by the term's closures to retrieve
   and convert command line arguments (see the Arg module). *)

module Cmdline :sig
  exception Error of string
  val choose_term : term_info -> (term_info * 'a) list -> string list ->
    term_info * string list
  val create : ?peek_opts:bool -> arg_info list -> string list -> cmdline
  val opt_arg : cmdline -> arg_info -> (int * string * (string option)) list
  val pos_arg : cmdline -> arg_info -> string list
end = struct
  exception Error of string

  let opt_arg cl a = match try Amap.find a cl with Not_found -> assert false
  with O l -> l | _ -> assert false

  let pos_arg cl a = match try Amap.find a cl with Not_found -> assert false
  with P l -> l | _ -> assert false

  let choose_term ti choices = function
  | [] -> ti, []
  | maybe :: args' as args ->
      if String.length maybe > 1 && maybe.[0] = '-' then ti, args else
      let index =
        let add acc (choice, _) = Trie.add acc choice.name choice in
        List.fold_left add Trie.empty choices
      in
      match Trie.find index maybe with
      | `Ok choice -> choice, args'
      | `Not_found ->
        let all = Trie.ambiguities index "" in
        let hints = suggest maybe all in
        raise (Error (Err.unknown "command" ~hints maybe))
      | `Ambiguous ->
          let ambs = List.sort compare (Trie.ambiguities index maybe) in
          raise (Error (Err.ambiguous "command" maybe ambs))

  let arg_info_indexes al =
    (* from [al] returns a trie mapping the names of optional arguments to
       their arg_info, a list with all arg_info for positional arguments and
       a cmdline mapping each arg_info to an empty [arg]. *)
    let rec aux opti posi cl = function
    | a :: l ->
        if is_pos a then aux opti (a :: posi) (Amap.add a (P []) cl) l else
        let add t name = Trie.add t name a in
        aux (List.fold_left add opti a.o_names) posi (Amap.add a (O []) cl) l
    | [] -> opti, posi, cl
    in
    aux Trie.empty [] Amap.empty al

  let parse_opt_arg s =          (* (name,value) of opt arg, assert len > 1. *)
    let l = String.length s in
    if s.[1] <> '-' then
      if l = 2 then s, None else
      String.sub s 0 2, Some (String.sub s 2 (l - 2))
    else try
      let i = String.index s '=' in
      String.sub s 0 i, Some (String.sub s (i + 1) (l - i - 1))
    with Not_found -> s, None

  let parse_args ~peek_opts opti cl args =
    (* returns an updated [cl] cmdline according to the options found in [args]
       with the trie index [opti]. Positional arguments are returned in order
       in a list. *)
    let rec aux k opti cl pargs = function
    | [] -> cl, (List.rev pargs)
    | "--" :: args -> cl, (List.rev_append pargs args)
    | s :: args ->
        let is_opt s = String.length s > 1 && s.[0] = '-' in
        let is_short_opt s = String.length s = 2 && s.[0] = '-' in
        if not (is_opt s) then aux (k+1) opti cl (s :: pargs) args else
        let name, value = parse_opt_arg s in
        match Trie.find opti name with
        | `Ok a ->
            let value, args = match value, a.o_kind with
            | Some v, Flag when is_short_opt name -> None, ("-" ^ v) :: args
            | Some v, _ -> value, args
            | None, Flag -> value, args
            | None, _ ->
                match args with
                | v :: rest -> if is_opt v then None, args else Some v, rest
                | [] -> None, args
            in
            let arg = O ((k, name, value) :: opt_arg cl a) in
            aux (k+1) opti (Amap.add a arg cl) pargs args
        | `Not_found when peek_opts -> aux (k+1) opti cl pargs args (* skip *)
        | `Not_found ->
            let hints =
              if String.length s <= 2 then [] else
              let short_opt, long_opt =
                if s.[1] <> '-'
                then s, Printf.sprintf "-%s" s
                else String.sub s 1 (String.length s - 1), s
              in
              let short_opt, _ = parse_opt_arg short_opt in
              let long_opt, _ = parse_opt_arg long_opt in
              let all = Trie.ambiguities opti "-" in
              match List.mem short_opt all, suggest long_opt all with
              | false, [] -> []
              | false, l -> l
              | true, [] -> [short_opt]
              | true, l -> if List.mem short_opt l then l else short_opt :: l
            in
            raise (Error (Err.unknown "option" ~hints name))
        | `Ambiguous ->
            let ambs = List.sort compare (Trie.ambiguities opti name) in
            raise (Error (Err.ambiguous "option" name ambs))
    in
    aux 0 opti cl [] args

  let process_pos_args posi cl pargs =
    (* returns an updated [cl] cmdline in which each positional arg mentionned
       in the list index posi, is given a value according the list
       of positional arguments values [pargs]. *)
    if pargs = [] then cl else
    let rec take n acc l =
      if n = 0 then List.rev acc else
      take (n - 1) (List.hd l :: acc) (List.tl l)
    in
    let rec aux pargs last cl max_spec = function
    | a :: al ->
        let arg, max_spec = match a.p_kind with
        | All -> P pargs, last
        | Nth (rev, k) ->
            let k = if rev then last - k else k in
            let max_spec = max k max_spec in
            if k < 0 || k > last then P [], max_spec else
            P ([List.nth pargs k]), max_spec
        | Left (rev, k) ->
            let k = if rev then last - k else k in
            let max_spec = max k max_spec in
            if k <= 0 || k > last then P [], max_spec else
            P (take k [] pargs), max_spec
        | Right (rev, k) ->
            let k = if rev then last - k else k in
            if k < 0 || k >= last then P [], last else
            P (List.rev (take (last - k) [] (List.rev pargs))), last
        in
        aux pargs last (Amap.add a arg cl) max_spec al
    | [] -> cl, max_spec
    in
    let last = List.length pargs - 1 in
    let cl, max_spec = aux pargs last cl (-1) posi in
    if last <= max_spec then cl else
    let excess = List.rev (take (last - max_spec) [] (List.rev pargs)) in
    raise (Error (Err.pos_excess excess))

  let create ?(peek_opts = false) al args =
    let opti, posi, cl = arg_info_indexes al in
    let cl, pargs = parse_args ~peek_opts opti cl args in
    if peek_opts then cl (* skip positional arguments *) else
    process_pos_args posi cl pargs
end

module Arg = struct
  type 'a parser = string -> [ `Ok of 'a | `Error of string ]
  type 'a printer = Format.formatter -> 'a -> unit
  type 'a converter = 'a parser * 'a printer
  type env = env_info
  type 'a arg_converter = (eval_info -> cmdline -> 'a)
  type 'a t = arg_info list * 'a arg_converter
  type info = arg_info

  let env_var ?(docs = "ENVIRONMENT VARIABLES") ?(doc = "See option $(opt).")
      env_var
    =
    { env_var = env_var; env_doc = doc; env_docs = docs }

  let ( & ) f x = f x
  let parse_error e = raise (Cmdline.Error e)
  let some ?(none = "") (parse, print) =
    (fun s -> match parse s with `Ok v -> `Ok (Some v) | `Error _ as e -> e),
    (fun ppf v -> match v with None -> pr_str ppf none| Some v -> print ppf v)

  let info ?docs ?(docv = "") ?(doc = "") ?env names =
    let dash n = if String.length n = 1 then "-" ^ n else "--" ^ n in
    let docs = match docs with
    | None -> if names = [] then "ARGUMENTS" else "OPTIONS"
    | Some s -> s
    in
    { id = arg_id (); absent = Val (lazy "");
      env_info = env;
      doc = doc; docv = docv; docs = docs;
      p_kind = All; o_kind = Flag; o_names = List.rev_map dash names;
      o_all = false; }

  let env_bool_parse s = match String.lowercase s with
  | "" | "false" | "no" | "n" | "0" -> `Ok false
  | "true" | "yes" | "y" | "1" -> `Ok true
  | s -> `Error (Err.invalid_val s (alts_str ["true"; "yes"; "false"; "no" ]))

  let parse_to_list parser s = match parser s with
  | `Ok v -> `Ok [v]
  | `Error _ as e -> e

  let try_env ei a parse ~absent = match a.env_info with
  | None -> absent
  | Some env ->
      match ei.env env.env_var with
      | None -> absent
      | Some v ->
          match parse v with
          | `Ok v -> v
          | `Error e ->
              parse_error (Err.env_parse_value env.env_var e)

  let flag a =
    if is_pos a then invalid_arg err_not_opt else
    let convert ei cl = match Cmdline.opt_arg cl a with
    | [] -> try_env ei a env_bool_parse ~absent:false
    | [_, _, None] -> true
    | [_, f, Some v] -> parse_error (Err.flag_value f v)
    | (_, f, _) :: (_ ,g, _) :: _  -> parse_error (Err.opt_repeated f g)
    in
    [a], convert

  let flag_all a =
    if is_pos a then invalid_arg err_not_opt else
    let a = { a with o_all = true } in
    let convert ei cl = match Cmdline.opt_arg cl a with
    | [] -> try_env ei a (parse_to_list env_bool_parse) ~absent:[]
    | l ->
        let truth (_, f, v) = match v with
        | None -> true | Some v -> parse_error (Err.flag_value f v)
        in
        List.rev_map truth l
    in
    [a], convert

  let vflag v l =
    let convert _ cl =
      let rec aux fv = function
      | (v, a) :: rest ->
          begin match Cmdline.opt_arg cl a with
          | [] -> aux fv rest
          | [_, f, None] ->
              begin match fv with
              | None -> aux (Some (f, v)) rest
              | Some (g, _) -> parse_error (Err.opt_repeated g f)
              end
          | [_, f, Some v] -> parse_error (Err.flag_value f v)
          | (_, f, _) :: (_, g, _) :: _ -> parse_error (Err.opt_repeated g f)
          end
      | [] -> match fv with None -> v | Some (_, v) -> v
      in
      aux None l
    in
    let flag (_, a) = if is_pos a then invalid_arg err_not_opt else a in
    List.rev_map flag l, convert

  let vflag_all v l =
    let convert _ cl =
      let rec aux acc = function
      | (fv, a) :: rest ->
          begin match Cmdline.opt_arg cl a with
          | [] -> aux acc rest
          | l ->
              let fval (k, f, v) = match v with
              | None -> (k, fv) | Some v -> parse_error (Err.flag_value f v)
              in
              aux (List.rev_append (List.rev_map fval l) acc) rest
          end
      | [] ->
          if acc = [] then v else List.rev_map snd (List.sort rev_compare acc)
      in
      aux [] l
    in
    let flag (_, a) =
      if is_pos a then invalid_arg err_not_opt else { a with o_all = true }
    in
    List.rev_map flag l, convert

  let parse_opt_value parse f v = match parse v with
  | `Ok v -> v | `Error e -> parse_error (Err.opt_parse_value f e)

  let opt ?vopt (parse, print) v a =
    if is_pos a then invalid_arg err_not_opt else
    let a = { a with absent = Val (lazy (str_of_pp print v));
                     o_kind = match vopt with
                     | None -> Opt | Some dv -> Opt_vopt (str_of_pp print dv) }
    in
    let convert ei cl = match Cmdline.opt_arg cl a with
    | [] -> try_env ei a parse ~absent:v
    | [_, f, Some v] -> parse_opt_value parse f v
    | [_, f, None] ->
        begin match vopt with
        | None -> parse_error (Err.opt_value_missing f)
        | Some optv -> optv
        end
    | (_, f, _) :: (_, g, _) :: _ -> parse_error (Err.opt_repeated g f)
    in
    [a], convert

  let opt_all ?vopt (parse, print) v a =
    if is_pos a then invalid_arg err_not_opt else
    let a = { a with absent = Val (lazy ""); o_all = true;
                     o_kind = match vopt with
                     | None -> Opt | Some dv -> Opt_vopt (str_of_pp print dv) }
    in
    let convert ei cl = match Cmdline.opt_arg cl a with
    | [] -> try_env ei a (parse_to_list parse) ~absent:v
    | l ->
        let parse (k, f, v) = match v with
        | Some v -> (k, parse_opt_value parse f v)
        | None -> match vopt with
        | None -> parse_error (Err.opt_value_missing f)
        | Some dv -> (k, dv)
        in
        List.rev_map snd (List.sort rev_compare (List.rev_map parse l))
    in
    [a], convert

  (* Positional arguments *)

  let parse_pos_value parse a v = match parse v with
  | `Ok v -> v | `Error e -> parse_error (Err.pos_parse_value a e)

  let pos ?(rev = false) k (parse, print) v a =
    if is_opt a then invalid_arg err_not_pos else
    let a = { a with p_kind = Nth (rev, k);
                     absent = Val (lazy (str_of_pp print v)) }
    in
    let convert ei cl = match Cmdline.pos_arg cl a with
    | [] -> try_env ei a parse ~absent:v
    | [v] -> parse_pos_value parse a v
    | _ -> assert false
    in
    [a], convert

  let pos_list kind (parse, _) v a =
    if is_opt a then invalid_arg err_not_pos else
    let a = { a with p_kind = kind } in
    let convert ei cl = match Cmdline.pos_arg cl a with
    | [] -> try_env ei a (parse_to_list parse) ~absent:v
    | l -> List.rev (List.rev_map (parse_pos_value parse a) l)
    in
    [a], convert

  let pos_all c v a = pos_list All c v a
  let pos_left ?(rev = false) k = pos_list (Left (rev, k))
  let pos_right ?(rev = false) k = pos_list (Right (rev, k))

  (* Arguments as terms *)

  let absent_error al = List.rev_map (fun a -> { a with absent = Error }) al
  let value a = a
  let required (al, convert) =
    let al = absent_error al in
    let convert ei cl = match convert ei cl with
    | Some v -> v
    | None -> parse_error (Err.arg_missing (List.hd al))
    in
    al, convert

  let non_empty (al, convert) =
    let al = absent_error al in
    let convert ei cl = match convert ei cl with
    | [] -> parse_error (Err.arg_missing (List.hd al))
    | l -> l
    in
    al, convert

  let last (al, convert) =
    let convert ei cl = match convert ei cl with
    | [] -> parse_error (Err.arg_missing (List.hd al))
    | l -> List.hd (List.rev l)
    in
    al, convert

  (* Predefined converters. *)

  let bool =
    (fun s -> try `Ok (bool_of_string s) with Invalid_argument _ ->
        `Error (Err.invalid_val s (alts_str ["true"; "false"]))),
    Format.pp_print_bool

  let char =
    (fun s -> if String.length s = 1 then `Ok s.[0] else
      `Error (Err.invalid_val s "expected a character")),
    pr_char

  let parse_with t_of_str exp s =
    try `Ok (t_of_str s) with Failure _ -> `Error (Err.invalid_val s exp)

  let int =
    parse_with int_of_string "expected an integer", Format.pp_print_int

  let int32 =
    parse_with Int32.of_string "expected a 32-bit integer",
    (fun ppf -> pr ppf "%ld")

  let int64 =
    parse_with Int64.of_string "expected a 64-bit integer",
    (fun ppf -> pr ppf "%Ld")

  let nativeint =
    parse_with Nativeint.of_string "expected a processor-native integer",
    (fun ppf -> pr ppf "%nd")

  let float =
    parse_with float_of_string "expected a floating point number",
    Format.pp_print_float

  let string = (fun s -> `Ok s), pr_str
  let enum sl =
    if sl = [] then invalid_arg err_empty_list else
    let t = Trie.of_list sl in
    let parse s = match Trie.find t s with
    | `Ok _ as r -> r
    | `Ambiguous ->
        let ambs = List.sort compare (Trie.ambiguities t s) in
        `Error (Err.ambiguous "enum value" s ambs)
    | `Not_found ->
        let alts = List.rev (List.rev_map (fun (s, _) -> s) sl) in
        `Error (Err.invalid_val s ("expected " ^ (alts_str alts)))
    in
    let print ppf v =
      let sl_inv = List.rev_map (fun (s,v) -> (v,s)) sl in
      try pr_str ppf (List.assoc v sl_inv)
      with Not_found -> invalid_arg err_incomplete_enum
    in
    parse, print

  let file =
    (fun s -> if Sys.file_exists s then `Ok s else
      `Error (Err.no "file or directory" s)),
    pr_str

  let dir =
    (fun s ->
       if Sys.file_exists s then
         if Sys.is_directory s then `Ok s else `Error (Err.not_dir s)
       else
       `Error (Err.no "directory" s)),
    pr_str

  let non_dir_file =
    (fun s ->
       if Sys.file_exists s then
         if not (Sys.is_directory s) then `Ok s else `Error (Err.is_dir s)
       else
       `Error (Err.no "file" s)),
    pr_str

  let split_and_parse sep parse s =
    let parse sub = match parse sub with
    | `Error e -> failwith e | `Ok v -> v in
    let rec split accum j =
      let i = try String.rindex_from s j sep with Not_found -> -1 in
      if (i = -1) then
        let p = String.sub s 0 (j + 1) in
        if p <> "" then parse p :: accum else accum
      else
      let p = String.sub s (i + 1) (j - i) in
      let accum' = if p <> "" then parse p :: accum else accum in
      split accum' (i - 1)
    in
    split [] (String.length s - 1)

  let list ?(sep = ',') (parse, pr_e) =
    let parse s = try `Ok (split_and_parse sep parse s) with
    | Failure e -> `Error (Err.element "list" s e)
    in
    let rec print ppf = function
    | v :: l -> pr_e ppf v; if (l <> []) then (pr_char ppf sep; print ppf l)
    | [] -> ()
    in
    parse, print

  let array ?(sep = ',') (parse, pr_e) =
    let parse s = try `Ok (Array.of_list (split_and_parse sep parse s)) with
    | Failure e -> `Error (Err.element "array" s e)
    in
    let print ppf v =
      let max = Array.length v - 1 in
      for i = 0 to max do pr_e ppf v.(i); if i <> max then pr_char ppf sep done
    in
    parse, print

  let split_left sep s =
    try
      let i = String.index s sep in
      let len = String.length s in
      Some ((String.sub s 0 i), (String.sub s (i + 1) (len - i - 1)))
    with Not_found -> None

  let pair ?(sep = ',') (pa0, pr0) (pa1, pr1) =
    let parser s = match split_left sep s with
    | None -> `Error (Err.sep_miss sep s)
    | Some (v0, v1) ->
        match pa0 v0, pa1 v1 with
        | `Ok v0, `Ok v1 -> `Ok (v0, v1)
        | `Error e, _ | _, `Error e -> `Error (Err.element "pair" s e)
    in
    let printer ppf (v0, v1) = pr ppf "%a%c%a" pr0 v0 sep pr1 v1 in
    parser, printer

  let t2 = pair
  let t3 ?(sep = ',') (pa0, pr0) (pa1, pr1) (pa2, pr2) =
    let parse s = match split_left sep s with
    | None -> `Error (Err.sep_miss sep s)
    | Some (v0, s) ->
        match split_left sep s with
        | None -> `Error (Err.sep_miss sep s)
        | Some (v1, v2) ->
            match pa0 v0, pa1 v1, pa2 v2 with
            | `Ok v0, `Ok v1, `Ok v2 -> `Ok (v0, v1, v2)
            | `Error e, _, _ | _, `Error e, _ | _, _, `Error e ->
                `Error (Err.element "triple" s e)
    in
    let print ppf (v0, v1, v2) =
      pr ppf "%a%c%a%c%a" pr0 v0 sep pr1 v1 sep pr2 v2
    in
    parse, print

  let t4 ?(sep = ',') (pa0, pr0) (pa1, pr1) (pa2, pr2) (pa3, pr3) =
    let parse s = match split_left sep s with
    | None -> `Error (Err.sep_miss sep s)
    | Some(v0, s) ->
        match split_left sep s with
        | None -> `Error (Err.sep_miss sep s)
        | Some (v1, s) ->
            match split_left sep s with
            | None -> `Error (Err.sep_miss sep s)
            | Some (v2, v3) ->
                match pa0 v0, pa1 v1, pa2 v2, pa3 v3 with
                | `Ok v1, `Ok v2, `Ok v3, `Ok v4 -> `Ok (v1, v2, v3, v4)
                | `Error e, _, _, _ | _, `Error e, _, _ | _, _, `Error e, _
                | _, _, _, `Error e -> `Error (Err.element "quadruple" s e)
    in
    let print ppf (v0, v1, v2, v3) =
      pr ppf "%a%c%a%c%a%c%a" pr0 v0 sep pr1 v1 sep pr2 v2 sep pr3 v3
    in
    parse, print

  (* Documentation formatting helpers *)

  let doc_quote = quote
  let doc_alts = alts_str
  let doc_alts_enum ?quoted enum = alts_str ?quoted (List.map fst enum)
end

module Term = struct
  type info = term_info
  type +'a t = arg_info list * (eval_info -> cmdline -> 'a)
  type 'a result = [
    | `Ok of 'a | `Error of [`Parse | `Term | `Exn ] | `Version | `Help ]

  exception Term of
      [ `Help of [`Pager | `Plain | `Groff] * string option
      | `Error of bool * string ]

  let info  ?(sdocs = "OPTIONS") ?(man = []) ?(docs = "COMMANDS") ?(doc = "")
      ?version name =
    { name = name; version = version; tdoc = doc; tdocs = docs; sdocs = sdocs;
      man = man }

  let name ti = ti.name
  let const v = [], (fun _ _ -> v)
  let pure (* deprecated *) = const
  let app (al, f) (al', v) =
    List.rev_append al al',
    fun ei cl -> (f ei cl) (v ei cl)

  let ( $ ) = app

  type 'a ret =
    [ `Help of [`Pager | `Plain | `Groff] * string option
    | `Error of (bool * string)
    | `Ok of 'a ]

  let ret (al, v) =
    al, fun ei cl -> match v ei cl with
    | `Ok v -> v
    | `Error (u,e) -> raise (Term (`Error (u,e)))
    | `Help h -> raise (Term (`Help h))

  let main_name = [], (fun ei _ -> (fst ei.main).name)
  let choice_names =
    [], fun ei _ -> List.rev_map (fun e -> (fst e).name) ei.choices

  let man_format =
    let fmts = ["pager", `Pager; "groff", `Groff; "plain", `Plain] in
    let doc = "Show output in format $(docv) (pager, plain or groff)."in
    Arg.(value & opt (enum fmts) `Pager & info ["man-format"] ~docv:"FMT" ~doc)

  (* Evaluation *)

  let remove_exec argv =
    try List.tl (Array.to_list argv) with Failure _ -> invalid_arg err_argv

  let add_std_opts ei =
    let docs = (fst ei.term).sdocs in
    let args, v_lookup =
      if (fst ei.main).version = None then [], None else
      let (a, lookup) =
        Arg.flag (Arg.info ["version"] ~docs ~doc:"Show version information.")
      in
      a, Some lookup
    in
    let args, h_lookup =
      let (a, lookup) =
        let fmt = Arg.enum ["pager",`Pager; "groff",`Groff; "plain",`Plain] in
        let doc = "Show this help in format $(docv) (pager, plain or groff)."in
        let a = Arg.info ["help"] ~docv:"FMT" ~docs ~doc in
        Arg.opt ~vopt:(Some `Pager) (Arg.some fmt) None a
      in
      List.rev_append a args, lookup
    in
    h_lookup, v_lookup,
    { ei with term = (fst ei.term), List.rev_append args (snd ei.term) }

  let eval_term help err ei f args =
    let help_arg, vers_arg, ei = add_std_opts ei in
    try
      let cl = Cmdline.create (snd ei.term) args in
      match help_arg ei cl, vers_arg with
      | Some fmt, _ -> Help.print fmt help ei; `Help
      | None, Some v_arg when v_arg ei cl -> Help.pr_version help ei; `Version
      | _ -> `Ok (f ei cl)
    with
    | Cmdline.Error e -> Err.pr_usage err ei e; `Error `Parse
    | Term (`Error (usage, e)) ->
        if usage then Err.pr_usage err ei e else Err.print err ei e;
        `Error `Term
    | Term (`Help (fmt, cmd)) ->
        let ei = match cmd with
        | Some cmd ->
            let cmd =
              try List.find (fun (i, _) -> i.name = cmd) ei.choices
              with Not_found -> invalid_arg (err_help cmd)
            in
            {ei with term = cmd }
        | None -> { ei with term = ei.main }
        in
        let _, _, ei = add_std_opts ei in
        Help.print fmt help ei; `Help

  let env_default v = try Some (Sys.getenv v) with Not_found -> None

  let eval ?(help = Format.std_formatter) ?(err = Format.err_formatter)
      ?(catch = true) ?(env = env_default) ?(argv = Sys.argv) ((al, f), ti) =
    let term = ti, al in
    let ei = { term = term; main = term; choices = []; env = env } in
    try eval_term help err ei f (remove_exec argv) with
    | e when catch ->
        Err.pr_backtrace err ei e (Printexc.get_backtrace ()); `Error `Exn

  let eval_choice ?(help = Format.std_formatter) ?(err = Format.err_formatter)
      ?(catch = true) ?(env = env_default) ?(argv = Sys.argv)
      (((al, f) as t), ti) choices =
    let ei_choices = List.rev_map (fun ((al, _), ti) -> ti, al) choices in
    let main = (ti, al) in
    let ei = { term = main; main = main; choices = ei_choices; env = env } in
    try
      let chosen, args = Cmdline.choose_term ti ei_choices (remove_exec argv) in
      let find_chosen (_, ti) = ti = chosen in
      let (al, f), _ = List.find find_chosen ((t, ti) :: choices) in
      let ei = { ei with term = (chosen, al) } in
      eval_term help err ei f args
    with
    | Cmdline.Error e ->                    (* may be raised by choose_term. *)
        Err.pr_usage err ei e; `Error `Parse
    | e when catch ->
        Err.pr_backtrace err ei e (Printexc.get_backtrace ()); `Error `Exn

  let eval_peek_opts ?(version_opt = false) ?(env = env_default)
      ?(argv = Sys.argv) (al, f) =
    let args = remove_exec argv in
    let version = if version_opt then Some "dummy" else None in
    let term = info ?version "dummy", al in
    let ei = { term = term; main = term; choices = []; env = env } in
    let help_arg, vers_arg, ei = add_std_opts ei in
    try
      let cl = Cmdline.create ~peek_opts:true (snd ei.term) args in
      match help_arg ei cl, vers_arg with
      | Some fmt, _ ->
          (try (Some (f ei cl), `Help) with e -> None, `Help)
      | None, Some v_arg when v_arg ei cl ->
          (try (Some (f ei cl), `Version) with e -> None, `Version)
      | _ ->
          let v = f ei cl in
          Some v, `Ok v
    with
    | Cmdline.Error _ -> None, (`Error `Parse)
    | Term _ -> None, (`Error `Term)
    | e -> None, (`Error `Exn)
end

(*---------------------------------------------------------------------------
   Copyright (c) 2011 Daniel C. B端nzli
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

   3. Neither the name of Daniel C. B端nzli nor the names of
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  ---------------------------------------------------------------------------*)

end
module Cmdliner_shim
= struct
#1 "cmdliner_shim.ml"
open Cmdliner

(*
What follows is a gross violation of natural law.

Motivation: sometimes `refmt` raises exceptions, and we want to handle those
            before Cmdliner does. While we could either:
              1) wrap the entirety of the body of refmt in a try/with
                OR
              2) write a wrapper function that takes the same # of arguments,
            we decided to try this instead.
*)

type handler = exn -> string
type +'a q = Success of ('a * handler) | Exception of string

let wrap x handler = Success (x, handler)

let unwrap = function
  | Success (x, _) -> x
  | Exception m -> `Error (true, m)

let app : ('a -> 'b) q -> 'a -> 'b q = fun f a ->
  let (f', handler) = match f with
    | Success x -> x
    | _ -> failwith "can't happen"
  in
  try
    Success ((f' a), handler)
  with
  | exn -> Exception (handler exn)

let load x =
    Term.app (Term.const unwrap) x

let appq : (('a -> 'b) q) Term.t -> 'a Term.t -> ('b q) Term.t = fun qtF at ->
    Term.app (Term.app (Term.const app) qtF) at

let ($) = appq

end
module Package
= struct
#1 "package.ml"

let version = "1.8.2"
let git_version = "ac73dea817effda9046b2c7e0b95b4b1c64d6976"
let git_short_version = "ac73dea"

end
module Easy_format : sig 
#1 "easy_format.mli"
(**
   Easy_format: indentation made easy.
*)

(**
  This module provides a functional, simplified layer over
  the Format module of the standard library.

  Input data must be first modelled as a tree using 3 kinds of nodes:
  - atoms
  - lists
  - labelled nodes

  Atoms represent any text that is guaranteed to be printed as-is.
  Lists can model any sequence of items such as arrays of data
  or lists of definitions that are labelled with something
  like "int main", "let x =" or "x:".
*)

type wrap =
    [ `Wrap_atoms
    | `Always_wrap
    | `Never_wrap
    | `Force_breaks
    | `Force_breaks_rec
    | `No_breaks ]
(** List wrapping conditions:
    - [`Wrap_atoms]: wrap if the list contains only atoms
    - [`Always_wrap]: always wrap when needed
    - [`Never_wrap]: never wrap,
      i.e. the list is either horizontal or vertical
    - [`Force_breaks]: align vertically,
      i.e. always break line between list items and
      align the left edge of each item.
    - [`Force_breaks_rec]: same as [`Force_breaks] but turns
      any wrappable ancestor node's wrap property ([`Wrap_atoms]
      or [`Always_wrap]) into [`Force_breaks].
    - [`No_breaks]: align horizontally,
      i.e. never break line between list items
*)

type label_break = [
  | `Auto
  | `Always
  | `Always_rec
  | `Never
]
(** When to break the line after a [Label]:
    - [Auto]: break after the label if there's not enough room
    - [Always]: always break after the label
    - [Always_rec]: always break after the label and force breaks in all parent
      lists and labels, similarly to [`Force_breaks_rec] for lists.
    - [Never]: never break after the label
*)

type style_name = string

type style = {
  tag_open : string;
  tag_close : string
}
    (** Pair of opening and closing tags that are inserted around
	text after pretty-printing. *)

type atom_param = {
  atom_style : style_name option; (** Default: [None] *)
}

val atom : atom_param


(** List-formatting parameters.
    Always derive a new set of parameters from an existing record.
    See {!Easy_format.list}.
*)
type list_param = {
  space_after_opening : bool; (** Whether there must be some whitespace
				  after the opening string.
				  Default: [true] *)
  space_after_separator : bool; (** Whether there must be some whitespace
				    after the item separators.
				    Default: [true] *)
  space_before_separator : bool; (** Whether there must be some whitespace
				     before the item separators.
				     Default: [false] *)
  separators_stick_left : bool; (** Whether the separators must
				    stick to the item on the left.
				    Default: [true] *)
  space_before_closing : bool; (** Whether there must be some whitespace
				   before the closing string.
				   Default: [true] *)
  stick_to_label : bool; (** Whether the opening string should be fused
			     with the preceding label.
			     Default: [true] *)
  align_closing : bool; (** Whether the beginning of the
			    closing string must be aligned
			    with the beginning of the opening string
			    (stick_to_label = false) or
			    with the beginning of the label if any
			    (stick_to_label = true).
			    Default: [true] *)
  wrap_body : wrap; (** Defines under which conditions the list body
			may be wrapped, i.e. allow several lines
			and several list items per line.
			Default: [`Wrap_atoms] *)
  indent_body : int; (** Extra indentation of the list body.
			 Default: [2] *)

  list_style : style_name option; (** Default: [None] *)
  opening_style : style_name option; (** Default: [None] *)
  body_style : style_name option; (** Default: [None] *)
  separator_style : style_name option; (** Default: [None] *)
  closing_style : style_name option; (** Default: [None] *)
}

val list : list_param
  (** Default list-formatting parameters, using the default values
      described in the type definition above.

      In order to make code compatible with future versions of the library,
      the record inheritance syntax should be used, e.g.
      [ { list with align_closing = false } ].
      If new record fields are added, the program would still compile
      and work as before.
  *)

(** Label-formatting parameters.
    Always derive a new set of parameters from an existing record.
    See {!Easy_format.label}.
*)
type label_param = {
  label_break: label_break;
    (** Whether to break the line after the label.
        Introduced in version 1.2.0.
        Default: [`Auto] *)

  space_after_label : bool;
    (** Whether there must be some whitespace after the label.
	Default: [true] *)

  indent_after_label : int;
    (** Extra indentation before the item that comes after a label.
	Default: [2]
    *)

  label_style : style_name option;
    (** Default: [None] *)
}

val label : label_param
  (** Default label-formatting parameters, using the default values
      described in the type definition above.

      In order to make code compatible with future versions of the library,
      the record inheritance syntax should be used, e.g.
      [ { label with indent_after_label = 0 } ].
      If new record fields are added, the program would still compile
      and work as before.
 *)



type t =
    Atom of string * atom_param (** Plain string normally
				    without line breaks. *)

  | List of
      (
	string    (* opening *)
	* string  (* separator *)
	* string  (* closing *)
	* list_param
      )
      * t list
	(** [List ((opening, separator, closing, param), nodes)] *)

  | Label of (t * label_param) * t
      (** [Label ((label, param), node)]: labelled node. *)

  | Custom of (Format.formatter -> unit)
      (** User-defined printing function that allows to use the
	  Format module directly if necessary. It is responsible
	  for leaving the formatter in a clean state. *)
(** The type of the tree to be pretty-printed. Each node contains
    its own formatting parameters.

    Detail of a list node
    [List ((opening, separator, closing, param), nodes)]:

    - [opening]: opening string such as ["\{"] ["\["] ["("] ["begin"] [""] etc.
    - [separator]: node separator such as [";"] [","] [""] ["+"] ["|"] etc.
    - [closing]: closing string such as ["\}"] ["\]"] [")"] ["end"] [""] etc.
    - [nodes]: elements of the list.

*)

type escape =
    [ `None
    | `Escape of
	((string -> int -> int -> unit) -> string -> int -> int -> unit)
    | `Escape_string of (string -> string) ]

type styles = (style_name * style) list

(** The regular pretty-printing functions *)
module Pretty :
sig
  val define_styles : Format.formatter -> escape -> styles -> unit
  val to_formatter : Format.formatter -> t -> unit

  val to_buffer : ?escape:escape -> ?styles:styles -> Buffer.t -> t -> unit
  val to_string : ?escape:escape -> ?styles:styles -> t -> string
  val to_channel : ?escape:escape -> ?styles:styles -> out_channel -> t -> unit
  val to_stdout : ?escape:escape -> ?styles:styles -> t -> unit
  val to_stderr : ?escape:escape -> ?styles:styles -> t -> unit
end

(** No spacing or newlines other than those in the input data
    or those produced by [Custom] printing. *)
module Compact :
sig
  val to_buffer : Buffer.t -> t -> unit
  val to_string : t -> string
  val to_channel : out_channel -> t -> unit
  val to_stdout : t -> unit
  val to_stderr : t -> unit
  val to_formatter : Format.formatter -> t -> unit
 end


(**/**)

(** Deprecated. Predefined sets of parameters *)
module Param :
sig
  val list_true : list_param
    (** Deprecated. All boolean fields set to true. indent_body = 2. *)

  val label_true : label_param
    (** Deprecated. All boolean fields set to true. indent_after_label = 2. *)

  val list_false : list_param
    (** Deprecated. All boolean fields set to false. indent_body = 2. *)

  val label_false : label_param
    (** Deprecated. All boolean fields set to false. indent_after_label = 2. *)
end


end = struct
#1 "easy_format.ml"
open Format

type wrap = [
  | `Wrap_atoms
  | `Always_wrap
  | `Never_wrap
  | `Force_breaks
  | `Force_breaks_rec
  | `No_breaks
]

type label_break = [
  | `Auto
  | `Always
  | `Always_rec
  | `Never
]

type style_name = string
type style = {
  tag_open : string;
  tag_close : string
}

type atom_param = {
  atom_style : style_name option;
}

let atom = {
  atom_style = None
}

type list_param = {
  space_after_opening : bool;
  space_after_separator : bool;
  space_before_separator : bool;
  separators_stick_left : bool;
  space_before_closing : bool;
  stick_to_label : bool;
  align_closing : bool;
  wrap_body : wrap;
  indent_body : int;
  list_style : style_name option;
  opening_style : style_name option;
  body_style : style_name option;
  separator_style : style_name option;
  closing_style : style_name option;
}

let list = {
  space_after_opening = true;
  space_after_separator = true;
  space_before_separator = false;
  separators_stick_left = true;
  space_before_closing = true;
  stick_to_label = true;
  align_closing = true;
  wrap_body = `Wrap_atoms;
  indent_body = 2;
  list_style = None;
  opening_style = None;
  body_style = None;
  separator_style = None;
  closing_style = None;
}

type label_param = {
  label_break: label_break;
  space_after_label : bool;
  indent_after_label : int;
  label_style : style_name option;
}

let label = {
  label_break = `Auto;
  space_after_label = true;
  indent_after_label = 2;
  label_style = None;
}

type t =
    Atom of string * atom_param
  | List of (string * string * string * list_param) * t list
  | Label of (t * label_param) * t
  | Custom of (formatter -> unit)

type escape =
    [ `None
    | `Escape of
        ((string -> int -> int -> unit) -> string -> int -> int -> unit)
    | `Escape_string of (string -> string) ]

type styles = (style_name * style) list

(*
   Transform a tree starting from the leaves, propagating and merging
   accumulators until reaching the root.
*)
let propagate_from_leaf_to_root
  ~init_acc  (* create initial accumulator for a leaf *)
  ~merge_acc (* merge two accumulators coming from child nodes *)
  ~map_node  (* (node, acc) -> (node, acc) *)
  x =

  let rec aux x =
    match x with
    | Atom _ ->
        let acc = init_acc x in
        map_node x acc
    | List (param, children) ->
        let new_children, accs = List.split (List.map aux children) in
        let acc = List.fold_left merge_acc (init_acc x) accs in
        map_node (List (param, new_children)) acc
    | Label ((x1, param), x2) ->
        let acc0 = init_acc x in
        let new_x1, acc1 = aux x1 in
        let new_x2, acc2 = aux x2 in
        let acc = merge_acc (merge_acc acc0 acc1) acc2 in
        map_node (Label ((new_x1, param), new_x2)) acc
    | Custom _ ->
        let acc = init_acc x in
        map_node x acc
  in
  aux x

(*
   Convert wrappable lists into vertical lists if any of their descendants
   has the attribute wrap_body = `Force_breaks_rec.
*)
let propagate_forced_breaks x =
  (* acc = whether to force breaks in wrappable lists or labels *)
  let init_acc = function
    | List ((_, _, _, { wrap_body = `Force_breaks_rec }), _)
    | Label ((_, { label_break = `Always_rec }), _) -> true
    | Atom _
    | Label _
    | Custom _
    | List _ -> false
  in
  let merge_acc force_breaks1 force_breaks2 =
    force_breaks1 || force_breaks2
  in
  let map_node x force_breaks =
    match x with
    | List ((_, _, _, { wrap_body = `Force_breaks_rec }), _) -> x, true
    | List ((_, _, _, { wrap_body = `Force_breaks }), _) -> x, force_breaks

    | List ((op, sep, cl, ({ wrap_body = (`Wrap_atoms
                                         | `Never_wrap
                                         | `Always_wrap) } as p)),
            children) ->
        if force_breaks then
          let p = { p with wrap_body = `Force_breaks } in
          List ((op, sep, cl, p), children), true
        else
          x, false

    | Label ((a, ({ label_break = `Auto } as lp)), b) ->
        if force_breaks then
          let lp = { lp with label_break = `Always } in
          Label ((a, lp), b), true
        else
          x, false

    | List ((_, _, _, { wrap_body = `No_breaks }), _)
    | Label ((_, { label_break = (`Always | `Always_rec | `Never) }), _)
    | Atom _
    | Custom _ -> x, force_breaks
  in
  let new_x, forced_breaks =
    propagate_from_leaf_to_root
      ~init_acc
      ~merge_acc
      ~map_node
      x
  in
  new_x

module Pretty =
struct
  (*
     Rewrite the tree to be printed.
     Currently, this is used only to handle `Force_breaks_rec.
  *)
  let rewrite x = propagate_forced_breaks x

  (*
    Relies on the fact that mark_open_tag and mark_close_tag
    are called exactly once before calling pp_output_string once.
    It's a reasonable assumption although not guaranteed by the
    documentation of the Format module.
  *)
  let set_escape fmt escape =
    let print0, flush0 = pp_get_formatter_output_functions fmt () in
    let tagf0 = pp_get_formatter_tag_functions fmt () in

    let is_tag = ref false in

    let mot tag =
      is_tag := true;
      tagf0.mark_open_tag tag
    in

    let mct tag =
      is_tag := true;
      tagf0.mark_close_tag tag
    in

    let print s p n =
      if !is_tag then
        (print0 s p n;
         is_tag := false)
      else
        escape print0 s p n
    in

    let tagf = {
      tagf0 with
        mark_open_tag = mot;
        mark_close_tag = mct
    }
    in
    pp_set_formatter_output_functions fmt print flush0;
    pp_set_formatter_tag_functions fmt tagf


  let set_escape_string fmt esc =
    let escape print s p n =
      let s0 = String.sub s p n in
      let s1 = esc s0 in
      print s1 0 (String.length s1)
    in
    set_escape fmt escape


  let define_styles fmt escape l =
    if l <> [] then (
      pp_set_tags fmt true;
      let tbl1 = Hashtbl.create (2 * List.length l) in
      let tbl2 = Hashtbl.create (2 * List.length l) in
      List.iter (
        fun (style_name, style) ->
          Hashtbl.add tbl1 style_name style.tag_open;
          Hashtbl.add tbl2 style_name style.tag_close
      ) l;
      let mark_open_tag style_name =
        try Hashtbl.find tbl1 style_name
        with Not_found -> ""
      in
      let mark_close_tag style_name =
        try Hashtbl.find tbl2 style_name
        with Not_found -> ""
      in

      let tagf = {
        (pp_get_formatter_tag_functions fmt ()) with
          mark_open_tag = mark_open_tag;
          mark_close_tag = mark_close_tag
      }
      in
      pp_set_formatter_tag_functions fmt tagf
    );

    (match escape with
         `None -> ()
       | `Escape esc -> set_escape fmt esc
       | `Escape_string esc -> set_escape_string fmt esc)


  let pp_open_xbox fmt p indent =
    match p.wrap_body with
	`Always_wrap
      | `Never_wrap
      | `Wrap_atoms -> pp_open_hvbox fmt indent
      | `Force_breaks
      | `Force_breaks_rec -> pp_open_vbox fmt indent
      | `No_breaks -> pp_open_hbox fmt ()

  let extra_box p l =
    let wrap =
      match p.wrap_body with
          `Always_wrap -> true
        | `Never_wrap
        | `Force_breaks
        | `Force_breaks_rec
        | `No_breaks -> false
        | `Wrap_atoms ->
            List.for_all (function Atom _ -> true | _ -> false) l
    in
    if wrap then
      ((fun fmt -> pp_open_hovbox fmt 0),
       (fun fmt -> pp_close_box fmt ()))
    else
      ((fun fmt -> ()),
       (fun fmt -> ()))


  let pp_open_nonaligned_box fmt p indent l =
    match p.wrap_body with
        `Always_wrap -> pp_open_hovbox fmt indent
      | `Never_wrap -> pp_open_hvbox fmt indent
      | `Wrap_atoms ->
          if List.for_all (function Atom _ -> true | _ -> false) l then
            pp_open_hovbox fmt indent
          else
            pp_open_hvbox fmt indent
      | `Force_breaks
      | `Force_breaks_rec -> pp_open_vbox fmt indent
      | `No_breaks -> pp_open_hbox fmt ()


  let open_tag fmt = function
      None -> ()
    | Some s -> pp_open_tag fmt s

  let close_tag fmt = function
      None -> ()
    | Some _ -> pp_close_tag fmt ()

  let tag_string fmt o s =
    match o with
        None -> pp_print_string fmt s
      | Some tag ->
          pp_open_tag fmt tag;
          pp_print_string fmt s;
          pp_close_tag fmt ()

  let rec fprint_t fmt = function
      Atom (s, p) ->
        tag_string fmt p.atom_style s;

    | List ((_, _, _, p) as param, l) ->
        open_tag fmt p.list_style;
        if p.align_closing then
          fprint_list fmt None param l
        else
          fprint_list2 fmt param l;
        close_tag fmt p.list_style

    | Label (label, x) -> fprint_pair fmt label x
    | Custom f -> f fmt

  and fprint_list_body_stick_left fmt p sep hd tl =
    open_tag fmt p.body_style;
    fprint_t fmt hd;
    List.iter (
      fun x ->
        if p.space_before_separator then
          pp_print_string fmt " ";
        tag_string fmt p.separator_style sep;
        if p.space_after_separator then
          pp_print_space fmt ()
        else
          pp_print_cut fmt ();
        fprint_t fmt x
    ) tl;
    close_tag fmt p.body_style

  and fprint_list_body_stick_right fmt p sep hd tl =
    open_tag fmt p.body_style;
    fprint_t fmt hd;
    List.iter (
      fun x ->
        if p.space_before_separator then
          pp_print_space fmt ()
        else
          pp_print_cut fmt ();
        tag_string fmt p.separator_style sep;
        if p.space_after_separator then
          pp_print_string fmt " ";
        fprint_t fmt x
    ) tl;
    close_tag fmt p.body_style

  and fprint_opt_label fmt = function
      None -> ()
    | Some (lab, lp) ->
        open_tag fmt lp.label_style;
        fprint_t fmt lab;
        close_tag fmt lp.label_style;
        if lp.space_after_label then
          pp_print_string fmt " "

  (* Either horizontal or vertical list *)
  and fprint_list fmt label ((op, sep, cl, p) as param) = function
      [] ->
        fprint_opt_label fmt label;
        tag_string fmt p.opening_style op;
        if p.space_after_opening || p.space_before_closing then
          pp_print_string fmt " ";
        tag_string fmt p.closing_style cl

    | hd :: tl as l ->

        if tl = [] || p.separators_stick_left then
          fprint_list_stick_left fmt label param hd tl l
        else
          fprint_list_stick_right fmt label param hd tl l


  and fprint_list_stick_left fmt label (op, sep, cl, p) hd tl l =
    let indent = p.indent_body in
    pp_open_xbox fmt p indent;
    fprint_opt_label fmt label;

    tag_string fmt p.opening_style op;

    if p.space_after_opening then
      pp_print_space fmt ()
    else
      pp_print_cut fmt ();

    let open_extra, close_extra = extra_box p l in
    open_extra fmt;
    fprint_list_body_stick_left fmt p sep hd tl;
    close_extra fmt;

    if p.space_before_closing then
      pp_print_break fmt 1 (-indent)
    else
      pp_print_break fmt 0 (-indent);
    tag_string fmt p.closing_style cl;
    pp_close_box fmt ()

  and fprint_list_stick_right fmt label (op, sep, cl, p) hd tl l =
    let base_indent = p.indent_body in
    let sep_indent =
      String.length sep + (if p.space_after_separator then 1 else 0)
    in
    let indent = base_indent + sep_indent in

    pp_open_xbox fmt p indent;
    fprint_opt_label fmt label;

    tag_string fmt p.opening_style op;

    if p.space_after_opening then
      pp_print_space fmt ()
    else
      pp_print_cut fmt ();

    let open_extra, close_extra = extra_box p l in
    open_extra fmt;

    fprint_t fmt hd;
    List.iter (
      fun x ->
        if p.space_before_separator then
          pp_print_break fmt 1 (-sep_indent)
        else
          pp_print_break fmt 0 (-sep_indent);
        tag_string fmt p.separator_style sep;
        if p.space_after_separator then
          pp_print_string fmt " ";
        fprint_t fmt x
    ) tl;

    close_extra fmt;

    if p.space_before_closing then
      pp_print_break fmt 1 (-indent)
    else
      pp_print_break fmt 0 (-indent);
    tag_string fmt p.closing_style cl;
    pp_close_box fmt ()



  (* align_closing = false *)
  and fprint_list2 fmt (op, sep, cl, p) = function
      [] ->
        tag_string fmt p.opening_style op;
        if p.space_after_opening || p.space_before_closing then
          pp_print_string fmt " ";
        tag_string fmt p.closing_style cl

    | hd :: tl as l ->
        tag_string fmt p.opening_style op;
        if p.space_after_opening then
          pp_print_string fmt " ";

        pp_open_nonaligned_box fmt p 0 l ;
        if p.separators_stick_left then
          fprint_list_body_stick_left fmt p sep hd tl
        else
          fprint_list_body_stick_right fmt p sep hd tl;
        pp_close_box fmt ();

        if p.space_before_closing then
          pp_print_string fmt " ";
        tag_string fmt p.closing_style cl


  (* Printing a label:value pair.

     The opening bracket stays on the same line as the key, no matter what,
     and the closing bracket is either on the same line
     or vertically aligned with the beginning of the key.
  *)
  and fprint_pair fmt ((lab, lp) as label) x =
    match x with
        List ((op, sep, cl, p), l) when p.stick_to_label && p.align_closing ->
          fprint_list fmt (Some label) (op, sep, cl, p) l

      | _ ->
          let indent = lp.indent_after_label in
          pp_open_hvbox fmt 0;

          open_tag fmt lp.label_style;
          fprint_t fmt lab;
          close_tag fmt lp.label_style;

          (match lp.label_break with
           | `Auto ->
               if lp.space_after_label then
                 pp_print_break fmt 1 indent
               else
                 pp_print_break fmt 0 indent
           | `Always
           | `Always_rec ->
               pp_force_newline fmt ();
               pp_print_string fmt (String.make indent ' ')
           | `Never ->
               if lp.space_after_label then
                 pp_print_char fmt ' '
               else
                 ()
          );
          fprint_t fmt x;
          pp_close_box fmt ()

  let to_formatter fmt x =
    let x = rewrite x in
    fprint_t fmt x;
    pp_print_flush fmt ()

  let to_buffer ?(escape = `None) ?(styles = []) buf x =
    let fmt = Format.formatter_of_buffer buf in
    define_styles fmt escape styles;
    to_formatter fmt x

  let to_string ?escape ?styles x =
    let buf = Buffer.create 500 in
    to_buffer ?escape ?styles buf x;
    Buffer.contents buf

  let to_channel ?(escape = `None) ?(styles = []) oc x =
    let fmt = formatter_of_out_channel oc in
    define_styles fmt escape styles;
    to_formatter fmt x

  let to_stdout ?escape ?styles x = to_channel ?escape ?styles stdout x
  let to_stderr ?escape ?styles x = to_channel ?escape ?styles stderr x

end




module Compact =
struct
  open Printf

  let rec fprint_t buf = function
      Atom (s, _) -> Buffer.add_string buf s
    | List (param, l) -> fprint_list buf param l
    | Label (label, x) -> fprint_pair buf label x
    | Custom f ->
        (* Will most likely not be compact *)
        let fmt = formatter_of_buffer buf in
        f fmt;
        pp_print_flush fmt ()

  and fprint_list buf (op, sep, cl, _) = function
      [] -> bprintf buf "%s%s" op cl
    | x :: tl ->
        Buffer.add_string buf op;
        fprint_t buf x;
        List.iter (
          fun x ->
            Buffer.add_string buf sep;
            fprint_t buf x
        ) tl;
        Buffer.add_string buf cl

  and fprint_pair buf (label, _) x =
    fprint_t buf label;
    fprint_t buf x


  let to_buffer buf x = fprint_t buf x

  let to_string x =
    let buf = Buffer.create 500 in
    to_buffer buf x;
    Buffer.contents buf

  let to_formatter fmt x =
    let s = to_string x in
    Format.fprintf fmt "%s" s;
    pp_print_flush fmt ()

  let to_channel oc x =
    let buf = Buffer.create 500 in
    to_buffer buf x;
    Buffer.output_buffer oc buf

  let to_stdout x = to_channel stdout x
  let to_stderr x = to_channel stderr x
end




(* Obsolete *)
module Param =
struct
  let list_true = {
    space_after_opening = true;
    space_after_separator = true;
    space_before_separator = true;
    separators_stick_left = true;
    space_before_closing = true;
    stick_to_label = true;
    align_closing = true;
    wrap_body = `Wrap_atoms;
    indent_body = 2;
    list_style = None;
    opening_style = None;
    body_style = None;
    separator_style = None;
    closing_style = None;
  }

  let list_false = {
    space_after_opening = false;
    space_after_separator = false;
    space_before_separator = false;
    separators_stick_left = false;
    space_before_closing = false;
    stick_to_label = false;
    align_closing = false;
    wrap_body = `Wrap_atoms;
    indent_body = 2;
    list_style = None;
    opening_style = None;
    body_style = None;
    separator_style = None;
    closing_style = None;
  }

  let label_true = {
    label_break = `Auto;
    space_after_label = true;
    indent_after_label = 2;
    label_style = None;
  }

  let label_false = {
    label_break = `Auto;
    space_after_label = false;
    indent_after_label = 2;
    label_style = None;
  }
end

end
module Syntax_util
= struct
#1 "syntax_util.ml"
open Ast_mapper
open Asttypes
open Parsetree
open Longident
open Ast_helper

(** [is_prefixed prefix i str] checks if prefix is the prefix of str
  * starting from position i
  *)
let is_prefixed prefix str i =
  let len = String.length prefix in
  if i + len > String.length str then false else
  let rec loop j =
    if j >= len then true else
      if String.unsafe_get prefix j <> String.unsafe_get str (i + j) then false else loop (j + 1)
    in
  loop 0

(**
 * pick_while returns a tuple where first element is longest prefix (possibly empty) of the list of elements that satisfy p
 * and second element is the remainder of the list
 *)
let rec pick_while p = function
  | [] -> [], []
  | hd::tl when p hd ->
                  let (satisfied, not_satisfied) = pick_while p tl in
                  hd :: satisfied, not_satisfied
  | l -> ([], l)


let rec replace_string_ old_str new_str i str buffer =
  if i >= String.length str then
    ()
  else
    (* found match *)
    if is_prefixed old_str str i then
      (* split string *)
      let old_str_len = String.length old_str in
      Buffer.add_string buffer new_str;
      replace_string_ old_str new_str (i + old_str_len) str buffer
    else
      let start = String.sub str i 1 in
      Buffer.add_string buffer start;
      replace_string_ old_str new_str (i + 1) str buffer


(** [replace_string old_str new_str str] replaces old_str to new_str in str *)
let replace_string old_str new_str str =
  let buffer = Buffer.create (String.length old_str * 2) in
  replace_string_ old_str new_str 0 str buffer;
  Buffer.contents buffer

(* This is lifted from https://github.com/bloomberg/bucklescript/blob/14d94bb9c7536b4c5f1208c8e8cc715ca002853d/jscomp/ext/ext_string.ml#L32
  Thanks @bobzhang and @hhugo! *)
let split_by ?(keep_empty=false) is_delim str =
  let len = String.length str in
  let rec loop acc last_pos pos =
    if pos = -1 then
      if last_pos = 0 && not keep_empty then
        (*
           {[ split " test_unsafe_obj_ffi_ppx.cmi" ~keep_empty:false ' ']}
        *)
        acc
      else
        String.sub str 0 last_pos :: acc
    else
      if is_delim str.[pos] then
        let new_len = (last_pos - pos - 1) in
        if new_len <> 0 || keep_empty then
          let v = String.sub str (pos + 1) new_len in
          loop ( v :: acc)
            pos (pos - 1)
        else loop acc pos (pos - 1)
    else loop acc last_pos (pos - 1)
  in
  loop [] len (len - 1)

let rec trim_right_idx str idx =
  if idx = -1 then 0
  else
    match String.get str idx with
    | '\t' | ' ' | '\n' | '\r' -> trim_right_idx str (idx - 1)
    | _ -> idx + 1

let trim_right str =
  let length = String.length str in
  if length = 0 then ""
  else
    let index = trim_right_idx str (length - 1) in
    if index = 0 then ""
    else if index = length then str
    else String.sub str 0 index

let strip_trailing_whitespace str =
  split_by ~keep_empty:true (fun x -> x = '\n') str
  |> List.map trim_right
  |> String.concat "\n"
  |> String.trim

module StringMap = Map.Make (String)


(** Generate a suitable extension node for Merlin's consumption,
    for the purposes of reporting a syntax error - only used
    in recovery mode.
 *)
let syntax_error_extension_node loc message =
  let str = Location.mkloc "merlin.syntax-error" loc in
  let payload = PStr [{
    pstr_loc = Location.none;
    pstr_desc = Pstr_eval (
      {
        pexp_loc = Location.none;
        pexp_desc = Pexp_constant (Asttypes.Const_string (message, None));
        pexp_attributes = [];
      },
      []
    );
  }]
 in
 (str, payload)

let reason_to_ml_swapping_alist = [
  "===",  "==";
  "==",  "=";
  (* ===\/ and !==\/ are not representable in OCaml but
   * representable in Reason
   *)
  "\\!==", "!==";
  "\\===", "===";
  "!=", "<>";
  "!==", "!=";
  "match", "switch";
  "method", "pub";
  "private", "pri";
]

let swap_txt map txt =
  if StringMap.mem txt map then
    StringMap.find txt map
  else
    txt

(** identifier_mapper maps all identifiers in an AST with a mapping function f
  *)
let identifier_mapper f =
{ default_mapper with
  expr = begin fun mapper expr ->
    let expr =
      match expr with
        | {pexp_desc=Pexp_ident ({txt} as id);
           pexp_loc;
           pexp_attributes} ->
             let swapped = match txt with
               | Lident s -> Lident (f s)
               | Ldot(longPrefix, s) -> Ldot(longPrefix, f s)
               | Lapply (y,s) -> Lapply (y, s)
             in
             {expr with pexp_desc=Pexp_ident ({id with txt=swapped})}
        | _ -> expr
    in
    default_mapper.expr mapper expr
  end;
  pat = begin fun mapper pat ->
    let pat =
      match pat with
        | {ppat_desc=Ppat_var ({txt} as id);
           ppat_loc;
           ppat_attributes} ->
             {pat with ppat_desc=Ppat_var ({id with txt=(f txt)})}
        | _ -> pat
    in
    default_mapper.pat mapper pat
  end;
}
(*
let create_auto_printer_mapper =
  let attach_printer = function
    | { pstr_desc=Pstr_type type_decls } as ty ->
        let str_of_type = Ppx_deriving_show.str_of_type ~options:[] ~path:[] in
        let printer = List.concat (List.map str_of_type type_decls) in
        (ty, Some (Str.value Recursive printer))
    | ty -> (ty, None)
  in
  { default_mapper with structure = begin fun mapper decls ->
    let decls =
      let maybe_concat acc = function
        | (s, None) -> s::acc
        | (s, Some x) -> x::s::acc
      in
      List.rev (List.fold_left maybe_concat [] (List.map attach_printer decls))
    in
    default_mapper.structure mapper decls
  end }
*)

(** unescape_stars_slashes_mapper unescapes all stars and slases in an AST
  *)
let unescape_stars_slashes_mapper =
  let unescape_stars_slashes str =
    let len = String.length str in
    if len < 2 then
      str
    else
      let ending = String.sub str 1 (len - 1) in
    String.sub str 0 1 ^
      replace_string "\\*" "*"
        (replace_string ("\\/") "/" ending)
  in
  identifier_mapper unescape_stars_slashes

(** escape_stars_slashes_mapper escapes all stars and slases in an AST
  *)
let escape_stars_slashes_mapper =
  let escape_stars_slashes str =
    let len = String.length str in
    if len < 2 then
      str
    else
      let ending = String.sub str 1 (len -1) in
      String.sub str 0 1 ^
        replace_string "*" "\\*"
          (replace_string "/" "\\/" ending)
  in
  identifier_mapper escape_stars_slashes

(**
 * swap_operator_mapper is a mapper that swaps two operators at parse/print time.
 * We need this since we want to transform operator such as "=" in Ocaml to "==" in Reason.
 * In this case, in the parser, everytime we see a token "==" in Reason, we transform it into "=";
 * Similarly, in the printer, everytime we see a token "=", we transform it into "==";
 *)
let swap_operator_mapper map = identifier_mapper (swap_txt map)

let reason_to_ml_swap_map = List.fold_left
                              (fun map (op1, op2) -> (StringMap.add op1 op2 map))
                              StringMap.empty
                              reason_to_ml_swapping_alist

let ml_to_reason_swap_map = List.fold_left
                              (fun map (op1, op2) -> (StringMap.add op2 op1 map))
                              StringMap.empty
                              reason_to_ml_swapping_alist

(* To be used in parser, transform a token into an ast node with different identifier
 *)
let reason_to_ml_swap_operator_mapper = swap_operator_mapper reason_to_ml_swap_map

(* To be used in printer, transform an ast node into a token with different identifier
 *)
let ml_to_reason_swap_operator_mapper = swap_operator_mapper ml_to_reason_swap_map

(* attribute_equals tests an attribute is txt
 *)
let attribute_equals to_compare = function
  | ({txt; _}, _) -> txt = to_compare

(* attribute_exists tests if an attribute exists in a list
 *)
let attribute_exists txt attributes = List.exists (attribute_equals txt) attributes

(* conflicted_attributes tests if both attribute1 and attribute2
 * exist
 *)
let attributes_conflicted attribute1 attribute2 attributes =
  attribute_exists attribute1 attributes &&
  attribute_exists attribute2 attributes

(* normalized_attributes removes attribute from a list of attributes
 *)
let normalized_attributes attribute attributes =
  List.filter (fun x -> not (attribute_equals attribute x)) attributes

(*
 * apply_mapper_chain family applies an ast_mapper_chain to an ast,
 * ordering from left to right.
 *)
let apply_mapper_chain_to_structure =
  List.fold_left (fun s mapper -> mapper.structure mapper s )
let apply_mapper_chain_to_signature =
  List.fold_left (fun s mapper -> mapper.signature mapper s )
let apply_mapper_chain_to_type =
  List.fold_left (fun s mapper -> mapper.typ mapper s )
let apply_mapper_chain_to_expr =
  List.fold_left (fun s mapper -> mapper.expr mapper s )
let apply_mapper_chain_to_pattern =
  List.fold_left (fun s mapper -> mapper.pat mapper s )

let apply_mapper_chain_to_toplevel_phrase toplevel_phrase chain =
  match toplevel_phrase with
  | Ptop_def x -> Ptop_def (apply_mapper_chain_to_structure x chain)
  | x -> x

let apply_mapper_chain_to_use_file use_file chain =
  List.map (fun x -> apply_mapper_chain_to_toplevel_phrase x chain) use_file

(* The following logic defines our own Error object
 * and register it with ocaml so it knows how to print it
 *)

type error = Syntax_error of string

exception Error of Location.t * error

let report_error ppf (Syntax_error err) =
  Format.(fprintf ppf "%s" err)

let () =
  Location.register_error_of_exn
    (function
     | Error (loc, err) ->
        Some (Location.error_of_printer loc report_error err)
     | _ ->
        None
     )


type menhirMessagesError = {
  msg: string;
  loc: Location.t;
}

type menhirError =
  | NoMenhirMessagesError
  | MenhirMessagesError of menhirMessagesError

let menhirMessagesError = ref [NoMenhirMessagesError]

let findMenhirErrorMessage loc =
    let rec find messages =
      match messages with
      | MenhirMessagesError err :: tail when err.loc = loc -> MenhirMessagesError err
      | _ :: tail -> find tail
      | [] -> NoMenhirMessagesError
    in find !menhirMessagesError

let add_error_message err =
  let msg = if err.msg = "<SYNTAX ERROR>\n" then
    [MenhirMessagesError {err with msg = "A syntax error occurred. Help to improve this message: https://github.com/facebook/reason/wiki/Add-a-Menhir-error-message"}]
  else
    [MenhirMessagesError err]
  in
  menhirMessagesError := !menhirMessagesError @ msg;

end
module Reason_pprint_ast
= struct
#1 "reason_pprint_ast.ml"
(*
 *  Copyright (c) 2015-present, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 *  Forked from OCaml, which is provided under the license below:
 *
 *  Xavier Leroy, projet Cristal, INRIA Rocquencourt
 *
 *  Copyright 息 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Inria
 *
 *  Permission is hereby granted, free of charge, to the Licensee obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense
 *  under any license of the Licensee's choice, and/or sell copies of the
 *  Software, subject to the following conditions:
 *
 *  1.	Redistributions of source code must retain the above copyright notice
 *  and the following disclaimer.
 *  2.	Redistributions in binary form must reproduce the above copyright
 *  notice, the following disclaimer in the documentation and/or other
 *  materials provided with the distribution.
 *  3.	All advertising materials mentioning features or use of the Software
 *  must display the following acknowledgement: This product includes all or
 *  parts of the Caml system developed by Inria and its contributors.
 *  4.	Other than specified in clause 3, neither the name of Inria nor the
 *  names of its contributors may be used to endorse or promote products
 *  derived from the Software without specific prior written permission.
 *
 *  Disclaimer
 *
 *  This software is provided by Inria and contributors as is and any express
 *  or implied warranties, including, but not limited to, the implied
 *  warranties of merchantability and fitness for a particular purpose are
 *  disclaimed. in no event shall Inria or its contributors be liable for any
 *  direct, indirect, incidental, special, exemplary, or consequential damages
 *  (including, but not limited to, procurement of substitute goods or
 *  services; loss of use, data, or profits; or business interruption) however
 *  caused and on any theory of liability, whether in contract, strict
 *  liability, or tort (including negligence or otherwise) arising in any way
 *  out of the use of this software, even if advised of the possibility of such
 *  damage.
 *
 *)

(* TODO more fine-grained precedence pretty-printing *)

open Asttypes
open Format
open Location
open Lexing
open Longident
open Parsetree
open Easy_format
open Syntax_util
open Ast_mapper


type commentCategory =
  | EndOfLine
  | SingleLine
  | Regular

(* (comment text, attachment_location, physical location) *)
type commentWithCategory = (String.t * commentCategory * Location.t) list

let print_easy easyFormatted =
  match easyFormatted with
  | Atom (s,_) -> s
  | List (_,_) -> "list"
  | Label (_,_) -> "label"
  | Custom _ -> "custom"

let (|>) = fun x f -> f x
let (<|) = fun f x -> f x

exception NotPossible of string

let useSingleColonForNamedArgs = false

let case_not_implemented msg loc (file, line, column) =
  Format.fprintf Format.err_formatter
    "Not Implemented Yet %s %a (from: %s:%s:%s)@."
    msg
    Location.print_loc loc
    file
    (string_of_int line)
    (string_of_int column)

let exprDescrString x =
  x.pexp_loc.loc_start.Lexing.pos_fname ^
    "[" ^
    (string_of_int x.pexp_loc.loc_start.Lexing.pos_lnum) ^
    ", " ^
    (string_of_int x.pexp_loc.loc_end.Lexing.pos_lnum) ^
    "]"

type ruleInfoData = {
  reducePrecedence: precedence;
  shiftPrecedence: precedence;
}

and ruleCategory =
  (* Printing will be parsed with very high precedence, so not much need to
     worry about ensuring it will reduce correctly. In short, you can put
     `FunctionApplication` content anywhere around an infix identifier without
     wrapping in parens. For example `myFunc x y z` or `if x {y} else {z}`
     The layout is kept in list form only to allow for elegant wrapping rules
     to take into consideration the *number* of high precedence parsed items. *)
  | FunctionApplication of layoutNode list
  (* Care should be taken to ensure the rule that caused it to be parsed will
     reduce again on the printed output - context should carefully consider
     wrapping in parens according to the ruleInfoData. *)
  | SpecificInfixPrecedence of ruleInfoData * layoutNode
  (* Not safe to include anywhere between infix operators without wrapping in
     parens. This describes expressions like `fun x => x` which doesn't fit into
     our simplistic algorithm for printing function applications separated by infix.

     It might be possible to include these in between infix, but there are
     tricky rules to determining when these must be guarded by parens (it
     depends highly on context that is hard to reason about). It's so nuanced
     that it's easier just to always wrap them in parens.  *)
  | PotentiallyLowPrecedence of layoutNode
  | Simple of layoutNode

and associativity =
  | Right
  | Nonassoc
  | Left

and precedenceEntryType =
  | TokenPrecedence
  | CustomPrecedence

and precedence =
  | Token of string
  | Custom of string

(* Make a standard list *)
and whenToDoSomething =
  | Never
  | IfNeed
  | Always
  (* Always_rec not only will break, it will break recursively up to the root *)
  | Always_rec

(* Describes the "fixity" of a token, and stores its *printed* representation
   should it be rendered as infix/prefix (This rendering may be different than
   how it is stored in the AST). *)
and tokenFixity =
  (* Such as !simple_expr and ~!simple_expr. These function applications are
     considered *almost* "simple" because they may be allowed anywhere a simple
     expression is accepted, except for when on the left hand side of a
     dot/send. *)
  | AlmostSimplePrefix of string
  | UnaryPlusPrefix of string
  | UnaryMinusPrefix of string
  | Infix of string
  | Normal

and easyFormatLabelFormatter = Easy_format.t -> Easy_format.t -> Easy_format.t
and listConfig = {
  (* Newlines above items that do not have any comments immediately above it.
     Only really useful when used with break:Always/Always_rec *)
  newlinesAboveItems: int;
  (* Newlines above regular comments *)
  newlinesAboveComments: int;
  (* Newlines above doc comments *)
  newlinesAboveDocComments: int;
  (* If you are only grouping something for the sake of visual appearance, and
   * not forming an actual conceptual sequence of items, then this is often
   * useful. For example, if you're appending a semicolon etc. *)
  interleaveComments: bool;
  (* Whether or not to render the final separator *)
  renderFinalSep: bool;
  break: whenToDoSomething;
  (* Break setting that becomes activated if a comment becomes interleaved into
   * this list. Typically, if not specified, the behavior from [break] will be
   * used.
   *)
  wrap: string * string;
  inline: bool * bool;
  sep: string;
  indent: int;
  sepLeft: bool;
  preSpace: bool;
  postSpace: bool;
  pad: bool * bool;
  (* A function, because the system might rearrange your previous settings, and
   * a function allows you to not be locked into some configuration that is made
   * out of date by the formatting system (suppose it removes the separator
   * token etc.) Having a function allows you to instruct our formatter how to
   * extend the "freshest" notion of the list config when comments are
   * interleaved. *)
  listConfigIfCommentsInterleaved: (listConfig -> listConfig) option;

  (* Formatting to use if an item in a list had an end-of-line comment appended *)
  listConfigIfEolCommentsInterleaved: (listConfig -> listConfig) option;
}

(**
 * These represent "intent to format" the AST, with some parts being annotated
 * with original source location. The benefit of tracking this in an
 * intermediate structure, is that we can then interleave comments throughout
 * the tree before generating the final representation. That prevents the
 * formatting code from having to thread comments everywhere.
 *
 * The final representation is rendered using Easy_format.
 *)
and layoutNode =
  | SourceMap of Location.t * layoutNode (* a layout with location info *)
  | WithEOLComment of string * layoutNode (* a layout with comment attached *)
  | Sequence of listConfig * (layoutNode list)
  | Label of easyFormatLabelFormatter * layoutNode * layoutNode
  | Easy of Easy_format.t

let print_comment_type = function
  | Regular -> "Regular"
  | EndOfLine -> "End of Line"
  | SingleLine -> "SingleLine"

let rec print_comments = function
  | [] -> ()
  | ((s, t, loc)::tl) ->
       printf "%d (%d:%d)-%d (%d:%d) -- %s:||%s||\n"
              loc.loc_start.Lexing.pos_cnum
              loc.loc_start.Lexing.pos_lnum
              (loc.loc_start.Lexing.pos_cnum - loc.loc_start.Lexing.pos_bol)
              loc.loc_end.Lexing.pos_cnum
              loc.loc_end.Lexing.pos_lnum
              (loc.loc_end.Lexing.pos_cnum - loc.loc_end.Lexing.pos_bol)
              (print_comment_type t)
              s;
       print_comments tl;
       ()

let rec print_easy_rec ?(indent=0) easyFormatted =
  let space = Array.fold_left (^) "" (Array.make indent " ") in
  match easyFormatted with
  | Atom (s,_) ->
     printf "%s Atom:'%s'\n" space s
  | List ((opening, sep, closing, config), items) ->
     let break = (match config.wrap_body with
                  | `No_breaks -> "No_breaks"
                  | `Wrap_atoms -> "Wrap_atoms"
                  | `Never_wrap -> "Never_wrap"
                  | `Force_breaks -> "Force_breaks"
                  | `Force_breaks_rec -> "Force_breaks_rec"
                  | `Always_wrap -> "Always_wrap") in
     printf "%s List: open %s close %s sep %s break %s \n" space opening closing sep break;
     let _ = List.map (print_easy_rec ~indent:(indent+2)) items in
     ()
  | Label ((left, config), right) ->
     let break = match config.label_break with
     | `Never -> "Never"
     | `Always_rec -> "Always_rec"
     | `Auto -> "Auto"
     | `Always -> "Always" in
     printf "%s Label (break = %s): \n" space break;
     printf "  %s left \n" space;
     print_easy_rec ~indent:(indent+2) left;
     printf "  %s right \n" space;
     print_easy_rec ~indent:(indent+2) right;
  | Custom _ -> printf "custom \n"

let rec print_layout ?(indent=0) layout =
  let space = Array.fold_left (^) "" (Array.make indent " ") in
  match layout with
  | SourceMap (loc, layout) ->
     printf "%s [%d (%d:%d)-%d (%d:%d)]\n" space
            loc.loc_start.Lexing.pos_cnum
            loc.loc_start.Lexing.pos_lnum
            (loc.loc_start.Lexing.pos_cnum - loc.loc_start.Lexing.pos_bol)
            loc.loc_end.Lexing.pos_cnum
            loc.loc_end.Lexing.pos_lnum
            (loc.loc_end.Lexing.pos_cnum - loc.loc_end.Lexing.pos_bol);
     print_layout ~indent:(indent+2) layout
  | Sequence (config, layout_list) ->
     let break = match config.break with
       | Never  -> "Never"
       | IfNeed  -> "if need"
       | Always  -> "Always"
       | Always_rec  -> "Always_rec" in
     printf "%s Sequence of %d, sep: %s, finalSep: %s stick_to_left: %s break: %s\n" space (List.length layout_list) config.sep (string_of_bool config.renderFinalSep) (string_of_bool config.sepLeft) break;
     let _ = List.map (print_layout ~indent:(indent+2)) layout_list in
     ()
  | WithEOLComment (comment, layout) ->
     printf "%s WithEOLComment: \n" space;
     printf "  %s node \n" space;
     print_layout ~indent:(indent+2) layout;
     printf "  %s comments : \n" space;
     printf "  %s %s\n" space comment;
     printf "\n";
  | Label (_, left, right) ->
     printf "%s Label: \n" space;
     printf "  %s left \n" space;
     print_layout ~indent:(indent+2) left;
     printf "  %s right \n" space;
     print_layout ~indent:(indent+2) right;
  | Easy e ->
     printf "%s Easy: %s \n" space (print_easy e)

let rec longIdentSame = function
  | (Lident l1, Lident l2) -> String.compare l1 l2 == 0
  | (Ldot (path1, l1), Ldot (path2, l2)) ->
    longIdentSame (path1, path2) && String.compare l1 l2 == 0
  | (Lapply (l11, l12), Lapply (l21, l22)) ->
    longIdentSame (l11, l21) && longIdentSame (l12, l22)
  | _ -> false

let rec trueForEachPair l1 l2 tester = match (l1, l2) with
  | ([], []) -> true
  | ([], _::_) -> false
  | (_::_, []) -> false
  | (hd1::tl1, hd2::tl2) -> (tester hd1 hd2 && trueForEachPair tl1 tl2 tester)

(*
   Checks to see if two types are the same modulo the process of varification
   which turns abstract types into type variables of the same name.
   For example, [same_ast_modulo_varification] would consider (a => b) and ('a
   => 'b) to have the same ast. This is useful in recovering syntactic sugar
   for explicit polymorphic types with locally abstract types.

   Does not compare attributes, or extensions intentionally.

   TODO: This has one more issue: We need to compare only accepting t1's type
   variables, to be considered compatible with t2's type constructors - not the
   other way around.
 *)
let same_ast_modulo_varification_and_extensions t1 t2 =
  let rec loop t1 t2 = match (t1.ptyp_desc, t2.ptyp_desc) with
    (* Importantly, cover the case where type constructors (of the form [a])
       are converted to type vars of the form ['a].
     *)
    | (Ptyp_constr({txt=Lident s1}, []), Ptyp_var s2) -> String.compare s1 s2 == 0
    (* Now cover the case where type variables (of the form ['a]) are
       converted to type constructors of the form [a].
     *)
    | (Ptyp_var s1, Ptyp_constr({txt=Lident s2}, [])) -> String.compare s1 s2 == 0
    (* Now cover the typical case *)
    | (Ptyp_constr(longident1, lst1), Ptyp_constr(longident2, lst2))  ->
      longIdentSame (longident1.txt, longident2.txt) &&
      trueForEachPair lst1 lst2 loop
    | (Ptyp_any, Ptyp_any) -> true
    | (Ptyp_var x1, Ptyp_var x2) -> String.compare x1 x2 == 0
    | (Ptyp_arrow (label1, core_type1, core_type1'), Ptyp_arrow (label2, core_type2, core_type2')) ->
      String.compare label1 label2 == 0 &&
      loop core_type1 core_type2 &&
      loop core_type1' core_type2'
    | (Ptyp_tuple lst1, Ptyp_tuple lst2) -> trueForEachPair lst1 lst2 loop
    | (Ptyp_object (lst1, o1), Ptyp_object (lst2, o2)) ->
      let tester = fun (s1, attrs1, t1) (s2, attrs2, t2) ->
        String.compare s1 s2 == 0 &&
        loop t1 t2
      in
      trueForEachPair lst1 lst2 tester &&
      o1 == o2
    | (Ptyp_class (longident1, lst1), Ptyp_class (longident2, lst2)) ->
      longIdentSame (longident1.txt, longident2.txt) &&
      trueForEachPair lst1 lst2 loop
    | (Ptyp_alias(core_type1, string1), Ptyp_alias(core_type2, string2)) ->
      loop core_type1 core_type2 &&
      String.compare string1 string2 == 0
    | (Ptyp_variant(row_field_list1, flag1, lbl_lst_option1), Ptyp_variant(row_field_list2, flag2, lbl_lst_option2)) ->
      trueForEachPair row_field_list1 row_field_list2 rowFieldEqual &&
      flag1 == flag2 &&
      lbl_lst_option1 == lbl_lst_option2
    | (Ptyp_poly (string_lst1, core_type1), Ptyp_poly (string_lst2, core_type2))->
      trueForEachPair string_lst1 string_lst2 (fun s1 s2 -> String.compare s1 s2 == 0) &&
      loop core_type1 core_type2
    | (Ptyp_package(longident1, lst1), Ptyp_package (longident2, lst2)) ->
      longIdentSame (longident1.txt, longident2.txt) &&
      trueForEachPair lst1 lst2 testPackageType
    | (Ptyp_extension (s1, arg1), Ptyp_extension (s2, arg2)) ->
      String.compare s1.txt s2.txt == 0
    | _ -> false
  and testPackageType (lblLongIdent1, ct1) (lblLongIdent2, ct2) =
    longIdentSame (lblLongIdent1.txt, lblLongIdent2.txt) &&
    loop ct1 ct2
  and rowFieldEqual f1 f2 = match (f1, f2) with
    | ((Rtag(label1, attrs1, flag1, lst1)), (Rtag (label2, attrs2, flag2, lst2))) ->
      String.compare label1 label2 == 0 &&
      flag1 == flag2 &&
      trueForEachPair lst1 lst2 loop
    | (Rinherit t1, Rinherit t2) -> loop t1 t2
    | _ -> false
  in
  loop t1 t2

let wrapLayoutWithLoc loc layout =
  match loc with
  | None -> layout
  | Some loc -> SourceMap (loc, layout)

let expandLocation pos ~expand:(startPos, endPos) =
  { pos with
    loc_start = {
      pos.loc_start with
        Lexing.pos_cnum = pos.loc_start.Lexing.pos_cnum + startPos
    };
    loc_end = {
      pos.loc_end with
        Lexing.pos_cnum = pos.loc_end.Lexing.pos_cnum + endPos
    }
  }

(*
 * Returns (arityAttrs, docAttrs, standard_attrs, jsxAttrs)
 *)
let rec partitionAttributes attrs =
  match attrs with
    | [] -> ([], [], [], [])
    | (({txt="JSX"; loc}, _) as jsx)::atTl ->
        let (tlArity, tlDoc, tlStandard, tlJsx) = partitionAttributes atTl in
        (tlArity, tlDoc, tlStandard, jsx :: tlJsx)
    | (({txt="explicit_arity"; loc}, _) as arity_attr)::atTl
    | (({txt="implicit_arity"; loc}, _) as arity_attr)::atTl ->
        let (tlArity, tlDoc, tlStandard, tlJsx) = partitionAttributes atTl in
        (arity_attr::tlArity, tlDoc, tlStandard, tlJsx)
    | (({txt="ocaml.text"; loc}, _) as doc)::atTl
    | (({txt="ocaml.doc"; loc}, _) as doc)::atTl ->
        let (tlArity, tlDoc, tlStandard, tlJsx) = partitionAttributes atTl in
        (tlArity, doc::tlDoc, tlStandard, tlJsx)
    | atHd::atTl ->
        let (tlArity, tlDoc, tlStandard, tlJsx) = partitionAttributes atTl in
        (tlArity, tlDoc, atHd::tlStandard, tlJsx)

let partitionNonrecAttr attrs = List.partition (fun attr ->
    match attr with
    | ({txt="nonrec"; _}, _) -> true
    | _ -> false) attrs

let extractStdAttrs attrs =
  let (arityAttrs, docAttrs, standard_attrs, jsxAttrs) = partitionAttributes attrs in
  standard_attrs

let rec sequentialIfBlocks x =
  match x with
    | Some ({pexp_desc=Pexp_ifthenelse (e1, e2, els)}) -> (
       let (nestedIfs, finalExpression) = (sequentialIfBlocks els) in
       ((e1, e2)::nestedIfs, finalExpression)
      )
    | Some e -> ([], Some e)
    | None -> ([], None)


(*
  TODO: IDE integration beginning with Vim:

  - Create recovering version of parser that creates regions of "unknown"
    content in between let sequence bindings (anything between semicolons,
    really).
  - Use Easy_format's "style" features to tag each known node.
  - Turn those style annotations into editor highlight commands.
  - Editors have a set of keys that retrigger the parsing/rehighlighting
    process (typically newline/semi/close-brace).
  - On every parsing/rehighlighting, this pretty printer can be used to
    determine the highlighting of recovered regions, and the editor plugin can
    relegate highlighting of malformed regions to the editor which mostly does
    so based on token patterns.

*)

(*
     @avoidSingleTokenWrapping

  +-----------------------------+
  |+------+                     |     Another label
  || let ( \                    |
  ||    a  | Label              |
  ||    o  |                    |     The thing to the right of any label must be a
  ||    p _+ label RHS          |     list in order for it to wrap correctly. Lists
  ||  ): /   v                  |     will wrap if they need to/can. NON-lists will
  |+--+ sixteenTuple = echoTuple|(    wrap (indented) even though they're no lists!
  +---/ 0,\---------------------+     To prevent a single item from wrapping, make
        0,                            an unbreakable list via ensureSingleTokenSticksToLabel.
        0
      );                              In general, the best approach for indenting
                                      let bindings is to keep building up labels from
                                      the "let", always ensuring things that you want
                                      to wrap will either be lists or guarded in
                                      [ensureSingleTokenSticksToLabel].
                                      If you must join several lists together (via =)
                                      (or colon), ensure that joining is done via
                                      [makeList] (which won't break), and that new
                                      list is always appended to the left
                                      hand side of the label. (So that the right hand
                                      side may always be the untouched list that you want
                                      to wrap with aligned closing).
                                      Always make sure rhs of the label are the

                                      Creating nested labels will preserve the original
                                      indent location ("let" in this
                                      case) as long as that nesting is
                                      done on the left hand side of the labels.

*)

(*
    Table 2.1. Precedence and associativity.
    Precedence from highest to lowest: From RWOC, modified to include !=
    ---------------------------------------

    Operator prefix	Associativity
    !..., ?..., ~...	                              Prefix
    ., .(, .[	-
    function application, constructor, assert, lazy	Left associative
    -, -.                                           Prefix
    **..., lsl, lsr, asr                            Right associative
    *..., /..., %..., mod, land, lor, lxor          Left associative
    +..., -...                                      Left associative
    ::                                              Right associative
    @..., ^...                                      Right associative
---
    !=                                              Left associative (INFIXOP0 listed first in lexer)
    =..., <..., >..., |..., &..., $...              Left associative (INFIXOP0)
    =, <, >                                         Left associative (IN SAME row as INFIXOP0 listed after)
---
    &, &&                                           Right associative
    or, ||                                          Right associative
    ,                                               -
    :=, =                                         	Right associative
    if                                              -
    ;                                               Right associative


   Note: It would be much better if &... and |... were in separate precedence
   groups just as & and | are. This way, we could encourage custom infix
   operators to use one of the two precedences and no one would be confused as
   to precedence (leading &, | are intuitive). Two precedence classes for the
   majority of infix operators is totally sufficient.

   TODO: Free up the (&) operator from pervasives so it can be reused for
   something very common such as string concatenation or list appending.

   let x = tail & head;
 *)

(* "Almost Simple Prefix" function applications parse with the rule:

   `PREFIXOP simple_expr %prec below_DOT_AND_SHARP`, which in turn is almost
   considered a "simple expression" (it's acceptable anywhere a simple
   expression is except in a couple of edge cases.

   "Unary Prefix" function applications parse with the rule:

   `MINUS epxr %prec prec_unary_minus`, which in turn is considered an
   "expression" (not simple). All unary operators are mapped into an identifier
   beginning with "~".

   TODO: Migrate all "almost simple prefix" to "unsary prefix". When `!`
   becomes "not", then it will make more sense that !myFunc (arg) is parsed as
   !(myFunc arg) instead of (!myFunc) arg.

 *)
let almost_simple_prefix_symbols  = [ '!'; '?'; '~'] ;;
(* Subset of prefix symbols that have special "unary precedence" *)
let unary_minus_prefix_symbols  = [ "~-"; "~-."] ;;
let unary_plus_prefix_symbols  = ["~+"; "~+." ] ;;
let infix_symbols = [ '='; '<'; '>'; '@'; '^'; '|'; '&'; '+'; '-'; '*'; '/';
                      '$'; '%'; '\\'; '#' ]
let operator_chars = [ '!'; '$'; '%'; '&'; '*'; '+'; '-'; '.'; '/';
                       ':'; '<'; '='; '>'; '?'; '@'; '^'; '|'; '~' ]
let numeric_chars  = [ '0'; '1'; '2'; '3'; '4'; '5'; '6'; '7'; '8'; '9' ]

let special_infix_strings =
  ["asr"; "land"; "lor"; "lsl"; "lsr"; "lxor"; "mod"; "or"; ":="; "!="; "!=="]

let updateToken = "="
let requireIndentFor = [updateToken; ":="]

let infixTokenRequiresIndent printedIdent =
  if List.exists (fun i -> i = printedIdent) requireIndentFor then None else Some 0

let getPrintableUnaryIdent s =
  if List.mem s unary_minus_prefix_symbols || List.mem s unary_plus_prefix_symbols then
    String.sub s 1 (String.length s -1)
  else s


(* determines if the string is an infix string.
   checks backwards, first allowing a renaming postfix ("_102") which
   may have resulted from Pexp -> Texp -> Pexp translation, then checking
   if all the characters in the beginning of the string are valid infix
   characters. *)
let printedStringAndFixity  = function
  | s when List.mem s special_infix_strings -> Infix s
  | s when List.mem s.[0] infix_symbols -> Infix s
  (* Correctness under assumption that unary operators are stored in AST with
     leading "~" *)
  | s when List.mem s.[0] almost_simple_prefix_symbols &&
           not (List.mem s special_infix_strings) &&
           not (s = "?")-> (
      (* What *kind* of prefix fixity? *)
      if List.mem s unary_plus_prefix_symbols then
        UnaryPlusPrefix (getPrintableUnaryIdent s)
      else if List.mem s unary_minus_prefix_symbols then
        UnaryMinusPrefix (getPrintableUnaryIdent s)
      else
        AlmostSimplePrefix s
  )
  | _ -> Normal


(* Also, this doesn't account for != and !== being infixop!!! *)
let isSimplePrefixToken s = match printedStringAndFixity s with
  | AlmostSimplePrefix _ -> true
  | _ -> false


(* Convenient bank of information that represents the parser's precedence
   rankings.  Each instance describes a precedence table entry. The function
   tests either a token string encountered by the parser, or (in the case of
   `CustomPrecedence`) the string name of a custom rule precedence declared
   using %prec *)
let rules = [
  [
    (TokenPrecedence, (fun s -> (Nonassoc, isSimplePrefixToken s)));
  ];
  [
    (CustomPrecedence, (fun s -> (Nonassoc, s = "prec_unary_minus")));
    (CustomPrecedence, (fun s -> (Nonassoc, s = "prec_unary_plus")));
  ];
  (* Note the special case for "*\*", BARBAR, and LESSMINUS, AMPERSAND(s) *)
  [
    (TokenPrecedence, (fun s -> (Right, String.length s > 1 && s.[0] == '*' && s.[1] == '\\' && s.[2] == '*')));
    (TokenPrecedence, (fun s -> (Right, s = "lsl")));
    (TokenPrecedence, (fun s -> (Right, s = "lsr")));
    (TokenPrecedence, (fun s -> (Right, s = "asr")));
  ];
  [
    (TokenPrecedence, (fun s -> (Left, s.[0] == '*' && (String.length s == 1 || s != "*\\*"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '/')));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '%' )));
    (TokenPrecedence, (fun s -> (Left, s = "mod" )));
    (TokenPrecedence, (fun s -> (Left, s = "land" )));
    (TokenPrecedence, (fun s -> (Left, s = "lor" )));
    (TokenPrecedence, (fun s -> (Left, s = "lxor" )));
  ];
  [
    (* Even though these use the same *tokens* as unary plus/minus at parse
       time, when unparsing infix -/+, the CustomPrecedence rule would be
       incorrect to use, and instead we need a rule that models what infix
       parsing would use - just the regular token precedence without a custom
       precedence. *)
    (TokenPrecedence, (fun s -> (Left, s.[0] == '+' )));
    (TokenPrecedence ,(fun s -> (Left, s.[0] == '-' )));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = "::")));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s.[0] == '@')));
    (TokenPrecedence, (fun s -> (Right, s.[0] == '^')));
  ];
  [
    (TokenPrecedence, (fun s -> (Left, s.[0] == '=' && not (s = "=") && not (s = "=>"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '<' && not (s = "<"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '>' && not (s = ">"))));
    (TokenPrecedence, (fun s -> (Left, s = "!=")));  (* Not preset in the RWO table! *)
    (TokenPrecedence, (fun s -> (Left, s = "!==")));  (* Not preset in the RWO table! *)
    (TokenPrecedence, (fun s -> (Left, s = "==")));
    (TokenPrecedence, (fun s -> (Left, s = "===")));
    (TokenPrecedence, (fun s -> (Left, s = "<")));
    (TokenPrecedence, (fun s -> (Left, s = ">")));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '|' && not (s = "||"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '&' && not (s = "&") && not (s = "&&"))));
    (TokenPrecedence, (fun s -> (Left, s.[0] == '$')));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = "&")));
    (TokenPrecedence, (fun s -> (Right, s = "&&")));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = "or")));
    (TokenPrecedence, (fun s -> (Right, s = "||")));
  ];
  [
    (* The Left shouldn't ever matter in practice. Should never get in a
       situation with two consecutive infix ? - the colon saves us. *)
    (TokenPrecedence, (fun s -> (Left, s = "?")));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = ":=")));
  ];
  [
    (TokenPrecedence, (fun s -> (Right, s = updateToken)));
  ];
  (* It's important to account for ternary ":" being lower precedence than "?" *)
  [
    (TokenPrecedence, (fun s -> (Right, s = ":")))
  ];
  [
    (TokenPrecedence, (fun s -> (Nonassoc, s = "=>")));
  ];
]

(* remove all prefixing backslashes, e.g. \=== becomes === *)
let rec without_prefixed_backslashes str =
  if str = "" then str
  else if String.get str 0 = '\\' then String.sub str 1 (String.length str - 1)
  else str

let indexOfFirstMatch ~prec lst =
  let rec indexOfFirstMatchN ~prec lst n = match lst with
    | [] -> None
    | []::tl -> indexOfFirstMatchN ~prec tl (n + 1)
    | (hdHd::hdTl)::tl -> (
      let (kind, tester) = hdHd in
      match (prec, kind) with
      | (Token str, TokenPrecedence)
      | (Custom str, CustomPrecedence) ->
        let (associativity, foundMatch) = tester str in
        if foundMatch then
          Some (associativity, n)
        else
          indexOfFirstMatchN ~prec (hdTl::tl) (n)
      | _ -> indexOfFirstMatchN ~prec (hdTl::tl) (n)
    )
  in
  indexOfFirstMatchN ~prec lst 0

(* Assuming it's an infix function application. *)
let precedenceInfo ~prec =
  (* Removes prefixed backslashes in order to do proper conversion *)
  let normalizedCheck =
    match prec with
      | Token str -> Token (without_prefixed_backslashes str)
      | Custom str -> prec
  in
  indexOfFirstMatch ~prec:normalizedCheck rules

let isLeftAssociative ~prec = match precedenceInfo ~prec with
  | None -> false
  | Some (Left, _) -> true
  | Some (Right, _) -> false
  | Some (Nonassoc, _) -> false

let isRightAssociative ~prec = match precedenceInfo ~prec with
  | None -> false
  | Some (Right, _) -> true
  | Some (Left, _) -> false
  | Some (Nonassoc, _) -> false

let higherPrecedenceThan c1 c2 = match ((precedenceInfo c1), (precedenceInfo c2)) with
  | (_, None)
  | (None, _) ->
    let (str1, str2) = match (c1, c2) with
      | (Token s1, Token s2) -> ("Token " ^ s1, "Token " ^ s2)
      | (Token s1, Custom s2) -> ("Token " ^ s1, "Custom " ^ s2)
      | (Custom s1, Token s2) -> ("Custom " ^ s1, "Token " ^ s2)
      | (Custom s1, Custom s2) -> ("Custom " ^ s1, "Custom " ^ s2)
    in
    raise (NotPossible ("Cannot determine precedence of two checks " ^ str1 ^ " vs. " ^ str2))
  | (Some (_, p1), Some (_, p2)) -> p1 < p2


let printedStringAndFixityExpr = function
  | {pexp_desc = Pexp_ident {txt=Lident l}} -> printedStringAndFixity l
  | _ -> Normal

let is_predef_option = function
  | (Ldot (Lident "*predef*","option")) -> true
  | _ -> false

(* which identifiers are in fact operators needing parentheses *)
let needs_parens txt =
  match printedStringAndFixity txt with
    | Infix _ -> true
    | UnaryPlusPrefix _ -> true
    | UnaryMinusPrefix _ -> true
    | AlmostSimplePrefix _ -> true
    | Normal -> false

(* some infixes need spaces around parens to avoid clashes with comment
   syntax. This isn't needed for comment syntax /* */ *)
let needs_spaces txt =
  txt.[0]='*' || txt.[String.length txt - 1] = '*'

(* add parentheses to binders when they are in fact infix or prefix operators *)
let protect_ident ppf txt =
  let format : (_, _, _) format =
    if not (needs_parens txt) then "%s"
    else if needs_spaces txt then "(@;%s@;)"
    else "(%s)"
  in fprintf ppf format txt

let protect_longident ppf print_longident longprefix txt =
  let format : (_, _, _) format =
    if not (needs_parens txt) then "%a.%s"
    else if needs_spaces txt then  "(@;%a.%s@;)"
    else "(%a.%s)" in
  fprintf ppf format print_longident longprefix txt

let rec longident f = function
  | Lident s -> protect_ident f s
  | Ldot(y,s) -> protect_longident f longident y s
  | Lapply (y,s) ->
      fprintf f "%a(%a)" longident y longident s

let rec orList = function (* only consider ((A|B)|C)*)
  | {ppat_desc = Ppat_or (p1, p2)} -> (orList p1) @ (orList p2)
  | x -> [x]

type space_formatter = (unit, Format.formatter, unit) format

let override = function
  | Override -> "!"
  | Fresh -> ""

(* variance encoding: need to sync up with the [parser.mly] *)
let type_variance = function
  | Invariant -> ""
  | Covariant -> "+"
  | Contravariant -> "-"

type construct =
  [ `cons of expression list
  | `list of expression list
  | `nil
  | `normal
  | `simple of Longident.t
  | `tuple ]

let view_expr x =
  match x.pexp_desc with
    | Pexp_construct ( {txt= Lident "()"; _},_) -> `tuple
    | Pexp_construct ( {txt= Lident "[]"},_) -> `nil
    | Pexp_construct ( {txt= Lident"::"},Some _) ->
        let rec loop exp acc = match exp with
          | {pexp_desc=Pexp_construct ({txt=Lident "[]"},_)} ->
              (List.rev acc,true)
          | {pexp_desc=
               Pexp_construct ({txt=Lident "::"},
                 Some ({pexp_desc= Pexp_tuple([e1;e2])}))} ->
              loop e2 (e1::acc)
          | e -> (List.rev (e::acc),false) in
        let (ls,b) = loop x []  in
        if b then
          `list ls
        else `cons ls
    | Pexp_construct (x,None) -> `simple (x.txt)
    | _ -> `normal

let is_simple_construct :construct -> bool = function
  | `nil | `tuple | `list _ | `simple _ | `cons _  -> true
  | `normal -> false

let pp = fprintf

let default = new Pprintast.printer ()

type funcReturnStyle =
  | ReturnValOnSameLine

let detectTernary l = match l with
  | [{
      pc_lhs={ppat_desc=Ppat_construct ({txt=Lident "true"}, _)};
      pc_guard=None;
      pc_rhs=ifTrue
    };
    {
      pc_lhs={ppat_desc=Ppat_construct ({txt=Lident "false"}, _)};
      pc_guard=None;
      pc_rhs=ifFalse
    }] -> Some (ifTrue, ifFalse)
  | _ -> None
type funcApplicationLabelStyle =
  (* No attaching to the label, but if the entire application fits on one line,
     the entire application will appear next to the label as you 'd expect. *)
  | NeverWrapFinalItem
  (* Attach the first term if there are exactly two terms involved in the
     application.

     let x = firstTerm (secondTerm_1 secondTerm_2) thirdTerm;

     Ideally, we'd be able to attach all but the last argument into the label any
     time all but the last term will fit - and *not* when (attaching all but
     the last term isn't enough to prevent a wrap) - But there's no way to tell
     ahead of time if it would prevent a wrap.

     However, the number two is somewhat convenient. This models the
     indentation that you'd prefer in non-curried syntax languages like
     JavaScript, where application only ever has two terms.
  *)
  | WrapFinalListyItemIfFewerThan of int

(*
    space=2, indentWrappedPatternArgs=1, funcReturnStyle=ReturnValOnSameLine
    ------------------------------------------------------------------------
    (* When [ReturnValOnSameLine], [indentWrappedPatternArgs] has no effect! *)
    let myFunc
        (wrappedArgOne:int)
        (wrappedArgTwo:int) => {
      valOne: 10,
      valTwo: 20
    };

    space=2, indentWrappedPatternArgs=2, funcReturnStyle=ReturnValOnSameLine
    ------------------------------------------------------------------------
    (* When [ReturnValOnSameLine], [indentWrappedPatternArgs] has no effect! *)
    let myFunc
        (wrappedArgOne:int)
        (wrappedArgTwo:int) => {
      valOne: 10,
      valTwo: 20
    };

*)

type formatSettings = {
  (* Whether or not to expect that the original parser that generated the AST
     would have annotated constructor argument tuples with explicit arity to
     indicate that they are multiple arguments. (True if parsed in original
     OCaml AST, false if using Reason parser).
  *)
  constructorTupleImplicitArity: bool;
  space: int;
  (* Whether or not to begin a curried function's return expression immediately
     after the [=>] without a newline.
  *)
  returnStyle: funcReturnStyle;

  (* For curried arguments in function *definitions* only: Number of [space]s
     to offset beyond the [let] keyword. Default 1.
  *)
  listsRecordsIndent: int;

  (* When [funcReturnStyle] = [ReturnValOnSameLine],
     [indentWrappedPatternArgs] is not adjustable - wrapped arguments will
     always be aligned with the function name. *)
  indentWrappedPatternArgs: int;

  indentMatchCases: int;

  (* Amount to indent in label-like constructs such as wrapped function
     applications, etc - or even record fields. This is not the same concept as an
     indented curried argument list. *)
  indentAfterLabels: int;

  (* Amount to indent after the opening brace of switch/try.
     Here's an example of what it would look like w/ [trySwitchIndent = 2]:
     Sticks the expression to the last item in a sequence in several [X | Y | Z
     => expr], and forces X, Y, Z to be split onto several lines. (Otherwise,
     sticking to Z would result in hanging expressions).  TODO: In the first case,
     it's clear that we want patterns to have an "extra" indentation with matching
     in a "match". Create extra config param to pass to [self#pattern] for extra
     indentation in this one case.

      switch x {
      | TwoCombos
          (HeresTwoConstructorArguments x y)
          (HeresTwoConstructorArguments a b) =>
          ((a + b) + x) + y;
      | Short
      | AlsoHasARecord a b {x, y} => (
          retOne,
          retTwo
        )
      | AlsoHasARecord a b {x, y} =>
        callMyFunction
          withArg
          withArg
          withArg
          withArg;
      }
  *)
  trySwitchIndent: int;


  (* In the case of two term function application (when flattened), the first
     term should become part of the label, and the second term should be able to wrap
     This doesn't effect n != 2.

       [true]
       let x = reallyShort allFitsOnOneLine;
       let x = someFunction {
         reallyLongObject: true,
         thatWouldntFitOnThe: true,
         firstLine: true
       };

       [false]
       let x = reallyShort allFitsOnOneLine;
       let x =
        someFunction
          {
            reallyLongObject: true,
            thatWouldntFitOnThe: true,
            firstLine: true
          };
  *)
  funcApplicationLabelStyle: funcApplicationLabelStyle;

  funcCurriedPatternStyle: funcApplicationLabelStyle;

  width: int;

  assumeExplicitArity: bool;

  constructorLists: string list;
}

let defaultSettings = {
  constructorTupleImplicitArity = false;
  space = 1;
  returnStyle = ReturnValOnSameLine;
  listsRecordsIndent = 2;
  indentWrappedPatternArgs = 2;
  indentMatchCases = 2;
  indentAfterLabels = 2;
  trySwitchIndent = 0;
  funcApplicationLabelStyle = WrapFinalListyItemIfFewerThan 3;
  (* WrapFinalListyItemIfFewerThan is currently a bad idea for curried
     arguments: It looks great in some cases:

        let myFun (a:int) :(
          int,
          string
        ) => (a, "this is a");

     But horrible in others:

        let myFun
            {
              myField,
              yourField
            } :someReturnType => myField + yourField;

        let myFun
            {            // Curried arg wraps
              myField,
              yourField
            } : (       // But the last is "listy" so it docks
          int,          // To the [let].
          int,
          int
        ) => myField + yourField;

     We probably want some special listy label docking/wrapping mode for
     curried function bindings.

  *)
  funcCurriedPatternStyle = NeverWrapFinalItem;
  width = 90;
  assumeExplicitArity = false;
  constructorLists = [];
}
let configuredSettings = ref defaultSettings

let configure ~width ~assumeExplicitArity ~constructorLists = (
  configuredSettings := {defaultSettings with width; assumeExplicitArity; constructorLists}
)

let string_of_formatter f x =
  Format.asprintf "%a" f x

let createFormatter () =
let module Formatter = struct

let settings = !configuredSettings


(* How do we make
   this a label?

   /---------------------\
   let myVal = (oneThing, {
   field: [],
   anotherField: blah
   });

   But in this case, this wider region a label?
   /------------------------------------------------------\
   let myVal = callSomeFunc (oneThing, {field: [], anotherField: blah}, {
   boo: 'hi'
   });

   This is difficult. You must form a label from the preorder traversal of every
   node - except the last encountered in the traversal. An easier heuristic is:

   - The last argument to a functor application is expanded.

   React.CreateClass SomeThing {
   let render {props} => {
   };
   }

   - The last argument to a function application is expanded on the same line.
   - Only if it's not curried with another invocation.
   -- Optionally: "only if everything else is an atom"
   -- Optionally: "only if there are no other args"

   React.createClass someThing {
   render: fn x => y,
   }

   !!! NOT THIS
   React.createClass someThing {
   render: fn x => y,
   }
   somethingElse
*)

let isArityClear attrs =
  (!configuredSettings).assumeExplicitArity ||
  List.exists
    (function
      | ({txt="explicit_arity"; loc}, _) -> true
      | _ -> false
    )
    attrs


let list_settings = {
  Easy_format.space_after_opening = false;
  space_after_separator = false;
  space_before_separator = false;
  separators_stick_left = true;
  space_before_closing = false;
  stick_to_label = true;
  align_closing = true;
  wrap_body = `No_breaks;
  indent_body = settings.listsRecordsIndent * settings.space;
  list_style = Some "list";
  opening_style = None;
  body_style = None;
  separator_style = None;
  closing_style = None;
}

let nullStyle = { Easy_format.atom_style = Some "null" }
let boolStyle = { Easy_format.atom_style = Some "bool" }
let intStyle = { Easy_format.atom_style = Some "int" }
let stringStyle = { Easy_format.atom_style = Some "string" }
let labelStringStyle = { Easy_format.atom_style = Some "atomClss" }
let colonStyle = { Easy_format.atom_style = Some "punct" }

let simplifiedApplicationSettings = {
  list_settings with
    align_closing = true; (* So the semicolon sticks to end of application *)
    (* This must be true to support this case:

        let oneNestedInvocationThatWraps = outerFunc (
          nestedFuncToInvokeThatCausesWrapping
          []
        );

       Otherwise, we would get:
        let oneNestedInvocationThatWraps = outerFunc
          (nestedFuncToInvokeThatCausesWrapping []);
    *)
    stick_to_label = true; (* I don't believe this has a purpose *)
    space_after_separator = true;
    wrap_body = `Never_wrap
}

let easyListSettingsFromListConfig listConfig =
  let {
    break;
    wrap;
    inline;
    indent;
    sepLeft;
    preSpace;
    postSpace;
    pad;
    sep;
  } = listConfig in
  let (opn, cls) = wrap in
  let (padOpn, padCls) = pad in
  let (inlineStart, inlineEnd) = inline in
  (opn, sep, cls, {
    list_settings with
      wrap_body = (
        match break with
          | Never -> `No_breaks
          (* Yes, `Never_wrap is a horrible name - really means "if needed". *)
          | IfNeed -> `Never_wrap
          | Always -> `Force_breaks
          | Always_rec -> `Force_breaks_rec
      );
      indent_body = indent;
      space_after_separator = postSpace;
      space_before_separator = preSpace;
      space_after_opening = padOpn;
      space_before_closing = padCls;
      stick_to_label = inlineStart;
      align_closing = not inlineEnd;
  })

let makeListConfig
    ?(newlinesAboveItems=0)
    ?(newlinesAboveComments=0)
    ?(newlinesAboveDocComments=0)
    ?(interleaveComments=true)
    ?listConfigIfCommentsInterleaved
    ?(listConfigIfEolCommentsInterleaved)
    ?(renderFinalSep=false)
    ?(break=Never)
    ?(wrap=("", ""))
    ?(inline=(true, false))
    ?(sep="")
    ?(indent=list_settings.indent_body)
    ?(sepLeft=true)
    ?(preSpace=false)
    ?(postSpace=false)
    ?(pad=(false,false))
    () =
  {
    newlinesAboveItems;
    newlinesAboveComments;
    newlinesAboveDocComments;
    interleaveComments;
    listConfigIfCommentsInterleaved;
    listConfigIfEolCommentsInterleaved;
    renderFinalSep;
    break;
    wrap;
    inline;
    sep;
    indent;
    sepLeft;
    preSpace;
    postSpace;
    pad;
  }

let easyListWithConfig listConfig easyListItems =
  let (opn, sep, cls, settings) =
    easyListSettingsFromListConfig listConfig in
  Easy_format.List ((opn, sep, cls, settings), easyListItems)

let makeEasyList
    ?(newlinesAboveItems=0)
    ?(newlinesAboveComments=0)
    ?(newlinesAboveDocComments=0)
    ?(interleaveComments=true)
    ?(renderFinalSep=false)
    ?(break=Never)
    ?(wrap=("", ""))
    ?(inline=(true, false))
    ?(sep="")
    ?(indent=list_settings.indent_body)
    ?(sepLeft=true)
    ?(preSpace=false)
    ?(postSpace=false)
    ?(pad=(false,false)) easyListItems =
  let listConfig =
    makeListConfig
      ~newlinesAboveItems
      ~newlinesAboveComments
      ~newlinesAboveDocComments
      ~interleaveComments
      (* This is unused at this point - separators are handled by our pretty printer,
         not Easy_format (so that we can interleave comments intelligently) *)
      ~renderFinalSep
      ~break
      ~wrap
      ~inline
      ~sep
      ~indent
      ~sepLeft
      ~preSpace
      ~postSpace
      ~pad
      ()
  in
  let (opn, sep, cls, listSettings) = easyListSettingsFromListConfig listConfig in
  Easy_format.List ((opn, sep, cls, listSettings), easyListItems)

let makeList
    (* Allows a fallback in the event that comments were interleaved with the
     * list *)
    ?(newlinesAboveItems=0)
    ?(newlinesAboveComments=0)
    ?(newlinesAboveDocComments=0)
    ?(interleaveComments=true)
    ?listConfigIfCommentsInterleaved
    ?listConfigIfEolCommentsInterleaved
    ?(renderFinalSep=false)
    ?(break=Never)
    ?(wrap=("", ""))
    ?(inline=(true, false))
    ?(sep="")
    ?(indent=list_settings.indent_body)
    ?(sepLeft=true)
    ?(preSpace=false)
    ?(postSpace=false)
    ?(pad=(false,false)) lst =
  let config =
    makeListConfig
      ~newlinesAboveItems
      ~newlinesAboveComments
      ~newlinesAboveDocComments
      ~interleaveComments
      ?listConfigIfCommentsInterleaved
      ?listConfigIfEolCommentsInterleaved
      ~renderFinalSep
      ~break
      ~wrap
      ~inline
      ~sep
      ~indent
      ~sepLeft
      ~preSpace
      ~postSpace
      ~pad
      ()
  in
  Sequence (config, lst)

let makeAppList l =
  match l with
  | hd::[] -> hd
  | _ -> makeList ~inline:(true, true) ~postSpace:true ~break:IfNeed l

let ensureSingleTokenSticksToLabel x =
  makeList
    ~interleaveComments:true
    ~listConfigIfCommentsInterleaved: (
      fun currentConfig -> {currentConfig with break=Always_rec; postSpace=true; indent=0; inline=(true, true)}
    )
    [x]

let unbreakLabelFormatter formatter =
  let newFormatter labelTerm term =
    match formatter labelTerm term with
    | Easy_format.Label ((labelTerm, settings), term) ->
       Easy_format.Label ((labelTerm,
                           {settings with label_break = `Never}),
                          term)
    | _ -> failwith "not a label"
  in newFormatter

let inlineLabel labelTerm term =
  let settings = {
    label_break = `Never;
    space_after_label = true;
    indent_after_label = 0;
    label_style = Some "inlineLabel";
  } in
  Easy_format.Label ((labelTerm, settings), term)

(* Just for debugging: Set debugWithHtml = true *)
let debugWithHtml = ref false

let html_escape_string s =
  let buf = Buffer.create (2 * String.length s) in
  for i = 0 to String.length s - 1 do
    match s.[i] with
        '&' -> Buffer.add_string buf "&amp;"
      | '<' -> Buffer.add_string buf "&lt;"
      | '>' -> Buffer.add_string buf "&gt;"
      | c -> Buffer.add_char buf c
  done;
  Buffer.contents buf

let html_escape = `Escape_string html_escape_string
let html_style = [
  "atom", { Easy_format.tag_open = "<a>"; tag_close = "</a>" };
  "body", { tag_open = "<lb>"; tag_close = "</lb>" };
  "list", { tag_open = "<l>"; tag_close = "</l>" };
  "op", { tag_open = "<op>"; tag_close = "</op>" };
  "cl", { tag_open = "<cl>"; tag_close = "</cl>" };
  "sep", { tag_open = "<sep>"; tag_close = "</sep>" };
  "label", { tag_open = "<la>"; tag_close = "</la>" };
]


let easyLabel ?(break=`Auto) ?(space=false) ?(indent=settings.indentAfterLabels) labelTerm term =
  let settings = {
    label_break = break;
    space_after_label = space;
    indent_after_label = indent;
    label_style = Some "label";
  } in
  Easy_format.Label ((labelTerm, settings), term)

let label ?(break=`Auto) ?(space=false) ?(indent=settings.indentAfterLabels) (labelTerm:layoutNode) (term:layoutNode) =
  Label (
    (fun x y -> easyLabel ~break ~indent ~space x y),
    labelTerm,
    term
  )

let labelSpace l r = label ~space:true l r

let atom ?loc str =
  let layout = Easy (Easy_format.Atom(str, labelStringStyle)) in
  wrapLayoutWithLoc loc layout

let easyAtom str = Easy_format.Atom(str, labelStringStyle)

(** Take x,y,z and n and generate [x, y, z, ...n] *)
let makeES6List lst last =
  let last_dots = makeList [atom "..."; last] in
  makeList ~wrap:("[", "]") ~break:IfNeed ~postSpace:true ~sep:"," (lst @ [last_dots])

let makeNonIndentedBreakingList lst =
    (* No align closing: So that semis stick to the ends of every break *)
  makeList ~break:Always_rec ~indent:0 ~inline:(true, true) lst

let break =
    (* No align closing: So that semis stick to the ends of every break *)
  makeListConfig ~break:Always_rec ~indent:0 ~inline:(true, true) ()

let makeBreakableList lst = makeList ~break:IfNeed ~inline:(true, true) lst

let makeNonIndentedBreakableEasyList lst = makeEasyList ~break:IfNeed ~inline:(true, true) ~indent:0 lst

(* Like a <span> could place with other breakableInline lists without upsetting final semicolons *)
let makeSpacedBreakableInlineList lst =
  makeList ~break:IfNeed ~inline:(true, true) ~postSpace:true lst

let makeCommaBreakableList lst = makeList ~break:IfNeed ~postSpace:true lst

let makeCommaBreakableListSurround opn cls lst =
  makeList ~break:IfNeed ~postSpace:true ~sep:"," ~wrap:(opn, cls) lst

(* TODO: Allow configuration of spacing around colon symbol *)

let formatPrecedence ?loc formattedTerm =
  let withParens = makeList ~wrap:("(", ")") ~break:IfNeed [formattedTerm] in
  match loc with
    | None -> withParens
    | Some l -> SourceMap (l, withParens)

(* What to do when a comment wasn't interleaved in a list - default is to attach and break. *)
let fallbackCommentListConfig = break


let eolCommentListConfig = makeListConfig ~break:Never ~postSpace:true ~inline:(true, true) ()

let isListy = function
  | Easy_format.List _ -> true
  | _ -> false

let easyFormatToFormatter f x =
  let buf = Buffer.create 1000 in
  let fauxmatter = Format.formatter_of_buffer buf in
  let _ = Format.pp_set_margin fauxmatter settings.width in
  if debugWithHtml.contents then
    Easy_format.Pretty.define_styles fauxmatter html_escape html_style;
  let _ = Easy_format.Pretty.to_formatter fauxmatter x in
  let trimmed = Syntax_util.strip_trailing_whitespace (Buffer.contents buf) in
  Format.fprintf f "%s\n" trimmed;
  pp_print_flush f ()

let wrap fn = fun term ->
  ignore (flush_str_formatter ());
  let f = str_formatter in
  (fn f term; atom (flush_str_formatter ()))


(** Either an ItemComment  (not eol) designates if it's a doc comment (which
    have extra leading stars).  Or an Item which might include its eol
    comments. *)
type commentOrItem =
  | ItemComment of Easy_format.t * bool
  (* The item, and a list of "end of line" comments to render *)
  | Item of (Easy_format.t * Easy_format.t list)


(**
 * Invokes the supplied partitioning function with normalized location
 * positions. AST nodes and comments' locations have endpoints that are not one
 * beyond the actual end. [extractComments] normalizes this and provides
 * the exact first/last character position. The function should return true iff
 * an item with that exact location is to be included in the left partition.
 *
 * The callback is invoked with both normalized physical location, as well as
 * the "attachment" location. The attachment location makes note of where
 * the comment was relative to indentation or the beginning of a line.
 *
 * Attachment location: What portion of text is the comment annotating
 * (including the comment text itself)?
 * Physical location: Where in the file was the comment? Usually a subset of
 * attachment location.
 *)
let rec extractComments comments tester =
  let open Lexing in
  (* There might be an issue here - we shouldn't have to split "up to and including".
     Up to should be sufficient. Comments' end position might be off by one (too large) *)
  comments |> List.partition (fun (str, attLoc, physLoc) ->
    let oneGreaterThanAttachmentLocEnd = attLoc.loc_end.pos_cnum in
    let attachmentLocLastChar = oneGreaterThanAttachmentLocEnd - 1 in
    let oneGreaterThanPhysLocEnd = physLoc.loc_end.pos_cnum in
    let physLastChar = oneGreaterThanPhysLocEnd - 1 in
    tester attLoc.loc_start.pos_cnum attachmentLocLastChar physLoc.loc_start.pos_cnum physLastChar
  )

(* Don't use `trim` since it kills line return too? *)
let rec beginsWithStar_ line length idx =
  if idx = length then false
  else
    let ch = String.get line idx in
    if ch = '*' then true
    else if ch = '\t' || ch = ' ' then beginsWithStar_ line length (idx + 1)
    else false

let beginsWithStar line = beginsWithStar_ line (String.length line) 0

let rec numLeadingSpace_ line length idx accum =
  if idx = length then accum
  else
    let ch = String.get line idx in
    if ch = '\t' || ch = ' ' then numLeadingSpace_ line length (idx + 1) (accum + 1)
    else accum

let numLeadingSpace line = numLeadingSpace_ line (String.length line) 0 0

(* Computes the smallest leading spaces for non-empty lines *)
let smallestLeadingSpaces strs =
  let rec smallestLeadingSpaces curMin strs = match strs with
    | [] -> curMin
    | hd::tl ->
      if hd = "" then
        smallestLeadingSpaces curMin tl
      else
        let leadingSpace = numLeadingSpace hd in
        let nextMin = min curMin leadingSpace in
        smallestLeadingSpaces nextMin tl
  in
  smallestLeadingSpaces 99999 strs

let convertIsListyToIsSequencey isListyImpl =
  let rec isSequencey layoutNode = match layoutNode with
    | SourceMap (_, subLayoutNode) -> isSequencey subLayoutNode
    | Sequence _ -> true
    | WithEOLComment (_, sub) -> isSequencey sub
    | Label (_, _, _) -> false
    | Easy easy -> isListyImpl easy
  in
  isSequencey

let isSequencey = convertIsListyToIsSequencey isListy

let inline ?(preSpace=false) ?(postSpace=false) labelTerm term =
  makeList ~inline:(true, true) ~postSpace ~preSpace ~indent:0 ~break:Never [labelTerm; term]

let breakline labelTerm term =
  makeList ~inline:(true, true) ~indent:0 ~break:Always_rec [labelTerm; term]

let insertBlankLines n term =
  if n = 0 then
    term
  else
    makeList ~inline:(true, true) ~indent:0 ~break:Always_rec (Array.to_list (Array.make n (atom "")) @ [term])

let string_after s n = String.sub s n (String.length s - n)

let wrapComment txt =
  ("/*" ^ txt ^ "*/")

(* This is a special-purpose functions only used by `formatComment_`. Notice we
skip a char below during usage because we know the comment starts with `/*` *)
let rec lineZeroMeaningfulContent_ line length idx accum =
  if idx = length then None
  else
    let ch = String.get line idx in
    if ch = '\t' || ch = ' ' || ch = '*' then
      lineZeroMeaningfulContent_ line length (idx + 1) (accum + 1)
    else Some accum

let lineZeroMeaningfulContent line = lineZeroMeaningfulContent_ line (String.length line) 1 0

let formatComment_ txt =
  let commLines = Syntax_util.split_by ~keep_empty:true (fun x -> x = '\n') (wrapComment txt) in
  match commLines with
  | [] -> atom ""
  | [hd] ->
    makeList ~inline:(true, true) ~postSpace:true ~preSpace:true ~indent:0 ~break:IfNeed [atom hd]
  | zero::one::tl ->
    let attemptRemoveCount = (smallestLeadingSpaces (one::tl)) in
    let leftPad =
      if beginsWithStar one then 1
      else match lineZeroMeaningfulContent zero with
      | None -> 1
      | Some num -> num + 1
    in
    let padNonOpeningLine s =
      let numLeadingSpaceForThisLine = numLeadingSpace s in
      if String.length s == 0 then ""
      else (String.make leftPad ' ') ^
            (string_after s (min attemptRemoveCount numLeadingSpaceForThisLine)) in
    let lines = zero :: List.map padNonOpeningLine (one::tl) in
    makeList ~inline:(true, true) ~indent:0 ~break:Always_rec (List.map atom lines)

let formatComment ?locOpt txt =
  let list = formatComment_ txt in
  match locOpt with
  | None ->
     list
  | Some loc ->
     SourceMap (loc, list)

(** [hasComment layout] checks if a layout has comment attached to it *)
let rec hasComment = function
  | WithEOLComment (_, _) -> true
  | SourceMap (_, sub) -> hasComment sub
  | _ -> false

let rec append ?(space=false) txt = function
  | SourceMap (loc, sub) -> SourceMap (loc, append ~space txt sub)
  | Sequence (config, l) when snd config.wrap <> "" ->
     let sep = if space then " " else "" in
     Sequence ({config with wrap=(fst config.wrap, snd config.wrap ^ sep ^ txt)}, l)
  | Sequence (config, l) when List.length l = 0 ->
     Sequence (config, [atom txt])
  | Sequence (config, l) when config.sep = "" ->
     let sub = List.mapi (fun i layout ->
                   (* append to the end of the list *)
                   if i + 1 = List.length l then
                     append ~space txt layout
                   else
                     layout
                 ) l in
     Sequence (config, sub)
  | Label (formatter, left, right) ->
     Label (formatter, left, append ~space txt right)
  | layout ->
     inline ~postSpace:space layout (atom txt)

let appendSep spaceBeforeSep sep layout =
  let sep = if spaceBeforeSep then
              " " ^ sep
            else
              sep in
  append sep layout

let rec flattenCommentAndSep ?spaceBeforeSep:(spaceBeforeSep=false) ?sep = function
  | WithEOLComment (txt, sub) ->
     begin
       match sep with
       | None -> append ~space:true (wrapComment txt) sub
       | Some sep -> append ~space:true (wrapComment txt)
                                   (appendSep spaceBeforeSep sep sub)
     end
  | Sequence (listConfig, [hd]) when hasComment hd ->
    Sequence (listConfig, [flattenCommentAndSep ~spaceBeforeSep ?sep hd])
  | SourceMap (loc, sub) ->
     SourceMap (loc, flattenCommentAndSep ~spaceBeforeSep ?sep sub)
  | layout ->
     begin
       match sep with
       | None -> layout
       | Some sep -> appendSep spaceBeforeSep sep layout
     end

let rec preOrderWalk f layout =
  match f layout with
  | Sequence (listConfig, sublayouts) ->
     let newSublayouts = List.map (preOrderWalk f) sublayouts in
     (Sequence (listConfig, newSublayouts))
  | Label (formatter, left, right) ->
     let newLeftLayout = preOrderWalk f left in
     let newRightLayout = preOrderWalk f right in
     Label (formatter, newLeftLayout, newRightLayout)
  | SourceMap (loc, sub) ->
     let newSub = preOrderWalk f sub in
     SourceMap (loc, newSub)
  | WithEOLComment (c, sub) ->
     let newSub = preOrderWalk f sub in
     WithEOLComment (c, newSub)
  | _ -> layout

(** Recursively unbreaks a layout to make sure they stay within the same line *)
let unbreaklayout = preOrderWalk (function
  | Sequence (listConfig, sublayouts) ->
    Sequence ({listConfig with break=Never}, sublayouts)
  | Label (formatter, left, right) ->
    Label (unbreakLabelFormatter formatter, left, right)
  | layout -> layout
)

(** [consolidateSeparator layout] walks the [layout], extract separators out of each
 *  list and insert them into PrintTree as separated items
 *)
let consolidateSeparator = preOrderWalk (function
  | Sequence (listConfig, sublayouts)
       when listConfig.sep <> ""
         && listConfig.sepLeft
    ->
     let layoutsWithSepAndComment =
       List.mapi (fun i layout ->
           (* Do not render the final separator *)
           if not listConfig.renderFinalSep && i + 1 = List.length sublayouts then
             flattenCommentAndSep ~spaceBeforeSep:listConfig.preSpace layout
           else
             flattenCommentAndSep ~spaceBeforeSep:listConfig.preSpace ~sep:listConfig.sep layout) sublayouts in
     let break = if List.exists hasComment sublayouts then
                   Always_rec
                 else
                   listConfig.break in
     let sep = "" in
     let preSpace = false in
     Sequence ({listConfig with sep; break; preSpace}, layoutsWithSepAndComment)
  | WithEOLComment _ as layout ->
     makeList ~inline:(true, true) ~postSpace:false ~preSpace:true ~indent:0
              ~break:Always_rec [flattenCommentAndSep layout]
  | layout -> layout
)

(** [insertLinesAboveItems layout] walkts the [layout] and insert empty lines
 *  based on the configuration of newlinesAboveItems
 *)
let insertLinesAboveItems = preOrderWalk (function
  | Sequence (listConfig, sublayouts)
       when listConfig.newlinesAboveItems <> 0
    ->
     let layoutsWithLinesInjected =
       List.map (insertBlankLines listConfig.newlinesAboveItems) sublayouts in
     Sequence ({listConfig with newlinesAboveItems=0}, layoutsWithLinesInjected)
  | layout -> layout
)

(** Union of two locations *)
let unionLoc loc1 loc2 =
  match (loc1, loc2) with
  | None, _ -> loc2
  | _, None -> loc1
  | Some loc1, Some loc2  -> Some {loc1 with loc_end = loc2.loc_end}

(** [getLocFromLayout] recursively takes the unioned location of its children,
 *  and returns the max one
 *)
let rec getLocFromLayout = function
  | Sequence (listConfig, subLayouts) ->
     let locs = List.map getLocFromLayout subLayouts in
     List.fold_left unionLoc None locs
  | Label (formatter, left, right) ->
     let leftLoc = getLocFromLayout left in
     let rightLoc = getLocFromLayout right in
     unionLoc leftLoc rightLoc
  | SourceMap (loc, _) ->
     Some loc
  | WithEOLComment (_, sub) ->
     getLocFromLayout sub
  | _ -> None

(**
 * Returns true if loc1 contains loc2
 *)
let containLoc loc1 loc2 =
  loc1.loc_start.Lexing.pos_cnum <= loc2.loc_start.Lexing.pos_cnum &&
  loc1.loc_end.Lexing.pos_cnum >= loc2.loc_end.Lexing.pos_cnum

(**
 * Returns true if loc1 is before loc2
 *)
let beforeLoc loc1 loc2 =
  loc1.loc_end.Lexing.pos_cnum <= loc2.loc_start.Lexing.pos_cnum

let attachEOLComment layout txt =
  WithEOLComment (txt, layout)


(**
 * Returns true if the layout's location contains loc
 *)
let layoutContainsLoc loc layout =
  match getLocFromLayout layout with
  | None -> false
  | Some subLoc -> containLoc subLoc loc


(**
 * Returns true if any of the subLayout's location contains loc
 *)
let anySublayoutContainLocation loc =
  List.exists (layoutContainsLoc loc)

let isDocComment (c, _, _) = String.length c > 0 && c.[0] == '*'

(**
 * prependSingleLineComment inserts a single line comment right above layout
 *)
let rec prependSingleLineComment ?newlinesAboveDocComments:(newlinesAboveDocComments=0) comment layout =
  let (txt, _, loc) = comment in
  match layout with
  | WithEOLComment (c, sub) ->
     WithEOLComment (c, prependSingleLineComment ~newlinesAboveDocComments comment sub)
  | SourceMap (loc, sub) ->
     SourceMap (loc, prependSingleLineComment ~newlinesAboveDocComments comment sub)
  | Sequence (config, hd::tl) when config.break = Always_rec->
     Sequence(config, (prependSingleLineComment ~newlinesAboveDocComments comment hd)::tl)
  | layout ->
     let withComment = breakline (formatComment ~locOpt:loc txt) layout in
     if isDocComment comment then
       insertBlankLines newlinesAboveDocComments withComment
     else
       withComment

(**
 * [looselyAttachComment layout comment] preorderly walks the layout and
 * find a place where the comment can be loosely attached to
 *)
let rec looselyAttachComment layout ((txt, _, commentLoc) as comment) =
  match layout with
  | SourceMap (loc, sub) ->
     SourceMap (loc, looselyAttachComment sub comment)
  | WithEOLComment (c, sub) ->
     WithEOLComment (c, looselyAttachComment sub comment)
  | Easy e ->
     inline ~postSpace:true layout (formatComment txt)
  | Sequence (listConfig, subLayouts) when anySublayoutContainLocation commentLoc subLayouts ->
     (* If any of the subLayout strictly contains this comment, recurse into to it *)
     let subLayouts = List.map (fun layout ->
                          if layoutContainsLoc commentLoc layout then
                            looselyAttachComment layout comment
                          else
                            layout
                        ) subLayouts in
     Sequence (listConfig, subLayouts)
  | Sequence (listConfig, subLayouts) when subLayouts == [] ->
    (* If there are no subLayouts (empty body), create a Sequence of just the comment *)
    Sequence (listConfig, [formatComment txt])
  | Sequence (listConfig, subLayouts) ->
     let (beforeComment, afterComment) = Syntax_util.pick_while (fun layout ->
                                             match getLocFromLayout layout with
                                             | None -> true
                                             | Some loc -> beforeLoc loc commentLoc
                                           ) subLayouts in
     let newSubLayout = match List.rev beforeComment with
       | [] ->
          prependSingleLineComment comment (List.hd afterComment) :: (List.tl afterComment)
       | hd::tl -> (attachEOLComment hd txt :: tl |> List.rev) @ afterComment
     in
     Sequence (listConfig, newSubLayout)
  | Label (formatter, left, right) ->
     let leftLoc = getLocFromLayout left in
     let rightLoc = getLocFromLayout right in
     let newLeft, newRight = match (leftLoc, rightLoc) with
       | (None, None) ->
          (left, looselyAttachComment right comment)
       | (_, Some loc2) when containLoc loc2 commentLoc ->
          (left, looselyAttachComment right comment)
       | (Some loc1, _) when containLoc loc1 commentLoc ->
          (looselyAttachComment left comment, right)
       | (Some loc1, Some loc2) when beforeLoc commentLoc loc1 ->
          (prependSingleLineComment comment left, right)
       | (Some loc1, Some loc2) when beforeLoc commentLoc loc2 ->
          (left, prependSingleLineComment comment right)
       | _ -> (left, attachEOLComment right txt)
     in
     Label (formatter, newLeft, newRight)

(**
 * [insertSingleLineComment layout comment] preorderly walks the layout and
 * find a place where the SingleLineComment can be fit into
 *)
let rec insertSingleLineComment layout comment =
  let (txt, _, commentLoc) = comment in
      match layout with
      | SourceMap (loc, sub) ->
         SourceMap (loc, insertSingleLineComment sub comment)
      | WithEOLComment (c, sub) ->
         WithEOLComment (c, insertSingleLineComment sub comment)
      | Easy e ->
         prependSingleLineComment comment layout
      | Sequence (listConfig, subLayouts) when subLayouts == [] ->
        (* If there are no subLayouts (empty body), create a Sequence of just the comment *)
        Sequence (listConfig, [formatComment txt])
      | Sequence (listConfig, subLayouts) ->
         let newlinesAboveDocComments = listConfig.newlinesAboveDocComments in
         let (beforeComment, afterComment) = Syntax_util.pick_while (fun layout ->
                                                 match getLocFromLayout layout with
                                                 | None -> true
                                                 | Some loc -> beforeLoc loc commentLoc
                                               ) subLayouts in
         begin
           match afterComment with
           | (* Nothing in the list is after comment, attach comment to the statement before the comment *)
           [] -> let revBeforeComment = List.rev beforeComment in
                 let lastItemBeforeComment = List.hd revBeforeComment in
                 Sequence (listConfig,  (List.rev
                                           (breakline lastItemBeforeComment (formatComment ~locOpt:commentLoc txt) :: (List.tl revBeforeComment))))
           | hd::tl ->
              let afterComment =
                match getLocFromLayout hd with
                | Some loc when containLoc loc commentLoc ->
                   insertSingleLineComment hd comment :: tl
                | Some loc ->
                   SourceMap (loc, (prependSingleLineComment ~newlinesAboveDocComments comment hd)) :: tl
                | _ ->
                   prependSingleLineComment ~newlinesAboveDocComments comment hd :: tl
              in
              Sequence (listConfig, beforeComment @ afterComment)
         end
      | Label (formatter, left, right) ->
         let leftLoc = getLocFromLayout left in
         let rightLoc = getLocFromLayout right in
         let newLeft, newRight = match (leftLoc, rightLoc) with
           | (None, None) ->
              (left, insertSingleLineComment right comment)
           | (_, Some loc2) when containLoc loc2 commentLoc ->
              (left, insertSingleLineComment right comment)
           | (Some loc1, _) when containLoc loc1 commentLoc ->
              (insertSingleLineComment left comment, right)
           | (Some loc1, Some loc2) when beforeLoc commentLoc loc1 ->
              (prependSingleLineComment comment left, right)
           | (Some loc1, Some loc2) when beforeLoc commentLoc loc2 ->
              (left, prependSingleLineComment comment right)
           | _ -> (left, breakline right (formatComment ~locOpt:commentLoc txt))
         in
         Label (formatter, newLeft, newRight)

let rec attachCommentToNodeRight layout ((txt, t, loc) as comment) =
  match layout with
  | Sequence (config, sub) when snd config.wrap <> "" ->
     Sequence ({config with wrap=(fst config.wrap, snd config.wrap ^ " " ^ (wrapComment txt))}, sub)
  | SourceMap (loc, sub) ->
     SourceMap (loc, attachCommentToNodeRight sub comment)
  | layout ->
     begin
       match t with
       | EndOfLine ->
          WithEOLComment (txt, layout)
       | _ ->
          inline ~postSpace:true layout (formatComment txt)
     end

let rec attachCommentToNodeLeft ((txt, _, loc) as comment) layout =
  match layout with
  | Sequence (config, sub) when snd config.wrap <> "" ->
     Sequence ({config with wrap=(wrapComment txt ^ " " ^ (fst config.wrap), snd config.wrap)}, sub)
  | SourceMap (loc, sub) ->
     SourceMap (loc, attachCommentToNodeLeft comment sub )
  | layout ->
     Label (inlineLabel, (formatComment txt), layout)

let isNone opt =
  match opt with
  | None -> true | _ -> false


(** [tryPerfectlyAttachComment layout comment] postorderly walk the [layout] and tries
 *  to perfectly attach a comment with a layout node.
 *
 *  Perfectly attach here means a comment's start location is equal to the node's end location
 *  and vice versa.
 *
 *  If the comment can be perfectly attached to any layout node, returns (newLayout, None),
 *  meaning the comment is consumed. Otherwise returns the (unchangedLayout, Some comment),
 *  meaning the comment is not consumed.
 *)
let rec tryPerfectlyAttachComment layout comment =
  match comment with
  | None -> layout, comment
  | Some ((s, t, commLoc) as c)  -> begin
     match layout with
     | Sequence (listConfig, subLayouts) ->
        let distributeCommentIntoSubLayouts (i, processed, newComment) layout =
          let (layout, newComment) = tryPerfectlyAttachComment layout newComment in
          i + 1, layout::processed, newComment
        in
        let (_, processed, consumed) = List.fold_left distributeCommentIntoSubLayouts
                                                      (0, [], comment) (List.rev subLayouts) in
        Sequence (listConfig, processed), consumed
     | Label (labelFormatter, left, right) ->
        let (newRight, comment) = tryPerfectlyAttachComment right comment in
        let (newLeft, comment) = tryPerfectlyAttachComment left comment in
        Label (labelFormatter, newLeft, newRight), comment
     | SourceMap (loc, subLayout) ->
        if loc.loc_end.Lexing.pos_lnum = loc.loc_start.Lexing.pos_lnum &&
             commLoc.loc_start.Lexing.pos_cnum = loc.loc_end.Lexing.pos_cnum then
          SourceMap (loc, makeList ~inline:(true, true) ~break:Always
                                   [unbreaklayout (attachCommentToNodeRight subLayout c)]), None
        else
          let (layout, comment) = tryPerfectlyAttachComment subLayout comment in
          begin
            match comment with
            | None -> (SourceMap (loc, layout), None)
            | Some ((s, t, commLoc) as comment)->
               if commLoc.loc_end.Lexing.pos_cnum = loc.loc_start.Lexing.pos_cnum  then
                 SourceMap (loc, attachCommentToNodeLeft comment layout), None
               else if commLoc.loc_start.Lexing.pos_cnum = loc.loc_end.Lexing.pos_cnum then
                 SourceMap (loc, attachCommentToNodeRight layout comment), None
               else
                 SourceMap (loc, layout), Some comment
          end
     | WithEOLComment (c, sub) ->
        let (processed, consumed) = tryPerfectlyAttachComment sub comment in
        WithEOLComment (c, processed), consumed
     | _ -> layout, comment
     end

(** [insertComment layout comment] inserts comment into layout*)
let insertComment layout comment =
  (* print_layout layout; *)
  let (txt, t, loc) = comment in
  let layout = match t with
  | Regular
  | EndOfLine ->
     let (layout, c) = tryPerfectlyAttachComment layout (Some comment) in
     begin
     match c with
     | None -> layout
     | Some _ -> looselyAttachComment layout comment
     end
  | SingleLine -> insertSingleLineComment layout comment
  in
  (* print_comments [comment]; *)
  (* print_layout layout; *)
  layout

(** [insertComments layout comments] inserts comments into layout*)
let insertComments = List.fold_left insertComment

(** [isSingleLineComment comment] checks if a comment is singleline comment*)
let isSingleLineComment (_, t, _) =
  match t with
  | SingleLine -> true | _ -> false

let rec layoutToEasyFormat_ = function
  | Sequence (listConfig, subLayouts) ->
     easyListWithConfig listConfig (List.map layoutToEasyFormat_ subLayouts)
  | Label (labelFormatter, left, right) ->
     labelFormatter (layoutToEasyFormat_ left) (layoutToEasyFormat_ right)
  | SourceMap (_, subLayout) ->
     layoutToEasyFormat_ subLayout
  | WithEOLComment (_, sub) ->
     layoutToEasyFormat_ sub
  | Easy e -> e

let layoutToEasyFormatNoComments layoutNode =
  layoutToEasyFormat_ layoutNode


let layoutToEasyFormat layoutNode comments =
  (* print_layout layoutNode; *)
  let layout = layoutNode in
  let revComments = List.rev comments in
  let (singleLineComments, nonSingleLineComments) = (List.partition isSingleLineComment revComments) in
  let layout = insertComments layout nonSingleLineComments in
  let layout = consolidateSeparator layout in
  let layout = insertComments layout singleLineComments in
  let layout = insertLinesAboveItems layout in
  let easyFormat= layoutToEasyFormat_ layout in
  (* print_easy_rec easyFormat; *)
  makeEasyList ~break:Always_rec ~indent:0 ~inline:(true, true) [easyFormat]

let partitionFinalWrapping listTester wrapFinalItemSetting x =
  let rev = List.rev x in
  match (rev, wrapFinalItemSetting) with
    | ([], _) -> raise (NotPossible "shouldnt be partitioning 0 label attachments")
    | (_, NeverWrapFinalItem) -> None
    | (last::revEverythingButLast, WrapFinalListyItemIfFewerThan max) ->
        if not (listTester last) || (List.length x) >= max then
          None
        else
          Some (List.rev revEverythingButLast, last)

let semiTerminated term = makeList ~interleaveComments:false [term; atom ";"]


(* postSpace is so that when comments are interleaved, we still use spacing rules. *)
let makeLetSequence letItems =
  makeList
    ~break:Always_rec
    ~inline:(true, false)
    ~wrap:("{", "}")
    ~newlinesAboveComments:0
    ~newlinesAboveItems:0
    ~newlinesAboveDocComments:1
    ~renderFinalSep:false
    ~postSpace:true
    ~sep:";"
    letItems

let makeLetSequenceSingleLine letItems =
  makeList
    ~break:IfNeed
    ~inline:(true, false)
    ~wrap:("{", "}")
    ~newlinesAboveComments:0
    ~newlinesAboveItems:0
    ~newlinesAboveDocComments:1
    ~renderFinalSep:false
    ~preSpace:true
    ~postSpace:true
    ~sep:";"
    letItems

(* postSpace is so that when comments are interleaved, we still use spacing rules. *)
let makeUngaurdedLetSequence letItems =
  makeList
    ~break:Always_rec
    ~inline:(true, true)
    ~wrap:("", "")
    ~newlinesAboveComments:0
    ~indent:0
    ~newlinesAboveItems:0
    ~newlinesAboveDocComments:1
    ~renderFinalSep:false
    ~postSpace:true
    ~sep:";"
    letItems

let formatSimpleAttributed x y =
  makeList
    ~wrap:("(", ")")
    ~break:IfNeed
    ~indent:0
    ~postSpace:true
    [x; y;]

let formatAttributed x y =
  makeList
    ~break:IfNeed
    ~inline:(true, true)
    ~indent:0
    ~postSpace:true
    [x; y]

(* For when the type constraint should be treated as a separate breakable line item itself
   not docked to some value/pattern label.
   fun x
       y
       : retType => blah;
 *)
let formatJustTheTypeConstraint =
  if useSingleColonForNamedArgs then
    (fun typ ->
       (makeList ~postSpace:true [atom ":"; typ]))
  else
    (fun typ ->
       (makeList ~postSpace:false [atom ":"; typ]))

let formatTypeConstraint =
  if useSingleColonForNamedArgs then
    (fun one two ->
      label ~space:true (makeList ~postSpace:true [one; atom ":"]) two)
  else
    (fun one two ->
      label ~space:true (makeList ~postSpace:false [one; atom ":"]) two)

let formatLabeledArgument =
  if useSingleColonForNamedArgs then
    (fun lbl lblSuffix term ->
      label ~space:false (makeList [lbl; atom (":" ^ lblSuffix)]) term)
  else
    (fun lbl lblSuffix term ->
      label ~space:false (makeList [lbl; atom ("::" ^ lblSuffix)]) term)

let formatCoerce expr optType coerced =
  match optType with
    | None ->
      label ~space:true (makeList ~postSpace:true [expr; atom ":>"]) coerced
    | Some typ ->
      label ~space:true (makeList ~postSpace:true [formatTypeConstraint expr typ; atom ":>"]) coerced


(* Standard function application style indentation - no special wrapping
 * behavior.
 *
 * Formats like this:
 *
 *   let result =
 *     someFunc
 *       (10, 20);
 *
 *
 * Instead of this:
 *
 *   let result =
 *     someFunc (
 *       10,
 *       20
 *     );
 *
 * The outer list wrapping fixes #566: format should break the whole
 * application before breaking arguments.
 *)
let formatIndentedApplication headApplicationItem argApplicationItems =
  makeList ~inline:(true, true) ~postSpace:true ~break:IfNeed [
    label
      ~space:true
      headApplicationItem
      (makeAppList argApplicationItems)
  ]


(* The loc, is an optional location or the returned app terms *)
let formatAttachmentApplication finalWrapping (attachTo: (bool * layoutNode) option) (appTermItems, loc) =
  let partitioning = finalWrapping appTermItems in
  let maybeSourceMap maybeLoc x =
    match maybeLoc with
      | None -> x
      | Some loc -> SourceMap (loc, x)
  in
  match partitioning with
    | None -> (
        match (appTermItems, attachTo) with
          | ([], _) -> raise (NotPossible "No app terms")
          | ([hd], None) -> maybeSourceMap loc hd
          | ([hd], (Some (useSpace, toThis))) -> label ~space:useSpace toThis (maybeSourceMap loc hd)
          | (hd::tl, None) ->
            maybeSourceMap loc (formatIndentedApplication hd tl)
          | (hd::tl, (Some (useSpace, toThis))) ->
            label
              ~space:useSpace
              toThis
              (maybeSourceMap loc (formatIndentedApplication hd tl))
      )
    | Some (attachedList, wrappedListy) -> (
        match (attachedList, attachTo) with
          | ([], Some (useSpace, toThis)) -> label ~space:useSpace toThis (maybeSourceMap loc wrappedListy)
          | ([], None) ->
            (* Not Sure when this would happen *)
            maybeSourceMap loc wrappedListy
          | (hd::tl, Some (useSpace, toThis)) ->
            (* TODO: Can't attach location to this - maybe rewrite anyways *)
            let attachedArgs = makeAppList attachedList in
              (label ~space:useSpace toThis (label
              ~space:true attachedArgs wrappedListy))

          | (hd::tl, None) ->
            (* Args that are "attached to nothing" *)
            let appList = makeAppList attachedList in
            maybeSourceMap loc (label ~space:true appList wrappedListy)
      )

(*
  Preprocesses an expression term for the sake of label attachments ([letx =
  expr]or record [field: expr]). Function application should have special
  treatment when placed next to a label. (The invoked function term should
  "stick" to the label in some cases). In others, the invoked function term
  should become a new label for the remaining items to be indented under.
 *)
let applicationFinalWrapping x =
  partitionFinalWrapping isSequencey settings.funcApplicationLabelStyle x

let curriedFunctionFinalWrapping x =
  partitionFinalWrapping isSequencey settings.funcCurriedPatternStyle x

let typeApplicationFinalWrapping typeApplicationItems =
  partitionFinalWrapping isSequencey settings.funcApplicationLabelStyle typeApplicationItems


(* add parentheses to binders when they are in fact infix or prefix operators *)
let protectIdentifier txt =
  if not (needs_parens txt) then atom txt
  else if needs_spaces txt then makeList ~interleaveComments:false ~wrap:("(", ")") ~pad:(true, true) [atom txt]
  else atom ("(" ^ txt ^ ")")

let protectLongIdentifier longPrefix txt =
  makeList ~interleaveComments:false [longPrefix; atom "."; protectIdentifier txt]

let pun_labelled_expression e lbl =
  (match e with
    | { pexp_desc = (Pexp_ident { txt; _ }); _ } when txt = (Longident.parse lbl) -> ""
    | _ -> lbl )

let pun_labelled_pattern e lbl =
  (match e with
    | { ppat_desc = (Ppat_var { txt; _ }) } when txt = lbl -> ""
    | _ -> lbl )

let isLongIdentWithDot = function
  | Ldot _ -> true
  | _ -> false

let recordRowIsPunned pld =
      let name = pld.pld_name.txt in
      (match pld.pld_type with
        | { ptyp_desc = (Ptyp_constr ({ txt; _ }, args)); _}
            when
            (Longident.last txt = name
              (* Don't pun types from other modules, e.g. type bar = {foo: Baz.foo}; *)
              && isLongIdentWithDot txt == false
              (* don't pun parameterized types, e.g. {tag: tag 'props} *)
              && List.length args == 0) -> true
        | _ -> false)

class printer  ()= object(self:'self)
  val pipe = false
  val semi = false
  (* The test and first branch of ternaries must be guarded *)
  method under_pipe = {<pipe=true>}
  method under_semi = {<semi=true>}
  method reset_semi = {<semi=false>}
  method reset_pipe = {<pipe=false>}
  method reset = {<pipe=false;semi=false>}
  method list : 'a . ?sep:space_formatter -> ?first:space_formatter ->
    ?last:space_formatter -> (Format.formatter -> 'a -> unit) ->
    Format.formatter -> 'a list -> unit
    = default#list
  method option : 'a. ?first:space_formatter -> ?last:space_formatter ->
    (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a option -> unit =
    default#option

  method longident = function
    | Lident s -> (protectIdentifier s)
    | Ldot(longPrefix, s) ->
        (protectLongIdentifier (self#longident longPrefix) s)
    | Lapply (y,s) -> makeList ~interleaveComments:false [self#longident y; atom "("; self#longident s; atom ")";]

  (* This form allows applicative functors. *)
  method longident_class_or_type_loc x = self#longident x.txt
  (* TODO: Fail if observing applicative functors for this form. *)
  method longident_loc (x:Longident.t Location.loc) = SourceMap (x.loc, self#longident (x.txt))
  method constant = wrap default#constant

  method constant_string = wrap default#constant_string
  method tyvar = wrap default#tyvar

  (* c ['a,'b] *)
  method class_params_def = function
    | [] -> atom ""
    | l ->
      makeList ~postSpace:true (List.map self#type_param l)

  (* This will fall through to the simple version. *)
  method non_arrowed_core_type x = self#non_arrowed_non_simple_core_type x

  method core_type2 x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.ptyp_attributes in
    if stdAttrs <> [] then
      formatAttributed
        (self#non_arrowed_simple_core_type {x with ptyp_attributes=[]})
        (self#attributes stdAttrs)
    else
      let rec allArrowSegments xx = match xx.ptyp_desc with
        | Ptyp_arrow (l, ct1, ct2) ->
            (self#type_with_label (l,ct1))::(allArrowSegments ct2)
        | _ -> [self#core_type2 xx]
      in
      match (x.ptyp_desc) with
        | (Ptyp_arrow (l, ct1, ct2)) ->
            let normalized =
              makeList ~break:IfNeed ~sep:"=>" ~preSpace:true ~postSpace:true ~inline:(true, true) (allArrowSegments x)
            in
            SourceMap (x.ptyp_loc, normalized)
        | Ptyp_poly (sl, ct) ->
            let poly =
              makeList ~break:IfNeed [
                makeList ~postSpace:true [
                  makeList ~postSpace:true (List.map (fun x -> self#tyvar x) sl);
                  atom ".";
                ];
                self#core_type ct;
              ]
            in SourceMap (x.ptyp_loc, poly)
        | _ -> self#non_arrowed_core_type x

  (* Same as core_type2 but can be aliased *)
  method core_type x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrss) = partitionAttributes x.ptyp_attributes in
    if stdAttrs <> [] then
      formatAttributed
        (self#non_arrowed_simple_core_type {x with ptyp_attributes=[]})
        (self#attributes stdAttrs)
    else match (x.ptyp_desc) with
      | (Ptyp_alias (ct, s)) ->
        SourceMap (
          x.ptyp_loc,
          (label
            ~space:true
            (self#core_type ct)
            (makeList ~postSpace:true [atom "as"; atom ("'" ^ s)])
          )
        )
      | _ -> self#core_type2 x

  method type_with_label (label, ({ptyp_desc} as c)) =
    match label with
      | "" ->  self#non_arrowed_non_simple_core_type c (* otherwise parenthesize *)
      | s  ->
          if s.[0]='?' then
            let len = String.length s - 1 in
            let lbl = String.sub s 1 len in
            match ptyp_desc with
              | Ptyp_constr ({txt}, l) ->
                  assert (is_predef_option txt);
                  let everythingButQuestion =
                    formatLabeledArgument
                      (atom lbl)
                      ""
                      (makeList
                         ~postSpace:true
                         ~break:IfNeed
                         ~inline:(true, true)
                         (* Why not support aliasing here? *)
                         (* I don't think you'll have more than one l here. *)
                         (List.map (self#non_arrowed_non_simple_core_type) l)
                      ) in
                    makeList [everythingButQuestion; atom "?"]
              | _ -> failwith "invalid input in print_type_with_label"
          else formatLabeledArgument (atom s) "" (self#non_arrowed_non_simple_core_type c)

  method type_param (ct, a) =
    makeList [atom (type_variance a); self#core_type ct]

  (* According to the parse rule [type_declaration], the "type declaration"'s
   * physical location (as indicated by [td.ptype_loc]) begins with the
   * identifier and includes the constraints. *)
  method formatOneTypeDef prepend name assignToken ({ptype_params; ptype_kind; ptype_manifest; ptype_loc} as td) =
    let (equalInitiatedSegments, constraints) = (self#type_declaration_binding_segments td) in
    let formattedTypeParams = List.map self#type_param ptype_params in
    let binding = makeList ~postSpace:true (prepend::name::[]) in
    (*
        /-----------everythingButConstraints--------------  | -constraints--\
       /-innerL---| ------innerR--------------------------\
      /binding\     /typeparams\ /--equalInitiatedSegments-\
      type name      'v1    'v1  =  foo = private bar        constraint a = b
    *)

    let labelWithParams = match formattedTypeParams with
        [] -> binding
      | phd::ptl -> label ~space:true binding (makeList ~postSpace:true ~break:IfNeed ~inline:(true, true) (phd::ptl)) in
    let everythingButConstraints =
      let nameParamsEquals = makeList ~postSpace:true [labelWithParams; assignToken] in
      match equalInitiatedSegments with
        | [] -> labelWithParams
        | hd::hd2::hd3::tl -> raise (NotPossible "More than two type segments.")
        | hd::[] ->
            formatAttachmentApplication
              typeApplicationFinalWrapping
              (Some (true, nameParamsEquals))
              (hd, None)
        | hd::hd2::[] ->
            let first = makeList ~postSpace:true ~break:IfNeed ~inline:(true, true) hd in
            let second = makeList ~postSpace:true ~break:IfNeed ~inline:(true, true) hd2 in
            label ~space:true nameParamsEquals (
              label ~space:true
                (makeList ~postSpace:true [first; atom "="])
                (second)
            )
    in
    let everything =
      match constraints with
        | [] -> everythingButConstraints
        | hd::tl -> makeList ~break:IfNeed ~postSpace:true ~indent:0 ~inline:(true, true) (everythingButConstraints::hd::tl)
    in
    (SourceMap (ptype_loc, everything))

  method formatOneTypeExt prepend name assignToken te =
    let equalInitiatedSegments =
      let segments = List.map self#type_extension_binding_segments te.ptyext_constructors in
      [makeList ~break:Always_rec ~postSpace:true ~inline:(true, true) segments] in
    let formattedTypeParams = List.map self#type_param te.ptyext_params in
    let binding = makeList ~postSpace:true (prepend::name::[]) in
    let labelWithParams = match formattedTypeParams with
        [] -> binding
      | phd::ptl -> label ~space:true binding (makeList ~postSpace:true ~break:IfNeed ~inline:(true, true) (phd::ptl)) in
    let everything =
      let nameParamsEquals = makeList ~postSpace:true [labelWithParams; assignToken] in
      formatAttachmentApplication
             typeApplicationFinalWrapping
             (Some (true, nameParamsEquals))
             (equalInitiatedSegments, None)
    in
    SourceMap (te.ptyext_path.loc, everything)

  method type_extension_binding_segments {pext_kind; pext_loc; pext_attributes; pext_name} =
    let normalize lst = match lst with
        | [] -> raise (NotPossible "should not be called")
        | [hd] -> hd
        | _::_ -> makeList ~break:Never ~postSpace:true lst
      in
      let add_bar name args =
        let lbl = label ~space:true name args in
        makeList ~postSpace:true [atom "|"; lbl]
      in
    let sourceMappedName = SourceMap (pext_name.loc, atom pext_name.txt) in
    let nameOf = makeList ~postSpace:true [sourceMappedName] in
    let barName = makeList ~postSpace:true [atom "|"; sourceMappedName] in
    let resolved = match pext_kind with
      | Pext_decl (ctor_args, gadt) ->
        let formattedArgs = (List.map self#non_arrowed_simple_core_type ctor_args) in
        let formattedGadt = match gadt with
        | None -> None
        | Some x -> Some (
            makeList [
              formatJustTheTypeConstraint (self#core_type x)
            ]
          )
        in
        (formattedArgs, formattedGadt)
      (* type bar += Foo = Attr.Foo *)
      | Pext_rebind rebind ->
        let r = self#longident_loc rebind in
        let prepend = (atom "=") in
        ([makeList ~postSpace:true [prepend; r]], None)
    in
      (**
        The first element of the tuple represents constructor arguments,
        the second an optional formatted gadt.

        Case 1: No constructor arguments, neither a gadt
          type attr = ..;
          type attr += | Str

        Case 2: No constructor arguments, is a gadt
          type attr = ..;
          type attr += | Str :attr

        Case 3: Has Constructor args, not a gadt
          type attr  = ..;
          type attr += | Str string;
          type attr += | Point int int;

        Case 4: Has Constructor args & is a gadt
          type attr  = ..;
          type attr += | Point int int :attr;
      *)
    let everything = match resolved with
      | ([], None) -> barName
      | ([], Some gadt) -> add_bar sourceMappedName gadt
      | (ctorArgs, None) -> add_bar nameOf (normalize ctorArgs)
      | (ctorArgs, Some gadt) -> add_bar nameOf (normalize (ctorArgs@[gadt]))
    in
    (SourceMap (pext_loc, self#attach_std_attrs pext_attributes everything))

  (* shared by [Pstr_type,Psig_type]*)
  method type_def_list l =
    (* As oposed to used in type substitution. *)
    let formatOneTypeDefStandard prepend td =
      let itm =
        self#formatOneTypeDef
          prepend
          (SourceMap (td.ptype_name.loc, (atom td.ptype_name.txt)))
          (atom "=")
          td
      in
      self#attach_std_item_attrs td.ptype_attributes itm
    in

    match l with
      | [] -> raise (NotPossible "asking for type list of nothing")
      | hd::tl ->
          let first =
            match partitionNonrecAttr hd.ptype_attributes with
            | ([], _) -> formatOneTypeDefStandard (atom "type") hd
            | (_, attrs) ->
                let newHd = { hd with ptype_attributes = attrs } in
                formatOneTypeDefStandard (atom "type nonrec") newHd
          in
          match tl with
            (* Exactly one type *)
            | [] -> first
            | tlhd::tltl -> makeList ~indent:0 ~inline:(true, true) ~break:Always_rec (
                first::(List.map (formatOneTypeDefStandard (atom "and")) (tlhd::tltl))
              )

  method type_variant_leaf ?opt_ampersand:(a=false) ?polymorphic:(p=false) = self#type_variant_leaf1 a p true
  method type_variant_leaf_nobar ?opt_ampersand:(a=false) ?polymorphic:(p=false) = self#type_variant_leaf1 a p false

  (* TODOATTRIBUTES: Attributes on the entire variant leaf are likely
   * not parsed or printed correctly. *)
  method type_variant_leaf1 opt_ampersand polymorphic print_bar x =
    let {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} = x in
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes pcd_attributes in
    let prefix = if polymorphic then "`" else "" in
    let sourceMappedName = SourceMap (pcd_name.loc, atom (prefix ^ pcd_name.txt)) in
    let nameOf = makeList ~postSpace:true [sourceMappedName] in
    let barName =
      let lst = if print_bar then [atom "|"; sourceMappedName] else [sourceMappedName] in
      makeList ~postSpace:true lst in
    let ampersand_helper i arg =
      let ct = self#non_arrowed_simple_core_type arg in
      let add_ampersand = label (atom "&") in
      if polymorphic then
        if i == 0 && not opt_ampersand then
          ct
        else
          add_ampersand ct
      else
        ct
    in
    let args = List.mapi ampersand_helper pcd_args in
    let gadtRes = match pcd_res with
      | None -> None
      | Some x -> Some (
          makeList ~inline:(true, true) ~break:IfNeed [ (* Single row just so the entire return type breaks onto its own line *)
            formatJustTheTypeConstraint (self#core_type x)
          ]
      ) in
      let normalize lst = match lst with
        | [] -> raise (NotPossible "should not be called")
        | [hd] -> hd
        | _::_ -> makeList ~inline:(true, true) ~break:IfNeed ~postSpace:true lst
      in
      let add_bar name args =
        let lbl = label ~space:true name args in
        makeList ~postSpace:true (if print_bar then [atom "|"; lbl] else [lbl])
      in
      let everything = match (args, gadtRes) with
        | ([], None) -> barName
        | ([], Some res) -> add_bar sourceMappedName res
        | (_::_, None) -> add_bar nameOf (normalize args)
        | (_::_, Some res) -> add_bar nameOf (normalize (args@[res]))
      in
      let everythingWithAttrs =
        if stdAttrs <> [] then
          formatAttributed everything (self#attributes stdAttrs)
        else
          everything
      in
      (SourceMap (pcd_loc, everythingWithAttrs))

  (* Returns the type declaration partitioned into three segments - one
     suitable for appending to a label, the actual type manifest
     and the list of constraints. *)
  method type_declaration_binding_segments x =
    (* Segments of the type binding (occuring after the type keyword) that
       should begin with "=". Zero to two total sections.
       This is just a straightforward reverse mapping from the original parser:
        type_kind:
            /*empty*/
              { (Ptype_abstract, Public, None) }
          | EQUAL core_type
              { (Ptype_abstract, Public, Some $2) }
          | EQUAL PRIVATE core_type
              { (Ptype_abstract, Private, Some $3) }
          | EQUAL constructor_declarations
              { (Ptype_variant(List.rev $2), Public, None) }
          | EQUAL PRIVATE constructor_declarations
              { (Ptype_variant(List.rev $3), Private, None) }
          | EQUAL private_flag BAR constructor_declarations
              { (Ptype_variant(List.rev $4), $2, None) }
          | EQUAL DOTDOT
              { (Ptype_open, Public, None) }
          | EQUAL private_flag LBRACE label_declarations opt_comma RBRACE
              { (Ptype_record(List.rev $4), $2, None) }
          | EQUAL core_type EQUAL private_flag opt_bar constructor_declarations
              { (Ptype_variant(List.rev $6), $4, Some $2) }
          | EQUAL core_type EQUAL DOTDOT
              { (Ptype_open, Public, Some $2) }
          | EQUAL core_type EQUAL private_flag LBRACE label_declarations opt_comma RBRACE
              { (Ptype_record(List.rev $6), $4, Some $2) }
    *)
    let privateAtom = (atom "pri") in
    let privatize scope lst = match scope with
      | Public -> lst
      | Private -> privateAtom::lst in

    let recordRow pld =
      let hasPunning = recordRowIsPunned pld in
      let name = if hasPunning then
        SourceMap (pld.pld_name.loc, makeList [atom pld.pld_name.txt;])
      else
        SourceMap (pld.pld_name.loc, makeList [atom pld.pld_name.txt; atom ":"])
      in
      let withMutable =
        match pld.pld_mutable with
          | Immutable -> name
          | Mutable -> makeList ~postSpace:true [atom "mutable"; name]
      in
      let recordRow = if hasPunning then
        label withMutable (atom "")
      else
         label ~space:true withMutable (self#core_type pld.pld_type)
      in
        SourceMap (pld.pld_loc, recordRow)
    in
    let recordize ?assumeRecordLoc lst =
      let rows = List.map recordRow lst in
      let rowList = makeList ~wrap:("{", "}") ~sep:"," ~postSpace:true ~break:IfNeed rows in
      match assumeRecordLoc with
        | None -> rowList
        | Some loc -> SourceMap(loc, rowList)
    in

    let estimateRecordOpenBracePoint () =
      match x.ptype_params with
        | [] -> x.ptype_name.loc.loc_end
        | hd::tl ->
          (fst (List.nth x.ptype_params (List.length x.ptype_params - 1))).ptyp_loc.loc_end
    in

    let equalInitiatedSegments = match (x.ptype_kind, x.ptype_private, x.ptype_manifest) with
      (* /*empty*/ {(Ptype_abstract, Public, None)} *)
      | (Ptype_abstract, Public, None) -> [

        ]
      (* EQUAL core_type {(Ptype_abstract, Public, Some _)} *)
      | (Ptype_abstract, Public, Some y) -> [
          [self#core_type y]
        ]
      (* EQUAL PRIVATE core_type {(Ptype_abstract, Private, Some $3)} *)
      | (Ptype_abstract, Private, Some y) -> [
          [privateAtom; self#core_type y]
        ]
      (* EQUAL constructor_declarations {(Ptype_variant _., Public, None)} *)
      (* This case is redundant *)
      (* | (Ptype_variant lst, Public, None) -> [ *)
      (*     [makeSpacedBreakableInlineList (List.map type_variant_leaf lst)] *)
      (*   ] *)
      (* EQUAL PRIVATE constructor_declarations {(Ptype_variant _, Private, None)} *)
      | (Ptype_variant lst, Private, None) -> [
          [privateAtom; makeList ~break:IfNeed ~postSpace:true ~inline:(true, true) (List.map self#type_variant_leaf lst)]
        ]
      (* EQUAL private_flag BAR constructor_declarations {(Ptype_variant _, $2, None)} *)
      | (Ptype_variant lst, scope, None) ->  [
          privatize scope [makeList ~break:Always_rec ~postSpace:true ~inline:(true, true) (List.map self#type_variant_leaf lst)]
        ]
      (* EQUAL DOTDOT {(Ptype_open, Public, None)} *)
      | (Ptype_open, Public, None) -> [
          [atom ".."]
        ]
      (* Super confusing how record/variants' manifest is not actually the
         description of the structure. What's in the manifest in that case is
         the *second* EQUALS asignment. *)

      (* EQUAL private_flag LBRACE label_declarations opt_comma RBRACE {(Ptype_record _, $2, None)} *)
      | (Ptype_record lst, scope, None) ->
          let assumeRecordLoc = {loc_start = estimateRecordOpenBracePoint(); loc_end = x.ptype_loc.loc_end; loc_ghost = false} in
          [privatize scope [recordize ~assumeRecordLoc lst]]
      (* And now all of the forms involving *TWO* equals *)
      (* Again, super confusing how manifests of variants/records represent the
         structure after the second equals. *)
      (* ================================================*)


      (* EQUAL core_type EQUAL private_flag opt_bar constructor_declarations {
         (Ptype_variant _, _, Some _)} *)
      | (Ptype_variant lst, scope, Some mani) -> [
          [self#core_type mani];
          let variant = makeList ~break:IfNeed ~postSpace:true ~inline:(true, true) (List.map self#type_variant_leaf lst) in
          privatize scope [variant];
        ]

      (* EQUAL core_type EQUAL DOTDOT {(Ptype_open, Public, Some $2)} *)
      | (Ptype_open, Public, Some mani) -> [
          [atom ".."];
          [self#core_type mani];
        ]
      (* EQUAL core_type EQUAL private_flag LBRACE label_declarations opt_comma RBRACE
           {(Ptype_record _, $4, Some $2)} *)
      | (Ptype_record lst, scope, Some mani) -> [
          [self#core_type mani];
          privatize scope [recordize lst];
        ]

      (* Everything else is impossible *)
      (* ================================================*)

      | (_, _, _ ) ->  raise (NotPossible "Encountered impossible type specification")
    in

    let makeConstraint (ct1, ct2, _) =
      let constraintEq = makeList ~postSpace:true [
        atom "constraint";
        self#core_type ct1;
        atom "=";
      ] in
      label ~space:true constraintEq (self#core_type ct2) in
    let constraints = List.map makeConstraint x.ptype_cstrs in
    (equalInitiatedSegments, constraints)

  method non_arrowed_non_simple_core_type x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.ptyp_attributes in
    if stdAttrs <> [] then
      formatAttributed
        (self#non_arrowed_simple_core_type {x with ptyp_attributes=[]})
        (self#attributes stdAttrs)
    else
      match x.ptyp_desc with
    (* This significantly differs from the standard OCaml printer/parser:
       Type constructors are no longer simple *)
    | Ptyp_constr (li, l) ->

      (*
         The single identifier has to be wrapped in a [ensureSingleTokenSticksToLabel] to
         avoid (@see @avoidSingleTokenWrapping):
      *)
      let constr = match l with
        (* [ensureSingleTokenSticksToLabel] loses location information which is important
           when you are embedded inside a list and comments are to be interleaved around you.
           Therefore, we wrap the result in the correct [SourceMap].
         *)
        | [] -> SourceMap (li.loc, ensureSingleTokenSticksToLabel (self#longident_loc li))
        | hd::tl ->
            let sourceMappedIdent = SourceMap (li.loc, self#longident_loc li) in

            let typeList = match tl with
              | [] -> self#non_arrowed_simple_core_type hd
              | _ ->
                 let simpleTypeList = (List.map (self#non_arrowed_simple_core_type) (hd::tl)) in
                 (makeList ~inline:(true, true) ~postSpace:true ~break:IfNeed simpleTypeList)
            in
            (label ~space:true sourceMappedIdent typeList)
      in
      (* It's actually better without this source mapped *)
      constr
    | _ -> self#non_arrowed_simple_core_type x

  method non_arrowed_simple_core_type x =
    let (arityAttrs, docAttrs, stdAttrs, jsxAttrs) = partitionAttributes x.ptyp_attributes in
    if stdAttrs <> [] then
      formatSimpleAttributed
        (self#non_arrowed_simple_core_type {x with ptyp_attributes=[]})
        (self#attributes stdAttrs)
    else
      let result =
        match x.ptyp_desc with
        (*   LPAREN core_type_comma_list RPAREN %prec below_NEWDOT *)
        (*       { match $2 with *)
        (*         | [] -> raise Parse_error *)
        (*         | one::[] -> one *)
        (*         | moreThanOne -> mktyp(Ptyp_tuple(List.rev moreThanOne)) } *)
        | Ptyp_tuple l ->
            makeList ~wrap:("(",")") ~sep:"," ~postSpace:true ~break:IfNeed (List.map (self#core_type) l)
        | Ptyp_object (l, o) ->
          let core_field_type (s, attrs, ct) =
            let l = extractStdAttrs attrs in
            (match l with
              | [] -> label ~space:true
                      (label ~space:true (atom s) (atom ":"))
                      (self#core_type ct)
              | _::_ ->
                makeList
                  ~postSpace:true
                  ~break:IfNeed
                  [atom s; (self#attributes attrs); atom ":"; self#core_type ct]
            )
          in
          let openness = match o with
            | Closed -> [atom "."]
            | Open -> [atom ".."]
          in
          let rows = List.map core_field_type l in
          makeList ~break:IfNeed ~preSpace:(List.length rows > 0) ~wrap:("{", "}") (openness @ [makeList ~break:IfNeed ~inline:(true, (List.length rows > 0)) ~postSpace:true ~sep:"," rows])
        | Ptyp_package (lid, cstrs) ->
          let typeConstraint (s, ct) =
            label
              (makeList ~break:IfNeed ~postSpace:true [atom "type"; self#longident_loc s; atom "="])
              (self#core_type ct)
          in
          (
            match cstrs with
              | [] ->
                makeList ~wrap:("(", ")") [
                  (makeList ~postSpace:true [atom "module"; self#longident_loc lid])
                ]
              | _ ->
                makeList ~wrap:("(", ")") [
                  label ~space:true
                    (makeList ~postSpace:true [atom "module"; self#longident_loc lid])
                    (makeList
                      ~break:IfNeed
                      ~sep:" and"
                      ~wrap:("with", "")
                      ~pad:(true, false)
                      (List.map typeConstraint cstrs))
                ]
          )
        (*   | QUOTE ident *)
        (*       { mktyp(Ptyp_var $2) } *)
        | Ptyp_var s -> ensureSingleTokenSticksToLabel (self#tyvar s)
        (*   | UNDERSCORE *)
        (*       { mktyp(Ptyp_any) } *)
        | Ptyp_any -> ensureSingleTokenSticksToLabel (atom "_")
        (*   | type_longident *)
        (*       { mktyp(Ptyp_constr(mkrhs $1 1, [])) } *)
        | Ptyp_constr (li, []) ->
            (* Only simple if zero type paramaters *)
            ensureSingleTokenSticksToLabel (self#longident_loc li)
        | Ptyp_variant (l, closed, low) ->
          let pcd_loc = x.ptyp_loc in
          let pcd_attributes = x.ptyp_attributes in
          let pcd_res = None in
          let variant_helper rf =
            match rf with
              | Rtag (label, _, opt_ampersand, pcd_args) ->
                let pcd_name = {
                  txt = label;
                  loc = pcd_loc;
                } in
                self#type_variant_leaf ~opt_ampersand ~polymorphic:true {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes}
              | Rinherit ct -> self#core_type ct in
          let (designator, tl) =
            match (closed,low) with
              | (Closed,None) -> ("", [])
              | (Closed,Some tl) -> ("<", tl)
              | (Open,_) -> (">", []) in
          let node_list = List.map variant_helper l in
          let ll = (List.map (fun t -> atom ("`" ^ t)) tl) in
          let tag_list = makeList ~postSpace:true ~break:IfNeed ((atom ">")::ll) in
          let type_list = if List.length tl != 0 then node_list@[tag_list] else node_list in
          makeList ~wrap:("[" ^ designator,"]") ~pad:(true, false) ~postSpace:true ~break:IfNeed type_list
        | Ptyp_class (li, l) ->
          (match l with
            | [] -> makeList [atom "#"; self#longident_loc li]
            | _::_ ->
              label
                ~space:true
                (makeList [atom "#"; self#longident_loc li])
                (makeList ~postSpace:true ~inline:(true, false) (List.map self#core_type l))
          )
        | Ptyp_extension e -> self#extension e
        | Ptyp_constr (_, _::_)
        | Ptyp_arrow (_, _, _)
        | Ptyp_alias (_, _)
        | Ptyp_poly (_, _) ->
            makeList ~wrap:("(",")") ~break:IfNeed [self#core_type x]
      in
      SourceMap (x.ptyp_loc, result)
  (* TODO: ensure that we have a form of desugaring that protects *)
  (* when final argument of curried pattern is a type constraint: *)
  (* | COLON non_arrowed_core_type EQUALGREATER expr
      { mkexp_constraint $4 (Some $2, None) }         *)
  (*                         \----/   \--/
                             constraint coerce

                             Creates a ghost expression:
                             mkexp_constraint | Some t, None -> ghexp(Pexp_constraint(e, t))
  *)

  method pattern_list_split_cons acc = function
    | {
      ppat_desc = Ppat_construct (
        { txt = Lident("::"); loc=consLoc },
        Some {ppat_desc = Ppat_tuple ([pat1; pat2])}
      )
    } ->
        self#pattern_list_split_cons (pat1::acc) pat2
    | p -> (List.rev acc), p

  (*
   * Adds parens to the right sub-tree when it is not a single node:
   *
   * A | B                   is formatted as    A | B
   * A | (B | C)             is formatted as    A | (B | C)
   *
   * Also, adds parens to both sub-trees when both of them
   * are not a single node:
   * (A | B) | (C | D)       is formatted as    A | B | (C | D)
   * A | B | (C | D)         is formatted as    A | B | (C | D)
   * (A | B) | C             is formatted as    A | B | C
   * A | B | C               is formatted as    A | B | C
   *
   *)
  method or_pattern p1 p2 =
    let (p1_raw, p2_raw) = (self#pattern p1, self#pattern p2) in
    let (left, right) =
      match p2.ppat_desc with
        | Ppat_or _ -> (p1_raw, formatPrecedence p2_raw)
        | _ -> (p1_raw, p2_raw)
    in
    makeList
      ~break:IfNeed
      ~inline:(true, true)
      ~sep:"|"
      ~postSpace:true
      ~preSpace:true
      [left; right]

  method pattern_without_or x =
    let patternSourceMap pt layout = (SourceMap (pt.ppat_loc, layout)) in
    (* TODOATTRIBUTES: Handle the stdAttrs here *)
    let (arityAttrs, docAtrs, _, jsxAttrs) = partitionAttributes x.ppat_attributes in
    match x.ppat_desc with
      | Ppat_alias (p, s) ->
          let raw_pattern = (self#pattern p) in
          let pattern_with_precedence = match p.ppat_desc with
            | Ppat_or (p1, p2) -> formatPrecedence (self#or_pattern p1 p2)
            | _ -> raw_pattern
          in
          label ~space:true
            (patternSourceMap p pattern_with_precedence)
            (makeList ~postSpace:true [
              atom "as";
              (SourceMap (s.loc, (protectIdentifier s.txt)))
            ]) (* RA*)
      | Ppat_variant (l, Some p) ->
          if arityAttrs != [] then
            raise (NotPossible "Should never see embedded attributes on poly variant")
          else
            let layout = (self#constructor_pattern ~polyVariant:true ~arityIsClear:true (atom ("`" ^ l)) p) in
            SourceMap (x.ppat_loc, layout)
      | Ppat_lazy p -> label ~space:true (atom "lazy") (self#simple_pattern p)
      | Ppat_construct (({txt} as li), po) when not (txt = Lident "::")-> (* FIXME The third field always false *)
          let liSourceMapped = SourceMap (li.loc, (self#longident_loc li)) in
          let formattedConstruction = match po with
            (* TODO: Check the explicit_arity field on the pattern/constructor
               attributes to determine if should desugar to an *actual* tuple. *)
            (* | Some ({ *)
            (*   ppat_desc=Ppat_tuple l; *)
            (*   ppat_attributes=[{txt="explicit_arity"; loc}] *)
            (* }) -> *)
            (*   label ~space:true (self#longident_loc li) (makeSpacedBreakableInlineList (List.map self#simple_pattern l)) *)
            | Some xx ->
                let arityIsClear = isArityClear arityAttrs in
                self#constructor_pattern ~arityIsClear liSourceMapped xx
            | None ->
                liSourceMapped

          in
            SourceMap (x.ppat_loc, formattedConstruction)
      | _ -> self#simple_pattern x

  method pattern x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.ppat_attributes in
    if stdAttrs <> [] then
      formatAttributed
        (* Doesn't need to be simple_pattern because attributes are parse as
         * appyling to the entire "function application style" syntax preceeding them *)
        (self#pattern {x with ppat_attributes=arityAttrs})
        (self#attributes stdAttrs)
    else match x.ppat_desc with
      | Ppat_or (p1, p2) ->
        self#or_pattern p1 p2
      | _ -> self#pattern_without_or x

  method pattern_list_helper pat =
    let pat_list, pat_last = self#pattern_list_split_cons [] pat in
    match pat_last with
    | {ppat_desc = Ppat_construct ({txt=Lident "[]"},_)} -> (* [x,y,z] *)
        makeList ~break:IfNeed ~wrap:("[", "]") ~sep:"," ~postSpace:true (List.map self#pattern pat_list)
    | _ -> (* x::y *)
        makeES6List (List.map self#pattern pat_list) (self#pattern pat_last)

  method potentiallyConstrainedPattern1 x = match x.ppat_desc with
    | Ppat_constraint (p, ct) ->
        formatTypeConstraint (self#pattern p) (self#core_type ct)
    | _  -> self#pattern x

  method simple_pattern x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.ppat_attributes in
    if stdAttrs <> [] then
      formatSimpleAttributed
        (self#simple_pattern {x with ppat_attributes=arityAttrs})
        (self#attributes stdAttrs)
    else
      let itm =
        match x.ppat_desc with
          | Ppat_construct (({loc; txt=Lident ("()"|"[]" as x)}), _) ->
              (* Patterns' locations might include a leading bar depending on the
               * context it was parsed in. Therefore, we need to include further
               * information about the contents of the pattern such as tokens etc,
               * in order to get comments to be distributed correctly.*)

              SourceMap (loc, (atom x))
          | Ppat_construct (({txt=Lident "::"}), po) ->
                self#pattern_list_helper x (* LIST PATTERN *)
          | Ppat_construct (({txt} as li), None) ->
              let liSourceMapped = SourceMap (li.loc, (self#longident_loc li)) in
              SourceMap (x.ppat_loc, liSourceMapped)
          | Ppat_any -> atom "_"
          | Ppat_var ({loc; txt = txt}) ->
            (*
               To prevent this:

                 let oneArgShouldWrapToAlignWith
                   theFunctionNameBinding => theFunctionNameBinding;

               And instead do:

                 let oneArgShouldWrapToAlignWith
                     theFunctionNameBinding => theFunctionNameBinding;

               We have to do something to the non "listy" patterns. Non listy
               patterns don't indent the same amount as listy patterns when docked
               to a label.

               If wrapping the non-listy pattern in [ensureSingleTokenSticksToLabel]
               you'll get the following (even though it should wrap)

                 let oneArgShouldWrapToAlignWith theFunctionNameBinding => theFunctionNameBinding;

             *)
              SourceMap (loc, (protectIdentifier txt))
          | Ppat_array l ->
              makeList ~wrap:("[|", "|]") ~break:IfNeed ~postSpace:true ~sep:"," (List.map self#pattern l)
          | Ppat_unpack (s) ->
              makeList ~wrap:("(", ")") ~break:IfNeed ~postSpace:true [atom "module"; atom s.txt]
          | Ppat_type li ->
              makeList [atom "#"; self#longident_loc li]
          | Ppat_record (l, closed) ->
              let longident_x_pattern (li, p) =
                match (li, p.ppat_desc) with
                  | ({txt=Lident s}, Ppat_var {txt}) when s = txt ->
                      self#longident_loc li
                  | _ ->
                      label ~space:true (makeList [self#longident_loc li; atom ":"]) (self#pattern p)
              in
              let rows = (List.map longident_x_pattern l)@(
                match closed with
                  | Closed -> []
                  | _ -> [atom "_"]
              ) in
              makeList ~wrap:("{", "}") ~break:IfNeed ~sep:"," ~postSpace:true rows
          | Ppat_tuple l ->
              makeList ~wrap:("(", ")") ~sep:"," ~postSpace:true ~break:IfNeed (List.map (self#potentiallyConstrainedPattern1) l)
          | Ppat_constant (c) -> (self#constant c)
          | Ppat_interval (c1, c2) -> makeList [self#constant c1; atom ".."; self#constant c2]
          | Ppat_variant (l, None) -> makeList[atom "`"; atom l]
          | Ppat_constraint (p, ct) ->
              formatPrecedence (formatTypeConstraint (self#pattern p) (self#core_type ct))
          | Ppat_lazy p ->formatPrecedence (label ~space:true (atom "lazy") (self#simple_pattern p))
          | Ppat_extension e -> self#extension e
          | Ppat_exception p ->
              (*
                An exception pattern with an alias should be wrapped in (...)
                The rules for what goes to the right of the exception are a little (too) nuanced.
                It accepts "non simple" parameters, except in the case of `as`.
                Here we consistently apply "simplification" to the exception argument.
                Example:
                  | exception (Sys_error _ as exc) => raise exc
                 parses correctly while
                  | Sys_error _ as exc => raise exc
                 results in incorrect parsing with type error otherwise.
              *)
               makeList ~postSpace:true [atom "exception"; self#simple_pattern p]
          | _ -> formatPrecedence (self#pattern x) (* May have a redundant sourcemap *)
        in
        SourceMap (x.ppat_loc, itm)

  method label_exp (l,opt,p) =
    if l = "" then
      self#simple_pattern p (*single case pattern parens needed here *)
    else
    if l.[0] = '?' then
      let len = String.length l - 1 in
      let lbl = String.sub l 1 len in
        let lbl = pun_labelled_pattern p lbl in
        (formatLabeledArgument
           (atom lbl)
           ""
           (label
             (makeList [(self#simple_pattern p); atom "="])
             (match opt with None -> (atom "?") | Some o -> (self#simplifyUnparseExpr o))))
    else
      match p.ppat_desc with
        | _ ->
          let lbl = pun_labelled_pattern p l in
          formatLabeledArgument
            (atom lbl)
            ""
            (self#simple_pattern p)

  method access op cls e1 e2 = makeList ~interleaveComments:false [
    (* Important that this be not breaking - at least to preserve same
       behavior as stock desugarer. It might even be required (double check
       in parser.mly) *)
    e1;
    atom ".";
    atom op;
    e2;
    atom cls;
  ]

  method simple_get_application x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.pexp_attributes in
    match (x.pexp_desc, stdAttrs, jsxAttrs) with
    | (_, attrHd::attrTl, []) -> None (* Has some printed attributes - not simple *)
    | (Pexp_apply ({pexp_desc=Pexp_ident loc}, l), [], jsx::_) -> (
      (* TODO: Soon, we will allow the final argument to be an identifier which
         represents the entire list. This would be written as
         `<tag>...list</tag>`. If you imagine there being an implicit [] inside
         the tag, then it would be consistent with array spread:
         [...list] evaluates to the thing as list.
      *)
      let hasLabelledChildrenListLiteral = List.exists (function
        | ("children", {pexp_desc = Pexp_construct ({txt = Lident "::" | Lident "[]"}, _)}) -> true
        | _ -> false
      ) l in
      let rec hasSingleNonLabelledUnitAndIsAtTheEnd l = match l with
      | [] -> false
      | ("", {pexp_desc = Pexp_construct ({txt = Lident "()"}, _)}) :: [] -> true
      | ("", _) :: rest -> false
      | _ :: rest -> hasSingleNonLabelledUnitAndIsAtTheEnd rest
      in
      if hasLabelledChildrenListLiteral && hasSingleNonLabelledUnitAndIsAtTheEnd l then
        let moduleNameList = List.rev (List.tl (List.rev (Longident.flatten loc.txt))) in
        if List.length moduleNameList > 0 then
          if Longident.last loc.txt = "createElement" then
            Some (self#formatJSXComponent (String.concat "." moduleNameList) l)
          else None
        else Some (self#formatJSXComponent (Longident.last loc.txt) l)
      else None
    )
    | (Pexp_apply (eFun, ls), [], []) -> (
      match (printedStringAndFixityExpr eFun, ls) with
      (* We must take care not to print two subsequent prefix operators without
         spaces between them (`! !` could become `!!` which is totally
         different).  *)
      | (AlmostSimplePrefix prefixStr, [("", rightExpr)]) ->
        let forceSpace = match rightExpr.pexp_desc with
          | Pexp_apply (ee, lsls) ->
            (match printedStringAndFixityExpr ee with | AlmostSimplePrefix _ -> true | _ -> false)
          | _ -> false
        in
        let rightItm = self#simplifyUnparseExpr rightExpr in
        Some (label ~space:forceSpace (atom prefixStr) rightItm)
      | (Infix infixStr, [(_, leftExpr); (_, rightExpr)]) when infixStr.[0] = '#' ->
        (* Little hack. We check the right expression to see if it's also a SHARPOP, if it is
           we call `formatPrecedence` on the result of `simplifyUnparseExpr` to add the appropriate
           parens. This is done because `unparseExpr` doesn't seem to be able to handle
           high enough precedence things. Using the normal precedence handling, something like

              ret #= (Some 10)

            gets pretty printed to

              ret #= Some 10

            Which seems to indicate that the pretty printer doesn't think `#=` is of
            high enough precedence for the parens to be worth adding back. *)
        let rightItm = (
          match rightExpr.pexp_desc with
          | Pexp_apply (eFun, ls) -> (
            match (printedStringAndFixityExpr eFun, ls) with
              | (Infix infixStr, [(_, _); (_, _)]) when infixStr.[0] = '#' -> formatPrecedence (self#simplifyUnparseExpr rightExpr)
              | _ -> self#simplifyUnparseExpr rightExpr
          )
          | _ -> self#simplifyUnparseExpr rightExpr
        ) in
        Some (makeList [self#simple_enough_to_be_lhs_dot_send leftExpr; atom infixStr; rightItm])
      | (_, _) -> (
        match (eFun, ls) with
        | ({pexp_desc = Pexp_ident {txt = Ldot (Lident ("String"),"get")}}, [(_,e1);(_,e2)]) ->
          Some (self#access "[" "]" (self#simple_enough_to_be_lhs_dot_send e1) (self#unparseExpr e2))
        | ({pexp_desc = Pexp_ident {txt = Ldot (Lident ("Array"),"get")}}, [(_,e1);(_,e2)]) ->
          Some (self#access "(" ")" (self#simple_enough_to_be_lhs_dot_send e1) (self#unparseExpr e2))
        | (
            {pexp_desc= Pexp_ident {txt=Ldot (Ldot (Lident "Bigarray", "Genarray" ), "get")}},
            [(_,a); (_,{pexp_desc=Pexp_array ls})]
          ) ->
          let formattedList = List.map self#simplifyUnparseExpr ls in
          Some (self#access "{" "}" (self#simple_enough_to_be_lhs_dot_send a) (makeCommaBreakableList formattedList))
        | ({pexp_desc= Pexp_ident {txt=Ldot (Ldot (Lident "Bigarray", ("Array1"|"Array2"|"Array3")), "get")}}, (_,a)::rest) ->
          let formattedList = List.map self#simplifyUnparseExpr (List.map snd rest) in
          Some (self#access "{" "}" (self#simple_enough_to_be_lhs_dot_send a) (makeCommaBreakableList formattedList))
        | _ -> None
      )
    )
    | _ ->  None

  (** Detects "sugar expressions" (sugar for array/string setters) and returns their separate
      parts.  *)
  method sugar_set_expr_parts e =
    if e.pexp_attributes <> [] then None
    (* should also check attributes underneath *)
    else match e.pexp_desc with
      | Pexp_apply ({pexp_desc=Pexp_ident{txt=Ldot (Lident ("Array"), "set")}}, [(_,e1);(_,e2);(_,e3)]) ->
        Some (self#access "(" ")" (self#simple_enough_to_be_lhs_dot_send e1) (self#unparseExpr e2), e3)
      | Pexp_apply ({pexp_desc=Pexp_ident {txt=Ldot (Lident "String", "set")}}, [(_,e1);(_,e2);(_,e3)]) ->
        Some ((self#access "[" "]" (self#simple_enough_to_be_lhs_dot_send e1) (self#unparseExpr e2)), e3)
      | Pexp_apply (
        {pexp_desc=Pexp_ident {txt = Ldot (Ldot (Lident "Bigarray", array), "set")}},
        label_exprs
      ) -> (
        match array with
          | "Genarray" -> (
            match label_exprs with
            | [(_,a);(_,{pexp_desc=Pexp_array ls});(_,c)] ->
              let formattedList = List.map self#simplifyUnparseExpr ls in
              Some (self#access "{" "}" (self#simple_enough_to_be_lhs_dot_send a) (makeCommaBreakableList formattedList), c)
            | _ -> None
          )
          | ("Array1"|"Array2"|"Array3") -> (
            match label_exprs with
            | (_,a)::rest -> (
              match List.rev rest with
              | (_,v)::rest ->
                let args = List.map snd (List.rev rest) in
                let formattedList = List.map self#simplifyUnparseExpr args in
                Some (self#access "{" "}" (self#simple_enough_to_be_lhs_dot_send a) (makeCommaBreakableList formattedList), v)
              | _ -> assert false
            )
            | _ -> assert false
          )
          | _ -> None
        )
      | _ -> None

  (*

     How would we know not to print the sequence without { }; protecting the let a?

                            let a
                             |
                           sequence
                          /        \
                    let a           print a
                    alert a
     let res = {
       let a = something();
       {                     \
         alert(a);           | portion to be parsed as a sequence()
         let a = 20;         | The final ; print(a) causes the entire
         alert(a);           | portion to be parsed as a sequence()
       };                    |
       print (a);            /
     }

     ******************************************************************
     Any time the First expression of a sequence is another sequence, or (as in
     this case) a let, wrapping the first sequence expression in { } is
     required.
     ******************************************************************
  *)

  (**
     TODO: Configure the optional ability to print the *minimum* number of
     parens. It's simply a matter of changing [higherPrecedenceThan] to
     [higherOrEqualPrecedenceThan].
   *)

  (* Ensures a rule doesn't reduce until *after* `reducesAfterRight` gets a chance
     to reduce. Example: The addtion rule which has precedence of rightmost
     token "+", in `x + a * b` should not reduce until after the a * b gets
     a chance to reduce. This function would determine the minimum parens to
     ensure that. *)
  method ensureContainingRule ~withPrecedence ~reducesAfterRight =
    match self#unparseExprRecurse reducesAfterRight with
    | (SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, rightRecurse)) ->
      if higherPrecedenceThan shiftPrecedence withPrecedence then rightRecurse
      else if (higherPrecedenceThan withPrecedence shiftPrecedence) then
        formatPrecedence ~loc:reducesAfterRight.pexp_loc rightRecurse
      else (
        if isRightAssociative withPrecedence then
          rightRecurse
        else
          formatPrecedence ~loc:reducesAfterRight.pexp_loc rightRecurse
      )
    | FunctionApplication itms ->
      formatAttachmentApplication applicationFinalWrapping None (itms, Some reducesAfterRight.pexp_loc)
    | PotentiallyLowPrecedence itm -> formatPrecedence ~loc:reducesAfterRight.pexp_loc itm
    | Simple itm -> itm

  method ensureExpression expr ~reducesOnToken =
    match self#unparseExprRecurse expr with
    | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, leftRecurse) ->
      if higherPrecedenceThan reducePrecedence reducesOnToken then leftRecurse
      else if higherPrecedenceThan reducesOnToken reducePrecedence then
        formatPrecedence ~loc:expr.pexp_loc leftRecurse
      else (
        if isLeftAssociative reducesOnToken then
          leftRecurse
        else
          formatPrecedence ~loc:expr.pexp_loc leftRecurse
      )
    | FunctionApplication itms -> formatAttachmentApplication applicationFinalWrapping None (itms, Some expr.pexp_loc)
    | PotentiallyLowPrecedence itm -> formatPrecedence ~loc:expr.pexp_loc itm
    | Simple itm -> itm


  (** Attempts to unparse: The beginning of a more general printing algorithm,
      that determines how to print based on precedence of tokens and rules.
      The end goal is that this should be completely auto-generated from the
      Menhir parsing tables. We could move more and more into this function.

      You could always just call self#expression, but `unparseExpr` will render
      infix/prefix/unary/terary fixities in their beautiful forms while
      minimizing parenthesis.
  *)
  method unparseExpr x =
    match self#unparseExprRecurse x with
    | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, itm) -> itm
    | FunctionApplication itms -> formatAttachmentApplication applicationFinalWrapping None (itms, Some x.pexp_loc)
    | PotentiallyLowPrecedence itm -> itm
    | Simple itm -> itm

  method simplifyUnparseExpr x =
    match self#unparseExprRecurse x with
    | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, itm) -> formatPrecedence ~loc:x.pexp_loc itm
    | FunctionApplication itms ->
      formatPrecedence ~loc:x.pexp_loc (formatAttachmentApplication applicationFinalWrapping None (itms, Some x.pexp_loc))
    | PotentiallyLowPrecedence itm -> formatPrecedence ~loc:x.pexp_loc itm
    | Simple itm -> itm

  method unparseExprApplicationItems x =
    match self#unparseExprRecurse x with
    | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, itm) -> ([itm], Some x.pexp_loc)
    | FunctionApplication itms -> (itms, Some x.pexp_loc)
    | PotentiallyLowPrecedence itm -> ([itm], Some x.pexp_loc)
    | Simple itm -> ([itm], Some x.pexp_loc)

  method unparseExprRecurse x =
    (* If there are any attributes, render unary like `(~-) x [@ppx]`, and infix like `(+) x y [@attr]` *)
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.pexp_attributes in
    (* If there's any attributes, recurse without them, then apply them to
       the ends of functions, or simplify infix printings then append. *)
    if stdAttrs <> [] then
      let withoutVisibleAttrs = {x with pexp_attributes=(arityAttrs @ jsxAttrs)} in
      let attributesAsList = (List.map self#attribute stdAttrs) in
      let itms = match self#unparseExprRecurse withoutVisibleAttrs with
        | SpecificInfixPrecedence ({reducePrecedence; shiftPrecedence}, itm) -> [formatPrecedence ~loc:x.pexp_loc itm]
        | FunctionApplication itms -> itms
        | PotentiallyLowPrecedence itm -> [formatPrecedence ~loc:x.pexp_loc itm]
        | Simple itm -> [itm]
      in
      FunctionApplication [
        makeList
          ~break:IfNeed
          ~inline:(true, true)
          ~indent:0
          ~postSpace:true
          (List.concat [itms; attributesAsList])
      ]
    else
    match self#simplest_expression x with
    | Some se -> Simple se
    | None ->
    match x.pexp_desc with
    | Pexp_apply (e, ls) -> (
      match (self#sugar_set_expr_parts x) with
      (* Returns None if there's attributes - would render as regular function *)
      (* Format as if it were an infix function application with identifier "=" *)
      | Some (simplyFormatedLeftItm, rightExpr) -> (
        let tokenPrec = Token updateToken in
        let rightItm = self#ensureContainingRule ~withPrecedence:tokenPrec ~reducesAfterRight:rightExpr in
        let leftWithOp = makeList ~postSpace:true [simplyFormatedLeftItm; atom updateToken] in
        let expr = label ~space:true leftWithOp rightItm in
        SpecificInfixPrecedence ({reducePrecedence=tokenPrec; shiftPrecedence=tokenPrec}, expr)
      )
      | None -> (
        match (printedStringAndFixityExpr e, ls) with
        | (Infix printedIdent, [("", leftExpr); ("", rightExpr)]) ->
          let infixToken = Token printedIdent in
          let rightItm = self#ensureContainingRule ~withPrecedence:infixToken ~reducesAfterRight:rightExpr in
          let leftItm = self#ensureExpression leftExpr ~reducesOnToken:infixToken in
          let leftWithOp = makeList ~postSpace:true [leftItm; atom printedIdent] in
          let indent = infixTokenRequiresIndent printedIdent in
          let expr = label ~space:true ?indent leftWithOp rightItm in
          SpecificInfixPrecedence ({reducePrecedence=infixToken; shiftPrecedence=infixToken}, expr)
        (* Will be rendered as `(+) a b c` which is parsed with higher precedence than all
           the other forms unparsed here.*)
        | (UnaryPlusPrefix printedIdent, [("", rightExpr)]) ->
          let prec = Custom "prec_unary_plus" in
          let rightItm = self#ensureContainingRule ~withPrecedence:prec ~reducesAfterRight:rightExpr in
          let expr = label ~space:true (atom printedIdent) rightItm in
          SpecificInfixPrecedence ({reducePrecedence=prec; shiftPrecedence=Token printedIdent}, expr)
        | (UnaryMinusPrefix printedIdent, [("", rightExpr)]) ->
          let prec = Custom "prec_unary_minus" in
          let rightItm = self#ensureContainingRule ~withPrecedence:prec ~reducesAfterRight:rightExpr in
          let expr = label ~space:true (atom printedIdent) rightItm in
          SpecificInfixPrecedence ({reducePrecedence=prec; shiftPrecedence=Token printedIdent}, expr)
        (* Will need to be rendered in self#expression as (~-) x y z. *)
        | (_, _) ->
        (* This case will happen when there is something like

             Bar.createElement a::1 b::2 [] [@bla] [@JSX]

           At this point the bla will be stripped (because it's a visible
           attribute) but the JSX will still be there.
         *)
        (* If there was a JSX attribute BUT JSX component wasn't detected,
           that JSX attribute needs to be pretty printed so it doesn't get
           lost
         *)
        let maybeJSXAttr = (match jsxAttrs with
          | [] -> []
          | jsx -> (List.map self#attribute jsx)
        ) in
        let theFunc = SourceMap (e.pexp_loc, (self#simplifyUnparseExpr e)) in
        (*reset here only because [function,match,try,sequence] are lower priority*)
        let theArgs = List.map self#reset#label_x_expression_param ls in
        FunctionApplication (theFunc::theArgs @ maybeJSXAttr)
      )
    )
    | Pexp_construct (li, Some eo) when not (is_simple_construct (view_expr x)) -> (
        match view_expr x with
        (* TODO: Explicit arity *)
        | `normal ->
            let arityIsClear = isArityClear arityAttrs in
            FunctionApplication [self#constructor_expression ~arityIsClear stdAttrs (self#longident_loc li) eo]
        | _ -> assert false
      )
    | Pexp_variant (l, Some eo) ->
        if arityAttrs != [] then
          raise (NotPossible "Should never see embedded attributes on poly variant")
        else
          FunctionApplication [self#constructor_expression ~polyVariant:true ~arityIsClear:true stdAttrs (atom ("`" ^ l)) eo]
    (* TODO: Should protect this identifier *)
    | Pexp_setinstvar (s, rightExpr) ->
      let rightItm = self#ensureContainingRule ~withPrecedence:(Token updateToken) ~reducesAfterRight:rightExpr in
      let expr = label ~space:true (makeList ~postSpace:true [(protectIdentifier s.txt); atom updateToken]) rightItm in
      SpecificInfixPrecedence ({reducePrecedence=(Token updateToken); shiftPrecedence=(Token updateToken)}, expr)
    | Pexp_setfield (leftExpr, li, rightExpr) ->
      let rightItm = self#ensureContainingRule ~withPrecedence:(Token updateToken) ~reducesAfterRight:rightExpr in
      let leftItm =
        label
          (makeList ~interleaveComments:false [self#simple_enough_to_be_lhs_dot_send leftExpr; atom "."])
          (self#longident_loc li) in
      let expr = label ~space:true (makeList ~postSpace:true [leftItm; atom updateToken]) rightItm in
      SpecificInfixPrecedence ({reducePrecedence=(Token updateToken); shiftPrecedence=(Token updateToken)}, expr)
    | Pexp_match (e, l) when detectTernary l != None -> (
      match detectTernary l with
      | None -> raise (Invalid_argument "Impossible")
      | Some (tt, ff) ->
        let ifTrue = self#unparseExpr tt in
        let testItm = self#ensureExpression e ~reducesOnToken:(Token "?") in
        let ifFalse = self#ensureContainingRule ~withPrecedence:(Token ":") ~reducesAfterRight:ff in
        let withQuestion = SourceMap (e.pexp_loc, makeList ~postSpace:true [testItm; atom "?"]) in
        let trueFalseBranches =
          makeList ~inline:(true, true) ~break:IfNeed ~sep:":" ~postSpace:true ~preSpace:true [ifTrue; ifFalse]
        in
        let expr = label ~space:true withQuestion trueFalseBranches in
        SpecificInfixPrecedence ({reducePrecedence=Token ":"; shiftPrecedence=Token "?"}, expr)
    )
    | _ -> (
      match self#expression_requiring_parens_in_infix x with
      | Some e -> PotentiallyLowPrecedence e
      | None -> raise (Invalid_argument "No match for unparsing expression")
    )

  (*
     It's not enough to only check if precedence of an infix left/right is
     greater than the infix itself. We also should likely pay attention to
     left/right associativity. So how do we render the minimum number of
     parenthesis?

     The intuition is that sequential right associative operators will
     naturally build up deep trees on the right side (left builds up left-deep
     trees). So by default, we add parens to model the tree structure that
     we're rendering except when the parser will *naturally* parse the tree
     structure that the parens assert.

     Sequential identical infix operators:
     ------------------------------------
     So if we see a nested infix operator of precedence Y, as one side of
     another infix operator that has the same precedence (Y), that is S
     associative on the S side of the function application, we don't need to
     wrap in parens. In more detail:

     -Add parens around infix binary function application
       Exception 1: Unless we are a left-assoc operator of precedence X in the left branch of an operator w/ precedence X.
       Exception 2: Unless we are a right-assoc operator of precedence X in the right branch of an operator w/ precedence X.
       Exception 3: Unless we are a _any_-assoc X operator in the _any_ branch of an Y operator where X has greater precedence than Y.

     Note that the exceptions do not specify any special cases for mixing
     left/right associativity. Precedence is what determines necessity of
     parens for operators with non-identical precedences. Associativity
     only determines necessity of parens for identically precedented operators.

     PLUS is left assoc:
     - So this one *shouldn't* expand into two consecutive infix +:


            [Pexp_apply]
              /      \
         first +   [Pexp_apply]
                      /   \
                  second + third


     - This one *should*:

                    [Pexp_apply]
                      /      \
           [  Pexp_apply  ] + third
              /     \
           first +  second



     COLONCOLON is right assoc, so
     - This one *should* expand into two consecutive infix ::  :

            [Pexp_apply]
              /      \
         first ::   [Pexp_apply]
                      /   \
                  second :: third


     - This one *shouldn't*:

                    [Pexp_apply]
                      /      \
           [  Pexp_apply  ] :: third
              /     \
           first ::  second




     Sequential differing infix operators:
     ------------------------------------

     Neither of the following require paren grouping because of rule 3.


            [Pexp_apply]
              /      \
         first  +  [Pexp_apply]
                      /   \
                  second * third


                    [Pexp_apply]
                      /      \
            [Pexp_apply  +  third
              /     \
           first *  second

      The previous has nothing to do with the fact that + and * have the same
      associativity. Exception 3 applies to the following where :: is right assoc
      and + is left. + has higher precedence than ::

      - so parens aren't required to group + when it is in a branch of a
        lower precedence ::

            [Pexp_apply]
              /      \
         first ::   [Pexp_apply]
                      /   \
                  second + third


      - Whereas there is no Exception that applies in this case (Exception 3
        doesn't apply) so parens are required around the :: in this case.

                    [Pexp_apply]
                      /      \
           [  Pexp_apply  ] + third
              /     \
           first ::  second

  *)

  method classExpressionToFormattedApplicationItems x =
    let itms =
      match x.pcl_desc with
        | Pcl_apply (ce, l) ->
          (self#simple_class_expr ce)::
          (List.map self#label_x_expression_param l)
        | _ -> [self#class_expr x]
    in
    (itms, None)


  (**
        How JSX is formatted/wrapped. We want the attributes to wrap independently
        of children.

        <xxx
          attr1=blah
          attr2=foo>
          child
          child
          child
        </x>

      +-------------------------------+
      |  left   right (list of attrs) |
      |   / \   /   \                 |
      |   <tag                        |
      |     attr1=blah                |
      |     attr2=foo                 |
      +-------------------------------+
       |
       |
       |
       |      left       right  list of children with
       |   /       \    /  \     open,close = > </tag>
       |  +---------+
       +--|         |    >
          +---------+

          </tag>           *)
  method formatJSXComponent componentName args =
    let rec processArguments arguments processedAttrs children =
      match arguments with
      | ("children", {pexp_desc = Pexp_construct (_, None)}) :: tail ->
        processArguments tail processedAttrs None
      | ("children", {pexp_desc = Pexp_construct ({txt = Lident"::"}, Some {pexp_desc = Pexp_tuple(components)} )}) :: tail ->
        processArguments tail processedAttrs (self#formatChildren components [])
      | [] -> (processedAttrs, children)
      | ("", expression) :: [] -> (processedAttrs, children)
      | (lbl, expression) :: tail ->
         let nextAttr =
           match expression.pexp_desc with
           | Pexp_ident (ident) when (Longident.last ident.txt) = lbl -> atom lbl
           | _ -> (
             let firstChar = String.get lbl 0 in
             if firstChar == '?' then
                let lbl = String.sub lbl 1 ((String.length lbl) - 1) in
                makeList ([atom lbl; atom "=?"; self#simplifyUnparseExpr expression])
             else
                makeList ([atom lbl; atom "="; self#simplifyUnparseExpr expression])
                )
         in
         processArguments tail (nextAttr :: processedAttrs) children
    in
    let (reversedAttributes, children) = processArguments args [] None in
    match children with
    | None ->
      makeList
        ~break:IfNeed
        ~wrap:("<" ^ componentName, "/>")
        ~pad:(true, true)
        ~inline:(false, false)
        ~postSpace:true
        (List.rev reversedAttributes)
    | Some renderedChildren ->
      let openTagAndAttrs =
        match reversedAttributes with
        | [] -> (atom ("<" ^ componentName ^ ">"))
        | revAttrHd::revAttrTl ->
          let finalAttrList = (List.rev (makeList ~break:Never [revAttrHd; atom ">"] :: revAttrTl)) in
          let renderedAttrList = (makeList ~inline:(true, true) ~break:IfNeed ~pad:(false, false) ~preSpace:true finalAttrList) in
          label
            ~space:true
            (atom ("<" ^ componentName))
            renderedAttrList
      in
      label
        openTagAndAttrs
        (makeList
          ~wrap:("", "</" ^ componentName ^ ">")
          ~inline:(true, false)
          ~break:IfNeed
          ~pad:(true, true)
          ~postSpace:true
          renderedChildren)


  (* Creates a list of simple module expressions corresponding to module
     expression or functor application. *)
  method moduleExpressionToFormattedApplicationItems x =
    let rec functorApplicationList xx = match xx.pmod_desc with
      | Pmod_apply (me1, me2) ->
          SourceMap (me2.pmod_loc, (self#simple_module_expr me2))::
            (functorApplicationList me1)
      | _ -> SourceMap (xx.pmod_loc, (self#module_expr xx))::[]
    in
    (List.rev (functorApplicationList x), None)


  (*

     Watch out, if you see something like below (sixteenTuple getting put on a
     newline), yet a paren-wrapped list wouldn't have had an extra newlin, you
     might need to wrap the single token (sixteenTuple) in [ensureSingleTokenSticksToLabel].
     let (
        axx,
        oxx,
        pxx
      ):
        sixteenTuple = echoTuple (
        0,
        0,
        0
      );
  *)

  method formatSimplePatternBinding labelOpener layoutPattern typeConstraint appTerms =
    let letPattern = label ~break:`Never ~space:true (atom labelOpener) layoutPattern in
    let upUntilEqual =
      match typeConstraint with
        | None -> letPattern
        | Some tc -> formatTypeConstraint letPattern tc
    in
    let includingEqual = makeList ~postSpace:true [upUntilEqual; atom "="] in
    formatAttachmentApplication applicationFinalWrapping (Some (true, includingEqual)) appTerms

  (* Only formats a type annotation for a value binding. *)
  method formatSimpleSignatureBinding labelOpener bindingPattern typeConstraint =
    let letPattern = (label ~space:true (atom labelOpener) bindingPattern) in
    (formatTypeConstraint letPattern typeConstraint)


  (*
     The [bindingLabel] is either the function name (if let binding) or first
     arg (if lambda).

     For defining layout of the following form:

         lbl one
             two
             constraint => {
           ...
         }

     If using "=" as the arrow, can also be used for:

         met private
             myMethod
             constraint = fun ...

   *)
  method wrapCurriedFunctionBinding
         ?(attachTo)
         ?(arrow="=>")
         prefixText
         bindingLabel
         patternList
         returnedAppTerms =
    let allPatterns = bindingLabel::patternList in
    let partitioning = curriedFunctionFinalWrapping allPatterns in
    let everythingButReturnVal = match settings.returnStyle with
        (*
         Because align_closing is set to false, you get:

         (Brackets[] inserted to show boundaries between open/close of pattern list)
         let[firstThing
             secondThing
             thirdThing]

         It only wraps to indent four by coincidence: If the "opening" token was
         longer, you'd get:

         letReallyLong[firstThing
                       secondThing
                       thirdThing]

         For curried let bindings, we stick the arrow in the *last* pattern:
         let[firstThing
             secondThing
             thirdThing =>]

         But it could have just as easily been the "closing" token corresponding to
         "let". This works because we have [align_closing = false]. The benefit of
         shoving it in the last pattern, is that we can turn [align_closing = true]
         and still have the arrow stuck to the last pattern (which is usually what we
         want) (See modeTwo below).
      *)
      | ReturnValOnSameLine -> (
          match partitioning with
            | None ->
                (* We want the binding label to break *with* the arguments. Again,
                   there's no apparent way to add additional indenting for the
                   args with this setting. *)

                (**
                   Formats lambdas by treating the first pattern as the
                   "bindingLabel" which is kind of strange in some cases (when
                   you only have one arg that wraps)...

                      echoTheEchoer (
                        fun (
                              a,
                              p
                            ) => (
                          a,
                          b
                        )

                   But it makes sense in others (where you have multiple args):

                      echoTheEchoer (
                        fun (
                              a,
                              p
                            )
                            mySecondArg
                            myThirdArg => (
                          a,
                          b
                        )

                   Try any other convention for wrapping that first arg and it
                   won't look as balanced when adding multiple args.

                *)
              makeList
                ~pad:(true, true)
                ~wrap:(prefixText, arrow)
                ~indent:(settings.space * settings.indentWrappedPatternArgs)
                ~postSpace:true
                ~inline:(true, true)
                ~break:IfNeed
                allPatterns
            | Some (attachedList, wrappedListy) ->
                (* To get *only* the final argument to "break", while not
                   necessarily breaking the prior arguments, we dock everything
                   but the last item to a created label *)
              label
                ~space:true
                (
                  makeList
                    ~pad:(true, true)
                    ~wrap:(prefixText, arrow)
                    ~indent:(settings.space * settings.indentWrappedPatternArgs)
                    ~postSpace:true
                    ~inline:(true, true)
                    ~break:IfNeed
                    attachedList
                )
                wrappedListy
        )
    in

    let everythingButAppTerms = match attachTo with
      | None -> everythingButReturnVal
      | Some toThis -> label ~space:true toThis everythingButReturnVal
    in
    formatAttachmentApplication
      applicationFinalWrapping
      (Some (true, everythingButAppTerms))
      returnedAppTerms

  method leadingCurriedAbstractTypes x =
    let rec argsAndReturn xx =
      match xx.pexp_desc with
        | Pexp_newtype (str,e) ->
            let (nextArgs, return) = argsAndReturn e in
            (str::nextArgs, return)
        | _ -> ([], xx.pexp_desc)
    in argsAndReturn x

  method curriedConstructorPatternsAndReturnVal cl =
    let rec argsAndReturn xx =
      if xx.pcl_attributes <> [] then ([], xx)
      else match xx.pcl_desc with
      | Pcl_fun (label, eo, p, e) ->
        let (nextArgs, return) = argsAndReturn e in
        if label="" then
          let args = SourceMap (p.ppat_loc, (self#simple_pattern p))::nextArgs in
          (args, return)
        else
          let args = SourceMap (p.ppat_loc, (self#label_exp (label, eo, p)))::nextArgs in
          (args, return)
      | _ -> ([], xx)
    in argsAndReturn cl


  (*
    Returns the arguments list (if any, that occur before the =>), and the
    final expression (that is either returned from the function (after =>) or
    that is bound to the value (if there are no arguments, and this is just a
    let pattern binding)).
  *)
  method curriedPatternsAndReturnVal x =
    let rec argsAndReturn xx =
      if xx.pexp_attributes <> [] then ([], xx)
      else match xx.pexp_desc with
        (* label * expression option * pattern * expression *)
        | Pexp_fun (label, eo, p, e) ->
            let (nextArgs, return) = argsAndReturn e in
            if label="" then
              let args = SourceMap (p.ppat_loc, (self#simple_pattern p))::nextArgs in
              (args, return)
            else
              let args = SourceMap (p.ppat_loc, (self#label_exp (label, eo, p)))::nextArgs in
              (args, return)
        | Pexp_newtype (str,e) ->
           let typeParamLayout = atom ("(type " ^ str ^ ")") in
           let (nextArgs, return) = argsAndReturn e in
           ((typeParamLayout)::nextArgs, return)
        | _ -> ([], xx)
    in argsAndReturn x

  (* Returns the (curriedModule, returnStructure) for a functor *)
  method curriedFunctorPatternsAndReturnStruct me = match me.pmod_desc with
    (* string loc * module_type option * module_expr *)
    | Pmod_functor(s, mt, me2) ->
        let firstOne =
          match mt with
            | None -> atom "()"
            | Some mt' -> makeList ~wrap:("(",")") ~break:IfNeed [formatTypeConstraint (atom s.txt) (self#module_type mt')]
        in
        let (functorArgsRecurse, returnStructure) = (self#curriedFunctorPatternsAndReturnStruct me2) in
        (firstOne::functorArgsRecurse, returnStructure)
    | _ -> ([], me)

  method isRenderableAsPolymorphicAbstractTypes
         typeVars
         polyType
         leadingAbstractVars
         nonVarifiedType =
      same_ast_modulo_varification_and_extensions polyType nonVarifiedType &&
      trueForEachPair typeVars leadingAbstractVars (fun x y -> String.compare x y == 0)
  (* Reinterpret this as a pattern constraint since we don't currently have a
     way to disambiguate. There is currently a way to disambiguate a parsing
     from Ppat_constraint vs.  Pexp_constraint. Currently (and consistent with
     OCaml standard parser):

       let (x: typ) = blah;
         Becomes Ppat_constraint
       let x:poly . type = blah;
         Becomes Ppat_constraint
       let x:typ = blah;
         Becomes Pexp_constraint(ghost)
       let x = (blah:typ);
         Becomes Pexp_constraint(ghost)

     How are double constraints represented?
     let (x:typ) = (blah:typ);
     If currently both constraints are parsed into a single Pexp_constraint,
     then something must be lost, and how could you fail type checking on:
     let x:int = (10:string) ?? Answer: It probably parses into a nested
     Pexp_constraint.

     Proposal:

       let (x: typ) = blah;
         Becomes Ppat_constraint   (still)
       let x:poly . type = blah;
         Becomes Ppat_constraint   (still)
       let x:typ = blah;
         Becomes Ppat_constraint
       let x = blah:typ;
         Becomes Pexp_constraint


     Reasoning: Allows parsing of any of the currently valid ML forms, but
     combines the two most similar into one form. The only lossyness is the
     unnecessary parens, which there is already precedence for dropping in
     expressions. In the existing approach, preserving a paren-constrained
     expression is *impossible* because it becomes pretty printed as
     let x:t =.... In the proposal, it is not impossible - it is only
     impossible to preserve unnecessary parenthesis around the let binding.

     The one downside is that integrating with existing code that uses [let x =
     (blah:typ)] in standard OCaml will be parsed as a Pexp_constraint. There
     might be some lossiness (beyond parens) that occurs in the original OCaml
     parser.
  *)

  method locallyAbstractPolymorphicFunctionBinding prefixText layoutPattern funWithNewTypes absVars bodyType =
    let appTerms = self#unparseExprApplicationItems funWithNewTypes in
    let locallyAbstractTypes = (List.map atom absVars) in
    let typeLayout =
      SourceMap (bodyType.ptyp_loc, (self#core_type bodyType)) in
    let polyType =
      label
        ~space:true
        (* TODO: This isn't a correct use of sep! It ruins how
         * comments are interleaved. *)
        (makeList [makeList ~sep:" " (atom "type"::locallyAbstractTypes); atom "."])
        typeLayout
      in
    self#formatSimplePatternBinding
      prefixText
      layoutPattern
      (Some polyType)
      appTerms

  (**
      Intelligently switches between:
      Curried function binding w/ constraint on return expr:
         lbl patt
             pattAux
             arg
             :constraint => {
           ...
         }

      Constrained:
         lbl patt
             pattAux...
             :constraint = {
           ...
         }
   *)
  method wrappedBinding prefixText pattern patternAux expr =
    let (argsList, return) = self#curriedPatternsAndReturnVal expr in
    let patternList =
      match patternAux with
        | [] -> pattern
        | _::_ -> makeList ~postSpace:true ~inline:(true, true) ~break:IfNeed (pattern::patternAux)
    in
    match (argsList, return.pexp_desc) with
      | ([], Pexp_constraint (e, ct)) ->
          let typeLayout = SourceMap (ct.ptyp_loc, (self#core_type ct)) in
          let appTerms = self#unparseExprApplicationItems e in
          self#formatSimplePatternBinding prefixText patternList (Some typeLayout) appTerms
      | ([], _) ->
          let appTerms = self#unparseExprApplicationItems expr  in
          self#formatSimplePatternBinding prefixText patternList None appTerms
      | (_::_, _) ->
          let (argsWithConstraint, actualReturn) = self#normalizeFunctionArgsConstraint argsList return in
          let fauxArgs =
            List.concat [patternAux; argsWithConstraint] in
          let returnedAppTerms = self#unparseExprApplicationItems actualReturn in
          self#wrapCurriedFunctionBinding prefixText pattern fauxArgs returnedAppTerms

  (* Similar to the above method. *)
  method wrappedClassBinding prefixText pattern patternAux expr =
    let (argsList, return) = self#curriedConstructorPatternsAndReturnVal expr in
    let patternList =
      match patternAux with
        | [] -> pattern
        | _::_ -> makeList ~postSpace:true ~inline:(true, true) ~break:IfNeed (pattern::patternAux)
    in
    match (argsList, return.pcl_desc) with
      | ([], Pcl_constraint (e, ct)) ->
          let typeLayout = SourceMap (ct.pcty_loc, (self#class_constructor_type ct)) in
          let appTerms = self#classExpressionToFormattedApplicationItems e in
          self#formatSimplePatternBinding prefixText patternList (Some typeLayout) appTerms
      | ([], _) ->
          let appTerms = self#classExpressionToFormattedApplicationItems expr in
          self#formatSimplePatternBinding prefixText patternList None appTerms
      | (_::_, _) ->
          let (argsWithConstraint, actualReturn) =
            self#normalizeConstructorArgsConstraint argsList return in
          let returnedAppTerms = self#classExpressionToFormattedApplicationItems actualReturn in
          let fauxArgs =
            List.concat [patternAux; argsWithConstraint] in
          self#wrapCurriedFunctionBinding prefixText pattern fauxArgs returnedAppTerms

  method binding {pvb_pat; pvb_expr=x} prefixText = (* TODO: print attributes *)
    match (pvb_pat.ppat_desc) with
      | (Ppat_var {txt}) ->
          let pattern = SourceMap (pvb_pat.ppat_loc, self#simple_pattern pvb_pat) in
          self#wrappedBinding prefixText pattern [] x
      (*
         Ppat_constraint is used in bindings of the form

            let (inParenVar:typ) = ...

         And in the case of let bindings for explicitly polymorphic type
         annotations (see parser for more details).

         See reason_parser.mly for explanation of how we encode the two primary
         forms of explicit polymorphic annotations in the parse tree, and how
         we must recover them here.
       *)
      | (Ppat_constraint(p, ty)) -> (
          (* Locally abstract forall types are *seriously* mangled by the parsing
             stage, and we have to be very smart about how to recover it.

              let df_locallyAbstractFuncAnnotated:
                type a b.
                  a =>
                  b =>
                  (inputEchoRecord a, inputEchoRecord b) =
                fun (input: a) (input2: b) => (
                  {inputIs: input},
                  {inputIs: input2}
                );

             becomes:

               let df_locallyAbstractFuncAnnotatedTwo:
                 'a 'b .
                 'a => 'b => (inputEchoRecord 'a, inputEchoRecord 'b)
                =
                 fun (type a) (type b) => (
                   fun (input: a) (input2: b) => ({inputIs: input}, {inputIs:input2}):
                     a => b => (inputEchoRecord a, inputEchoRecord b)
                 );
          *)
          let layoutPattern =
            SourceMap (pvb_pat.ppat_loc, (self#simple_pattern p)) in
          let leadingAbsTypesAndExpr = self#leadingCurriedAbstractTypes x in
          match (p.ppat_desc, ty.ptyp_desc, leadingAbsTypesAndExpr) with
            | (
                Ppat_var s,
                Ptyp_poly (typeVars, varifiedPolyType),
                (_::_ as absVars, Pexp_constraint(funWithNewTypes, nonVarifiedExprType))
              )
              when self#isRenderableAsPolymorphicAbstractTypes
                  typeVars
                  (* If even artificially varified - don't know until returns*)
                  varifiedPolyType
                  absVars
                  nonVarifiedExprType ->
              (*
                 We assume was the case whenever we see this pattern in the
                 AST, it was because the parser parsed the polymorphic locally
                 abstract type sugar.

                 Ppat_var..Ptyp_poly...Pexp_constraint:

                    let x: 'a 'b . 'a => 'b => 'b =
                      fun (type a) (type b) =>
                         (fun aVal bVal => bVal : a => b => b);

                 We need to be careful not to accidentally detect similar
                 forms, that cannot be printed as sugar.

                    let x: 'a 'b . 'a => 'b => 'b =
                      fun (type a) (type b) =>
                         (fun aVal bVal => bVal : int => int => int);

                 Should *NOT* be formatted as:

                    let x: type a b. int => int => int = fun aVal bVal => bVal;

                 The helper function
                 [same_ast_modulo_varification_and_extensions] was created to
                 help compare the varified constraint pattern body, and the
                 non-varified expression constraint type.

                 The second requirement that we check before assuming that the
                 sugar form is correct, is to make sure the list of type vars
                 corresponds to a leading prefix of the Pexp_newtype variables.
              *)
              self#locallyAbstractPolymorphicFunctionBinding
                prefixText
                layoutPattern
                funWithNewTypes
                absVars
                nonVarifiedExprType
            | _ ->
              let typeLayout = SourceMap (ty.ptyp_loc, (self#core_type ty)) in
              let appTerms = self#unparseExprApplicationItems x in
              self#formatSimplePatternBinding
                prefixText
                layoutPattern
                (Some typeLayout)
                appTerms
        )
      | (_) ->
          let layoutPattern =
            SourceMap (pvb_pat.ppat_loc, (self#pattern pvb_pat)) in
          let appTerms = self#unparseExprApplicationItems x in
          self#formatSimplePatternBinding prefixText layoutPattern None appTerms


  (* Ensures that the constraint is formatted properly for sake of function
     binding (formatted without arrows)
     let x y z : no_unguareded_arrows_allowed_here => ret;
   *)
  method normalizeFunctionArgsConstraint argsList return =
    match return.pexp_desc with
      | Pexp_constraint (e, ct) ->
        let typeLayout = SourceMap (ct.ptyp_loc, (self#non_arrowed_non_simple_core_type ct)) in
        (argsList@[formatJustTheTypeConstraint typeLayout], e)
      | _ -> (argsList, return)

  method normalizeConstructorArgsConstraint argsList return =
    match return.pcl_desc with
      | Pcl_constraint (e, ct) when return.pcl_attributes = [] ->
        let typeLayout = SourceMap (ct.pcty_loc, (self#non_arrowed_class_constructor_type ct)) in
        (argsList@[formatJustTheTypeConstraint typeLayout], e)
      | _ -> (argsList, return)

  method bindingsLocationRange l =
    let len = List.length l in
    let fstLoc = (List.nth l 0).pvb_loc in
    let lstLoc = (List.nth l (len - 1)).pvb_loc in
    {
      loc_start = fstLoc.loc_start;
      loc_end = lstLoc.loc_end;
      loc_ghost = false
    }

  method bindings (rf, l) =
    let firstLine = (
      match l with
        | [] -> raise (NotPossible "no bindings supplied")
        | x::[]
        | x::_ ->
          let label = match rf with
            | Nonrecursive -> "let"
            | Recursive -> "let rec" in
          SourceMap (x.pvb_loc, (self#binding x label))

    ) in
    let forEachRemaining = fun t -> SourceMap (t.pvb_loc, (self#binding t "and")) in
    let remainingBindings = (
      match l with
        | [] -> []
        | x::[] -> []
        | x::x2::xtl -> List.map forEachRemaining (x2::xtl)
    ) in
    match remainingBindings with
    | [] -> firstLine
    | _ ->
    makeList
      ~postSpace:true
      ~break:Always
      ~indent:0
      ~inline:(true, true)
      (firstLine::remainingBindings)

  method letList exprTerm =
    match (exprTerm.pexp_attributes, exprTerm.pexp_desc) with
      | ([], Pexp_let (rf, l, e)) ->
        (* For "letList" bindings, the start/end isn't as simple as with
         * module value bindings. For "let lists", the sequences were formed
         * within braces {}. The parser relocates the first let binding to the
         * first brace. *)
         let bindingsLayout = (self#bindings (rf, l)) in
         let bindingsLoc = self#bindingsLocationRange l in
         let bindingsSourceMapped = SourceMap (bindingsLoc, bindingsLayout) in
         bindingsSourceMapped::(self#letList e)
      | ([], Pexp_open (ovf, lid, e)) ->
        let listItems = (self#letList e) in
        if (List.length listItems == 1) && ovf == Fresh then
            (* The following logic is a syntax sugar
             * for an 'open' expression that has only one let item.
             *
             * Instead of printing:
             * let result =  {
             *   open Fmt;
             *   strf
             *     "-pkgs %a"
             *     (list sep::(unit ",") string)
             * }
             *
             * We format as:
             *
             * let result = Fmt.(strf "-pkgs %a" (list sep::(unit ",") string))
             *
             * (Also see https://github.com/facebook/Reason/issues/114)
             *)
            let expression = match e.pexp_desc with
                (* syntax sugar for M.{x:1} *)
                | Pexp_record _
                (* syntax sugar for M.(a, b) *)
                | Pexp_tuple _
                (* syntax sugar for M.{} *)
                | Pexp_object {pcstr_fields = []}
                (* syntax sugar for M.[x,y] *)
                | Pexp_construct ( {txt= Lident"::"},Some _) ->
                    (self#simplifyUnparseExpr e)
                (* syntax sugar for the rest, wrap with parens to avoid ambiguity.
                 * E.g., avoid M.(M2.v) being printed as M.M2.v
                 *)
                | _ ->
                    (makeList ~wrap:("(",")") ~break:IfNeed listItems)
            in
            let openLayout = label
              (label (self#longident_loc lid) (atom (".")))
              expression
            in [openLayout]
         else
            let overrideStr = match ovf with | Override -> "!" | Fresh -> "" in
            let openLayout = label ~space:true
              (atom ("open" ^ overrideStr))
              (self#longident_loc lid)
            in
            (* Just like the bindings, have to synthesize a location since the
             * Pexp location is parsed (potentially) beginning with the open
             * brace {} in the let sequence. *)
            let openSourceMapped = SourceMap (lid.loc, openLayout) in
            openSourceMapped::listItems
      | ([], Pexp_letmodule (s, me, e)) ->
          let prefixText = "module" in
          let bindingName = atom ~loc:s.loc s.txt in
          let moduleExpr = me in
          let letModuleLayout =
            (self#let_module_binding prefixText bindingName moduleExpr) in
          let letModuleLoc = {
            loc_start = s.loc.loc_start;
            loc_end = me.pmod_loc.loc_end;
            loc_ghost = false
          } in
          (* Just like the bindings, have to synthesize a location since the
           * Pexp location is parsed (potentially) beginning with the open
           * brace {} in the let sequence. *)
          let letModuleSourceMapped = SourceMap (letModuleLoc, letModuleLayout) in
           letModuleSourceMapped::(self#letList e)
      | ([], Pexp_sequence (({pexp_desc=Pexp_sequence _ }) as e1, e2))
      | ([], Pexp_sequence (({pexp_desc=Pexp_let _      }) as e1, e2))
      | ([], Pexp_sequence (({pexp_desc=Pexp_open _     }) as e1, e2))
      | ([], Pexp_sequence (({pexp_desc=Pexp_letmodule _}) as e1, e2))
      | ([], Pexp_sequence (e1, e2)) ->
          let e1Layout = (self#unparseExpr e1) in
          (* It's kind of difficult to synthesize a location here in the case
           * where this is the first expression in the braces. We could consider
           * deeply inspecting the leftmost token/term in the expression. *)
          let e1SourceMapped = SourceMap (e1.pexp_loc, e1Layout) in
          e1SourceMapped::(self#letList e2)
      | _ ->
          let exprTermLayout = (self#unparseExpr exprTerm) in
          let exprTermSourceMapped = SourceMap (exprTerm.pexp_loc, exprTermLayout) in
          (* Should really do something to prevent infinite loops here. Never
             allowing a top level call into letList to recurse back to
             self#unparseExpr- top level calls into letList *must* be one of the
             special forms above whereas lower level recursive calls may be of
             any form. *)
          [exprTermSourceMapped]

  method constructor_expression ?(polyVariant=false) ~arityIsClear stdAttrs ctor eo =
    let (implicit_arity, arguments) =
      match eo.pexp_desc with
        | Pexp_tuple l when not polyVariant -> (
            let exprs = match (List.map self#simplifyUnparseExpr l) with
              | [] -> raise (NotPossible "no tuple items")
              | hd::[] -> hd
              | hd::tl as all -> makeSpacedBreakableInlineList all
            in
            (* There is no ambiguity when the number of tuple components is 1.
               We don't need put implicit_arity in that case *)
            (List.length l > 1 && not arityIsClear, exprs)
          )
        | _ -> (false, self#simplifyUnparseExpr eo)
    in
    let construction =
      label ~space:true
        ctor
        (if isSequencey arguments then arguments else (ensureSingleTokenSticksToLabel arguments))
    in
    let attrs =
      if implicit_arity && (not polyVariant) then
        ({txt="implicit_arity"; loc=eo.pexp_loc}, PStr []) :: stdAttrs
      else
        stdAttrs
    in
    match attrs with
      | [] -> construction
      | _::_ -> formatAttributed construction (self#attributes attrs)

  (* TODOATTRIBUTES: Handle stdAttrs here (merge with implicit_arity) *)
  method constructor_pattern ?(polyVariant=false) ~arityIsClear ctor po =
    let (implicit_arity, arguments) =
      match po.ppat_desc with
        | Ppat_tuple l when not polyVariant ->
            let exprs = match (List.map self#simple_pattern l) with
              | [] -> raise (NotPossible "no tuple items")
              | [hd] -> hd
              | hd::tl as all -> makeSpacedBreakableInlineList all
            in
              (* There is no ambiguity when the number of tuple components is 1.
               We don't need put implicit_arity in that case *)
            (List.length l > 1 && not arityIsClear, exprs)
        | _ -> (false, self#simple_pattern po)
    in
    let construction = label ~space:true
      ctor
      (if isSequencey arguments then arguments else (ensureSingleTokenSticksToLabel arguments)) in
    if implicit_arity && (not polyVariant) then
      formatAttributed construction (self#attributes [({txt="implicit_arity"; loc=po.ppat_loc}, PStr [])])
    else
      construction

  method patternFunction loc l =
    let estimatedFunLocation = {
        loc_start = loc.loc_start;
        loc_end = {loc.loc_start with pos_cnum = loc.loc_start.Lexing.pos_cnum + 3};
        loc_ghost = false;
    } in
    makeList
      ~postSpace:true
      ~break:IfNeed
      ~inline:(true, true)
      ~pad:(false, false)
      ((atom ~loc:estimatedFunLocation "fun") :: (self#case_list l))

  (* Expressions requiring parens, in most contexts such as separated by infix *)
  method expression_requiring_parens_in_infix x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.pexp_attributes in
    assert (stdAttrs == []);
    match x.pexp_desc with
      (* The only reason Pexp_fun must also be wrapped in parens when under
         pipe, is that its => token will be confused with the match token.
         Simple expression will also invoke `#reset`. *)
      | Pexp_function _ when pipe || semi -> None (* Would be rendered as simplest_expression  *)
      | Pexp_function l -> Some (self#patternFunction x.pexp_loc l)
      | _ ->
        (* The Pexp_function cases above don't use location because comment printing
          breaks for them. *)
        let itm = match x.pexp_desc with
          | Pexp_fun _
          | Pexp_newtype _ ->
            let (args, ret) = self#curriedPatternsAndReturnVal x in
            (match args with
            | [] -> raise (NotPossible ("no arrow args in unparse "))
            | firstArg::tl ->
              (* Suboptimal printing of parens:

                    something >>= fun x => x + 1;

                 Will be printed as:

                    something >>= (fun x => x + 1);

                 Because the arrow has lower precedence than >>=, but it wasn't
                 needed because

                    (something >>= fun x) => x + 1;

                 Is not a valid parse. Parens around the `=>` weren't needed to
                 prevent reducing instead of shifting. To optimize this part, we need
                 a much deeper encoding of the parse rules to print parens only when
                 needed, testing which rules will be reduced. It really should be
                 integrated deeply with Menhir.

                 One question is, if it's this difficult to describe when parens are
                 needed, should we even print them with the minimum amount?  We can
                 instead model everything as "infix" with ranked precedences.  *)
              let retValUnparsed = self#unparseExprApplicationItems ret in
              Some (self#wrapCurriedFunctionBinding "fun" firstArg tl retValUnparsed)
            )
          | Pexp_try (e, l) ->
            let estimatedBracePoint = {
              loc_start = e.pexp_loc.loc_end;
              loc_end = x.pexp_loc.loc_end;
              loc_ghost = false;
            }
            in
            let cases = (self#case_list ~allowUnguardedSequenceBodies:true l) in
            let switchWith = label ~space:true (atom "try") (self#reset#simplifyUnparseExpr e) in
            Some (
              label
                ~space:true
                switchWith
                (SourceMap (estimatedBracePoint, (makeList ~indent:settings.trySwitchIndent ~wrap:("{", "}") ~break:Always_rec ~postSpace:true cases)))
            )
          (* These should have already been handled and we should never havgotten this far. *)
          | Pexp_setinstvar (s, e) -> raise (Invalid_argument "Cannot handle setinstvar here - call unparseExpr")
          | Pexp_setfield (_, _, _) -> raise (Invalid_argument "Cannot handle setfield here - call unparseExpr")
          | Pexp_apply (e, l) -> raise (Invalid_argument "Cannot handle apply here - call unparseExpr")
          | Pexp_match (e, l) ->
             let estimatedBracePoint = {
               loc_start = e.pexp_loc.loc_end;
               loc_end = x.pexp_loc.loc_end;
               loc_ghost = false;
             }
             in
             let cases = (self#case_list ~allowUnguardedSequenceBodies:true l) in
             let switchWith = label ~space:true (atom "switch") (self#reset#simplifyUnparseExpr e) in
             let lbl =
               label
                 ~space:true
                 switchWith
                 (SourceMap (estimatedBracePoint, (makeList ~indent:settings.trySwitchIndent ~wrap:("{", "}") ~break:Always_rec ~postSpace:true cases)))
             in
             Some lbl
          | Pexp_ifthenelse (e1, e2, eo) ->
            let (blocks, finalExpression) = sequentialIfBlocks eo in
            let rec singleExpression exp =
              match exp.pexp_desc with
              | Pexp_ident _ -> true
              | Pexp_constant _ -> true
              | Pexp_construct (_, arg) ->
                (match arg with
                | None -> true
                | Some x -> singleExpression x)
              | _ -> false
            in
            let singleLineIf =
              (singleExpression e1) &&
              (singleExpression e2) &&
              (match eo with
               | Some expr -> singleExpression expr
               | None -> true
              )
            in
            let makeLetSequence =
              if singleLineIf then
                makeLetSequenceSingleLine
              else
                makeLetSequence
            in
            let rec sequence soFar remaining = (
              match (remaining, finalExpression) with
                | ([], None) -> soFar
                | ([], Some e) ->
                  let soFarWithElseAppended = makeList ~postSpace:true [soFar; atom "else"] in
                  label ~space:true soFarWithElseAppended (makeLetSequence (self#letList e))
                | (hd::tl, _) ->
                  let (e1, e2) = hd in
                  let soFarWithElseIfAppended =
                    label
                      ~space:true
                      (makeList ~postSpace:true [soFar; atom "else if"])
                      (self#simplifyUnparseExpr e1)
                  in
                  let nextSoFar =
                    label ~space:true soFarWithElseIfAppended (makeLetSequence (self#letList e2)) in
                  sequence nextSoFar tl
            ) in
            let init =
              label
                ~space:true
                (SourceMap (e1.pexp_loc, (label ~space:true (atom "if") (self#simplifyUnparseExpr e1))))
                (makeLetSequence (self#letList e2)) in
            Some (sequence init blocks)
          | Pexp_while (e1, e2) ->
            let lbl =
              label
                ~space:true
                (label ~space:true (atom "while") (self#simplifyUnparseExpr e1))
                (makeLetSequence (self#letList e2)) in
            Some lbl
          | Pexp_for (s, e1, e2, df, e3) ->
            (*
             *  for longIdentifier in
             *      (longInit expr) to
             *      (longEnd expr) {
             *    print_int longIdentifier;
             *  };
             *)
            let identifierIn = (makeList ~postSpace:true [self#pattern s; atom "in";]) in
            let dockedToFor =
                (makeList
                  ~break:IfNeed
                  ~postSpace:true
                  ~inline:(true, true)
                  [
                    identifierIn;
                    makeList ~postSpace:true [self#simplifyUnparseExpr e1; self#direction_flag df];
                    (self#simplifyUnparseExpr e2);
                  ]
                )
            in
            let upToBody = makeList ~inline:(true, true) ~postSpace:true [atom "for"; dockedToFor] in
            Some (label ~space:true upToBody (makeLetSequence (self#letList e3)))
          | Pexp_new (li) ->
            Some (label ~space:true (atom "new") (self#longident_class_or_type_loc li))
          | Pexp_assert e ->
            Some (
              label ~space:true
                (atom "assert")
                (self#reset#simplifyUnparseExpr e);
            )
          | Pexp_lazy (e) ->
              Some (label ~space:true (atom "lazy") (self#simplifyUnparseExpr e))
          | Pexp_poly _ ->
            failwith (
              "This version of the pretty printer assumes it is impossible to " ^
              "construct a Pexp_poly outside of a method definition - yet it sees one."
            )
          | _ -> None
        in
        match itm with
          | None -> None
          | Some i -> Some (SourceMap (x.pexp_loc, i))

  method potentiallyConstrainedExpr x =
    match x.pexp_desc with
      | Pexp_constraint (e, ct) ->
          formatTypeConstraint (self#unparseExpr e) (self#core_type ct)
      | _ -> self#unparseExpr x


  (*
   * Because the rule BANG simple_expr was given %prec below_DOT_AND_SHARP,
   * !x.y.z will parse as !(x.y.z) and not (!x).y.z.
   *
   *     !x.y.z == !((x.y).z)
   *     !x#y#z == !((x#y)#z)
   *
   * So the intuition is: In general, any simple expression can exist to the
   * left of a `.`, except `BANG simple_expr`, which has special precedence,
   * and must be guarded in this one case.
   *
   * TODO: Instead of special casing this here, we should continue to extend
   * unparseExpr to also unparse simple expressions, (by encoding the
   * rules precedence below_DOT_AND_SHARP).
   *
   * TODO:
   *  Some would even have the prefix application be parsed with lower
   *  precedence function *application*. In the case of !, where ! means not,
   *  it makes a lot of sense because (!identifier)(arg) would be meaningless.
   *
   *  !callTheFunction(1, 2, 3)(andEvenCurriedArgs)
   *
   * Only problem is that it could then not appear anywhere simple expressions
   * would appear.
   *
   * We could make a special case for ! followed by one simple expression, and
   * consider the result simple.
   *
   * Alternatively, we can figure out a way to not require simple expressions
   * in the most common locations such as if/while tests. This is really hard
   * (impossible w/ grammars Menhir supports?)
   *
   * if ! myFunc argOne argTwo {
   *
   * } else {
   *
   * };
   *
   *)
  method simple_enough_to_be_lhs_dot_send x = match x.pexp_desc with
    | (Pexp_apply (eFun, _)) -> (
      match printedStringAndFixityExpr eFun with
        | AlmostSimplePrefix _ ->
          SourceMap (x.pexp_loc, formatPrecedence (self#simplifyUnparseExpr x))
        | UnaryPlusPrefix _
        | UnaryMinusPrefix _
        | Infix _
        | Normal -> self#simplifyUnparseExpr x
    )
    | _ -> self#simplifyUnparseExpr x

  method unparseRecord ?withStringKeys:(withStringKeys=false) ?allowPunning:(allowPunning=true) l eo =
    let quote = (atom "\"") in
    let maybeQuoteFirstElem fst rest =
        if withStringKeys then (match fst.txt with
          | Lident s -> quote::(atom s)::quote::rest
          | Ldot _  | Lapply _ -> assert false
          )
        else
          (self#longident_loc fst)::rest
    in
    let makeRow (li, e) appendComma shouldPun =
      let comma = atom "," in
      let totalRowLoc = {
        loc_start = li.Asttypes.loc.loc_start;
        loc_end = e.pexp_loc.loc_end;
        loc_ghost = false;
      } in
      let theRow =
        match e.pexp_desc with
          (* Punning *)
          |  Pexp_ident {txt} when li.txt = txt && shouldPun && allowPunning ->
              makeList (maybeQuoteFirstElem li (if appendComma then [comma] else []))
          | _ ->
             let (argsList, return) = self#curriedPatternsAndReturnVal e in (
               match (argsList, return.pexp_desc) with
                 | ([], _) ->
                   let appTerms = self#unparseExprApplicationItems e in
                   let upToColon = makeList (maybeQuoteFirstElem li [atom ":"]) in
                   let labelExpr =
                     formatAttachmentApplication
                       applicationFinalWrapping
                       (Some (true, upToColon))
                       appTerms in
                   if appendComma then
                     makeList [labelExpr; comma;]
                   else
                     labelExpr
                 | (firstArg::tl, _) ->
                   let upToColon = makeList (maybeQuoteFirstElem li [atom ":"]) in
                   let returnedAppTerms = self#unparseExprApplicationItems return in
                   let labelExpr =
                       (self#wrapCurriedFunctionBinding ~attachTo:upToColon "fun" firstArg tl returnedAppTerms) in
                   if appendComma then makeList [labelExpr; comma;] else labelExpr
             )
      in SourceMap (totalRowLoc, theRow)
    in
    let rec getRows l =
      match l with
        | [] -> []
        | hd::[] -> [makeRow hd false true]
        | hd::hd2::tl -> (makeRow hd true true)::(getRows (hd2::tl))
    in

    let allRows = match eo with
      | None -> (
        match l with
          (* No punning (or comma) for records with only a single field. *)
          (* See comment in parser.mly for lbl_expr_list_with_at_least_one_non_punned_field *)
          | [hd] -> [makeRow hd false false]
          | _ -> getRows l
        )
      | Some withRecord ->
        let firstRow = (
          (* Unclear why "sugar_expr" was special cased here. *)
          let appTerms = self#unparseExprApplicationItems withRecord in
          let firstRowContents =
            formatAttachmentApplication applicationFinalWrapping (Some (false, (atom "..."))) appTerms in
          if l == [] then firstRowContents else makeList [firstRowContents; atom ","]
        ) in
        SourceMap (withRecord.pexp_loc, firstRow)::(getRows l)
    in
    makeList ~wrap:("{", "}") ~break:IfNeed ~preSpace:true allRows

  method simplest_expression x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.pexp_attributes in
    if stdAttrs <> [] then
      None
    else
      let item = match x.pexp_desc with
        (* The only reason Pexp_fun must also be wrapped in parens is that its =>
           token will be confused with the match token. *)
        | Pexp_fun _ when pipe || semi -> Some (self#reset#simplifyUnparseExpr x)
        | Pexp_function l when pipe || semi -> Some (formatPrecedence ~loc:x.pexp_loc (self#reset#patternFunction x.pexp_loc l))
        | Pexp_apply (e, l) -> (
          match self#simple_get_application x with
          (* If it's the simple form of application. *)
          | Some simpleGet -> Some simpleGet
          | None -> None
        )
        | Pexp_object cs ->
          let obj =
            makeList
              ~sep:";"
              ~wrap:("{", "}")
              ~break:IfNeed
              ~postSpace:true
              ~inline:(true, false)
              (self#class_self_pattern_and_structure cs) in
          Some obj
        | Pexp_override l -> (* FIXME *)
          let string_x_expression (s, e) =
            label ~space:true (atom (s.txt ^ ":")) (self#unparseExpr e)
          in
          Some (
            makeList
              ~postSpace:true
              ~wrap:("{<", ">}")
              ~sep:","
              (List.map string_x_expression l)
          )
        | Pexp_construct _  when is_simple_construct (view_expr x) ->
            let hasJsxAttribute = jsxAttrs != [] in
            Some (
              match view_expr x with
              | `nil -> if hasJsxAttribute then atom "<> </>" else atom "[]"
              | `tuple -> atom "()"
              | `list xs -> (* LIST EXPRESSION *)
                if hasJsxAttribute then
                  let actualChildren =
                    match self#formatChildren xs [] with
                    | None -> []
                    | Some ch -> ch
                  in
                    makeList
                      ~break:IfNeed
                      ~inline:(false, false)
                      ~postSpace:true
                      ~wrap:("<>", "</>")
                      ~pad:(true, true)
                      actualChildren
                else
                  makeList ~break:IfNeed ~wrap:("[", "]") ~sep:"," ~postSpace:true (List.map self#unparseExpr xs)
              | `cons xs ->
                let seq, ext = match List.rev xs with
                  | ext :: seq_rev -> (List.rev seq_rev, ext)
                  | [] -> assert false in
                 makeES6List (List.map self#unparseExpr seq) (self#unparseExpr ext)
              | `simple x -> self#longident x
              | _ -> assert false
            )
        | Pexp_ident li ->
            (* Lone identifiers shouldn't break when to the right of a label *)
            Some (ensureSingleTokenSticksToLabel (self#longident_loc li))
        | Pexp_constant c ->
            (* Constants shouldn't break when to the right of a label *)
            Some (ensureSingleTokenSticksToLabel (self#constant c))
        | Pexp_pack me ->
          Some (
            makeList
              ~break:IfNeed
              ~postSpace:true
              ~wrap:("(", ")")
              ~inline:(true, true)
              [atom "module"; self#module_expr me;]
          )
        | Pexp_tuple l ->
            (* TODO: These may be simple, non-simple, or type constrained
               non-simple expressions *)
          Some (
            makeList
              ~wrap:("(", ")")
              ~sep:","
              ~break:IfNeed
              ~postSpace:true
              (List.map self#potentiallyConstrainedExpr l)
          )
        | Pexp_constraint (e, ct) ->
          Some (
            makeList
              ~break:IfNeed
              ~wrap:("(", ")")
              [formatTypeConstraint (self#unparseExpr e) (self#core_type ct)]
          )
        | Pexp_coerce (e, cto1, ct) ->
            let optFormattedType = match cto1 with
              | None -> None
              | Some typ -> Some (self#core_type typ) in
            Some (
              makeList
                ~break:IfNeed
                ~wrap:("(", ")")
                [formatCoerce (self#unparseExpr e) optFormattedType (self#core_type ct)]
            )
        | Pexp_variant (l, None) ->
            Some (ensureSingleTokenSticksToLabel (atom ("`" ^ l)))
        | Pexp_record (l, eo) -> Some (self#unparseRecord l eo)
        | Pexp_array (l) ->
          Some (
            makeList
              ~break:IfNeed
              ~sep:","
              ~postSpace:true
              ~wrap:("[|", "|]")
              (List.map self#unparseExpr l)
          )
        | Pexp_let (rf, l, e) ->
            Some (makeLetSequence (self#letList x))
        | Pexp_letmodule (s, me, e) ->
            Some (makeLetSequence (self#letList x))
        | Pexp_open (ovf, lid, e) ->
            let letItems = (self#letList x) in
            (match letItems with
                (* if an open expression has only one letItem in the list,
                 * we don't wrap it in "{}" so it becomes something like:
                 *
                 * let a = Fmt.(strf "-pkgs %a" (list sep::(unit ",") string))
                 *
                 * instead of:
                 *
                 * let a = {
                 *   Fmt.(strf "-pkgs %a" (list sep::(unit ",") string))
                 * }
                 *)
                | [item] -> Some item
                | _ -> Some (makeLetSequence letItems)
             )
        | Pexp_sequence _ ->
            Some (makeLetSequence (self#letList x))
        | Pexp_field (e, li) ->
          Some (label (makeList [self#simple_enough_to_be_lhs_dot_send e; atom "."]) (self#longident_loc li))
        | Pexp_send (e, s) ->
          Some (label (makeList [self#simple_enough_to_be_lhs_dot_send e; atom "#";]) (atom s))
        | Pexp_extension e -> Some (self#extension e)
        | _ -> None
      in
      match item with
        | None -> None
        | Some i -> Some (SourceMap (x.pexp_loc, i))

  method formatChildren children processedRev =
    match children with
    | {pexp_desc = Pexp_constant (constant)} :: remaining ->
      self#formatChildren remaining (self#constant constant :: processedRev)
    | {pexp_desc = Pexp_construct ({txt = Lident "::"}, Some {pexp_desc = Pexp_tuple(children)} )} :: remaining ->
      self#formatChildren (remaining @ children) processedRev
    | {pexp_desc = Pexp_apply(expr, l); pexp_attributes} :: remaining ->
      self#formatChildren remaining (self#simplifyUnparseExpr (List.hd children) :: processedRev)
    | {pexp_desc = Pexp_ident li} :: remaining ->
      self#formatChildren remaining (self#longident_loc li :: processedRev)
    | {pexp_desc = Pexp_construct ({txt = Lident "[]"}, None)} :: remaining -> self#formatChildren remaining processedRev
    | head :: remaining -> self#formatChildren remaining (self#simplifyUnparseExpr head :: processedRev)
    | [] -> match processedRev with
        | [] -> None
        | _::_ -> Some (List.rev processedRev)
  method direction_flag = function
    | Upto -> atom "to"
    | Downto -> atom "downto"

  method payload ppxToken ppxId e =
    let wrap = ("[" ^ ppxToken ^ ppxId.txt, "]") in
    let break = IfNeed in
    let pad = (true, false) in
    let postSpace = true in
    let sep = ";" in
    match e with
      | PStr [] -> atom ("[" ^ ppxToken  ^ ppxId.txt  ^ "]")
      | PStr [itm] -> makeList ~break ~wrap ~pad [self#structure_item itm]
      | PStr (_::_ as items) ->
        let rows = (List.map (self#structure_item) items) in
        makeList ~wrap ~break ~pad ~postSpace ~sep rows
      | PTyp x ->
        makeList ~wrap ~break ~pad [label ~space:true (atom ":") (self#core_type x)]
      (* Signatures in attributes were added recently *)
      (* | PSig x -> makeList [atom ":"; self#signature x] *)
      | PPat (x, None) ->
        makeList ~wrap ~break ~pad [label ~space:true (atom "?") (self#pattern x)]
      | PPat (x, Some e) ->
        makeList ~wrap ~break ~pad ~postSpace [
          label ~space:true (atom "?") (self#pattern x);
          label ~space:true (atom "when") (self#unparseExpr e)
        ]

  method extension (s, e) =
    match (s.txt) with
    (* We special case "bs.obj" for now to allow for a nicer interop with
     * BuckleScript. We might be able to generalize to any kind of record
     * looking thing with struct keys. *)
    | "bs.obj" -> (
      match e with
      | PStr [itm] -> (
        match itm with
        | {pstr_desc = Pstr_eval ({ pexp_desc = Pexp_record (l, eo) }, []) } ->
          self#unparseRecord ~withStringKeys:true ~allowPunning:false l eo
        | _ -> assert false
      )
      | _ -> assert false
    )
    | _ -> (self#payload "%" s e)

  method item_extension (s, e) = (self#payload "%%" s e)


  (* [@ ...] Simple attributes *)
  method attribute (s, e) = (self#payload "@" s e)

  (* [@@ ... ] Attributes that occur after a major item in a structure/class *)
  method item_attribute (s, e) = (self#payload "@@" s e)

  (* [@@@ ...] Attributes that occur not *after* an item in some structure/class/sig, but
     rather as their own standalone item. Note that syntactic distinction
     between item_attribute and floating_attribute is no longer necessary with
     Reason. Thank you semicolons. *)
  method floating_attribute (s, e) = (self#payload "@@@" s e)


  method attributes l =
	    makeList ~break:IfNeed ~postSpace:true (List.map self#attribute l)

  method attach_std_attrs l toThis =
    let l = extractStdAttrs l in
    match l with
      | [] -> toThis
      | _::_ -> makeList ~postSpace:true [toThis; (self#attributes l)]

  method attach_std_item_attrs l toThis =
    let l = extractStdAttrs l in
    match l with
      | [] -> toThis
      | _::_ ->
        makeList ~postSpace:true ~indent:0 ~break:IfNeed ~inline:(true, true) [
          toThis;
          makeList ~break:IfNeed ~postSpace:true (List.map self#item_attribute l);
        ]

  method exception_declaration ed =
    let pcd_name = ed.pext_name in
    let pcd_loc = ed.pext_loc in
    let pcd_attributes = ed.pext_attributes in
    let exn_arg = match ed.pext_kind with
      | Pext_decl (args, type_opt) ->
          let pcd_args, pcd_res = args, type_opt in
          [self#type_variant_leaf_nobar {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes}]
      | Pext_rebind id ->
          [atom pcd_name.txt; atom "="; (self#longident_loc id)] in
    makeList ~postSpace:true ((atom "exception")::exn_arg)

  (*
    Note: that override doesn't appear in class_sig_field, but does occur in
    class/object expressions.
    TODO: TODOATTRIBUTES
   *)
  method method_sig_flags_for s = function
    | Virtual -> [atom "virtual"; atom s]
    | Concrete ->  [atom s]

  method value_type_flags_for s = function
    | (Virtual, Mutable) -> [atom "virtual"; atom "mutable"; atom s]
    | (Virtual, Immutable) -> [atom "virtual"; atom s]
    | (Concrete, Mutable) -> [atom "mutable"; atom s]
    | (Concrete, Immutable) -> [atom s]

  method class_sig_field x =
    match x.pctf_desc with
    | Pctf_inherit (ct) ->
      label ~space:true (atom "inherit") (self#class_constructor_type ct)
    | Pctf_val (s, mf, vf, ct) ->
      let valueFlags = self#value_type_flags_for (s ^ ":") (vf, mf) in
      label
        ~space:true
        (
          label ~space:true
            (atom "val")
            (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed valueFlags)
        )
        (self#core_type ct)
    | Pctf_method (s, pf, vf, ct) ->
      let methodFlags = self#method_sig_flags_for (s ^ ":") vf
      in
      let pubOrPrivate =
        match pf with
        | Private -> "pri"
        | Public -> "pub"
      in
      let m = label
        ~space:true
        (label ~space:true
            (atom pubOrPrivate)
            (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed methodFlags)
        )
        (self#core_type ct)
      in
      (self#attach_std_item_attrs x.pctf_attributes m)
    | Pctf_constraint (ct1, ct2) ->
      label
        (atom "constraint")
        (label ~space:true
            (makeList ~postSpace:true [self#core_type ct1; atom "="])
            (self#core_type ct2)
        )
    | Pctf_attribute a -> self#floating_attribute a
    | Pctf_extension e -> self#item_extension e


  (* The type of something returned from a constructor. Formerly [class_signature]  *)
  method shouldDisplayClassInstTypeItem x = match x.pctf_desc with
    | Pctf_attribute (s, _) -> (not (s.txt = "ocaml.text") && not (s.txt = "ocaml.doc"))
    | _ -> true

  method shouldDisplayClassField x = match x.pcf_desc with
    | Pcf_attribute (s, _) -> (not (s.txt = "ocaml.text") && not (s.txt = "ocaml.doc"))
    | _ -> true

  method shouldDisplaySigItem x = match x.psig_desc with
    | Psig_attribute (s, _) -> (not (s.txt = "ocaml.text") && not (s.txt = "ocaml.doc"))
    | _ -> true

  method shouldDisplayStructureItem x = match x.pstr_desc with
    | Pstr_attribute (s, _) -> (not (s.txt = "ocaml.text") && not (s.txt = "ocaml.doc"))
    | _ -> true

  (*
    external render : reactElement => element => unit =   (* frstHalf *)
      "render" [@@bs.val] [@@bs.module "react-dom"];      (* sndHalf *)

    To improve the formatting with breaking & indentation:
      * consider the part before the '=' as a label
      * combine that label with '=' in a list
      * consider the part after the '=' as a list
      * combine both parts as a label
  *)
  method primitive_declaration vd =
    let attrs = List.map (fun x -> self#item_attribute x) vd.pval_attributes in
    let lblBefore =
      label ~space:true
        (makeList ~postSpace:true
          [atom "external"; protectIdentifier vd.pval_name.txt; atom ":"])
        (self#core_type vd.pval_type)
    in
    let frstHalf = makeList ~postSpace:true [lblBefore; atom "="] in
    let string_literals = makeSpacedBreakableInlineList (List.map self#constant_string vd.pval_prim) in
    let sndHalf =
      if (List.length attrs) == 0 then
        string_literals
      else
        makeSpacedBreakableInlineList [
          string_literals;
          makeSpacedBreakableInlineList attrs
        ]
    in
    label ~space:true frstHalf sndHalf

  method class_instance_type x = match x.pcty_desc with
    | Pcty_signature cs ->
        let {pcsig_self = ct; pcsig_fields = l} = cs in
        let instTypeFields =
          List.map self#class_sig_field (List.filter self#shouldDisplayClassInstTypeItem l) in
        let allItems = match ct.ptyp_desc with
          | Ptyp_any -> instTypeFields
          | _ ->
            label ~space:true (atom "as") (self#core_type ct) ::
            instTypeFields
        in
        makeList
          ~wrap:("{", "}")
          ~postSpace:true
          ~break:Always_rec
          ~sep:";"
          allItems
    | Pcty_constr (li, l) -> (
        match l with
          | [] -> self#longident_loc li
          | _::_ ->
            label
              ~space:true
              (makeList ~wrap:("(", ")") ~sep:"," (List.map self#core_type l))
              (self#longident_loc li)
      )
    | Pcty_extension e -> self#extension e
    | Pcty_arrow _ -> failwith "class_instance_type should not be printed with Pcty_arrow"

  method class_declaration_list l =
    let class_declaration ?(class_keyword=false)
        ({pci_params=ls; pci_name={txt}; pci_virt; pci_expr={pcl_desc}; pci_loc} as x) =
      let (firstToken, pattern, patternAux) = self#class_opening class_keyword txt pci_virt ls in
      let classBinding = self#wrappedClassBinding firstToken pattern patternAux x.pci_expr in
      let itm = self#attach_std_item_attrs x.pci_attributes classBinding in
      SourceMap (pci_loc, itm)
    in
    (match l with
      | [] -> raise (NotPossible "Class definitions will have at least one item.")
      | x::rest ->
        makeNonIndentedBreakingList (
          class_declaration ~class_keyword:true x ::
          List.map class_declaration rest
        )
    )
  (* For use with [class type a = class_instance_type]. Class type
     declarations/definitions declare the types of instances generated by class
     constructors.
     We have to call self#class_instance_type because self#class_constructor_type
     would add a "new" before the type.
     TODO: TODOATTRIBUTES:
  *)
  method class_type_declaration_list l =
    let class_type_declaration kwd ({pci_params=ls;pci_name={txt};pci_attributes} as x) =
      let opener = match x.pci_virt with
        | Virtual -> kwd ^ " " ^ "virtual"
        | Concrete -> kwd
      in

      let upToName =
        if ls == [] then
          label ~space:true (atom opener) (atom txt)
        else
          label
            ~space:true
            (label ~space:true (atom opener) (atom txt))
            (self#class_params_def ls)
      in
      let includingEqual = makeList ~postSpace:true [upToName; atom "="] in
      let itm = label ~space:true includingEqual (self#class_instance_type x.pci_expr) in
      let itmWithAttrs = self#attach_std_item_attrs x.pci_expr.pcty_attributes itm in
      self#attach_std_item_attrs pci_attributes itmWithAttrs
    in
    match l with
    | [] -> failwith "Should not call class_type_declaration with no classes"
    | [x] -> class_type_declaration "class type" x
    | x :: xs ->
      makeList
        ~break:Always_rec
        ~indent:0
        ~inline:(true, true)
        (
          (class_type_declaration "class type" x)::
          List.map (class_type_declaration "and") xs
        )

  (*
     Formerly the [class_type]
     Notice how class_constructor_type doesn't have any type attributes -
     class_instance_type does.
     TODO: Divide into class_constructor_types that allow arrows and ones
     that don't.
   *)
  method class_constructor_type x =
    match x.pcty_desc with
    | Pcty_arrow (l, co, cl) ->
      let rec allArrowSegments xx = match xx.pcty_desc with
        | Pcty_arrow (l, ct1, ct2) ->
            (self#type_with_label (l, ct1))::(allArrowSegments ct2)
        (* This "new" is unfortunate. See reason_parser.mly for details. *)
        | _ -> [self#class_constructor_type xx]
      in
      let normalized =
        makeList
          ~break:IfNeed
          ~sep:"=>"
          ~preSpace:true
          ~postSpace:true
          ~inline:(true, true)
          (allArrowSegments x)
      in
      SourceMap (x.pcty_loc, normalized)
    | _ ->
      (* Unfortunately, we have to have final components of a class_constructor_type
         be prefixed with the `new` keyword.  Hopefully this is temporary. *)
      label ~space:true (atom "new") (self#class_instance_type x)

  method non_arrowed_class_constructor_type x =
    match x.pcty_desc with
    | Pcty_arrow (l, co, cl) ->
      let normalized = formatPrecedence (self#class_constructor_type x) in
      SourceMap (x.pcty_loc, normalized)
    | _ -> self#class_instance_type x

  (* TODO: TODOATTRIBUTES. *)
  method class_field x =
    let itm =
      match x.pcf_desc with
      | Pcf_inherit (ovf, ce, so) ->
        let inheritText = ("inherit" ^ override ovf) in
        let inheritExp = self#class_expr ce in
        label
          ~space:true
          (atom inheritText)
          (
            match so with
            | None -> inheritExp;
            | Some (s) -> label ~space:true inheritExp (atom ("as " ^ s))
          )
      | Pcf_val (s, mf, Cfk_concrete (ovf, e)) ->
        let opening = match mf with
          | Mutable ->
            let mutableName = [atom "mutable"; atom s.txt] in
            label
              ~space:true
              (atom ("val" ^ override ovf))
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed mutableName)
          | Immutable -> label ~space:true (atom ("val" ^ override ovf)) (atom s.txt)
        in
        let valExprAndConstraint = match e.pexp_desc with
          | Pexp_constraint (ex, ct) ->
            let openingWithTypeConstraint = formatTypeConstraint opening (self#core_type ct) in
            label
              ~space:true
              (makeList ~postSpace:true [openingWithTypeConstraint; atom "="])
              (self#unparseExpr ex)
          | _ ->
            label ~space:true (makeList ~postSpace:true [opening; atom "="]) (self#unparseExpr e)
        in
        valExprAndConstraint
      | Pcf_val (s, mf, Cfk_virtual ct) ->
        let opening = match mf with
          | Mutable ->
            let mutableVirtualName = [atom "mutable"; atom "virtual"; atom s.txt] in
            let openingTokens =
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed mutableVirtualName) in
            label ~space:true (atom "val") openingTokens
          | Immutable ->
            let virtualName = [atom "virtual"; atom s.txt] in
            let openingTokens =
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed virtualName) in
            label ~space:true (atom "val") openingTokens
        in
        formatTypeConstraint opening (self#core_type ct)
      | Pcf_method (s, pf, Cfk_virtual ct) ->
        let opening = match pf with
          | Private ->
            let privateVirtualName = [atom "virtual"; atom s.txt] in
            let openingTokens =
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed privateVirtualName) in
            label ~space:true (atom "pri") openingTokens
          | Public ->
            let virtualName = [atom "virtual"; atom s.txt] in
            let openingTokens =
              (makeList ~postSpace:true ~inline:(false, true) ~break:IfNeed virtualName) in
            label ~space:true (atom "pub") openingTokens
        in
        formatTypeConstraint opening (self#core_type ct)
      | Pcf_method (s, pf, Cfk_concrete (ovf, e)) ->
        let methodText =
           let postFix = if ovf == Override then "!" else "" in
           (
           match pf with
           | Private -> "pri" ^ postFix
           | Public -> "pub" ^ postFix
           ) in
        (* Should refactor the binding logic so faking out the AST isn't needed,
           currently, it includes a ton of nuanced logic around recovering explicitly
           polymorphic type definitions, and that furthermore, that representation...
           Actually, let's do it.

           For some reason, concrete methods are only ever parsed as Pexp_poly.
           If there *is* no polymorphic function for the method, then the return
           value of the function is wrapped in a ghost Pexp_poly with [None] for
           the type vars.*)
        (match e.pexp_desc with
          | (Pexp_poly
              ({pexp_desc=Pexp_constraint (methodFunWithNewtypes, nonVarifiedExprType)},
                Some ({ptyp_desc=Ptyp_poly (typeVars, varifiedPolyType)})
              )
            ) when (
              let (leadingAbstractVars, nonVarified) =
                self#leadingCurriedAbstractTypes methodFunWithNewtypes in
              self#isRenderableAsPolymorphicAbstractTypes
                typeVars
                (* If even artificially varified. Don't know until this returns*)
                varifiedPolyType
                leadingAbstractVars
                nonVarifiedExprType
          ) ->
            let (leadingAbstractVars, nonVarified) =
              self#leadingCurriedAbstractTypes methodFunWithNewtypes in
            self#locallyAbstractPolymorphicFunctionBinding
              methodText
              (atom s.txt)
              methodFunWithNewtypes
              leadingAbstractVars
              nonVarifiedExprType
          | Pexp_poly (e, Some ct) ->
            let typeLayout = SourceMap (ct.ptyp_loc, (self#core_type ct)) in
            let appTerms = self#unparseExprApplicationItems e in
            self#formatSimplePatternBinding methodText (atom s.txt) (Some typeLayout) appTerms
          (* This form means that there is no type constraint - it's a strange node name.*)
          | Pexp_poly (e, None) ->
            self#wrappedBinding methodText (atom s.txt) [] e
          | _ -> failwith "Concrete methods should only ever have Pexp_poly."
        )
      | Pcf_constraint (ct1, ct2) ->
        label
          ~space:true
          (atom "constraint")
          (
            makeList ~postSpace:true ~inline:(true, false) [
              makeList ~postSpace:true [self#core_type ct1; atom "="];
              self#core_type ct2
            ]
          )
      | Pcf_initializer (e) ->
        label
          ~space:true
          (atom "initializer =>")
          (self#unparseExpr e)
      | Pcf_attribute a -> self#floating_attribute a
      | Pcf_extension e ->
        (* And don't forget, we still need to print post_item_attributes even for
           this case *)
        self#item_extension e
    in
    SourceMap (x.pcf_loc, itm)

  method class_self_pattern_and_structure {pcstr_self = p; pcstr_fields = l} =
    let fields = (List.map self#class_field (List.filter self#shouldDisplayClassField l)) in
    (* Recall that by default self is bound to "this" at parse time. You'd
       have to go out of your way to bind it to "_". *)
    match (p.ppat_attributes, p.ppat_desc) with
      | ([], Ppat_var ({loc; txt = "this"})) -> fields
      | _ ->
        SourceMap (p.ppat_loc, (label ~space:true (atom "as") (self#pattern p)))
        ::fields

  method simple_class_expr x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.pcl_attributes in
    if stdAttrs <> [] then
      formatSimpleAttributed
        (self#simple_class_expr {x with pcl_attributes=[]})
        (self#attributes stdAttrs)
    else
      let itm =
        match x.pcl_desc with
        | Pcl_constraint (ce, ct) ->
          formatTypeConstraint (self#class_expr ce) (self#class_constructor_type ct)
        (* In OCaml,
          - In the most recent version of OCaml, when in the top level of a
            module, let _ = ... is a PStr_eval.
          - When in a function, it is a Pexp_let PPat_any
          - When in class pre-member let bindings it is a Pcl_let PPat_any

           Reason normalizes all of these to be simple imperative expressions
           with trailing semicolons, *except* in the case of classes because it
           will likely introduce a conflict with some proposed syntaxes for
           objects.
        *)
        | Pcl_let _
        | Pcl_structure _ ->
          let rows = (self#classExprLetsAndRest x) in
          makeList ~wrap:("{", "}") ~inline:(true, false) ~postSpace:true ~break:Always_rec (List.map semiTerminated rows)
        | Pcl_extension e -> self#extension e
        | _ -> formatPrecedence (self#class_expr x)
     in SourceMap (x.pcl_loc, itm)

  method classExprLetsAndRest x =
    match x.pcl_desc with
      | Pcl_structure cs -> self#class_self_pattern_and_structure cs
      | Pcl_let (rf, l, ce) ->
        (* For "letList" bindings, the start/end isn't as simple as with
         * module value bindings. For "let lists", the sequences were formed
         * within braces {}. The parser relocates the first let binding to the
         * first brace. *)
         let bindingsLayout = (self#bindings (rf, l)) in
         let bindingsLoc = self#bindingsLocationRange l in
         let bindingsSourceMapped = SourceMap (bindingsLoc, bindingsLayout) in
         bindingsSourceMapped::(self#classExprLetsAndRest ce)
      | _ -> [self#class_expr x]

  method class_expr x =
    let (arityAttrs, docAtrs, stdAttrs, jsxAttrs) = partitionAttributes x.pcl_attributes in
    (* We cannot handle the attributes here. Must handle them in each item *)
    if stdAttrs <> [] then
      (* Do not need a "simple" attributes precedence wrapper. *)
      formatAttributed
        (self#simple_class_expr {x with pcl_attributes=[]})
        (self#attributes stdAttrs)
    else
      match x.pcl_desc with
      | Pcl_fun (l, eo, p, e) ->
          label
            ~space:true
            (makeList ~postSpace:true [
               (label ~space:true (atom "fun") (self#label_exp (l, eo, p)));
              (atom "=>");
            ])
            (self#class_expr e);
      | Pcl_apply (ce, l) ->
        let applicationItems = self#classExpressionToFormattedApplicationItems x in
        formatAttachmentApplication applicationFinalWrapping None applicationItems
      | Pcl_constr (li, l) ->
          (* TODO: Allow classes to use the same syntax as every other type
             application. *)
        (match l with
          | [] -> label ~space:true (atom "class") (self#longident_loc li)
          | ll ->
            let typeParameters =
              makeList
                ~break:IfNeed
                ~postSpace:true
                ~inline:(true, true)
                (List.map self#non_arrowed_simple_core_type l)
            in
            label
              ~space:true
              (makeList ~postSpace:true [atom "class"; self#longident_loc li])
              typeParameters
        )
      | Pcl_constraint _
      | Pcl_extension _
      | Pcl_let _
      | Pcl_structure _ -> self#simple_class_expr x;

  method signature signatureItems =
    let signatureItems = List.filter self#shouldDisplaySigItem signatureItems in
    if List.length signatureItems == 0 then
      atom ""
    else
      let signatureItems = List.filter self#shouldDisplaySigItem signatureItems in
      let first = List.nth signatureItems 0 in
      let last = List.nth signatureItems (List.length signatureItems - 1) in
      SourceMap (
        {loc_start=first.psig_loc.loc_start; loc_end=last.psig_loc.loc_end; loc_ghost=false},
        makeList
          ~newlinesAboveComments:1
          ~newlinesAboveItems:1
          ~newlinesAboveDocComments:1
          ~renderFinalSep:true
          ~postSpace:true
          ~break:Always_rec
          ~indent:0
          ~inline:(true, false)
          ~sep:";"
          (List.map self#signature_item signatureItems)
      )

  method value_description x =
    let vd = self#core_type x.pval_type in
    self#attach_std_item_attrs x.pval_attributes vd

  method signature_item x :layoutNode =
    let item: layoutNode =
      match x.psig_desc with
        | Psig_type l ->
            self#type_def_list l
        | Psig_value vd ->
            if vd.pval_prim <> [] then
              self#primitive_declaration vd
            else
              let intro = atom "let" in
              (formatTypeConstraint
                 (label ~space:true intro (wrapLayoutWithLoc (Some (vd.pval_name.loc)) (protectIdentifier vd.pval_name.txt)))
                 (self#value_description vd))

        | Psig_typext te ->
            self#type_extension te
        | Psig_exception ed ->
            self#exception_declaration ed
        | Psig_class l ->
            let class_description
                ?(class_keyword=false)
                ({pci_params=ls; pci_name={txt}; pci_loc} as x) =
              let (firstToken, pattern, patternAux) = self#class_opening class_keyword txt x.pci_virt ls in
              let withColon = self#wrapCurriedFunctionBinding
                ~arrow:":"
                firstToken
                pattern
                patternAux
                ([(self#class_constructor_type x.pci_expr)], None)
              in
              let itm = self#attach_std_item_attrs x.pci_attributes withColon in
              SourceMap (pci_loc, itm)
            in
            makeNonIndentedBreakingList (
              match l with
              | [] -> raise (NotPossible "No recursive class bindings")
              | [x] -> [class_description ~class_keyword:true x]
              | x :: xs ->
                 (class_description ~class_keyword:true x)::
                 (List.map class_description xs)
            )
        | Psig_module {pmd_name; pmd_type={pmty_desc=Pmty_alias alias}} ->
            label ~space:true
              (makeList ~postSpace:true [
                 atom "module";
                 atom pmd_name.txt;
                 atom "="
               ])
              (self#longident_loc alias)
        | Psig_module pmd ->
            self#formatSimpleSignatureBinding
              "module"
              (atom pmd.pmd_name.txt)
              (self#module_type pmd.pmd_type);
        | Psig_open od ->
            label ~space:true
              (atom ("open" ^ (override od.popen_override)))
              (self#longident_loc od.popen_lid)
        | Psig_include incl ->
            label ~space:true
              (atom "include")
              (self#module_type incl.pincl_mod)
        | Psig_modtype {pmtd_name=s; pmtd_type=md} -> (
            match md with
              | None -> makeList ~postSpace:true [atom "module type"; atom s.txt]
              | Some mt ->
                  label ~space:true
                    (makeList ~postSpace:true [atom "module type"; atom s.txt; atom "="])
                    (self#module_type mt)
          )
        | Psig_class_type l -> self#class_type_declaration_list l
        | Psig_recmodule decls ->
            let first xx =
              self#formatSimpleSignatureBinding
                "module rec"
                (atom xx.pmd_name.txt)
                (self#module_type xx.pmd_type)
            in
            let notFirst xx =
              self#formatSimpleSignatureBinding
                "and"
                (atom xx.pmd_name.txt)
                (self#module_type xx.pmd_type)
            in

            let moduleBindings = match decls with
              | [] -> raise (NotPossible "No recursive module bindings")
              | hd::tl -> (first hd)::(List.map notFirst tl)
            in
            makeNonIndentedBreakingList moduleBindings
        | Psig_attribute a -> self#floating_attribute a
        | Psig_extension (e, a) ->
          self#attach_std_item_attrs a (self#item_extension e)
    in
    SourceMap (x.psig_loc, item)

  method non_arrowed_module_type x =
    match x.pmty_desc with
      | Pmty_alias li ->
          formatPrecedence (label ~space:true (atom "module") (self#longident_loc li))
      | Pmty_typeof me ->
          label ~space:true
            (atom "module type of")
            (self#module_expr me)
      | _ -> self#simple_module_type x

  method simple_module_type x =
    match x.pmty_desc with
      | Pmty_ident li ->
          self#longident_loc li;
      | Pmty_signature s ->
          makeList
            ~break:IfNeed
            ~inline:(true, false)
            ~wrap:("{", "}")
            ~newlinesAboveComments:0
            ~newlinesAboveItems:0
            ~newlinesAboveDocComments:1
            ~renderFinalSep:true
            ~postSpace:true
            ~sep:";"
            (List.map self#signature_item (List.filter self#shouldDisplaySigItem s))
      (* Not sure what this is about. *)
      | Pmty_extension _ -> assert false
      | _ -> makeList ~break:IfNeed ~wrap:("(", ")") [self#module_type x]

  method module_type x =
    (* The segments that should be separated by arrows. *)
    let rec functorTypeArgs xx = match xx.pmty_desc with
      | Pmty_functor (_, None, mt2) -> (atom "()")::(functorTypeArgs mt2)
      | Pmty_functor (s, Some mt1, mt2) ->
          if s.txt = "_" then
            (self#module_type mt1)::(functorTypeArgs mt2)
          else
            let cur =
              makeList ~wrap:("(",")") [
                formatTypeConstraint
                  (atom s.txt)
                  (self#module_type mt1)
              ] in
            cur::(functorTypeArgs mt2)
      | _ -> [self#module_type xx]
    in

    let pmty = match x.pmty_desc with
      | Pmty_functor _ ->
          let functorArgs = functorTypeArgs x in
          makeList ~break:IfNeed ~sep:"=>" ~preSpace:true ~postSpace:true ~inline:(true, true) functorArgs

      (* See comments in sugar_parser.mly about why WITH constraints aren't "non
       * arrowed" *)
      | Pmty_with (mt, l) ->
          let modSub atm li2 token = makeList ~postSpace:true [
            atom "module";
            atm;
            atom token;
            self#longident_loc li2
          ] in
          let typeAtom = atom "type" in
          let eqAtom = atom "=" in
          let destrAtom = atom ":=" in
          let with_constraint = function
            | Pwith_type (li, ({ptype_params} as td)) ->
                self#formatOneTypeDef
                  typeAtom
                  (SourceMap (li.loc, (self#longident_loc li)))
                  eqAtom
                  td
            | Pwith_module (li, li2) ->
                modSub (self#longident_loc li) li2 "="
            | Pwith_typesubst ({ptype_params} as td) ->
                self#formatOneTypeDef
                  typeAtom
                  (SourceMap (td.ptype_name.loc, (atom td.ptype_name.txt)))
                  destrAtom
                  td
            | Pwith_modsubst (s, li2) -> modSub (atom s.txt) li2 ":="
          in
          (match l with
            | [] -> self#module_type mt
            | _ ->
                label ~space:true
                  (makeList ~postSpace:true [self#module_type mt; atom "with"])
                  (makeList
                     ~break:IfNeed
                     ~inline:(true, true)
                     ~sep:"and"
                     ~postSpace:true
                     ~preSpace:true
                     (List.map with_constraint l));
          )
        (* Seems like an infinite loop just waiting to happen. *)
        | _ -> self#non_arrowed_module_type x
    in
    SourceMap (x.pmty_loc, pmty)

  method simple_module_expr x = match x.pmod_desc with
    | Pmod_unpack e ->
        formatPrecedence (makeList ~postSpace:true [atom "val"; self#unparseExpr e])
    | Pmod_ident (li) ->
        ensureSingleTokenSticksToLabel (self#longident_loc li)
    | Pmod_constraint (unconstrainedRet, mt) ->
        formatPrecedence (
          formatTypeConstraint
            (self#module_expr unconstrainedRet)
            (self#module_type mt)
        )
    | Pmod_structure (s) ->
      makeList
        ~break:Always_rec
        ~inline:(true, false)
        ~wrap:("{", "}")
        ~newlinesAboveComments:0
        ~newlinesAboveItems:0
        ~newlinesAboveDocComments:1
        ~renderFinalSep:true
        ~postSpace:true
        ~sep:";"
        (List.map self#structure_item (List.filter self#shouldDisplayStructureItem s))

    | _ ->
        (* For example, functor application will be wrapped. *)
        formatPrecedence (self#module_expr x)

  method module_expr x =
    match x.pmod_desc with
      | Pmod_functor _ ->
          let (argsList, return) = self#curriedFunctorPatternsAndReturnStruct x in (
            match (argsList, return.pmod_desc) with
              | ([], _) -> raise (NotPossible "functor must have some arg")
              | (firstArg::restArgs, _) ->
                (* See #19/20 in syntax.mls - cannot annotate return type at
                   the moment. *)
                let returnedAppTerms = self#moduleExpressionToFormattedApplicationItems return in
                self#wrapCurriedFunctionBinding "fun" firstArg restArgs returnedAppTerms
          )
      | Pmod_apply (me1, me2) ->
          let appTerms = self#moduleExpressionToFormattedApplicationItems x in
          (match appTerms with
            | ([], _) -> raise (NotPossible "no functor application terms")
            | ([hd], _) -> raise (NotPossible "one functor application terms")
            | (hd::tl, _) -> formatIndentedApplication hd tl
          )
      | Pmod_extension (s, e) -> self#payload "%" s e
      | Pmod_unpack _
      | Pmod_ident _
      | Pmod_constraint _
      | Pmod_structure _ -> self#simple_module_expr x


  method structure structureItems =
    if List.length structureItems == 0 then
      atom ""
    else
      let structureItems = List.filter self#shouldDisplayStructureItem structureItems in
      let first = List.nth structureItems 0 in
      let last = List.nth structureItems (List.length structureItems - 1) in
      SourceMap (
        {loc_start=first.pstr_loc.loc_start; loc_end=last.pstr_loc.loc_end; loc_ghost=false},
        makeList
          ~newlinesAboveComments:1
          ~newlinesAboveItems:1
          ~newlinesAboveDocComments:1
          ~renderFinalSep:true
          ~postSpace:true
          ~break:Always_rec
          ~indent:0
          ~inline:(true, false)
          ~sep:";"
          (List.map self#structure_item structureItems)
      )


  (*
     How do modules become parsed?
     let module (X: sig) = blah;
       Will not parse! (Should just make it parse to let [X:sig =]).
     let module X: sig = blah;
       Becomes Pmod_constraint
     let module X: sig = (blah:sig);
       Becomes Pmod_constraint .. Pmod_constraint
     let module X = blah:typ;
       Becomes Pmod_constraint
     let module X (Y:y) (Z:z):r => Q
       Becomes Pmod_functor...=> Pmod_constraint

     let module X (Y:y) (Z:z):r => (Q:r2)
       Probably becomes Pmod_functor...=> (Pmod_constraint..
       Pmod_constraint)

    let (module X) =
      Is a *completely* different thing (unpacking/packing first class modules).
      We should make sure this is very well distinguished.
      - Just replace all "let module" with a new three letter keyword (mod)?
      - Reserve let (module X) for unpacking first class modules.

    See the notes about how Ppat_constraint become parsed and attempt to unify
    those as well.
  *)

  method let_module_binding prefixText bindingName moduleExpr =
    let (argsList, return) = self#curriedFunctorPatternsAndReturnStruct moduleExpr in (
      match (argsList, return.pmod_desc) with
        (* Simple module with type constraint, no functor args. *)
        | ([], Pmod_constraint (unconstrainedRetTerm, ct)) ->
            let appTerms = self#moduleExpressionToFormattedApplicationItems unconstrainedRetTerm in
            self#formatSimplePatternBinding prefixText bindingName (Some (self#module_type ct)) appTerms
        (* Simple module with type no constraint, no functor args. *)
        | ([], _) ->
            let appTerms = self#moduleExpressionToFormattedApplicationItems return in
            self#formatSimplePatternBinding prefixText bindingName None appTerms
        | (_, _) ->
            (* A functor *)
            let (argsWithConstraint, actualReturn) = (
              match return.pmod_desc with
                (* A functor with constrained return type:
                 *
                 * let module X = (A) (B) : Ret => ...
                 * *)
                | Pmod_constraint (me, ct) -> (argsList@[formatJustTheTypeConstraint (self#non_arrowed_module_type ct)], me)
                | _ -> (argsList, return)
            ) in
            let returnedAppTerms = self#moduleExpressionToFormattedApplicationItems actualReturn in
            self#wrapCurriedFunctionBinding prefixText bindingName argsWithConstraint returnedAppTerms
    )

    method class_opening class_keyword name pci_virt ls =
      let firstToken = if class_keyword then "class" else "and" in
      match (pci_virt, ls) with
        (* When no class params, it's a very simple formatting for the
           opener - no breaking. *)
        | (Virtual, []) ->
          (firstToken, atom "virtual", [atom name])
        | (Concrete, []) ->
          (firstToken, atom name, [])
        | (Virtual, _::_) ->
          (firstToken, atom "virtual", [atom name; self#class_params_def ls])
        | (Concrete, _::_) ->
          (firstToken, atom name, [self#class_params_def ls])


  (* TODO: TODOATTRIBUTES: Structure items don't have attributes, but each
     pstr_desc *)
  method structure_item term =
    let item = (
      match term.pstr_desc with
        | Pstr_eval (e, _attrs) -> self#unparseExpr e
        | Pstr_type [] -> assert false
        | Pstr_type l  -> (self#type_def_list l)
        | Pstr_value (rf, l) -> (self#bindings (rf, l))
        | Pstr_typext te -> (self#type_extension te)
        | Pstr_exception ed -> (self#exception_declaration ed)
        | Pstr_module x ->
            let prefixText = "module" in
            let bindingName = atom ~loc:x.pmb_name.loc x.pmb_name.txt in
            let moduleExpr = x.pmb_expr in
            self#let_module_binding prefixText bindingName moduleExpr
        | Pstr_open od -> (
            makeList ~postSpace:true [
              atom ("open" ^ (override od.popen_override));
              self#longident_loc od.popen_lid;
            ]
        )
        | Pstr_modtype {pmtd_name=s; pmtd_type=md} -> (
            match md with
              | None -> makeList ~postSpace:true [atom "module type";atom s.txt]
              | Some mt ->
                  label ~space:true
                    (makeList ~postSpace:true [atom "module type";atom s.txt; atom "="])
                    (self#module_type mt)
          )
        | Pstr_class l -> self#class_declaration_list l
        | Pstr_class_type (l) -> self#class_type_declaration_list l
        | Pstr_primitive vd -> self#primitive_declaration vd
        | Pstr_include incl ->
            (* Kind of a hack *)
            let moduleExpr = incl.pincl_mod in
            let returnedAppTerms = self#moduleExpressionToFormattedApplicationItems moduleExpr in
            formatAttachmentApplication
              applicationFinalWrapping
              (Some (true, atom "include"))
              returnedAppTerms

        | Pstr_recmodule decls -> (* 3.07 *)
            let first xx =
              let prefixText = "module rec" in
              self#let_module_binding prefixText (atom xx.pmb_name.txt) xx.pmb_expr in
            let notFirst xx =
              let prefixText = "and" in
              self#let_module_binding prefixText (atom xx.pmb_name.txt) xx.pmb_expr in

            let moduleBindings = match decls with
              | [] -> raise (NotPossible "No recursive module bindings")
              | hd::tl -> (first hd)::(List.map notFirst tl)
            in
            (makeNonIndentedBreakingList moduleBindings)
        | Pstr_attribute a -> self#floating_attribute a
        | Pstr_extension (e, a) ->
          (* Notice how extensions have attributes - but not every structure
             item does. *)
          self#item_extension e
    ) in
    SourceMap(term.pstr_loc, item)

  method type_extension te =
    let formatOneTypeExtStandard prepend ({ptyext_path} as te) =
      let name = self#longident_loc ptyext_path in
      let item = self#formatOneTypeExt prepend name (atom "+=") te in
      self#attach_std_item_attrs te.ptyext_attributes item
    in
    formatOneTypeExtStandard (atom "type") te

  method extension_constructor = wrap default#extension_constructor
  (* [allowUnguardedSequenceBodies] allows sequence expressions {} to the right of `=>` to not
     be guarded in `{}` braces. *)
  method case_list ?(allowUnguardedSequenceBodies=false) l =
    let rec appendLabelToLast items rhs =
      match items with
        | hd::[] -> (label ~indent:0 ~space:true hd rhs)::[]
        | hd::tl -> hd::(appendLabelToLast tl rhs)
        | [] -> raise (NotPossible "Cannot append to last of nothing")
    in

    let case_row {pc_lhs; pc_guard; pc_rhs} =
      let theOrs = orList pc_lhs in

      (* match x with *)
      (* | AnotherReallyLongVariantName (_, _, _)   *)
      (* | AnotherReallyLongVariantName2 (_, _, _)
           when true => {                           *)

      (*   }                                        *)

      (*<sbi><X>match x with</X>   *)
      (*     <Y>everythingElse</Y> *)
      (*</sbi>                     *)



      (*     ............................................................
             :    each or segment has a spaced list <> that ties its    :
             : bar "|" to its pattern                                   :
             ...:..........................................................:.....
             :  :  each or-patterned match is grouped in SpacedBreakableInline  :
             :  :                                                          :    :
             v  v                                                          v    v
             <sbi><>|<lb><A><>     FirstThingStandalone t =></A></><B>t</B></lb></></sbi>
             <sbi><>|<C>           AnotherReallyLongVariantName (_, _, _)</C></>
             ^    <>|<lb><><lb><D>AnotherReallyLongVariantNam2 (_, _, _)</D>             (label the last in or ptn for or and label it again for arrow)
             :        ^  ^   ^     <E>when true<E></lb> =></><F>{
             :        :  :   :    </F>}</lb></sbi> ^       ^
             :        :  :   :            ^     ^   :      :
             :        :  :   :            :     :   :      :
             :        :  :   :If there is :a WHERE  :      :
             :        :  :   :an extra    :label is :      :
             :        :  :   :inserted bef:ore the  :      :
             :        :  :   :arrow.      :     :   :      :
             :        :  :   :............:.....:...:      :
             :        :  :                :     :          :
             :        :  :                :     :          :
             :        :  :                :     :          :
             :        :  :The left side of:this final label:
             :        :  :uses a list to  :append the arrow:
             :        :  :................:.....:..........:
             :        :                   :     :
             :        :                   :     :
             :        :                   :     :
             :        :Final or segment is:     :
             :        :wrapped in lbl that:     :
             :        :partitions pattern :     :
             :        :and arrow from     :     :
             :        :expression.        :     :
             :        :                   :     :
             :        :...................:     :
             :     [orsWithWhereAndArrowOnLast] :
             :                                  :
             :..................................:
                         [row]

      *)
      let bar xx = makeList ~postSpace:true [atom "|"; xx] in
      let appendWhereAndArrow p = match pc_guard with
          | None -> makeList ~interleaveComments:false ~postSpace:true [p; atom "=>"]
          | Some g ->
            (* when x should break as a whole - extra list added around it to make it break as one *)
            let withWhen = label ~space:true p (makeList ~break:Never ~inline:(true, true) ~postSpace:true [label ~space:true (atom "when") (self#unparseExpr g)]) in
            makeList ~interleaveComments:false ~inline:(true, true) ~postSpace:true [withWhen; atom "=>"]
      in

      let rec appendWhereAndArrowToLastOr = function
        | [] -> []
        | hd::tl -> (
          let formattedHd = match tl with
            | [] -> appendWhereAndArrow (self#pattern hd)
            | tl::tlTl -> (self#pattern hd)
          in
          formattedHd::(appendWhereAndArrowToLastOr tl)
        )
      in
      let orsWithWhereAndArrowOnLast = appendWhereAndArrowToLastOr theOrs in
      let rhs =
        if allowUnguardedSequenceBodies then
          match (self#under_pipe#letList pc_rhs) with
            (* TODO: Still render a list with located information here so that
               comments (eol) are interleaved *)
            | [hd] -> hd
            (* In this case, we don't need any additional indentation, because there aren't
               wrapping {} which would cause zero indentation to look strange. *)
            | lst -> makeUngaurdedLetSequence lst
        else self#under_pipe#unparseExpr pc_rhs in
      let row =
        let withoutBars = appendLabelToLast orsWithWhereAndArrowOnLast rhs in
        makeList ~break:Always_rec ~inline:(true, true) (List.map bar withoutBars)
      in
        SourceMap (
          (* Fake shift the location to accomodate for the bar, to make sure
           * the wrong comments don't make their way past the next bar. *)
          expandLocation ~expand:(0, 0) {
            loc_start = pc_lhs.ppat_loc.loc_start;
            loc_end = pc_rhs.pexp_loc.loc_end;
            loc_ghost = false;
          },
          row
        )

    in
    (List.map case_row l)

  method label_x_expression_param (l, e) =
    let param =
      match l with
        | ""  -> self#simplifyUnparseExpr e; (* level 2*)
        | lbl ->
            if lbl.[0] = '?' then
              let str = String.sub lbl 1 (String.length lbl-1) in
              let lbl = pun_labelled_expression e str in
              formatLabeledArgument (atom lbl) "?" (self#simplifyUnparseExpr e)
            else
              let lbl = pun_labelled_expression e lbl in
              formatLabeledArgument (atom lbl) "" (self#simplifyUnparseExpr e)
    in
    SourceMap (e.pexp_loc, param)

  method directive_argument = wrap default#directive_argument
  method toplevel_phrase = wrap default#toplevel_phrase
end;;


let easy = new printer ()

let toplevel_phrase f x =
  match x with
    | Ptop_def (s) ->
      easyFormatToFormatter f (layoutToEasyFormatNoComments (easy#structure s))
    | Ptop_dir (s, da) -> print_string "(* top directives not supported *)"

let case_list f x =
  let l = easy#case_list x in
  (List.iter (fun x -> easyFormatToFormatter f (layoutToEasyFormatNoComments x)) l)

let top_phrase f x =
  pp_print_newline f () ;
  toplevel_phrase f x;
  pp f ";;" ;
  pp_print_newline f ();;

(* Convert a Longident to a list of strings.
   E.g. M.Constructor will be ["Constructor"; "M.Constructor"]
   Also support ".Constructor" to specify access without a path.
 *)
let longident_for_arity lid =
  let rec toplevel = function
    | Lident s ->
        [s]
    | Ldot (lid, s) ->
        let append_s x = x ^ "." ^ s in
        s :: (List.map append_s (toplevel lid))
    | Lapply (y,s) ->
        toplevel s in
   match lid with
    | Lident s ->
        ("." ^ s) :: toplevel lid
    | _ ->
        toplevel lid

(* add expilcit_arity to a list of attributes
 *)
let add_explicit_arity loc attributes =
  ({txt="explicit_arity"; loc}, PStr []) ::
  normalized_attributes "explicit_arity" attributes

(* explicit_arity_exists check if expilcit_arity exists
 *)
let explicit_arity_not_exists attributes =
  not (attribute_exists "explicit_arity" attributes)

(* wrap_expr_with_tuple wraps an expression
 * with tuple as a sole argument.
 *)
let wrap_expr_with_tuple exp =
  {exp with pexp_desc = Pexp_tuple [exp]}

(* wrap_pat_with_tuple wraps an pattern
 * with tuple as a sole argument.
 *)
let wrap_pat_with_tuple pat =
  {pat with ppat_desc = Ppat_tuple [pat]}



(* explicit_arity_constructors is a set of constructors that are known to have
 * multiple arguments
 *
 *)

module StringSet = Set.Make(String);;

let built_in_explicit_arity_constructors = ["Some"; "Assert_failure"; "Match_failure"]

let explicit_arity_constructors = StringSet.of_list(built_in_explicit_arity_constructors @ (!configuredSettings).constructorLists)

let add_explicit_arity_mapper =
{ default_mapper with
  expr = begin fun mapper expr ->
    let expr =
      match expr with
        | {pexp_desc=Pexp_construct(lid, Some sp);
           pexp_loc;
           pexp_attributes} when
             List.exists
                (fun c -> StringSet.mem c explicit_arity_constructors)
                (longident_for_arity lid.txt) &&
             explicit_arity_not_exists pexp_attributes ->
           {pexp_desc=Pexp_construct(lid, Some (wrap_expr_with_tuple sp));
            pexp_loc;
            pexp_attributes=add_explicit_arity pexp_loc pexp_attributes}
        | x -> x
    in
    default_mapper.expr mapper expr
  end;
  pat = begin fun mapper pat ->
    let pat =
      match pat with
        | {ppat_desc=Ppat_construct(lid, Some sp);
           ppat_loc;
           ppat_attributes} when
              List.exists
                  (fun c -> StringSet.mem c explicit_arity_constructors)
                  (longident_for_arity lid.txt) &&
              explicit_arity_not_exists ppat_attributes ->
           {ppat_desc=Ppat_construct(lid, Some (wrap_pat_with_tuple sp));
            ppat_loc;
            ppat_attributes=add_explicit_arity ppat_loc ppat_attributes}
        | x -> x
    in
    default_mapper.pat mapper pat
  end;
}

let preprocessing_chain = [add_explicit_arity_mapper; escape_stars_slashes_mapper; ml_to_reason_swap_operator_mapper]

let core_type f x =
  easyFormatToFormatter f (layoutToEasyFormatNoComments (easy#core_type (apply_mapper_chain_to_type x preprocessing_chain)))
let pattern f x =
  easyFormatToFormatter f (layoutToEasyFormatNoComments (easy#pattern (apply_mapper_chain_to_pattern x preprocessing_chain)))
let signature (comments : commentWithCategory) f x =
  easyFormatToFormatter f (layoutToEasyFormat (easy#signature (apply_mapper_chain_to_signature x preprocessing_chain)) comments)
let structure (comments : commentWithCategory) f x =
  easyFormatToFormatter f (layoutToEasyFormat (easy#structure (apply_mapper_chain_to_structure x preprocessing_chain)) comments)
let expression f x =
  easyFormatToFormatter f (layoutToEasyFormatNoComments (easy#unparseExpr (apply_mapper_chain_to_expr x preprocessing_chain)))
let case_list = case_list
end
in
object
  method core_type = Formatter.core_type
  method pattern = Formatter.pattern
  method signature = Formatter.signature
  method structure = Formatter.structure
  (* For merlin-destruct *)
  method toplevel_phrase = Formatter.toplevel_phrase
  method expression = Formatter.expression
  method case_list = Formatter.case_list
end

let defaultSettings = defaultSettings

end
module Printer_maker
= struct
#1 "printer_maker.ml"
type parse_itype = [ `ML | `Reason | `Binary | `BinaryReason | `Auto ]
type print_itype = [ `ML | `Reason | `Binary | `BinaryReason | `AST | `None ]

exception Invalid_config of string

module type PRINTER =
    sig
        type t

        val parse : parse_itype ->
                    bool ->
                    string ->
                    ((t * Reason_pprint_ast.commentWithCategory) * bool)

        val print : print_itype ->
                    string ->
                    bool ->
                    out_channel ->
                    Format.formatter ->
                    ((t * Reason_pprint_ast.commentWithCategory) -> unit)
    end

let prepare_output_file = function
    | Some name -> open_out_bin name
    | None -> set_binary_mode_out stdout true; stdout

let close_output_file output_file output_chan =
    match output_file with
    | Some _ -> close_out output_chan
    | None -> ()

let ocamlBinaryParser use_stdin filename parsedAsInterface =
  let chan =
    match use_stdin with
      | true -> stdin
      | false ->
          let file_chan = open_in filename in
          seek_in file_chan 0;
          file_chan
  in
  let _ = really_input_string chan (String.length Config.ast_impl_magic_number) in
  let _ = input_value chan in
  let ast = input_value chan in
  ((ast, []), true, parsedAsInterface)

let reasonBinaryParser use_stdin filename =
  let chan =
    match use_stdin with
      | true -> stdin
      | false ->
          let file_chan = open_in filename in
          seek_in file_chan 0;
          file_chan
  in
  let (magic_number, filename, ast, comments, parsedAsML, parsedAsInterface) = input_value chan in
  ((ast, comments), parsedAsML, parsedAsInterface)

end
module Reason_config
= struct
#1 "reason_config.ml"
(**
 * Copyright (c) 2015-present, Facebook, Inc. All rights reserved.
 *)

let recoverable = ref false
let add_printers = ref false

let configure ~r ~ap = (
  recoverable := r;
  add_printers := ap
)

end
module MenhirLib : sig 
#1 "menhirLib.mli"
module General : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This module offers general-purpose functions on lists and streams. *)

(* --------------------------------------------------------------------------- *)

(* Lists. *)

(* [take n xs] returns the [n] first elements of the list [xs]. It is
   acceptable  for the list [xs] to have length less than [n], in
   which case [xs] itself is returned. *)

val take: int -> 'a list -> 'a list

(* [drop n xs] returns the list [xs], deprived of its [n] first elements.
   It is acceptable for the list [xs] to have length less than [n], in
   which case an empty list is returned. *)

val drop: int -> 'a list -> 'a list

(* [uniq cmp xs] assumes that the list [xs] is sorted according to the
   ordering [cmp] and returns the list [xs] deprived of any duplicate
   elements. *)

val uniq: ('a -> 'a -> int) -> 'a list -> 'a list

(* [weed cmp xs] returns the list [xs] deprived of any duplicate elements. *)

val weed: ('a -> 'a -> int) -> 'a list -> 'a list

(* --------------------------------------------------------------------------- *)

(* A stream is a list whose elements are produced on demand. *)

type 'a stream =
    'a head Lazy.t

and 'a head =
  | Nil
  | Cons of 'a * 'a stream

(* The length of a stream. *)

val length: 'a stream -> int

(* Folding over a stream. *)

val foldr: ('a -> 'b -> 'b) -> 'a stream -> 'b -> 'b

end
module Convert : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* An ocamlyacc-style, or Menhir-style, parser requires access to
   the lexer, which must be parameterized with a lexing buffer, and
   to the lexing buffer itself, where it reads position information. *)

(* This traditional API is convenient when used with ocamllex, but
   inelegant when used with other lexer generators. *)

type ('token, 'semantic_value) traditional =
    (Lexing.lexbuf -> 'token) -> Lexing.lexbuf -> 'semantic_value

(* This revised API is independent of any lexer generator. Here, the
   parser only requires access to the lexer, and the lexer takes no
   parameters. The tokens returned by the lexer may contain position
   information. *)

type ('token, 'semantic_value) revised =
    (unit -> 'token) -> 'semantic_value

(* --------------------------------------------------------------------------- *)

(* Converting a traditional parser, produced by ocamlyacc or Menhir,
   into a revised parser. *)

(* A token of the revised lexer is essentially a triple of a token
   of the traditional lexer (or raw token), a start position, and
   and end position. The three [get] functions are accessors. *)

(* We do not require the type ['token] to actually be a triple type.
   This enables complex applications where it is a record type with
   more than three fields. It also enables simple applications where
   positions are of no interest, so ['token] is just ['raw_token]
   and [get_startp] and [get_endp] return dummy positions. *)

val traditional2revised:
  ('token -> 'raw_token) ->
  ('token -> Lexing.position) ->
  ('token -> Lexing.position) ->
  ('raw_token, 'semantic_value) traditional ->
  ('token, 'semantic_value) revised

(* --------------------------------------------------------------------------- *)

(* Converting a revised parser back to a traditional parser. *)

val revised2traditional:
  ('raw_token -> Lexing.position -> Lexing.position -> 'token) ->
  ('token, 'semantic_value) revised ->
  ('raw_token, 'semantic_value) traditional

(* --------------------------------------------------------------------------- *)

(* Simplified versions of the above, where concrete triples are used. *)

module Simplified : sig

  val traditional2revised:
    ('token, 'semantic_value) traditional ->
    ('token * Lexing.position * Lexing.position, 'semantic_value) revised

  val revised2traditional:
    ('token * Lexing.position * Lexing.position, 'semantic_value) revised ->
    ('token, 'semantic_value) traditional

end
end
module IncrementalEngine : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

open General

(* This signature describes the incremental LR engine. *)

(* In this mode, the user controls the lexer, and the parser suspends
   itself when it needs to read a new token. *)

module type INCREMENTAL_ENGINE = sig

  type token

  (* The type ['a checkpoint] represents an intermediate or final state of the
     parser. An intermediate checkpoint is a suspension: it records the parser's
     current state, and allows parsing to be resumed. The parameter ['a] is
     the type of the semantic value that will eventually be produced if the
     parser succeeds. *)

  (* [Accepted] and [Rejected] are final checkpoints. [Accepted] carries a
     semantic value. *)

  (* [InputNeeded] is an intermediate checkpoint. It means that the parser wishes
     to read one token before continuing. *)

  (* [Shifting] is an intermediate checkpoint. It means that the parser is taking
     a shift transition. It exposes the state of the parser before and after
     the transition. The Boolean parameter tells whether the parser intends to
     request a new token after this transition. (It always does, except when
     it is about to accept.) *)

  (* [AboutToReduce] is an intermediate checkpoint. It means that the parser is
     about to perform a reduction step. It exposes the parser's current
     state as well as the production that is about to be reduced. *)

  (* [HandlingError] is an intermediate checkpoint. It means that the parser has
     detected an error and is currently handling it, in several steps. *)

  type env

  type production

  type 'a checkpoint = private
    | InputNeeded of env
    | Shifting of env * env * bool
    | AboutToReduce of env * production
    | HandlingError of env
    | Accepted of 'a
    | Rejected

  (* [offer] allows the user to resume the parser after it has suspended
     itself with a checkpoint of the form [InputNeeded env]. [offer] expects the
     old checkpoint as well as a new token and produces a new checkpoint. It does not
     raise any exception. *)

  val offer:
    'a checkpoint ->
    token * Lexing.position * Lexing.position ->
    'a checkpoint

  (* [resume] allows the user to resume the parser after it has suspended
     itself with a checkpoint of the form [AboutToReduce (env, prod)] or
     [HandlingError env]. [resume] expects the old checkpoint and produces a new
     checkpoint. It does not raise any exception. *)

  val resume:
    'a checkpoint ->
    'a checkpoint

  (* A token supplier is a function of no arguments which delivers a new token
     (together with its start and end positions) every time it is called. *)

  type supplier =
    unit -> token * Lexing.position * Lexing.position

  (* A pair of a lexer and a lexing buffer can be easily turned into a supplier. *)

  val lexer_lexbuf_to_supplier:
    (Lexing.lexbuf -> token) ->
    Lexing.lexbuf ->
    supplier

  (* The functions [offer] and [resume] are sufficient to write a parser loop.
     One can imagine many variations (which is why we expose these functions
     in the first place!). Here, we expose a few variations of the main loop,
     ready for use. *)

  (* [loop supplier checkpoint] begins parsing from [checkpoint], reading
     tokens from [supplier]. It continues parsing until it reaches a
     checkpoint of the form [Accepted v] or [Rejected]. In the former case, it
     returns [v]. In the latter case, it raises the exception [Error]. *)

  val loop: supplier -> 'a checkpoint -> 'a

  (* [loop_handle succeed fail supplier checkpoint] begins parsing from
     [checkpoint], reading tokens from [supplier]. It continues parsing until
     it reaches a checkpoint of the form [Accepted v] or [HandlingError env]
     (or [Rejected], but that should not happen, as [HandlingError _] will be
     observed first). In the former case, it calls [succeed v]. In the latter
     case, it calls [fail] with this checkpoint. It cannot raise [Error].

     This means that Menhir's traditional error-handling procedure (which pops
     the stack until a state that can act on the [error] token is found) does
     not get a chance to run. Instead, the user can implement her own error
     handling code, in the [fail] continuation. *)

  val loop_handle:
    ('a -> 'answer) ->
    ('a checkpoint -> 'answer) ->
    supplier -> 'a checkpoint -> 'answer

  (* [loop_handle_undo] is analogous to [loop_handle], except it passes a pair
     of checkpoints to the failure continuation.

     The first (and oldest) checkpoint is the last [InputNeeded] checkpoint that
     was encountered before the error was detected. The second (and newest)
     checkpoint is where the error was detected, as in [loop_handle]. Going back
     to the first checkpoint can be thought of as undoing any reductions that
     were performed after seeing the problematic token. (These reductions must
     be default reductions or spurious reductions.)

     [loop_handle_undo] must initially be applied to an [InputNeeded] checkpoint.
     The parser's initial checkpoints satisfy this constraint. *)

  val loop_handle_undo:
    ('a -> 'answer) ->
    ('a checkpoint -> 'a checkpoint -> 'answer) ->
    supplier -> 'a checkpoint -> 'answer

  (* [loop_test f checkpoint accu] assumes that [checkpoint] has been obtained
     by submitting a token to the parser. It runs the parser from [checkpoint],
     through an arbitrary number of reductions, until the parser either accepts
     this token (i.e., shifts) or rejects it (i.e., signals an error). If the
     parser decides to shift, then the accumulator is updated by applying the
     user function [f] to the [env] just before shifting and to the old [accu].
     Otherwise, the accumulator is not updated, i.e., [accu] is returned. *)

  (* It is desirable that the semantic actions be side-effect free, or that
     their side-effects be harmless (replayable). *)

  val loop_test:
    (env -> 'accu -> 'accu) ->
    'a checkpoint -> 'accu -> 'accu

  (* The function [loop_test] can be used, after an error has been detected, to
     dynamically test which tokens would have been accepted at this point. We
     provide this test, ready for use. *)

  (* For completeness, one must undo any spurious reductions before carrying out
     this test -- that is, one must apply [acceptable] to the FIRST checkpoint
     that is passed by [loop_handle_undo] to its failure continuation. *)

  (* This test causes some semantic actions to be run! The semantic actions
     should be side-effect free, or their side-effects should be harmless. *)

  (* The position [pos] is used as the start and end positions of the
     hypothetical token, and may be picked up by the semantic actions. We
     suggest using the position where the error was detected. *)

  val acceptable: 'a checkpoint -> token -> Lexing.position -> bool

  (* The abstract type ['a lr1state] describes the non-initial states of the
     LR(1) automaton. The index ['a] represents the type of the semantic value
     associated with this state's incoming symbol. *)

  type 'a lr1state

  (* The states of the LR(1) automaton are numbered (from 0 and up). *)

  val number: _ lr1state -> int

  (* An element is a pair of a non-initial state [s] and a semantic value [v]
     associated with the incoming symbol of this state. The idea is, the value
     [v] was pushed onto the stack just before the state [s] was entered. Thus,
     for some type ['a], the state [s] has type ['a lr1state] and the value [v]
     has type ['a]. In other words, the type [element] is an existential type. *)

  type element =
    | Element: 'a lr1state * 'a * Lexing.position * Lexing.position -> element

  (* The parser's stack is (or, more precisely, can be viewed as) a stream of
     elements. The type [stream] is defined by the module [General]. *)

  type stack =
    element stream

  (* This is the parser's stack, a stream of elements. This stream is empty if
     the parser is in an initial state; otherwise, it is non-empty.  The LR(1)
     automaton's current state is the one found in the top element of the
     stack. *)

  val stack: env -> stack

  (* These are the start and end positions of the current lookahead token. If
     invoked in an initial state, this function returns a pair of twice the
     initial position. *)

  val positions: env -> Lexing.position * Lexing.position

  (* This tells whether the parser is about to perform a default reduction.
     In particular, when applied to an environment taken from a result of
     the form [AboutToReduce (env, prod)], this tells whether the reduction
     that is about to take place is a default reduction. *)

  val has_default_reduction: env -> bool

end

(* This signature is a fragment of the inspection API that is made available
   to the user when [--inspection] is used. This fragment contains type
   definitions for symbols. *)

module type SYMBOLS = sig

  (* The type ['a terminal] represents a terminal symbol. The type ['a
     nonterminal] represents a nonterminal symbol. In both cases, the index
     ['a] represents the type of the semantic values associated with this
     symbol. The concrete definitions of these types are generated. *)

  type 'a terminal
  type 'a nonterminal

  (* The type ['a symbol] represents a terminal or nonterminal symbol. It is
     the disjoint union of the types ['a terminal] and ['a nonterminal]. *)

  type 'a symbol =
    | T : 'a terminal -> 'a symbol
    | N : 'a nonterminal -> 'a symbol

  (* The type [xsymbol] is an existentially quantified version of the type
     ['a symbol]. This type is useful in situations where the index ['a]
     is not statically known. *)

  type xsymbol =
    | X : 'a symbol -> xsymbol

end

(* This signature describes the inspection API that is made available to the
   user when [--inspection] is used. *)

module type INSPECTION = sig

  (* The types of symbols are described above. *)

  include SYMBOLS

  (* The type ['a lr1state] is meant to be the same as in [INCREMENTAL_ENGINE]. *)

  type 'a lr1state

  (* The type [production] is meant to be the same as in [INCREMENTAL_ENGINE].
     It represents a production of the grammar. A production can be examined
     via the functions [lhs] and [rhs] below. *)

  type production

  (* An LR(0) item is a pair of a production [prod] and a valid index [i] into
     this production. That is, if the length of [rhs prod] is [n], then [i] is
     comprised between 0 and [n], inclusive. *)

  type item =
      production * int

  (* Ordering functions. *)

  val compare_terminals: _ terminal -> _ terminal -> int
  val compare_nonterminals: _ nonterminal -> _ nonterminal -> int
  val compare_symbols: xsymbol -> xsymbol -> int
  val compare_productions: production -> production -> int
  val compare_items: item -> item -> int

  (* [incoming_symbol s] is the incoming symbol of the state [s], that is,
     the symbol that the parser must recognize before (has recognized when)
     it enters the state [s]. This function gives access to the semantic
     value [v] stored in a stack element [Element (s, v, _, _)]. Indeed,
     by case analysis on the symbol [incoming_symbol s], one discovers the
     type ['a] of the value [v]. *)

  val incoming_symbol: 'a lr1state -> 'a symbol

  (* [items s] is the set of the LR(0) items in the LR(0) core of the LR(1)
     state [s]. This set is not epsilon-closed. This set is presented as a
     list, in an arbitrary order. *)

  val items: _ lr1state -> item list

  (* [lhs prod] is the left-hand side of the production [prod]. This is
     always a non-terminal symbol. *)

  val lhs: production -> xsymbol

  (* [rhs prod] is the right-hand side of the production [prod]. This is
     a (possibly empty) sequence of (terminal or nonterminal) symbols. *)

  val rhs: production -> xsymbol list

  (* [nullable nt] tells whether the non-terminal symbol [nt] is nullable.
     That is, it is true if and only if this symbol produces the empty
     word [epsilon]. *)

  val nullable: _ nonterminal -> bool

  (* [first nt t] tells whether the FIRST set of the nonterminal symbol [nt]
     contains the terminal symbol [t]. That is, it is true if and only if
     [nt] produces a word that begins with [t]. *)

  val first: _ nonterminal -> _ terminal -> bool

  (* [xfirst] is analogous to [first], but expects a first argument of type
     [xsymbol] instead of [_ terminal]. *)

  val xfirst: xsymbol -> _ terminal -> bool

  (* [foreach_terminal] enumerates the terminal symbols, including [error].
     [foreach_terminal_but_error] enumerates the terminal symbols, excluding
     [error]. *)

  val foreach_terminal:           (xsymbol -> 'a -> 'a) -> 'a -> 'a
  val foreach_terminal_but_error: (xsymbol -> 'a -> 'a) -> 'a -> 'a

end

(* This signature combines the incremental API and the inspection API. *)

module type EVERYTHING = sig

  include INCREMENTAL_ENGINE

  include INSPECTION
    with type 'a lr1state := 'a lr1state
    with type production := production

end

end
module EngineTypes : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This file defines several types and module types that are used in the
   specification of module [Engine]. *)

(* --------------------------------------------------------------------------- *)

(* It would be nice if we could keep the structure of stacks and environments
   hidden. However, stacks and environments must be accessible to semantic
   actions, so the following data structure definitions must be public. *)

(* --------------------------------------------------------------------------- *)

(* A stack is a linked list of cells. A sentinel cell -- which is its own
   successor -- is used to mark the bottom of the stack. The sentinel cell
   itself is not significant -- it contains dummy values. *)

type ('state, 'semantic_value) stack = {

  (* The state that we should go back to if we pop this stack cell. *)

  (* This convention means that the state contained in the top stack cell is
     not the current state [env.current]. It also means that the state found
     within the sentinel is a dummy -- it is never consulted. This convention
     is the same as that adopted by the code-based back-end. *)

  state: 'state;

  (* The semantic value associated with the chunk of input that this cell
     represents. *)

  semv: 'semantic_value;

  (* The start and end positions of the chunk of input that this cell
     represents. *)

  startp: Lexing.position;
  endp: Lexing.position;

  (* The next cell down in the stack. If this is a self-pointer, then this
     cell is the sentinel, and the stack is conceptually empty. *)

  next: ('state, 'semantic_value) stack;

}

(* --------------------------------------------------------------------------- *)

(* A parsing environment contains all of the parser's state (except for the
   current program point). *)

type ('state, 'semantic_value, 'token) env = {

  (* If this flag is true, then the first component of [env.triple] should
     be ignored, as it has been logically overwritten with the [error]
     pseudo-token. *)

  error: bool;

  (* The last token that was obtained from the lexer, together with its start
     and end positions. Warning: before the first call to the lexer has taken
     place, a dummy (and possibly invalid) token is stored here. *)

  triple: 'token * Lexing.position * Lexing.position;

  (* The stack. In [CodeBackend], it is passed around on its own,
     whereas, here, it is accessed via the environment. *)

  stack: ('state, 'semantic_value) stack;

  (* The current state. In [CodeBackend], it is passed around on its
     own, whereas, here, it is accessed via the environment. *)

  current: 'state;

}

(* --------------------------------------------------------------------------- *)

(* This signature describes the parameters that must be supplied to the LR
   engine. *)

module type TABLE = sig

  (* The type of automaton states. *)

  type state

  (* States are numbered. *)

  val number: state -> int

  (* The type of tokens. These can be thought of as real tokens, that is,
     tokens returned by the lexer. They carry a semantic value. This type
     does not include the [error] pseudo-token. *)

  type token

  (* The type of terminal symbols. These can be thought of as integer codes.
     They do not carry a semantic value. This type does include the [error]
     pseudo-token. *)

  type terminal

  (* The type of semantic values. *)

  type semantic_value

  (* A token is conceptually a pair of a (non-[error]) terminal symbol and
     a semantic value. The following two functions are the pair projections. *)

  val token2terminal: token -> terminal
  val token2value: token -> semantic_value

  (* Even though the [error] pseudo-token is not a real token, it is a
     terminal symbol. Furthermore, for regularity, it must have a semantic
     value. *)

  val error_terminal: terminal
  val error_value: semantic_value

  (* The type of productions. *)

  type production

  (* If a state [s] has a default reduction on production [prod], then, upon
     entering [s], the automaton should reduce [prod] without consulting the
     lookahead token. The following function allows determining which states
     have default reductions. *)

  (* Instead of returning a value of a sum type -- either [DefRed prod], or
     [NoDefRed] -- it accepts two continuations, and invokes just one of
     them. This mechanism allows avoiding a memory allocation. *)

  val default_reduction:
    state ->
    ('env -> production -> 'answer) ->
    ('env -> 'answer) ->
    'env -> 'answer

  (* An LR automaton can normally take three kinds of actions: shift, reduce,
     or fail. (Acceptance is a particular case of reduction: it consists in
     reducing a start production.) *)

  (* There are two variants of the shift action. [shift/discard s] instructs
     the automaton to discard the current token, request a new one from the
     lexer, and move to state [s]. [shift/nodiscard s] instructs it to move to
     state [s] without requesting a new token. This instruction should be used
     when [s] has a default reduction on [#]. See [CodeBackend.gettoken] for
     details. *)

  (* This is the automaton's action table. It maps a pair of a state and a
     terminal symbol to an action. *)

  (* Instead of returning a value of a sum type -- one of shift/discard,
     shift/nodiscard, reduce, or fail -- this function accepts three
     continuations, and invokes just one them. This mechanism allows avoiding
     a memory allocation. *)

  (* In summary, the parameters to [action] are as follows:

     - the first two parameters, a state and a terminal symbol, are used to
       look up the action table;

     - the next parameter is the semantic value associated with the above
       terminal symbol; it is not used, only passed along to the shift
       continuation, as explained below;

     - the shift continuation expects an environment; a flag that tells
       whether to discard the current token; the terminal symbol that
       is being shifted; its semantic value; and the target state of
       the transition;

     - the reduce continuation expects an environment and a production;

     - the fail continuation expects an environment;

     - the last parameter is the environment; it is not used, only passed
       along to the selected continuation. *)

  val action:
    state ->
    terminal ->
    semantic_value ->
    ('env -> bool -> terminal -> semantic_value -> state -> 'answer) ->
    ('env -> production -> 'answer) ->
    ('env -> 'answer) ->
    'env -> 'answer

  (* This is the automaton's goto table. It maps a pair of a state and a
     production to a new state.

     This convention is slightly different from the textbook approach. The
     goto table is usually indexed by a state and a non-terminal symbol. *)

  val goto: state -> production -> state

  (* [is_start prod] tells whether the production [prod] is a start production. *)

  val is_start: production -> bool

  (* By convention, a semantic action is responsible for:

     1. fetching whatever semantic values and positions it needs off the stack;

     2. popping an appropriate number of cells off the stack, as dictated
        by the length of the right-hand side of the production;

     3. computing a new semantic value, as well as new start and end positions;

     4. pushing a new stack cell, which contains the three values
        computed in step 3;

     5. returning the new stack computed in steps 2 and 4.

     Point 1 is essentially forced upon us: if semantic values were fetched
     off the stack by this interpreter, then the calling convention for
     semantic actions would be variadic: not all semantic actions would have
     the same number of arguments. The rest follows rather naturally. *)

  (* Semantic actions are allowed to raise [Error]. *)

  exception Error

  type semantic_action =
      (state, semantic_value, token) env -> (state, semantic_value) stack

  val semantic_action: production -> semantic_action

  (* The LR engine requires a number of hooks, which are used for logging. *)

  (* The comments below indicate the conventional messages that correspond
     to these hooks in the code-based back-end; see [CodeBackend]. *)

  (* If the flag [log] is false, then the logging functions are not called.
     If it is [true], then they are called. *)

  val log : bool

  module Log : sig

    (* State %d: *)

    val state: state -> unit

    (* Shifting (<terminal>) to state <state> *)

    val shift: terminal -> state -> unit

    (* Reducing a production should be logged either as a reduction
       event (for regular productions) or as an acceptance event (for
       start productions). *)

    (* Reducing production <production> / Accepting *)

    val reduce_or_accept: production -> unit

    (* Lookahead token is now <terminal> (<pos>-<pos>) *)

    val lookahead_token: terminal -> Lexing.position -> Lexing.position -> unit

    (* Initiating error handling *)

    val initiating_error_handling: unit -> unit

    (* Resuming error handling *)

    val resuming_error_handling: unit -> unit

    (* Handling error in state <state> *)

    val handling_error: state -> unit

  end

end

(* --------------------------------------------------------------------------- *)

(* This signature describes the monolithic (traditional) LR engine. *)

(* In this interface, the parser controls the lexer. *)

module type MONOLITHIC_ENGINE = sig

  type state

  type token

  type semantic_value

  (* An entry point to the engine requires a start state, a lexer, and a lexing
     buffer. It either succeeds and produces a semantic value, or fails and
     raises [Error]. *)

  exception Error

  val entry:
    state ->
    (Lexing.lexbuf -> token) ->
    Lexing.lexbuf ->
    semantic_value

end

(* --------------------------------------------------------------------------- *)

(* The following signatures describe the incremental LR engine. *)

(* First, see [INCREMENTAL_ENGINE] in the file [IncrementalEngine.ml]. *)

(* The [start] function is set apart because we do not wish to publish
   it as part of the generated [parser.mli] file. Instead, the table
   back-end will publish specialized versions of it, with a suitable
   type cast. *)

module type INCREMENTAL_ENGINE_START = sig

  (* [start] is an entry point. It requires a start state and a start position
     and begins the parsing process. If the lexer is based on an OCaml lexing
     buffer, the start position should be [lexbuf.lex_curr_p]. [start] produces
     a checkpoint, which usually will be an [InputNeeded] checkpoint. (It could
     be [Accepted] if this starting state accepts only the empty word. It could
     be [Rejected] if this starting state accepts no word at all.) It does not
     raise any exception. *)

  (* [start s pos] should really produce a checkpoint of type ['a checkpoint],
     for a fixed ['a] that depends on the state [s]. We cannot express this, so
     we use [semantic_value checkpoint], which is safe. The table back-end uses
     [Obj.magic] to produce safe specialized versions of [start]. *)

  type state
  type semantic_value
  type 'a checkpoint

  val start:
    state ->
    Lexing.position ->
    semantic_value checkpoint

end

(* --------------------------------------------------------------------------- *)

(* This signature describes the LR engine, which combines the monolithic
   and incremental interfaces. *)

module type ENGINE = sig

  include MONOLITHIC_ENGINE

  include IncrementalEngine.INCREMENTAL_ENGINE
    with type token := token
     and type 'a lr1state = state (* useful for us; hidden from the end user *)

  include INCREMENTAL_ENGINE_START
    with type state := state
     and type semantic_value := semantic_value
     and type 'a checkpoint := 'a checkpoint

end

end
module Engine : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

open EngineTypes

(* The LR parsing engine. *)

module Make (T : TABLE) : ENGINE with type state = T.state
                                  and type token = T.token
                                  and type semantic_value = T.semantic_value
                                  and type production = T.production
end
module Printers : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This module is part of MenhirLib. *)

module Make

  (I : IncrementalEngine.EVERYTHING)

  (User : sig

    (* [print s] is supposed to send the string [s] to some output channel. *)

    val print: string -> unit

    (* [print_symbol s] is supposed to print a representation of the symbol [s]. *)

    val print_symbol: I.xsymbol -> unit

    (* [print_element e] is supposed to print a representation of the element [e].
       This function is optional; if it is not provided, [print_element_as_symbol]
       (defined below) is used instead. *)

    val print_element: (I.element -> unit) option

  end)

: sig

  open I

  (* Printing a list of symbols. *)

  val print_symbols: xsymbol list -> unit

  (* Printing an element as a symbol. This prints just the symbol
     that this element represents; nothing more. *)

  val print_element_as_symbol: element -> unit

  (* Printing a stack as a list of elements. This function needs an element
     printer. It uses [print_element] if provided by the user; otherwise
     it uses [print_element_as_symbol]. (Ending with a newline.) *)

  val print_stack: stack -> unit

  (* Printing an item. (Ending with a newline.) *)

  val print_item: item -> unit

  (* Printing a production. (Ending with a newline.) *)

  val print_production: production -> unit

  (* Printing the current LR(1) state. The current state is first displayed
     as a number; then the list of its LR(0) items is printed. (Ending with
     a newline.) *)

  val print_current_state: env -> unit

  (* Printing a summary of the stack and current state. This function just
     calls [print_stack] and [print_current_state] in succession. *)

  val print_env: env -> unit

end

end
module InfiniteArray : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(** This module implements infinite arrays. **)
type 'a t

(** [make x] creates an infinite array, where every slot contains [x]. **)
val make: 'a -> 'a t

(** [get a i] returns the element contained at offset [i] in the array [a].
   Slots are numbered 0 and up. **)
val get: 'a t -> int -> 'a

(** [set a i x] sets the element contained at offset [i] in the array
    [a] to [x]. Slots are numbered 0 and up. **)
val set: 'a t -> int -> 'a -> unit

(** [extent a] is the length of an initial segment of the array [a]
    that is sufficiently large to contain all [set] operations ever
    performed. In other words, all elements beyond that segment have
    the default value. *)
val extent: 'a t -> int

(** [domain a] is a fresh copy of an initial segment of the array [a]
    whose length is [extent a]. *)
val domain: 'a t -> 'a array
end
module PackedIntArray : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* A packed integer array is represented as a pair of an integer [k] and
   a string [s]. The integer [k] is the number of bits per integer that we
   use. The string [s] is just an array of bits, which is read in 8-bit
   chunks. *)

(* The ocaml programming language treats string literals and array literals
   in slightly different ways: the former are statically allocated, while
   the latter are dynamically allocated. (This is rather arbitrary.) In the
   context of Menhir's table-based back-end, where compact, immutable
   integer arrays are needed, ocaml strings are preferable to ocaml arrays. *)

type t =
  int * string

(* [pack a] turns an array of integers into a packed integer array. *)

(* Because the sign bit is the most significant bit, the magnitude of
   any negative number is the word size. In other words, [pack] does
   not achieve any space savings as soon as [a] contains any negative
   numbers, even if they are ``small''. *)

val pack: int array -> t

(* [get t i] returns the integer stored in the packed array [t] at index [i]. *)

(* Together, [pack] and [get] satisfy the following property: if the index [i]
   is within bounds, then [get (pack a) i] equals [a.(i)]. *)

val get: t -> int -> int

(* [get1 t i] returns the integer stored in the packed array [t] at index [i].
   It assumes (and does not check) that the array's bit width is [1]. The
   parameter [t] is just a string. *)

val get1: string -> int -> int

(* [unflatten1 (n, data) i j] accesses the two-dimensional bitmap
   represented by [(n, data)] at indices [i] and [j]. The integer
   [n] is the width of the bitmap; the string [data] is the second
   component of the packed array obtained by encoding the table as
   a one-dimensional array. *)

val unflatten1: int * string -> int -> int -> int

end
module RowDisplacement : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This module compresses a two-dimensional table, where some values
   are considered insignificant, via row displacement. *)

(* A compressed table is represented as a pair of arrays. The
   displacement array is an array of offsets into the data array. *)

type 'a table =
    int array * (* displacement *)
     'a array   (* data *)

(* [compress equal insignificant dummy m n t] turns the two-dimensional table
   [t] into a compressed table. The parameter [equal] is equality of data
   values. The parameter [wildcard] tells which data values are insignificant,
   and can thus be overwritten with other values. The parameter [dummy] is
   used to fill holes in the data array. [m] and [n] are the integer
   dimensions of the table [t]. *)

val compress:
  ('a -> 'a -> bool) ->
  ('a -> bool) ->
  'a ->
  int -> int ->
  'a array array ->
  'a table

(* [get ct i j] returns the value found at indices [i] and [j] in the
   compressed table [ct]. This function call is permitted only if the
   value found at indices [i] and [j] in the original table is
   significant -- otherwise, it could fail abruptly. *)

(* Together, [compress] and [get] have the property that, if the value
   found at indices [i] and [j] in an uncompressed table [t] is
   significant, then [get (compress t) i j] is equal to that value. *)

val get:
  'a table ->
  int -> int ->
  'a

(* [getget] is a variant of [get] which only requires read access,
   via accessors, to the two components of the table. *)

val getget:
  ('displacement -> int -> int) ->
  ('data -> int -> 'a) ->
  'displacement * 'data ->
  int -> int ->
  'a

end
module LinearizedArray : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* An array of arrays (of possibly different lengths!) can be ``linearized'',
   i.e., encoded as a data array (by concatenating all of the little arrays)
   and an entry array (which contains offsets into the data array). *)

type 'a t =
  (* data: *)   'a array *
  (* entry: *) int array

(* [make a] turns the array of arrays [a] into a linearized array. *)

val make: 'a array array -> 'a t

(* [read la i j] reads the linearized array [la] at indices [i] and [j].
   Thus, [read (make a) i j] is equivalent to [a.(i).(j)]. *)

val read: 'a t -> int -> int -> 'a

(* [write la i j v] writes the value [v] into the linearized array [la]
   at indices [i] and [j]. *)

val write: 'a t -> int -> int -> 'a -> unit

(* [length la] is the number of rows of the array [la]. Thus, [length (make
   a)] is equivalent to [Array.length a]. *)

val length: 'a t -> int

(* [row_length la i] is the length of the row at index [i] in the linearized
   array [la]. Thus, [row_length (make a) i] is equivalent to [Array.length
   a.(i)]. *)

val row_length: 'a t -> int -> int

(* [read_row la i] reads the row at index [i], producing a list. Thus,
   [read_row (make a) i] is equivalent to [Array.to_list a.(i)]. *)

val read_row: 'a t -> int -> 'a list

(* The following variants read the linearized array via accessors
   [get_data : int -> 'a] and [get_entry : int -> int]. *)

val row_length_via:
  (* get_entry: *) (int -> int) ->
  (* i: *)         int ->
                   int

val read_via:
  (* get_data: *)  (int -> 'a) ->
  (* get_entry: *) (int -> int) ->
  (* i: *)         int ->
  (* j: *)         int ->
                   'a

val read_row_via:
  (* get_data: *)  (int -> 'a) ->
  (* get_entry: *) (int -> int) ->
  (* i: *)         int ->
                   'a list

end
module TableFormat : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This signature defines the format of the parse tables. It is used as
   an argument to [TableInterpreter.Make]. *)

module type TABLES = sig

  (* This is the parser's type of tokens. *)

  type token

  (* This maps a token to its internal (generation-time) integer code. *)

  val token2terminal: token -> int

  (* This is the integer code for the error pseudo-token. *)

  val error_terminal: int

  (* This maps a token to its semantic value. *)

  val token2value: token -> Obj.t

  (* Traditionally, an LR automaton is described by two tables, namely, an
     action table and a goto table. See, for instance, the Dragon book.

     The action table is a two-dimensional matrix that maps a state and a
     lookahead token to an action. An action is one of: shift to a certain
     state, reduce a certain production, accept, or fail.

     The goto table is a two-dimensional matrix that maps a state and a
     non-terminal symbol to either a state or undefined. By construction, this
     table is sparse: its undefined entries are never looked up. A compression
     technique is free to overlap them with other entries.

     In Menhir, things are slightly different. If a state has a default
     reduction on token [#], then that reduction must be performed without
     consulting the lookahead token. As a result, we must first determine
     whether that is the case, before we can obtain a lookahead token and use it
     as an index in the action table.

     Thus, Menhir's tables are as follows.

     A one-dimensional default reduction table maps a state to either ``no
     default reduction'' (encoded as: 0) or ``by default, reduce prod''
     (encoded as: 1 + prod). The action table is looked up only when there
     is no default reduction. *)

  val default_reduction: PackedIntArray.t

  (* Menhir follows Dencker, Drre and Heuft, who point out that, although the
     action table is not sparse by nature (i.e., the error entries are
     significant), it can be made sparse by first factoring out a binary error
     matrix, then replacing the error entries in the action table with undefined
     entries. Thus:

     A two-dimensional error bitmap maps a state and a terminal to either
     ``fail'' (encoded as: 0) or ``do not fail'' (encoded as: 1). The action
     table, which is now sparse, is looked up only in the latter case. *)

  (* The error bitmap is flattened into a one-dimensional table; its width is
     recorded so as to allow indexing. The table is then compressed via
     [PackedIntArray]. The bit width of the resulting packed array must be
     [1], so it is not explicitly recorded. *)

  (* The error bitmap does not contain a column for the [#] pseudo-terminal.
     Thus, its width is [Terminal.n - 1]. We exploit the fact that the integer
     code assigned to [#] is greatest: the fact that the right-most column
     in the bitmap is missing does not affect the code for accessing it. *)

  val error: int (* width of the bitmap *) * string (* second component of [PackedIntArray.t] *)

  (* A two-dimensional action table maps a state and a terminal to one of
     ``shift to state s and discard the current token'' (encoded as: s | 10),
     ``shift to state s without discarding the current token'' (encoded as: s |
     11), or ``reduce prod'' (encoded as: prod | 01). *)

  (* The action table is first compressed via [RowDisplacement], then packed
     via [PackedIntArray]. *)

  (* Like the error bitmap, the action table does not contain a column for the
     [#] pseudo-terminal. *)

  val action: PackedIntArray.t * PackedIntArray.t

  (* A one-dimensional lhs table maps a production to its left-hand side (a
     non-terminal symbol). *)

  val lhs: PackedIntArray.t

  (* A two-dimensional goto table maps a state and a non-terminal symbol to
     either undefined (encoded as: 0) or a new state s (encoded as: 1 + s). *)

  (* The goto table is first compressed via [RowDisplacement], then packed
     via [PackedIntArray]. *)

  val goto: PackedIntArray.t * PackedIntArray.t

  (* The number of start productions. A production [prod] is a start
     production if and only if [prod < start] holds. This is also the
     number of start symbols. A nonterminal symbol [nt] is a start
     symbol if and only if [nt < start] holds. *)

  val start: int

  (* A one-dimensional semantic action table maps productions to semantic
     actions. The calling convention for semantic actions is described in
     [EngineTypes]. This table contains ONLY NON-START PRODUCTIONS, so the
     indexing is off by [start]. Be careful. *)

  val semantic_action: ((int, Obj.t, token) EngineTypes.env ->
                        (int, Obj.t)        EngineTypes.stack) array

  (* The parser defines its own [Error] exception. This exception can be
     raised by semantic actions and caught by the engine, and raised by the
     engine towards the final user. *)

  exception Error

  (* The parser indicates whether to generate a trace. Generating a
     trace requires two extra tables, which respectively map a
     terminal symbol and a production to a string. *)

  val trace: (string array * string array) option

end

end
module InspectionTableFormat : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This signature defines the format of the tables that are produced (in
   addition to the tables described in [TableFormat]) when the command line
   switch [--inspection] is enabled. It is used as an argument to
   [InspectionTableInterpreter.Make]. *)

module type TABLES = sig

  (* The types of symbols. *)

  include IncrementalEngine.SYMBOLS

  (* The type ['a lr1state] describes an LR(1) state. The generated parser defines
     it internally as [int]. *)

  type 'a lr1state

  (* Some of the tables that follow use encodings of (terminal and
     nonterminal) symbols as integers. So, we need functions that
     map the integer encoding of a symbol to its algebraic encoding. *)

  val    terminal: int -> xsymbol
  val nonterminal: int -> xsymbol

  (* The left-hand side of every production already appears in the
     signature [TableFormat.TABLES], so we need not repeat it here. *)

  (* The right-hand side of every production. This a linearized array
     of arrays of integers, whose [data] and [entry] components have
     been packed. The encoding of symbols as integers in described in
     [TableBackend]. *)

  val rhs: PackedIntArray.t * PackedIntArray.t

  (* A mapping of every (non-initial) state to its LR(0) core. *)

  val lr0_core: PackedIntArray.t

  (* A mapping of every LR(0) state to its set of LR(0) items. Each item is
     represented in its packed form (see [Item]) as an integer. Thus the
     mapping is an array of arrays of integers, which is linearized and
     packed, like [rhs]. *)

  val lr0_items: PackedIntArray.t * PackedIntArray.t

  (* A mapping of every LR(0) state to its incoming symbol, if it has one. *)

  val lr0_incoming: PackedIntArray.t

  (* A table that tells which non-terminal symbols are nullable. *)

  val nullable: string
    (* This is a packed int array of bit width 1. It can be read
       using [PackedIntArray.get1]. *)

  (* A two-table dimensional table, indexed by a nonterminal symbol and
     by a terminal symbol (other than [#]), encodes the FIRST sets. *)

  val first: int (* width of the bitmap *) * string (* second component of [PackedIntArray.t] *)

end

end
module InspectionTableInterpreter : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This functor is invoked inside the generated parser, in [--table] mode. It
   produces no code! It simply constructs the types [symbol] and [xsymbol] on
   top of the generated types [terminal] and [nonterminal]. *)

module Symbols (T : sig

  type 'a terminal
  type 'a nonterminal

end)

: IncrementalEngine.SYMBOLS
  with type 'a terminal := 'a T.terminal
   and type 'a nonterminal := 'a T.nonterminal

(* This functor is invoked inside the generated parser, in [--table] mode. It
   constructs the inspection API on top of the inspection tables described in
   [InspectionTableFormat]. *)

module Make
  (B : TableFormat.TABLES)
  (T : InspectionTableFormat.TABLES
       with type 'a lr1state = int)

: IncrementalEngine.INSPECTION
  with type 'a terminal := 'a T.terminal
   and type 'a nonterminal := 'a T.nonterminal
   and type 'a lr1state := 'a T.lr1state
   and type production := int

end
module TableInterpreter : sig
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This module instantiates the generic [Engine] with a thin decoding layer
   for the generated tables. Like [Engine], it is part of [MenhirLib]. *)

(* The exception [Error] is declared within the generated parser. This is
   preferable to pre-declaring it here, as it ensures that each parser gets
   its own, distinct [Error] exception. This is consistent with the code-based
   back-end. *)

(* This functor is invoked by the generated parser. *)

module Make (T : TableFormat.TABLES)

: EngineTypes.ENGINE with type state = int
                           and type token = T.token
                           and type semantic_value = Obj.t
                           and type production = int

end
module StaticVersion : sig
val require_20160808 : unit
end

end = struct
#1 "menhirLib.ml"
module General = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* --------------------------------------------------------------------------- *)

(* Lists. *)

let rec take n xs =
  match n, xs with
  | 0, _
  | _, [] ->
      []
  | _, (x :: xs as input) ->
     let xs' = take (n - 1) xs in
     if xs == xs' then
       input
     else
       x :: xs'

let rec drop n xs =
  match n, xs with
  | 0, _ ->
      xs
  | _, [] ->
      []
  | _, _ :: xs ->
      drop (n - 1) xs

let rec uniq1 cmp x ys =
  match ys with
  | [] ->
      []
  | y :: ys ->
      if cmp x y = 0 then
        uniq1 compare x ys
      else
        y :: uniq1 cmp y ys

let uniq cmp xs =
  match xs with
  | [] ->
      []
  | x :: xs ->
      x :: uniq1 cmp x xs

let weed cmp xs =
  uniq cmp (List.sort cmp xs)

(* --------------------------------------------------------------------------- *)

(* Streams. *)

type 'a stream =
    'a head Lazy.t

and 'a head =
  | Nil
  | Cons of 'a * 'a stream

(* The length of a stream. *)

let rec length xs =
  match Lazy.force xs with
  | Nil ->
      0
  | Cons (_, xs) ->
      1 + length xs

(* Folding over a stream. *)

let rec foldr f xs accu =
  match Lazy.force xs with
  | Nil ->
      accu
  | Cons (x, xs) ->
      f x (foldr f xs accu)

end
module Convert = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* An ocamlyacc-style, or Menhir-style, parser requires access to
   the lexer, which must be parameterized with a lexing buffer, and
   to the lexing buffer itself, where it reads position information. *)

(* This traditional API is convenient when used with ocamllex, but
   inelegant when used with other lexer generators. *)

type ('token, 'semantic_value) traditional =
    (Lexing.lexbuf -> 'token) -> Lexing.lexbuf -> 'semantic_value

(* This revised API is independent of any lexer generator. Here, the
   parser only requires access to the lexer, and the lexer takes no
   parameters. The tokens returned by the lexer may contain position
   information. *)

type ('token, 'semantic_value) revised =
    (unit -> 'token) -> 'semantic_value

(* --------------------------------------------------------------------------- *)

(* Converting a traditional parser, produced by ocamlyacc or Menhir,
   into a revised parser. *)

(* A token of the revised lexer is essentially a triple of a token
   of the traditional lexer (or raw token), a start position, and
   and end position. The three [get] functions are accessors. *)

(* We do not require the type ['token] to actually be a triple type.
   This enables complex applications where it is a record type with
   more than three fields. It also enables simple applications where
   positions are of no interest, so ['token] is just ['raw_token]
   and [get_startp] and [get_endp] return dummy positions. *)

let traditional2revised
  (get_raw_token : 'token -> 'raw_token)
  (get_startp    : 'token -> Lexing.position)
  (get_endp      : 'token -> Lexing.position)
  (parser : ('raw_token, 'semantic_value) traditional)
: ('token, 'semantic_value) revised =

  (* Accept a revised lexer. *)

  fun (lexer : unit -> 'token) ->

    (* Create a dummy lexing buffer. *)

    let lexbuf : Lexing.lexbuf =
      Lexing.from_string ""
    in

    (* Wrap the revised lexer as a traditional lexer. A traditional
       lexer returns a raw token and updates the fields of the lexing
       buffer with new positions, which will be read by the parser. *)

    let lexer (lexbuf : Lexing.lexbuf) : 'raw_token =
      let token : 'token = lexer() in
      lexbuf.Lexing.lex_start_p <- get_startp token;
      lexbuf.Lexing.lex_curr_p <- get_endp token;
      get_raw_token token
    in

    (* Invoke the traditional parser. *)

    parser lexer lexbuf

(* --------------------------------------------------------------------------- *)

(* Converting a revised parser back to a traditional parser. *)

let revised2traditional
  (make_token : 'raw_token -> Lexing.position -> Lexing.position -> 'token)
  (parser : ('token, 'semantic_value) revised)
: ('raw_token, 'semantic_value) traditional =

  (* Accept a traditional lexer and a lexing buffer. *)

  fun (lexer : Lexing.lexbuf -> 'raw_token) (lexbuf : Lexing.lexbuf) ->

    (* Wrap the traditional lexer as a revised lexer. *)

    let lexer () : 'token =
      let token : 'raw_token = lexer lexbuf in
      make_token token lexbuf.Lexing.lex_start_p lexbuf.Lexing.lex_curr_p
    in

    (* Invoke the revised parser. *)

    parser lexer

(* --------------------------------------------------------------------------- *)

(* Simplified versions of the above, where concrete triples are used. *)

module Simplified = struct

  let traditional2revised parser =
    traditional2revised
      (fun (token, _, _)  -> token)
      (fun (_, startp, _) -> startp)
      (fun (_, _, endp)   -> endp)
      parser

  let revised2traditional parser =
    revised2traditional
      (fun token startp endp -> (token, startp, endp))
      parser

end
end
module IncrementalEngine = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

open General

(* This signature describes the incremental LR engine. *)

(* In this mode, the user controls the lexer, and the parser suspends
   itself when it needs to read a new token. *)

module type INCREMENTAL_ENGINE = sig

  type token

  (* The type ['a checkpoint] represents an intermediate or final state of the
     parser. An intermediate checkpoint is a suspension: it records the parser's
     current state, and allows parsing to be resumed. The parameter ['a] is
     the type of the semantic value that will eventually be produced if the
     parser succeeds. *)

  (* [Accepted] and [Rejected] are final checkpoints. [Accepted] carries a
     semantic value. *)

  (* [InputNeeded] is an intermediate checkpoint. It means that the parser wishes
     to read one token before continuing. *)

  (* [Shifting] is an intermediate checkpoint. It means that the parser is taking
     a shift transition. It exposes the state of the parser before and after
     the transition. The Boolean parameter tells whether the parser intends to
     request a new token after this transition. (It always does, except when
     it is about to accept.) *)

  (* [AboutToReduce] is an intermediate checkpoint. It means that the parser is
     about to perform a reduction step. It exposes the parser's current
     state as well as the production that is about to be reduced. *)

  (* [HandlingError] is an intermediate checkpoint. It means that the parser has
     detected an error and is currently handling it, in several steps. *)

  type env

  type production

  type 'a checkpoint = private
    | InputNeeded of env
    | Shifting of env * env * bool
    | AboutToReduce of env * production
    | HandlingError of env
    | Accepted of 'a
    | Rejected

  (* [offer] allows the user to resume the parser after it has suspended
     itself with a checkpoint of the form [InputNeeded env]. [offer] expects the
     old checkpoint as well as a new token and produces a new checkpoint. It does not
     raise any exception. *)

  val offer:
    'a checkpoint ->
    token * Lexing.position * Lexing.position ->
    'a checkpoint

  (* [resume] allows the user to resume the parser after it has suspended
     itself with a checkpoint of the form [AboutToReduce (env, prod)] or
     [HandlingError env]. [resume] expects the old checkpoint and produces a new
     checkpoint. It does not raise any exception. *)

  val resume:
    'a checkpoint ->
    'a checkpoint

  (* A token supplier is a function of no arguments which delivers a new token
     (together with its start and end positions) every time it is called. *)

  type supplier =
    unit -> token * Lexing.position * Lexing.position

  (* A pair of a lexer and a lexing buffer can be easily turned into a supplier. *)

  val lexer_lexbuf_to_supplier:
    (Lexing.lexbuf -> token) ->
    Lexing.lexbuf ->
    supplier

  (* The functions [offer] and [resume] are sufficient to write a parser loop.
     One can imagine many variations (which is why we expose these functions
     in the first place!). Here, we expose a few variations of the main loop,
     ready for use. *)

  (* [loop supplier checkpoint] begins parsing from [checkpoint], reading
     tokens from [supplier]. It continues parsing until it reaches a
     checkpoint of the form [Accepted v] or [Rejected]. In the former case, it
     returns [v]. In the latter case, it raises the exception [Error]. *)

  val loop: supplier -> 'a checkpoint -> 'a

  (* [loop_handle succeed fail supplier checkpoint] begins parsing from
     [checkpoint], reading tokens from [supplier]. It continues parsing until
     it reaches a checkpoint of the form [Accepted v] or [HandlingError env]
     (or [Rejected], but that should not happen, as [HandlingError _] will be
     observed first). In the former case, it calls [succeed v]. In the latter
     case, it calls [fail] with this checkpoint. It cannot raise [Error].

     This means that Menhir's traditional error-handling procedure (which pops
     the stack until a state that can act on the [error] token is found) does
     not get a chance to run. Instead, the user can implement her own error
     handling code, in the [fail] continuation. *)

  val loop_handle:
    ('a -> 'answer) ->
    ('a checkpoint -> 'answer) ->
    supplier -> 'a checkpoint -> 'answer

  (* [loop_handle_undo] is analogous to [loop_handle], except it passes a pair
     of checkpoints to the failure continuation.

     The first (and oldest) checkpoint is the last [InputNeeded] checkpoint that
     was encountered before the error was detected. The second (and newest)
     checkpoint is where the error was detected, as in [loop_handle]. Going back
     to the first checkpoint can be thought of as undoing any reductions that
     were performed after seeing the problematic token. (These reductions must
     be default reductions or spurious reductions.)

     [loop_handle_undo] must initially be applied to an [InputNeeded] checkpoint.
     The parser's initial checkpoints satisfy this constraint. *)

  val loop_handle_undo:
    ('a -> 'answer) ->
    ('a checkpoint -> 'a checkpoint -> 'answer) ->
    supplier -> 'a checkpoint -> 'answer

  (* [loop_test f checkpoint accu] assumes that [checkpoint] has been obtained
     by submitting a token to the parser. It runs the parser from [checkpoint],
     through an arbitrary number of reductions, until the parser either accepts
     this token (i.e., shifts) or rejects it (i.e., signals an error). If the
     parser decides to shift, then the accumulator is updated by applying the
     user function [f] to the [env] just before shifting and to the old [accu].
     Otherwise, the accumulator is not updated, i.e., [accu] is returned. *)

  (* It is desirable that the semantic actions be side-effect free, or that
     their side-effects be harmless (replayable). *)

  val loop_test:
    (env -> 'accu -> 'accu) ->
    'a checkpoint -> 'accu -> 'accu

  (* The function [loop_test] can be used, after an error has been detected, to
     dynamically test which tokens would have been accepted at this point. We
     provide this test, ready for use. *)

  (* For completeness, one must undo any spurious reductions before carrying out
     this test -- that is, one must apply [acceptable] to the FIRST checkpoint
     that is passed by [loop_handle_undo] to its failure continuation. *)

  (* This test causes some semantic actions to be run! The semantic actions
     should be side-effect free, or their side-effects should be harmless. *)

  (* The position [pos] is used as the start and end positions of the
     hypothetical token, and may be picked up by the semantic actions. We
     suggest using the position where the error was detected. *)

  val acceptable: 'a checkpoint -> token -> Lexing.position -> bool

  (* The abstract type ['a lr1state] describes the non-initial states of the
     LR(1) automaton. The index ['a] represents the type of the semantic value
     associated with this state's incoming symbol. *)

  type 'a lr1state

  (* The states of the LR(1) automaton are numbered (from 0 and up). *)

  val number: _ lr1state -> int

  (* An element is a pair of a non-initial state [s] and a semantic value [v]
     associated with the incoming symbol of this state. The idea is, the value
     [v] was pushed onto the stack just before the state [s] was entered. Thus,
     for some type ['a], the state [s] has type ['a lr1state] and the value [v]
     has type ['a]. In other words, the type [element] is an existential type. *)

  type element =
    | Element: 'a lr1state * 'a * Lexing.position * Lexing.position -> element

  (* The parser's stack is (or, more precisely, can be viewed as) a stream of
     elements. The type [stream] is defined by the module [General]. *)

  type stack =
    element stream

  (* This is the parser's stack, a stream of elements. This stream is empty if
     the parser is in an initial state; otherwise, it is non-empty.  The LR(1)
     automaton's current state is the one found in the top element of the
     stack. *)

  val stack: env -> stack

  (* These are the start and end positions of the current lookahead token. If
     invoked in an initial state, this function returns a pair of twice the
     initial position. *)

  val positions: env -> Lexing.position * Lexing.position

  (* This tells whether the parser is about to perform a default reduction.
     In particular, when applied to an environment taken from a result of
     the form [AboutToReduce (env, prod)], this tells whether the reduction
     that is about to take place is a default reduction. *)

  val has_default_reduction: env -> bool

end

(* This signature is a fragment of the inspection API that is made available
   to the user when [--inspection] is used. This fragment contains type
   definitions for symbols. *)

module type SYMBOLS = sig

  (* The type ['a terminal] represents a terminal symbol. The type ['a
     nonterminal] represents a nonterminal symbol. In both cases, the index
     ['a] represents the type of the semantic values associated with this
     symbol. The concrete definitions of these types are generated. *)

  type 'a terminal
  type 'a nonterminal

  (* The type ['a symbol] represents a terminal or nonterminal symbol. It is
     the disjoint union of the types ['a terminal] and ['a nonterminal]. *)

  type 'a symbol =
    | T : 'a terminal -> 'a symbol
    | N : 'a nonterminal -> 'a symbol

  (* The type [xsymbol] is an existentially quantified version of the type
     ['a symbol]. This type is useful in situations where the index ['a]
     is not statically known. *)

  type xsymbol =
    | X : 'a symbol -> xsymbol

end

(* This signature describes the inspection API that is made available to the
   user when [--inspection] is used. *)

module type INSPECTION = sig

  (* The types of symbols are described above. *)

  include SYMBOLS

  (* The type ['a lr1state] is meant to be the same as in [INCREMENTAL_ENGINE]. *)

  type 'a lr1state

  (* The type [production] is meant to be the same as in [INCREMENTAL_ENGINE].
     It represents a production of the grammar. A production can be examined
     via the functions [lhs] and [rhs] below. *)

  type production

  (* An LR(0) item is a pair of a production [prod] and a valid index [i] into
     this production. That is, if the length of [rhs prod] is [n], then [i] is
     comprised between 0 and [n], inclusive. *)

  type item =
      production * int

  (* Ordering functions. *)

  val compare_terminals: _ terminal -> _ terminal -> int
  val compare_nonterminals: _ nonterminal -> _ nonterminal -> int
  val compare_symbols: xsymbol -> xsymbol -> int
  val compare_productions: production -> production -> int
  val compare_items: item -> item -> int

  (* [incoming_symbol s] is the incoming symbol of the state [s], that is,
     the symbol that the parser must recognize before (has recognized when)
     it enters the state [s]. This function gives access to the semantic
     value [v] stored in a stack element [Element (s, v, _, _)]. Indeed,
     by case analysis on the symbol [incoming_symbol s], one discovers the
     type ['a] of the value [v]. *)

  val incoming_symbol: 'a lr1state -> 'a symbol

  (* [items s] is the set of the LR(0) items in the LR(0) core of the LR(1)
     state [s]. This set is not epsilon-closed. This set is presented as a
     list, in an arbitrary order. *)

  val items: _ lr1state -> item list

  (* [lhs prod] is the left-hand side of the production [prod]. This is
     always a non-terminal symbol. *)

  val lhs: production -> xsymbol

  (* [rhs prod] is the right-hand side of the production [prod]. This is
     a (possibly empty) sequence of (terminal or nonterminal) symbols. *)

  val rhs: production -> xsymbol list

  (* [nullable nt] tells whether the non-terminal symbol [nt] is nullable.
     That is, it is true if and only if this symbol produces the empty
     word [epsilon]. *)

  val nullable: _ nonterminal -> bool

  (* [first nt t] tells whether the FIRST set of the nonterminal symbol [nt]
     contains the terminal symbol [t]. That is, it is true if and only if
     [nt] produces a word that begins with [t]. *)

  val first: _ nonterminal -> _ terminal -> bool

  (* [xfirst] is analogous to [first], but expects a first argument of type
     [xsymbol] instead of [_ terminal]. *)

  val xfirst: xsymbol -> _ terminal -> bool

  (* [foreach_terminal] enumerates the terminal symbols, including [error].
     [foreach_terminal_but_error] enumerates the terminal symbols, excluding
     [error]. *)

  val foreach_terminal:           (xsymbol -> 'a -> 'a) -> 'a -> 'a
  val foreach_terminal_but_error: (xsymbol -> 'a -> 'a) -> 'a -> 'a

end

(* This signature combines the incremental API and the inspection API. *)

module type EVERYTHING = sig

  include INCREMENTAL_ENGINE

  include INSPECTION
    with type 'a lr1state := 'a lr1state
    with type production := production

end

end
module EngineTypes = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This file defines several types and module types that are used in the
   specification of module [Engine]. *)

(* --------------------------------------------------------------------------- *)

(* It would be nice if we could keep the structure of stacks and environments
   hidden. However, stacks and environments must be accessible to semantic
   actions, so the following data structure definitions must be public. *)

(* --------------------------------------------------------------------------- *)

(* A stack is a linked list of cells. A sentinel cell -- which is its own
   successor -- is used to mark the bottom of the stack. The sentinel cell
   itself is not significant -- it contains dummy values. *)

type ('state, 'semantic_value) stack = {

  (* The state that we should go back to if we pop this stack cell. *)

  (* This convention means that the state contained in the top stack cell is
     not the current state [env.current]. It also means that the state found
     within the sentinel is a dummy -- it is never consulted. This convention
     is the same as that adopted by the code-based back-end. *)

  state: 'state;

  (* The semantic value associated with the chunk of input that this cell
     represents. *)

  semv: 'semantic_value;

  (* The start and end positions of the chunk of input that this cell
     represents. *)

  startp: Lexing.position;
  endp: Lexing.position;

  (* The next cell down in the stack. If this is a self-pointer, then this
     cell is the sentinel, and the stack is conceptually empty. *)

  next: ('state, 'semantic_value) stack;

}

(* --------------------------------------------------------------------------- *)

(* A parsing environment contains all of the parser's state (except for the
   current program point). *)

type ('state, 'semantic_value, 'token) env = {

  (* If this flag is true, then the first component of [env.triple] should
     be ignored, as it has been logically overwritten with the [error]
     pseudo-token. *)

  error: bool;

  (* The last token that was obtained from the lexer, together with its start
     and end positions. Warning: before the first call to the lexer has taken
     place, a dummy (and possibly invalid) token is stored here. *)

  triple: 'token * Lexing.position * Lexing.position;

  (* The stack. In [CodeBackend], it is passed around on its own,
     whereas, here, it is accessed via the environment. *)

  stack: ('state, 'semantic_value) stack;

  (* The current state. In [CodeBackend], it is passed around on its
     own, whereas, here, it is accessed via the environment. *)

  current: 'state;

}

(* --------------------------------------------------------------------------- *)

(* This signature describes the parameters that must be supplied to the LR
   engine. *)

module type TABLE = sig

  (* The type of automaton states. *)

  type state

  (* States are numbered. *)

  val number: state -> int

  (* The type of tokens. These can be thought of as real tokens, that is,
     tokens returned by the lexer. They carry a semantic value. This type
     does not include the [error] pseudo-token. *)

  type token

  (* The type of terminal symbols. These can be thought of as integer codes.
     They do not carry a semantic value. This type does include the [error]
     pseudo-token. *)

  type terminal

  (* The type of semantic values. *)

  type semantic_value

  (* A token is conceptually a pair of a (non-[error]) terminal symbol and
     a semantic value. The following two functions are the pair projections. *)

  val token2terminal: token -> terminal
  val token2value: token -> semantic_value

  (* Even though the [error] pseudo-token is not a real token, it is a
     terminal symbol. Furthermore, for regularity, it must have a semantic
     value. *)

  val error_terminal: terminal
  val error_value: semantic_value

  (* The type of productions. *)

  type production

  (* If a state [s] has a default reduction on production [prod], then, upon
     entering [s], the automaton should reduce [prod] without consulting the
     lookahead token. The following function allows determining which states
     have default reductions. *)

  (* Instead of returning a value of a sum type -- either [DefRed prod], or
     [NoDefRed] -- it accepts two continuations, and invokes just one of
     them. This mechanism allows avoiding a memory allocation. *)

  val default_reduction:
    state ->
    ('env -> production -> 'answer) ->
    ('env -> 'answer) ->
    'env -> 'answer

  (* An LR automaton can normally take three kinds of actions: shift, reduce,
     or fail. (Acceptance is a particular case of reduction: it consists in
     reducing a start production.) *)

  (* There are two variants of the shift action. [shift/discard s] instructs
     the automaton to discard the current token, request a new one from the
     lexer, and move to state [s]. [shift/nodiscard s] instructs it to move to
     state [s] without requesting a new token. This instruction should be used
     when [s] has a default reduction on [#]. See [CodeBackend.gettoken] for
     details. *)

  (* This is the automaton's action table. It maps a pair of a state and a
     terminal symbol to an action. *)

  (* Instead of returning a value of a sum type -- one of shift/discard,
     shift/nodiscard, reduce, or fail -- this function accepts three
     continuations, and invokes just one them. This mechanism allows avoiding
     a memory allocation. *)

  (* In summary, the parameters to [action] are as follows:

     - the first two parameters, a state and a terminal symbol, are used to
       look up the action table;

     - the next parameter is the semantic value associated with the above
       terminal symbol; it is not used, only passed along to the shift
       continuation, as explained below;

     - the shift continuation expects an environment; a flag that tells
       whether to discard the current token; the terminal symbol that
       is being shifted; its semantic value; and the target state of
       the transition;

     - the reduce continuation expects an environment and a production;

     - the fail continuation expects an environment;

     - the last parameter is the environment; it is not used, only passed
       along to the selected continuation. *)

  val action:
    state ->
    terminal ->
    semantic_value ->
    ('env -> bool -> terminal -> semantic_value -> state -> 'answer) ->
    ('env -> production -> 'answer) ->
    ('env -> 'answer) ->
    'env -> 'answer

  (* This is the automaton's goto table. It maps a pair of a state and a
     production to a new state.

     This convention is slightly different from the textbook approach. The
     goto table is usually indexed by a state and a non-terminal symbol. *)

  val goto: state -> production -> state

  (* [is_start prod] tells whether the production [prod] is a start production. *)

  val is_start: production -> bool

  (* By convention, a semantic action is responsible for:

     1. fetching whatever semantic values and positions it needs off the stack;

     2. popping an appropriate number of cells off the stack, as dictated
        by the length of the right-hand side of the production;

     3. computing a new semantic value, as well as new start and end positions;

     4. pushing a new stack cell, which contains the three values
        computed in step 3;

     5. returning the new stack computed in steps 2 and 4.

     Point 1 is essentially forced upon us: if semantic values were fetched
     off the stack by this interpreter, then the calling convention for
     semantic actions would be variadic: not all semantic actions would have
     the same number of arguments. The rest follows rather naturally. *)

  (* Semantic actions are allowed to raise [Error]. *)

  exception Error

  type semantic_action =
      (state, semantic_value, token) env -> (state, semantic_value) stack

  val semantic_action: production -> semantic_action

  (* The LR engine requires a number of hooks, which are used for logging. *)

  (* The comments below indicate the conventional messages that correspond
     to these hooks in the code-based back-end; see [CodeBackend]. *)

  (* If the flag [log] is false, then the logging functions are not called.
     If it is [true], then they are called. *)

  val log : bool

  module Log : sig

    (* State %d: *)

    val state: state -> unit

    (* Shifting (<terminal>) to state <state> *)

    val shift: terminal -> state -> unit

    (* Reducing a production should be logged either as a reduction
       event (for regular productions) or as an acceptance event (for
       start productions). *)

    (* Reducing production <production> / Accepting *)

    val reduce_or_accept: production -> unit

    (* Lookahead token is now <terminal> (<pos>-<pos>) *)

    val lookahead_token: terminal -> Lexing.position -> Lexing.position -> unit

    (* Initiating error handling *)

    val initiating_error_handling: unit -> unit

    (* Resuming error handling *)

    val resuming_error_handling: unit -> unit

    (* Handling error in state <state> *)

    val handling_error: state -> unit

  end

end

(* --------------------------------------------------------------------------- *)

(* This signature describes the monolithic (traditional) LR engine. *)

(* In this interface, the parser controls the lexer. *)

module type MONOLITHIC_ENGINE = sig

  type state

  type token

  type semantic_value

  (* An entry point to the engine requires a start state, a lexer, and a lexing
     buffer. It either succeeds and produces a semantic value, or fails and
     raises [Error]. *)

  exception Error

  val entry:
    state ->
    (Lexing.lexbuf -> token) ->
    Lexing.lexbuf ->
    semantic_value

end

(* --------------------------------------------------------------------------- *)

(* The following signatures describe the incremental LR engine. *)

(* First, see [INCREMENTAL_ENGINE] in the file [IncrementalEngine.ml]. *)

(* The [start] function is set apart because we do not wish to publish
   it as part of the generated [parser.mli] file. Instead, the table
   back-end will publish specialized versions of it, with a suitable
   type cast. *)

module type INCREMENTAL_ENGINE_START = sig

  (* [start] is an entry point. It requires a start state and a start position
     and begins the parsing process. If the lexer is based on an OCaml lexing
     buffer, the start position should be [lexbuf.lex_curr_p]. [start] produces
     a checkpoint, which usually will be an [InputNeeded] checkpoint. (It could
     be [Accepted] if this starting state accepts only the empty word. It could
     be [Rejected] if this starting state accepts no word at all.) It does not
     raise any exception. *)

  (* [start s pos] should really produce a checkpoint of type ['a checkpoint],
     for a fixed ['a] that depends on the state [s]. We cannot express this, so
     we use [semantic_value checkpoint], which is safe. The table back-end uses
     [Obj.magic] to produce safe specialized versions of [start]. *)

  type state
  type semantic_value
  type 'a checkpoint

  val start:
    state ->
    Lexing.position ->
    semantic_value checkpoint

end

(* --------------------------------------------------------------------------- *)

(* This signature describes the LR engine, which combines the monolithic
   and incremental interfaces. *)

module type ENGINE = sig

  include MONOLITHIC_ENGINE

  include IncrementalEngine.INCREMENTAL_ENGINE
    with type token := token
     and type 'a lr1state = state (* useful for us; hidden from the end user *)

  include INCREMENTAL_ENGINE_START
    with type state := state
     and type semantic_value := semantic_value
     and type 'a checkpoint := 'a checkpoint

end

end
module Engine = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

open EngineTypes

(* The LR parsing engine. *)

(* This module is used:

   - at compile time, if so requested by the user, via the --interpret options;
   - at run time, in the table-based back-end. *)

module Make (T : TABLE) = struct

  (* This propagates type and exception definitions. *)

  include T

  type env =
      (state, semantic_value, token) EngineTypes.env

  (* --------------------------------------------------------------------------- *)

  (* The type [checkpoint] represents an intermediate or final result of the
     parser. See [EngineTypes]. *)

  (* The type [checkpoint] is presented to the user as a private type (see
     [IncrementalEngine]). This prevents the user from manufacturing checkpoints
     (i.e., continuations) that do not make sense. (Such continuations could
     potentially violate the LR invariant and lead to crashes.) *)

  type 'a checkpoint =
    | InputNeeded of env
    | Shifting of env * env * bool
    | AboutToReduce of env * production
    | HandlingError of env
    | Accepted of 'a
    | Rejected

  (* --------------------------------------------------------------------------- *)

  (* In the code-based back-end, the [run] function is sometimes responsible
     for pushing a new cell on the stack. This is motivated by code sharing
     concerns. In this interpreter, there is no such concern; [run]'s caller
     is always responsible for updating the stack. *)

  (* In the code-based back-end, there is a [run] function for each state
     [s]. This function can behave in two slightly different ways, depending
     on when it is invoked, or (equivalently) depending on [s].

     If [run] is invoked after shifting a terminal symbol (or, equivalently,
     if [s] has a terminal incoming symbol), then [run] discards a token,
     unless [s] has a default reduction on [#]. (Indeed, in that case,
     requesting the next token might drive the lexer off the end of the input
     stream.)

     If, on the other hand, [run] is invoked after performing a goto transition,
     or invoked directly by an entry point, then there is nothing to discard.

     These two cases are reflected in [CodeBackend.gettoken].

     Here, the code is structured in a slightly different way. It is up to the
     caller of [run] to indicate whether to discard a token, via the parameter
     [please_discard]. This flag is set when [s] is being entered by shifting
     a terminal symbol and [s] does not have a default reduction on [#]. *)

  (* The following recursive group of functions are tail recursive, produce a
     checkpoint of type [semantic_value checkpoint], and cannot raise an
     exception. A semantic action can raise [Error], but this exception is
     immediately caught within [reduce]. *)

  let rec run env please_discard : semantic_value checkpoint =

    (* Log the fact that we just entered this state. *)

    if log then
      Log.state env.current;

    (* If [please_discard] is set, we discard the current lookahead token and
       fetch the next one. In order to request a token from the user, we
       return an [InputNeeded] continuation, which, when invoked by the user,
       will take us to [discard]. If [please_discard] is not set, we skip this
       step and jump directly to [check_for_default_reduction]. *)

    if please_discard then
      InputNeeded env
    else
      check_for_default_reduction env

  (* [discard env triple] stores [triple] into [env], overwriting the previous
     token. It is invoked by [offer], which itself is invoked by the user in
     response to an [InputNeeded] checkpoint. *)

  and discard env triple =
    if log then begin
      let (token, startp, endp) = triple in
      Log.lookahead_token (T.token2terminal token) startp endp
    end;
    let env = { env with error = false; triple } in
    check_for_default_reduction env

  and check_for_default_reduction env =

    (* Examine what situation we are in. This case analysis is analogous to
       that performed in [CodeBackend.gettoken], in the sub-case where we do
       not have a terminal incoming symbol. *)

    T.default_reduction
      env.current
      announce_reduce       (* there is a default reduction; perform it *)
      check_for_error_token (* there is none; continue below *)
      env

  and check_for_error_token env =

    (* There is no default reduction. Consult the current lookahead token
       so as to determine which action should be taken. *)

    (* Peeking at the first input token, without taking it off the input
       stream, is done by reading [env.triple]. We are careful to first
       check [env.error]. *)

    (* Note that, if [please_discard] was true, then we have just called
       [discard], so the lookahead token cannot be [error]. *)

    (* Returning [HandlingError env] is equivalent to calling [error env]
       directly, except it allows the user to regain control. *)

    if env.error then begin
      if log then
        Log.resuming_error_handling();
      HandlingError env
    end
    else
      let (token, _, _) = env.triple in

      (* We consult the two-dimensional action table, indexed by the
         current state and the current lookahead token, in order to
         determine which action should be taken. *)

      T.action
        env.current                    (* determines a row *)
        (T.token2terminal token)       (* determines a column *)
        (T.token2value token)
        shift                          (* shift continuation *)
        announce_reduce                (* reduce continuation *)
        initiate                       (* failure continuation *)
        env

  (* --------------------------------------------------------------------------- *)

  (* This function takes care of shift transitions along a terminal symbol.
     (Goto transitions are taken care of within [reduce] below.) The symbol
     can be either an actual token or the [error] pseudo-token. *)

  (* Here, the lookahead token CAN be [error]. *)

  and shift env
      (please_discard : bool)
      (terminal : terminal)
      (value : semantic_value)
      (s' : state) =

    (* Log the transition. *)

    if log then
      Log.shift terminal s';

    (* Push a new cell onto the stack, containing the identity of the
       state that we are leaving. *)

    let (_, startp, endp) = env.triple in
    let stack = {
      state = env.current;
      semv = value;
      startp;
      endp;
      next = env.stack;
    } in

    (* Switch to state [s']. *)

    let new_env = { env with stack; current = s' } in

    (* Expose the transition to the user. (In principle, we have a choice
       between exposing the transition before we take it, after we take
       it, or at some point in between. This affects the number and type
       of the parameters carried by [Shifting]. Here, we choose to expose
       the transition after we take it; this allows [Shifting] to carry
       only three parameters, whose meaning is simple.) *)

    Shifting (env, new_env, please_discard)

  (* --------------------------------------------------------------------------- *)

  (* The function [announce_reduce] stops the parser and returns a checkpoint
     which allows the parser to be resumed by calling [reduce]. *)

  (* Only ordinary productions are exposed to the user. Start productions
     are not exposed to the user. Reducing a start production simply leads
     to the successful termination of the parser. *)

  and announce_reduce env (prod : production) =
    if T.is_start prod then
      accept env prod
    else
      AboutToReduce (env, prod)

  (* The function [reduce] takes care of reductions. It is invoked by
     [resume] after an [AboutToReduce] event has been produced. *)

  (* Here, the lookahead token CAN be [error]. *)

  (* The production [prod] CANNOT be a start production. *)

  and reduce env (prod : production) =

    (* Log a reduction event. *)

    if log then
      Log.reduce_or_accept prod;

    (* Invoke the semantic action. The semantic action is responsible for
       truncating the stack and pushing a new cell onto the stack, which
       contains a new semantic value. It can raise [Error]. *)

    (* If the semantic action terminates normally, it returns a new stack,
       which becomes the current stack. *)

    (* If the semantic action raises [Error], we catch it and initiate error
       handling. *)

    (* This [match/with/exception] construct requires OCaml 4.02. *)

    match T.semantic_action prod env with
    | stack ->

        (* By our convention, the semantic action has produced an updated
           stack. The state now found in the top stack cell is the return
           state. *)

        (* Perform a goto transition. The target state is determined
           by consulting the goto table at the return state and at
           production [prod]. *)

        let current = T.goto stack.state prod in
        let env = { env with stack; current } in
        run env false

    | exception Error ->
        initiate env

  and accept env prod =
    (* Log an accept event. *)
    if log then
      Log.reduce_or_accept prod;
    (* Extract the semantic value out of the stack. *)
    let v = env.stack.semv in
    (* Finish. *)
    Accepted v

  (* --------------------------------------------------------------------------- *)

  (* The following functions deal with errors. *)

  (* [initiate] initiates or resumes error handling. *)

  (* Here, the lookahead token CAN be [error]. *)

  and initiate env =
    if log then
      Log.initiating_error_handling();
    let env = { env with error = true } in
    HandlingError env

  (* [error] handles errors. *)

  and error env =
    assert env.error;

    (* Consult the column associated with the [error] pseudo-token in the
       action table. *)

    T.action
      env.current                    (* determines a row *)
      T.error_terminal               (* determines a column *)
      T.error_value
      error_shift                    (* shift continuation *)
      error_reduce                   (* reduce continuation *)
      error_fail                     (* failure continuation *)
      env

  and error_shift env please_discard terminal value s' =

    (* Here, [terminal] is [T.error_terminal], and [value] is [T.error_value]. *)

    assert (terminal = T.error_terminal && value = T.error_value);

    (* This state is capable of shifting the [error] token. *)

    if log then
      Log.handling_error env.current;
    shift env please_discard terminal value s'

  and error_reduce env prod =

    (* This state is capable of performing a reduction on [error]. *)

    if log then
      Log.handling_error env.current;
    reduce env prod
      (* Intentionally calling [reduce] instead of [announce_reduce].
         It does not seem very useful, and it could be confusing, to
         expose the reduction steps taken during error handling. *)

  and error_fail env =

    (* This state is unable to handle errors. Attempt to pop a stack
       cell. *)

    let cell = env.stack in
    let next = cell.next in
    if next == cell then

      (* The stack is empty. Die. *)

      Rejected

    else begin

      (* The stack is nonempty. Pop a cell, updating the current state
         with that found in the popped cell, and try again. *)

      let env = { env with
        stack = next;
        current = cell.state
      } in
      HandlingError env

    end

  (* End of the nest of tail recursive functions. *)

  (* --------------------------------------------------------------------------- *)
  (* --------------------------------------------------------------------------- *)

  (* The incremental interface. See [EngineTypes]. *)

  (* [start s] begins the parsing process. *)

  let start (s : state) (initial : Lexing.position) : semantic_value checkpoint =

    (* Build an empty stack. This is a dummy cell, which is its own successor.
       Its [next] field WILL be accessed by [error_fail] if an error occurs and
       is propagated all the way until the stack is empty. Its [endp] field WILL
       be accessed (by a semantic action) if an epsilon production is reduced
       when the stack is empty. *)

    let rec empty = {
      state = s;                          (* dummy *)
      semv = T.error_value;               (* dummy *)
      startp = initial;                   (* dummy *)
      endp = initial;
      next = empty;
    } in

    (* Build an initial environment. *)

    (* Unfortunately, there is no type-safe way of constructing a
       dummy token. Tokens carry semantic values, which in general
       we cannot manufacture. This instance of [Obj.magic] could
       be avoided by adopting a different representation (e.g., no
       [env.error] field, and an option in the first component of
       [env.triple]), but I like this representation better. *)

    let dummy_token = Obj.magic () in
    let env = {
      error = false;
      triple = (dummy_token, initial, initial); (* dummy *)
      stack = empty;
      current = s;
    } in

    (* Begin parsing. *)

    (* The parameter [please_discard] here is [true], which means we know
       that we must read at least one token. This claim relies on the fact
       that we have ruled out the two special cases where a start symbol
       recognizes the empty language or the singleton language {epsilon}. *)

    run env true

  (* [offer checkpoint triple] is invoked by the user in response to a
     checkpoint of the form [InputNeeded env]. It checks that [checkpoint] is
     indeed of this form, and invokes [discard]. *)

  (* [resume checkpoint] is invoked by the user in response to a checkpoint of
     the form [AboutToReduce (env, prod)] or [HandlingError env]. It checks
     that [checkpoint] is indeed of this form, and invokes [reduce] or
     [error], as appropriate. *)

  (* In reality, [offer] and [resume] accept an argument of type
     [semantic_value checkpoint] and produce a checkpoint of the same type.
     The choice of [semantic_value] is forced by the fact that this is the
     parameter of the checkpoint [Accepted]. *)

  (* We change this as follows. *)

  (* We change the argument and result type of [offer] and [resume] from
     [semantic_value checkpoint] to ['a checkpoint]. This is safe, in this
     case, because we give the user access to values of type [t checkpoint]
     only if [t] is indeed the type of the eventual semantic value for this
     run. (More precisely, by examining the signatures [INCREMENTAL_ENGINE]
     and [INCREMENTAL_ENGINE_START], one finds that the user can build a value
     of type ['a checkpoint] only if ['a] is [semantic_value]. The table
     back-end goes further than this and produces versions of [start] composed
     with a suitable cast, which give the user access to a value of type
     [t checkpoint] where [t] is the type of the start symbol.) *)

  let offer : 'a . 'a checkpoint ->
                   token * Lexing.position * Lexing.position ->
                   'a checkpoint
  = function
    | InputNeeded env ->
        Obj.magic discard env
    | _ ->
        raise (Invalid_argument "offer expects InputNeeded")

  let resume : 'a . 'a checkpoint -> 'a checkpoint = function
    | HandlingError env ->
        Obj.magic error env
    | Shifting (_, env, please_discard) ->
        Obj.magic run env please_discard
    | AboutToReduce (env, prod) ->
        Obj.magic reduce env prod
    | _ ->
        raise (Invalid_argument "resume expects HandlingError | AboutToReduce")

  (* --------------------------------------------------------------------------- *)
  (* --------------------------------------------------------------------------- *)

  (* The traditional interface. See [EngineTypes]. *)

  (* --------------------------------------------------------------------------- *)

  (* Wrapping a lexer and lexbuf as a token supplier. *)

  type supplier =
    unit -> token * Lexing.position * Lexing.position

  let lexer_lexbuf_to_supplier
      (lexer : Lexing.lexbuf -> token)
      (lexbuf : Lexing.lexbuf)
  : supplier =
    fun () ->
      let token = lexer lexbuf in
      let startp = lexbuf.Lexing.lex_start_p
      and endp = lexbuf.Lexing.lex_curr_p in
      token, startp, endp

  (* --------------------------------------------------------------------------- *)

  (* The main loop repeatedly handles intermediate checkpoints, until a final
     checkpoint is obtained. This allows implementing the monolithic interface
     ([entry]) in terms of the incremental interface ([start], [offer],
     [handle], [reduce]). *)

  (* By convention, acceptance is reported by returning a semantic value, whereas
     rejection is reported by raising [Error]. *)

  (* [loop] is polymorphic in ['a]. No cheating is involved in achieving this.
     All of the cheating resides in the types assigned to [offer] and [handle]
     above. *)

  let rec loop : 'a . supplier -> 'a checkpoint -> 'a =
    fun read checkpoint ->
    match checkpoint with
    | InputNeeded _ ->
        (* The parser needs a token. Request one from the lexer,
           and offer it to the parser, which will produce a new
           checkpoint. Then, repeat. *)
        let triple = read() in
        let checkpoint = offer checkpoint triple in
        loop read checkpoint
    | Shifting _
    | AboutToReduce _
    | HandlingError _ ->
        (* The parser has suspended itself, but does not need
           new input. Just resume the parser. Then, repeat. *)
        let checkpoint = resume checkpoint in
        loop read checkpoint
    | Accepted v ->
        (* The parser has succeeded and produced a semantic value.
           Return this semantic value to the user. *)
        v
    | Rejected ->
        (* The parser rejects this input. Raise an exception. *)
        raise Error

  let entry (s : state) lexer lexbuf : semantic_value =
    let initial = lexbuf.Lexing.lex_curr_p in
    loop (lexer_lexbuf_to_supplier lexer lexbuf) (start s initial)

  (* --------------------------------------------------------------------------- *)

  (* [loop_handle] stops if it encounters an error, and at this point, invokes
     its failure continuation, without letting Menhir do its own traditional
     error-handling (which involves popping the stack, etc.). *)

  let rec loop_handle succeed fail read checkpoint =
    match checkpoint with
    | InputNeeded _ ->
        let triple = read() in
        let checkpoint = offer checkpoint triple in
        loop_handle succeed fail read checkpoint
    | Shifting _
    | AboutToReduce _ ->
        let checkpoint = resume checkpoint in
        loop_handle succeed fail read checkpoint
    | HandlingError _
    | Rejected ->
        (* The parser has detected an error. Invoke the failure continuation. *)
        fail checkpoint
    | Accepted v ->
        (* The parser has succeeded and produced a semantic value. Invoke the
           success continuation. *)
        succeed v

  (* --------------------------------------------------------------------------- *)

  (* [loop_handle_undo] is analogous to [loop_handle], except it passes a pair
     of checkpoints to the failure continuation.

     The first (and oldest) checkpoint is the last [InputNeeded] checkpoint that
     was encountered before the error was detected. The second (and newest)
     checkpoint is where the error was detected, as in [loop_handle]. Going back
     to the first checkpoint can be thought of as undoing any reductions that
     were performed after seeing the problematic token. (These reductions must
     be default reductions or spurious reductions.) *)

  let rec loop_handle_undo succeed fail read (inputneeded, checkpoint) =
    match checkpoint with
    | InputNeeded _ ->
        (* Update the last recorded [InputNeeded] checkpoint. *)
        let inputneeded = checkpoint in
        let triple = read() in
        let checkpoint = offer checkpoint triple in
        loop_handle_undo succeed fail read (inputneeded, checkpoint)
    | Shifting _
    | AboutToReduce _ ->
        let checkpoint = resume checkpoint in
        loop_handle_undo succeed fail read (inputneeded, checkpoint)
    | HandlingError _
    | Rejected ->
        fail inputneeded checkpoint
    | Accepted v ->
        succeed v

  (* For simplicity, we publish a version of [loop_handle_undo] that takes a
     single checkpoint as an argument, instead of a pair of checkpoints. We
     check that the argument is [InputNeeded _], and duplicate it. *)

  (* The parser cannot accept or reject before it asks for the very first
     character of input. (Indeed, we statically reject a symbol that
     generates the empty language or the singleton language {epsilon}.)
     So, the [start] checkpoint must match [InputNeeded _]. Hence, it is
     permitted to call [loop_handle_undo] with a [start] checkpoint. *)

  let loop_handle_undo succeed fail read checkpoint =
    assert (match checkpoint with InputNeeded _ -> true | _ -> false);
    loop_handle_undo succeed fail read (checkpoint, checkpoint)

  (* ------------------------------------------------------------------------ *)

  (* [loop_test f checkpoint accu] assumes that [checkpoint] has been obtained
     by submitting a token to the parser. It runs the parser from [checkpoint],
     through an arbitrary number of reductions, until the parser either accepts
     this token (i.e., shifts) or rejects it (i.e., signals an error). If the
     parser decides to shift, then the accumulator is updated by applying the
     user function [f] to the [env] just before shifting and to the old [accu].
     Otherwise, the accumulator is not updated, i.e., [accu] is returned. *)

  (* This test causes some semantic actions to be run! The semantic actions
     should be side-effect free, or their side-effects should be harmless. *)

  let rec loop_test f checkpoint accu =
    match checkpoint with
    | Shifting (env, _, _) ->
        (* The parser is about to shift, which means it is willing to
           consume the terminal symbol that we have fed it. Update the
           accumulator with the state just before this transition. *)
        f env accu
    | AboutToReduce _ ->
        (* The parser wishes to reduce. Just follow. *)
        loop_test f (resume checkpoint) accu
    | HandlingError _ ->
        (* The parser fails, which means it rejects the terminal symbol
           that we have fed it. Do not update the accumulator. *)
        accu
    | InputNeeded _
    | Accepted _
    | Rejected ->
        (* None of these cases can arise. Indeed, after a token is submitted
           to it, the parser must shift, reduce, or signal an error, before
           it can request another token or terminate. *)
        assert false

  (* --------------------------------------------------------------------------- *)

  (* The function [loop_test] can be used, after an error has been detected, to
     dynamically test which tokens would have been accepted at this point. We
     provide this test, ready for use. *)

  (* For completeness, one must undo any spurious reductions before carrying out
     this test -- that is, one must apply [acceptable] to the FIRST checkpoint
     that is passed by [loop_handle_undo] to its failure continuation. *)

  (* This test causes some semantic actions to be run! The semantic actions
     should be side-effect free, or their side-effects should be harmless. *)

  (* The position [pos] is used as the start and end positions of the
     hypothetical token, and may be picked up by the semantic actions. We
     suggest using the position where the error was detected. *)

  let acceptable checkpoint token pos =
    let triple = (token, pos, pos) in
    let checkpoint = offer checkpoint triple in
    loop_test (fun _env _accu -> true) checkpoint false

  (* --------------------------------------------------------------------------- *)

  (* The type ['a lr1state] describes the (non-initial) states of the LR(1)
     automaton. The index ['a] represents the type of the semantic value
     associated with the state's incoming symbol. *)

  (* The type ['a lr1state] is defined as an alias for [state], which itself
     is usually defined as [int] (see [TableInterpreter]). So, ['a lr1state]
     is technically a phantom type, but should really be thought of as a GADT
     whose data constructors happen to be represented as integers. It is
     presented to the user as an abstract type (see [IncrementalEngine]). *)

  type 'a lr1state =
      state

  (* --------------------------------------------------------------------------- *)

  (* Stack inspection. *)

  (* We offer a read-only view of the parser's state as a stream of elements.
     Each element contains a pair of a (non-initial) state and a semantic
     value associated with (the incoming symbol of) this state. Note that the
     type [element] is an existential type. *)

  type element =
    | Element: 'a lr1state * 'a * Lexing.position * Lexing.position -> element

  open General

  type stack =
    element stream

  (* If [current] is the current state and [cell] is the top stack cell,
     then [stack cell current] is a view of the parser's state as a stream
     of elements. *)

  let rec stack cell current : element stream =
    lazy (
      (* The stack is empty iff the top stack cell is its own successor. In
         that case, the current state [current] should be an initial state
         (which has no incoming symbol).
         We do not allow the user to inspect this state. *)
      let next = cell.next in
      if next == cell then
        Nil
      else
        (* Construct an element containing the current state [current] as well
           as the semantic value contained in the top stack cell. This semantic
           value is associated with the incoming symbol of this state, so it
           makes sense to pair them together. The state has type ['a state] and
           the semantic value has type ['a], for some type ['a]. Here, the OCaml
           type-checker thinks ['a] is [semantic_value] and considers this code
           well-typed. Outside, we will use magic to provide the user with a way
           of inspecting states and recovering the value of ['a]. *)
        let element = Element (
          current,
          cell.semv,
          cell.startp,
          cell.endp
        ) in
        Cons (element, stack next cell.state)
    )

  let stack env : element stream =
    stack env.stack env.current

  (* --------------------------------------------------------------------------- *)

  (* Access to the position of the lookahead token. *)

  let positions { triple = (_, startp, endp); _ } =
    startp, endp

  (* --------------------------------------------------------------------------- *)

  (* Access to information about default reductions. *)

  (* We can make this a function of states, or a function of environments. For
     now, the latter appears simpler. *)

  let has_default_reduction env : bool =
    T.default_reduction
      env.current
      (fun _env _prod -> true)
      (fun _env -> false)
      env

end

end
module Printers = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

module Make
  (I : IncrementalEngine.EVERYTHING)
  (User : sig
    val print: string -> unit
    val print_symbol: I.xsymbol -> unit
    val print_element: (I.element -> unit) option
  end)
= struct

  let arrow = " -> "
  let dot = "."
  let space = " "
  let newline = "\n"

  open User
  open I

  (* Printing a list of symbols. An optional dot is printed at offset
     [i] into the list [symbols], if this offset lies between [0] and
     the length of the list (included). *)

  let rec print_symbols i symbols =
    if i = 0 then begin
      print dot;
      print space;
      print_symbols (-1) symbols
    end
    else begin
      match symbols with
      | [] ->
          ()
      | symbol :: symbols ->
          print_symbol symbol;
          print space;
          print_symbols (i - 1) symbols
    end

  (* Printing an element as a symbol. *)

  let print_element_as_symbol element =
    match element with
    | Element (s, _, _, _) ->
        print_symbol (X (incoming_symbol s))

  (* Some of the functions that follow need an element printer. They use
     [print_element] if provided by the user; otherwise they use
     [print_element_as_symbol]. *)

  let print_element =
    match print_element with
    | Some print_element ->
        print_element
    | None ->
        print_element_as_symbol

  (* Printing a stack as a list of symbols. *)

  let print_stack stack =
    General.foldr (fun element () ->
      print_element element;
      print space
    ) stack ();
    print newline

  (* Printing an item. *)

  let print_item (prod, i) =
    print_symbol (lhs prod);
    print arrow;
    print_symbols i (rhs prod);
    print newline

  (* Printing a list of symbols (public version). *)

  let print_symbols symbols =
    print_symbols (-1) symbols

  (* Printing a production (without a dot). *)

  let print_production prod =
    print_item (prod, -1)

  (* Printing the current LR(1) state. *)

  let print_current_state env =
    print "Current LR(1) state: ";
    match Lazy.force (stack env) with
    | General.Nil ->
        print "<some initial state>";
        print newline
    | General.Cons (Element (current, _, _, _), _) ->
        print (string_of_int (Obj.magic current)); (* TEMPORARY safe conversion needed *)
        print newline;
        List.iter print_item (items current)

  let print_env env =
    print_stack (stack env);
    print_current_state env;
    print newline

end

end
module InfiniteArray = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(** This module implements infinite arrays, that is, arrays that grow
    transparently upon demand. *)

type 'a t = {
    default: 'a;
    mutable table: 'a array;
    mutable extent: int; (* the index of the greatest [set] ever, plus one *)
  }

let default_size =
  16384 (* must be non-zero *)

let make x = {
  default = x;
  table = Array.make default_size x;
  extent = 0;
}

let rec new_length length i =
  if i < length then
    length
  else
    new_length (2 * length) i

let ensure a i =
  assert (0 <= i);
  let table = a.table in
  let length = Array.length table in
  if i >= length then begin
    let table' = Array.make (new_length (2 * length) i) a.default in
    Array.blit table 0 table' 0 length;
    a.table <- table'
  end

let get a i =
  ensure a i;
  Array.unsafe_get a.table (i)

let set a i x =
  ensure a i;
  Array.unsafe_set a.table (i) x;
  if a.extent <= i then
    a.extent <- i + 1

let extent a =
  a.extent

let domain a =
  Array.sub a.table 0 a.extent

end
module PackedIntArray = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* A packed integer array is represented as a pair of an integer [k] and
   a string [s]. The integer [k] is the number of bits per integer that we
   use. The string [s] is just an array of bits, which is read in 8-bit
   chunks. *)

(* The ocaml programming language treats string literals and array literals
   in slightly different ways: the former are statically allocated, while
   the latter are dynamically allocated. (This is rather arbitrary.) In the
   context of Menhir's table-based back-end, where compact, immutable
   integer arrays are needed, ocaml strings are preferable to ocaml arrays. *)

type t =
  int * string

(* The magnitude [k] of an integer [v] is the number of bits required
   to represent [v]. It is rounded up to the nearest power of two, so
   that [k] divides [Sys.word_size]. *)

let magnitude (v : int) =
  if v < 0 then
    Sys.word_size
  else
    let rec check k max = (* [max] equals [2^k] *)
      if (max <= 0) || (v < max) then
        k
          (* if [max] just overflew, then [v] requires a full ocaml
             integer, and [k] is the number of bits in an ocaml integer
             plus one, that is, [Sys.word_size]. *)
      else
        check (2 * k) (max * max)
    in
    check 1 2

(* [pack a] turns an array of integers into a packed integer array. *)

(* Because the sign bit is the most significant bit, the magnitude of
   any negative number is the word size. In other words, [pack] does
   not achieve any space savings as soon as [a] contains any negative
   numbers, even if they are ``small''. *)

let pack (a : int array) : t =

  let m = Array.length a in

  (* Compute the maximum magnitude of the array elements. This tells
     us how many bits per element we are going to use. *)

  let k =
    Array.fold_left (fun k v ->
      max k (magnitude v)
    ) 1 a
  in

  (* Because access to ocaml strings is performed on an 8-bit basis,
     two cases arise. If [k] is less than 8, then we can pack multiple
     array entries into a single character. If [k] is greater than 8,
     then we must use multiple characters to represent a single array
     entry. *)

  if k <= 8 then begin

    (* [w] is the number of array entries that we pack in a character. *)

    assert (8 mod k = 0);
    let w = 8 / k in

    (* [n] is the length of the string that we allocate. *)

    let n =
      if m mod w = 0 then
        m / w
      else
        m / w + 1
    in

    let s =
      Bytes.create n
    in

    (* Define a reader for the source array. The reader might run off
       the end if [w] does not divide [m]. *)

    let i = ref 0 in
    let next () =
      let ii = !i in
      if ii = m then
        0 (* ran off the end, pad with zeroes *)
      else
        let v = a.(ii) in
        i := ii + 1;
        v
    in

    (* Fill up the string. *)

    for j = 0 to n - 1 do
      let c = ref 0 in
      for _x = 1 to w do
        c := (!c lsl k) lor next()
      done;
      Bytes.set s j (Char.chr !c)
    done;

    (* Done. *)

    k, Bytes.unsafe_to_string s

  end
  else begin (* k > 8 *)

    (* [w] is the number of characters that we use to encode an array entry. *)

    assert (k mod 8 = 0);
    let w = k / 8 in

    (* [n] is the length of the string that we allocate. *)

    let n =
      m * w
    in

    let s =
      Bytes.create n
    in

    (* Fill up the string. *)

    for i = 0 to m - 1 do
      let v = ref a.(i) in
      for x = 1 to w do
        Bytes.set s ((i + 1) * w - x) (Char.chr (!v land 255));
        v := !v lsr 8
      done
    done;

    (* Done. *)

    k, Bytes.unsafe_to_string s

  end

(* Access to a string. *)

let read (s : string) (i : int) : int =
  Char.code (String.unsafe_get s i)

(* [get1 t i] returns the integer stored in the packed array [t] at index [i].
   It assumes (and does not check) that the array's bit width is [1]. The
   parameter [t] is just a string. *)

let get1 (s : string) (i : int) : int =
  let c = read s (i lsr 3) in
  let c = c lsr ((lnot i) land 0b111) in
  let c = c land 0b1 in
  c

(* [get t i] returns the integer stored in the packed array [t] at index [i]. *)

(* Together, [pack] and [get] satisfy the following property: if the index [i]
   is within bounds, then [get (pack a) i] equals [a.(i)]. *)

let get ((k, s) : t) (i : int) : int =
  match k with
  | 1 ->
      get1 s i
  | 2 ->
      let c = read s (i lsr 2) in
      let c = c lsr (2 * ((lnot i) land 0b11)) in
      let c = c land 0b11 in
      c
  | 4 ->
      let c = read s (i lsr 1) in
      let c = c lsr (4 * ((lnot i) land 0b1)) in
      let c = c land 0b1111 in
      c
  | 8 ->
      read s i
  | 16 ->
      let j = 2 * i in
      (read s j) lsl 8 + read s (j + 1)
  | _ ->
      assert (k = 32); (* 64 bits unlikely, not supported *)
      let j = 4 * i in
      (((read s j lsl 8) + read s (j + 1)) lsl 8 + read s (j + 2)) lsl 8 + read s (j + 3)

(* [unflatten1 (n, data) i j] accesses the two-dimensional bitmap
   represented by [(n, data)] at indices [i] and [j]. The integer
   [n] is the width of the bitmap; the string [data] is the second
   component of the packed array obtained by encoding the table as
   a one-dimensional array. *)

let unflatten1 (n, data) i j =
   get1 data (n * i + j)

end
module RowDisplacement = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This module compresses a two-dimensional table, where some values
   are considered insignificant, via row displacement. *)

(* This idea reportedly appears in Aho and Ullman's ``Principles
   of Compiler Design'' (1977). It is evaluated in Tarjan and Yao's
   ``Storing a Sparse Table'' (1979) and in Dencker, Drre, and Heuft's
   ``Optimization of Parser Tables for Portable Compilers'' (1984). *)

(* A compressed table is represented as a pair of arrays. The
   displacement array is an array of offsets into the data array. *)

type 'a table =
    int array * (* displacement *)
     'a array   (* data *)

(* In a natural version of this algorithm, displacements would be greater
   than (or equal to) [-n]. However, in the particular setting of Menhir,
   both arrays are intended to be compressed with [PackedIntArray], which
   does not efficiently support negative numbers. For this reason, we are
   careful not to produce negative displacements. *)

(* In order to avoid producing negative displacements, we simply use the
   least significant bit as the sign bit. This is implemented by [encode]
   and [decode] below. *)

(* One could also think, say, of adding [n] to every displacement, so as
   to ensure that all displacements are nonnegative. This would work, but
   would require [n] to be published, for use by the decoder. *)

let encode (displacement : int) : int =
  if displacement >= 0 then
    displacement lsl 1
  else
    (-displacement) lsl 1 + 1

let decode (displacement : int) : int =
  if displacement land 1 = 0 then
    displacement lsr 1
  else
    -(displacement lsr 1)

(* It is reasonable to assume that, as matrices grow large, their
   density becomes low, i.e., they have many insignificant entries.
   As a result, it is important to work with a sparse data structure
   for rows. We internally represent a row as a list of its
   significant entries, where each entry is a pair of a [j] index and
   an element. *)

type 'a row =
    (int * 'a) list

(* [compress equal insignificant dummy m n t] turns the two-dimensional table
   [t] into a compressed table. The parameter [equal] is equality of data
   values. The parameter [wildcard] tells which data values are insignificant,
   and can thus be overwritten with other values. The parameter [dummy] is
   used to fill holes in the data array. [m] and [n] are the integer
   dimensions of the table [t]. *)

let compress
    (equal : 'a -> 'a -> bool)
    (insignificant : 'a -> bool)
    (dummy : 'a)
    (m : int) (n : int)
    (t : 'a array array)
    : 'a table =

  (* Be defensive. *)

  assert (Array.length t = m);
  assert begin
    for i = 0 to m - 1 do
      assert (Array.length t.(i) = n)
    done;
    true
  end;

  (* This turns a row-as-array into a row-as-sparse-list. The row is
     accompanied by its index [i] and by its rank (the number of its
     significant entries, that is, the length of the row-as-a-list. *)

  let sparse (i : int) (line : 'a array) : int * int * 'a row (* index, rank, row *) =

    let rec loop (j : int) (rank : int) (row : 'a row) =
      if j < 0 then
        i, rank, row
      else
        let x = line.(j) in
        if insignificant x then
          loop (j - 1) rank row
        else
          loop (j - 1) (1 + rank) ((j, x) :: row)
    in

    loop (n - 1) 0 []

  in

  (* Construct an array of all rows, together with their index and rank. *)

  let rows : (int * int * 'a row) array = (* index, rank, row *)
    Array.mapi sparse t
  in

  (* Sort this array by decreasing rank. This does not have any impact
     on correctness, but reportedly improves compression. The
     intuitive idea is that rows with few significant elements are
     easy to fit, so they should be inserted last, after the problem
     has become quite constrained by fitting the heavier rows. This
     heuristic is attributed to Ziegler. *)

  Array.fast_sort (fun (_, rank1, _) (_, rank2, _) ->
    compare rank2 rank1
  ) rows;

  (* Allocate a one-dimensional array of displacements. *)

  let displacement : int array =
    Array.make m 0
  in

  (* Allocate a one-dimensional, infinite array of values. Indices
     into this array are written [k]. *)

  let data : 'a InfiniteArray.t =
    InfiniteArray.make dummy
  in

  (* Determine whether [row] fits at offset [k] within the current [data]
     array, up to extension of this array. *)

  (* Note that this check always succeeds when [k] equals the length of
     the [data] array. Indeed, the loop is then skipped. This property
     guarantees the termination of the recursive function [fit] below. *)

  let fits k (row : 'a row) : bool =

    let d = InfiniteArray.extent data in

    let rec loop = function
      | [] ->
          true
      | (j, x) :: row ->

          (* [x] is a significant element. *)

          (* By hypothesis, [k + j] is nonnegative. If it is greater than or
             equal to the current length of the data array, stop -- the row
             fits. *)

          assert (k + j >= 0);

          if k + j >= d then
            true

          (* We now know that [k + j] is within bounds of the data
             array. Check whether it is compatible with the element [y] found
             there. If it is, continue. If it isn't, stop -- the row does not
             fit. *)

          else
            let y = InfiniteArray.get data (k + j) in
            if insignificant y || equal x y then
              loop row
            else
              false

    in
    loop row

  in

  (* Find the leftmost position where a row fits. *)

  (* If the leftmost significant element in this row is at offset [j],
     then we can hope to fit as far left as [-j] -- so this element
     lands at offset [0] in the data array. *)

  (* Note that displacements may be negative. This means that, for
     insignificant elements, accesses to the data array could fail: they could
     be out of bounds, either towards the left or towards the right. This is
     not a problem, as long as [get] is invoked only at significant
     elements. *)

  let rec fit k row : int =
    if fits k row then
      k
    else
      fit (k + 1) row
  in

  let fit row =
    match row with
    | [] ->
        0 (* irrelevant *)
    | (j, _) :: _ ->
        fit (-j) row
  in

  (* Write [row] at (compatible) offset [k]. *)

  let rec write k = function
    | [] ->
        ()
    | (j, x) :: row ->
        InfiniteArray.set data (k + j) x;
        write k row
  in

  (* Iterate over the sorted array of rows. Fit and write each row at
     the leftmost compatible offset. Update the displacement table. *)

  Array.iter (fun (i, _, row) ->
    let k = fit row in (* if [row] has leading insignificant elements, then [k] can be negative *)
    write k row;
    displacement.(i) <- encode k
  ) rows;

  (* Return the compressed tables. *)

  displacement, InfiniteArray.domain data

(* [get ct i j] returns the value found at indices [i] and [j] in the
   compressed table [ct]. This function call is permitted only if the
   value found at indices [i] and [j] in the original table is
   significant -- otherwise, it could fail abruptly. *)

(* Together, [compress] and [get] have the property that, if the value
   found at indices [i] and [j] in an uncompressed table [t] is
   significant, then [get (compress t) i j] is equal to that value. *)

let get (displacement, data) i j =
  assert (0 <= i && i < Array.length displacement);
  let k = decode displacement.(i) in
  assert (0 <= k + j && k + j < Array.length data);
    (* failure of this assertion indicates an attempt to access an
       insignificant element that happens to be mapped out of the bounds
       of the [data] array. *)
  data.(k + j)

(* [getget] is a variant of [get] which only requires read access,
   via accessors, to the two components of the table. *)

let getget get_displacement get_data (displacement, data) i j =
  let k = decode (get_displacement displacement i) in
  get_data data (k + j)

end
module LinearizedArray = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* The [entry] array contains offsets into the [data] array. It has [n+1]
   elements if the original (unencoded) array has [n] elements. The value
   of [entry.(n)] is the length of the [data] array. This convention is
   natural and allows avoiding a special case. *)

type 'a t =
  (* data: *)   'a array *
  (* entry: *) int array

let make (a : 'a array array) : 'a t =
  let n = Array.length a in
  (* Build the entry array. *)
  let size = ref 0 in
  let entry = Array.init (n + 1) (fun i ->
    let s = !size in
    if i < n then
      size := s + Array.length a.(i);
    s
  ) in
  assert (entry.(n) = !size);
  (* Build the data array. *)
  let i = ref 0
  and j = ref 0 in
  let data = Array.init !size (fun _ ->
    while !j = Array.length a.(!i) do
      i := !i + 1;
      j := 0;
    done;
    let x = a.(!i).(!j) in
    j := !j + 1;
    x
  ) in
  data, entry

let length ((_, entry) : 'a t) : int =
  Array.length entry

let row_length ((_, entry) : 'a t) i : int =
  entry.(i + 1) - entry.(i)

let row_length_via get_entry i =
  get_entry (i + 1) - get_entry i

let read ((data, entry) as la : 'a t) i j : 'a =
  assert (0 <= j && j < row_length la i);
  data.(entry.(i) + j)

let read_via get_data get_entry i j =
  assert (0 <= j && j < row_length_via get_entry i);
  get_data (get_entry i + j)

let write ((data, entry) as la : 'a t) i j (v : 'a) : unit =
  assert (0 <= j && j < row_length la i);
  data.(entry.(i) + j) <- v

let rec read_interval_via get_data i j =
  if i = j then
    []
  else
    get_data i :: read_interval_via get_data (i + 1) j

let read_row_via get_data get_entry i =
  read_interval_via get_data (get_entry i) (get_entry (i + 1))

let read_row ((data, entry) : 'a t) i : 'a list =
  read_row_via (Array.get data) (Array.get entry) i

end
module TableFormat = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This signature defines the format of the parse tables. It is used as
   an argument to [TableInterpreter.Make]. *)

module type TABLES = sig

  (* This is the parser's type of tokens. *)

  type token

  (* This maps a token to its internal (generation-time) integer code. *)

  val token2terminal: token -> int

  (* This is the integer code for the error pseudo-token. *)

  val error_terminal: int

  (* This maps a token to its semantic value. *)

  val token2value: token -> Obj.t

  (* Traditionally, an LR automaton is described by two tables, namely, an
     action table and a goto table. See, for instance, the Dragon book.

     The action table is a two-dimensional matrix that maps a state and a
     lookahead token to an action. An action is one of: shift to a certain
     state, reduce a certain production, accept, or fail.

     The goto table is a two-dimensional matrix that maps a state and a
     non-terminal symbol to either a state or undefined. By construction, this
     table is sparse: its undefined entries are never looked up. A compression
     technique is free to overlap them with other entries.

     In Menhir, things are slightly different. If a state has a default
     reduction on token [#], then that reduction must be performed without
     consulting the lookahead token. As a result, we must first determine
     whether that is the case, before we can obtain a lookahead token and use it
     as an index in the action table.

     Thus, Menhir's tables are as follows.

     A one-dimensional default reduction table maps a state to either ``no
     default reduction'' (encoded as: 0) or ``by default, reduce prod''
     (encoded as: 1 + prod). The action table is looked up only when there
     is no default reduction. *)

  val default_reduction: PackedIntArray.t

  (* Menhir follows Dencker, Drre and Heuft, who point out that, although the
     action table is not sparse by nature (i.e., the error entries are
     significant), it can be made sparse by first factoring out a binary error
     matrix, then replacing the error entries in the action table with undefined
     entries. Thus:

     A two-dimensional error bitmap maps a state and a terminal to either
     ``fail'' (encoded as: 0) or ``do not fail'' (encoded as: 1). The action
     table, which is now sparse, is looked up only in the latter case. *)

  (* The error bitmap is flattened into a one-dimensional table; its width is
     recorded so as to allow indexing. The table is then compressed via
     [PackedIntArray]. The bit width of the resulting packed array must be
     [1], so it is not explicitly recorded. *)

  (* The error bitmap does not contain a column for the [#] pseudo-terminal.
     Thus, its width is [Terminal.n - 1]. We exploit the fact that the integer
     code assigned to [#] is greatest: the fact that the right-most column
     in the bitmap is missing does not affect the code for accessing it. *)

  val error: int (* width of the bitmap *) * string (* second component of [PackedIntArray.t] *)

  (* A two-dimensional action table maps a state and a terminal to one of
     ``shift to state s and discard the current token'' (encoded as: s | 10),
     ``shift to state s without discarding the current token'' (encoded as: s |
     11), or ``reduce prod'' (encoded as: prod | 01). *)

  (* The action table is first compressed via [RowDisplacement], then packed
     via [PackedIntArray]. *)

  (* Like the error bitmap, the action table does not contain a column for the
     [#] pseudo-terminal. *)

  val action: PackedIntArray.t * PackedIntArray.t

  (* A one-dimensional lhs table maps a production to its left-hand side (a
     non-terminal symbol). *)

  val lhs: PackedIntArray.t

  (* A two-dimensional goto table maps a state and a non-terminal symbol to
     either undefined (encoded as: 0) or a new state s (encoded as: 1 + s). *)

  (* The goto table is first compressed via [RowDisplacement], then packed
     via [PackedIntArray]. *)

  val goto: PackedIntArray.t * PackedIntArray.t

  (* The number of start productions. A production [prod] is a start
     production if and only if [prod < start] holds. This is also the
     number of start symbols. A nonterminal symbol [nt] is a start
     symbol if and only if [nt < start] holds. *)

  val start: int

  (* A one-dimensional semantic action table maps productions to semantic
     actions. The calling convention for semantic actions is described in
     [EngineTypes]. This table contains ONLY NON-START PRODUCTIONS, so the
     indexing is off by [start]. Be careful. *)

  val semantic_action: ((int, Obj.t, token) EngineTypes.env ->
                        (int, Obj.t)        EngineTypes.stack) array

  (* The parser defines its own [Error] exception. This exception can be
     raised by semantic actions and caught by the engine, and raised by the
     engine towards the final user. *)

  exception Error

  (* The parser indicates whether to generate a trace. Generating a
     trace requires two extra tables, which respectively map a
     terminal symbol and a production to a string. *)

  val trace: (string array * string array) option

end

end
module InspectionTableFormat = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* This signature defines the format of the tables that are produced (in
   addition to the tables described in [TableFormat]) when the command line
   switch [--inspection] is enabled. It is used as an argument to
   [InspectionTableInterpreter.Make]. *)

module type TABLES = sig

  (* The types of symbols. *)

  include IncrementalEngine.SYMBOLS

  (* The type ['a lr1state] describes an LR(1) state. The generated parser defines
     it internally as [int]. *)

  type 'a lr1state

  (* Some of the tables that follow use encodings of (terminal and
     nonterminal) symbols as integers. So, we need functions that
     map the integer encoding of a symbol to its algebraic encoding. *)

  val    terminal: int -> xsymbol
  val nonterminal: int -> xsymbol

  (* The left-hand side of every production already appears in the
     signature [TableFormat.TABLES], so we need not repeat it here. *)

  (* The right-hand side of every production. This a linearized array
     of arrays of integers, whose [data] and [entry] components have
     been packed. The encoding of symbols as integers in described in
     [TableBackend]. *)

  val rhs: PackedIntArray.t * PackedIntArray.t

  (* A mapping of every (non-initial) state to its LR(0) core. *)

  val lr0_core: PackedIntArray.t

  (* A mapping of every LR(0) state to its set of LR(0) items. Each item is
     represented in its packed form (see [Item]) as an integer. Thus the
     mapping is an array of arrays of integers, which is linearized and
     packed, like [rhs]. *)

  val lr0_items: PackedIntArray.t * PackedIntArray.t

  (* A mapping of every LR(0) state to its incoming symbol, if it has one. *)

  val lr0_incoming: PackedIntArray.t

  (* A table that tells which non-terminal symbols are nullable. *)

  val nullable: string
    (* This is a packed int array of bit width 1. It can be read
       using [PackedIntArray.get1]. *)

  (* A two-table dimensional table, indexed by a nonterminal symbol and
     by a terminal symbol (other than [#]), encodes the FIRST sets. *)

  val first: int (* width of the bitmap *) * string (* second component of [PackedIntArray.t] *)

end

end
module InspectionTableInterpreter = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

(* -------------------------------------------------------------------------- *)

(* The type functor. *)

module Symbols (T : sig

  type 'a terminal
  type 'a nonterminal

end) = struct

  open T

  (* This should be the only place in the whole library (and generator!)
     where these types are defined. *)

  type 'a symbol =
    | T : 'a terminal -> 'a symbol
    | N : 'a nonterminal -> 'a symbol

  type xsymbol =
    | X : 'a symbol -> xsymbol

end

(* -------------------------------------------------------------------------- *)

(* The code functor. *)

module Make
  (B : TableFormat.TABLES)
  (T : InspectionTableFormat.TABLES
       with type 'a lr1state = int)
= struct

  (* Including [T] is an easy way of inheriting the definitions of the types
     [symbol] and [xsymbol]. *)

  include T

  (* This auxiliary function decodes a packed linearized array, as created by
     [TableBackend.linearize_and_marshal1]. Here, we read a row all at once. *)

  let read_packed_linearized ((data, entry) : PackedIntArray.t * PackedIntArray.t) (i : int) : int list =
    LinearizedArray.read_row_via
      (PackedIntArray.get data)
      (PackedIntArray.get entry)
      i

  (* This auxiliary function decodes a symbol. The encoding was done by
     [encode_symbol] or [encode_symbol_option] in the table back-end. *)

  let decode_symbol (symbol : int) : T.xsymbol =
    (* If [symbol] is 0, then we have no symbol. This could mean e.g.
       that the function [incoming_symbol] has been applied to an
       initial state. In principle, this cannot happen. *)
    assert (symbol > 0);
    (* The low-order bit distinguishes terminal and nonterminal symbols. *)
    let kind = symbol land 1 in
    let symbol = symbol lsr 1 in
    if kind = 0 then
      T.terminal (symbol - 1)
    else
      T.nonterminal symbol

  (* These auxiliary functions convert a symbol to its integer code. For speed
     and for convenience, we use an unsafe type cast. This relies on the fact
     that the data constructors of the [terminal] and [nonterminal] GADTs are
     declared in an order that reflects their internal code. In the case of
     nonterminal symbols, we add [start] to account for the presence of the
     start symbols. *)

  let n2i (nt : 'a T.nonterminal) : int =
    let answer = B.start + Obj.magic nt in
    assert (T.nonterminal answer = X (N nt)); (* TEMPORARY roundtrip *)
    answer

  let t2i (t : 'a T.terminal) : int =
    let answer = Obj.magic t in
    assert (T.terminal answer = X (T t)); (* TEMPORARY roundtrip *)
    answer

  (* Ordering functions. *)

  let compare_terminals t1 t2 =
    (* Subtraction is safe because overflow is impossible. *)
    t2i t1 - t2i t2

  let compare_nonterminals nt1 nt2 =
    (* Subtraction is safe because overflow is impossible. *)
    n2i nt1 - n2i nt2

  let compare_symbols symbol1 symbol2 =
    match symbol1, symbol2 with
    | X (T _), X (N _) ->
        -1
    | X (N _), X (T _) ->
        1
    | X (T t1), X (T t2) ->
        compare_terminals t1 t2
    | X (N nt1), X (N nt2) ->
        compare_nonterminals nt1 nt2

  let compare_productions prod1 prod2 =
    (* Subtraction is safe because overflow is impossible. *)
    prod1 - prod2

  let compare_items (prod1, index1) (prod2, index2) =
    let c = compare_productions prod1 prod2 in
    (* Subtraction is safe because overflow is impossible. *)
    if c <> 0 then c else index1 - index2

  (* The function [incoming_symbol] goes through the tables [T.lr0_core] and
     [T.lr0_incoming]. This yields a representation of type [xsymbol], out of
     which we strip the [X] quantifier, so as to get a naked symbol. This last
     step is ill-typed and potentially dangerous. It is safe only because this
     function is used at type ['a lr1state -> 'a symbol], which forces an
     appropriate choice of ['a]. *)

  let incoming_symbol (s : 'a T.lr1state) : 'a T.symbol =
    let core = PackedIntArray.get T.lr0_core s in
    let symbol = decode_symbol (PackedIntArray.get T.lr0_incoming core) in
    match symbol with
    | T.X symbol ->
        Obj.magic symbol

  (* The function [lhs] reads the table [B.lhs] and uses [T.nonterminal]
     to decode the symbol. *)

  let lhs prod =
    T.nonterminal (PackedIntArray.get B.lhs prod)

  (* The function [rhs] reads the table [T.rhs] and uses [decode_symbol]
     to decode the symbol. *)

  let rhs prod =
    List.map decode_symbol (read_packed_linearized T.rhs prod)

  (* The function [items] maps the LR(1) state [s] to its LR(0) core,
     then uses [core] as an index into the table [T.lr0_items]. The
     items are then decoded by the function [export] below, which is
     essentially a copy of [Item.export]. *)

  type item =
      int * int

  let export t : item =
    (t lsr 7, t mod 128)

  let items s =
    (* Map [s] to its LR(0) core. *)
    let core = PackedIntArray.get T.lr0_core s in
    (* Now use [core] to look up the table [T.lr0_items]. *)
    List.map export (read_packed_linearized T.lr0_items core)

  (* The function [nullable] maps the nonterminal symbol [nt] to its
     integer code, which it uses to look up the array [T.nullable].
     This yields 0 or 1, which we map back to a Boolean result. *)

  let decode_bool i =
    assert (i = 0 || i = 1);
    i = 1

  let nullable nt =
    decode_bool (PackedIntArray.get1 T.nullable (n2i nt))

  (* The function [first] maps the symbols [nt] and [t] to their integer
     codes, which it uses to look up the matrix [T.first]. *)

  let first nt t =
    decode_bool (PackedIntArray.unflatten1 T.first (n2i nt) (t2i t))

  let xfirst symbol t =
    match symbol with
    | X (T t') ->
        compare_terminals t t' = 0
    | X (N nt) ->
        first nt t

  (* The function [foreach_terminal] exploits the fact that the
     first component of [B.error] is [Terminal.n - 1], i.e., the
     number of terminal symbols, including [error] but not [#]. *)

  let rec foldij i j f accu =
    if i = j then
      accu
    else
      foldij (i + 1) j f (f i accu)

  let foreach_terminal f accu =
    let n, _ = B.error in
    foldij 0 n (fun i accu ->
      f (T.terminal i) accu
    ) accu

  let foreach_terminal_but_error f accu =
    let n, _ = B.error in
    foldij 0 n (fun i accu ->
      if i = B.error_terminal then
        accu
      else
        f (T.terminal i) accu
    ) accu

end
end
module TableInterpreter = struct
(**************************************************************************)
(*                                                                        *)
(*  Menhir                                                                *)
(*                                                                        *)
(*  Fran巽ois Pottier, INRIA Paris-Rocquencourt                            *)
(*  Yann R辿gis-Gianas, PPS, Universit辿 Paris Diderot                      *)
(*                                                                        *)
(*  Copyright 2005-2015 Institut National de Recherche en Informatique    *)
(*  et en Automatique. All rights reserved. This file is distributed      *)
(*  under the terms of the GNU Library General Public License, with the   *)
(*  special exception on linking described in file LICENSE.               *)
(*                                                                        *)
(**************************************************************************)

module Make (T : TableFormat.TABLES)

= Engine.Make (struct

  type state =
      int

  let number s = s

  type token =
      T.token

  type terminal =
      int

  type semantic_value =
      Obj.t

  let token2terminal =
    T.token2terminal

  let token2value =
    T.token2value

  let error_terminal =
    T.error_terminal

  let error_value =
    Obj.repr ()

  type production =
      int

  let default_reduction state defred nodefred env =
    let code = PackedIntArray.get T.default_reduction state in
    if code = 0 then
      nodefred env
    else
      defred env (code - 1)

  let is_start prod =
    prod < T.start

  (* This auxiliary function helps access a compressed, two-dimensional
     matrix, like the action and goto tables. *)

  let unmarshal2 table i j =
    RowDisplacement.getget
      PackedIntArray.get
      PackedIntArray.get
      table
      i j

  (* This auxiliary function helps access a flattened, two-dimensional
     matrix, like the error bitmap. *)

  let action state terminal value shift reduce fail env =
    match PackedIntArray.unflatten1 T.error state terminal with
    | 1 ->
        let action = unmarshal2 T.action state terminal in
        let opcode = action land 0b11
        and param = action lsr 2 in
        if opcode >= 0b10 then
          (* 0b10 : shift/discard *)
          (* 0b11 : shift/nodiscard *)
          let please_discard = (opcode = 0b10) in
          shift env please_discard terminal value param
        else
          (* 0b01 : reduce *)
          (* 0b00 : cannot happen *)
          reduce env param
    | c ->
        assert (c = 0);
        fail env

  let goto state prod =
    let code = unmarshal2 T.goto state (PackedIntArray.get T.lhs prod) in
    (* code = 1 + state *)
    code - 1

  exception Error =
        T.Error

  type semantic_action =
      (state, semantic_value, token) EngineTypes.env ->
      (state, semantic_value)        EngineTypes.stack

  let semantic_action prod =
    (* Indexing into the array [T.semantic_action] is off by [T.start],
       because the start productions do not have entries in this array. *)
    T.semantic_action.(prod - T.start)

  (* If [T.trace] is [None], then the logging functions do nothing. *)

  let log =
    match T.trace with Some _ -> true | None -> false

  module Log = struct

    open Printf

    let state state =
      match T.trace with
      | Some _ ->
          fprintf stderr "State %d:\n%!" state
      | None ->
          ()

    let shift terminal state =
      match T.trace with
      | Some (terminals, _) ->
          fprintf stderr "Shifting (%s) to state %d\n%!" terminals.(terminal) state
      | None ->
          ()

    let reduce_or_accept prod =
      match T.trace with
      | Some (_, productions) ->
          fprintf stderr "%s\n%!" productions.(prod)
      | None ->
          ()

    let lookahead_token token startp endp =
      match T.trace with
      | Some (terminals, _) ->
          fprintf stderr "Lookahead token is now %s (%d-%d)\n%!"
            terminals.(token)
            startp.Lexing.pos_cnum
            endp.Lexing.pos_cnum
      | None ->
          ()

    let initiating_error_handling () =
      match T.trace with
      | Some _ ->
          fprintf stderr "Initiating error handling\n%!"
      | None ->
          ()

    let resuming_error_handling () =
      match T.trace with
      | Some _ ->
          fprintf stderr "Resuming error handling\n%!"
      | None ->
          ()

    let handling_error state =
      match T.trace with
      | Some _ ->
          fprintf stderr "Handling error in state %d\n%!" state
      | None ->
          ()

  end

end)

end
module StaticVersion = struct
let require_20160808 = ()
end

end
module Reason_parser : sig 
#1 "reason_parser.mli"

(* The type of tokens. *)

type token = 
  | WITH
  | WHILE
  | WHEN
  | VIRTUAL
  | VAL
  | UNDERSCORE
  | UIDENT of (string)
  | TYPE
  | TRY
  | TRUE
  | TO
  | TILDE
  | THEN
  | SWITCH
  | STRUCT
  | STRING of (string * string option)
  | STAR
  | SLASHGREATER
  | SIG
  | SHARPOP of (string)
  | SHARP
  | SEMISEMI
  | SEMI
  | RPAREN
  | REC
  | RBRACKET
  | RBRACE
  | QUOTE
  | QUESTION
  | PUB
  | PRI
  | PREFIXOP of (string)
  | PLUSEQ
  | PLUSDOT
  | PLUS
  | PERCENT
  | OR
  | OPTIONAL_NO_DEFAULT
  | OPEN
  | OF
  | OBJECT
  | NONREC
  | NEW
  | NATIVEINT of (nativeint)
  | MUTABLE
  | MODULE
  | MINUSGREATER
  | MINUSDOT
  | MINUS
  | LPAREN
  | LIDENTCOLONCOLON of (string)
  | LIDENT of (string)
  | LET
  | LESSSLASHIDENTGREATER of (string)
  | LESSSLASHGREATER
  | LESSSLASH
  | LESSMINUS
  | LESSIDENT of (string)
  | LESSGREATER
  | LESSDOTDOTGREATER
  | LESS
  | LBRACKETPERCENTPERCENT
  | LBRACKETPERCENT
  | LBRACKETLESS
  | LBRACKETGREATER
  | LBRACKETBAR
  | LBRACKETATATAT
  | LBRACKETATAT
  | LBRACKETAT
  | LBRACKET
  | LBRACELESS
  | LBRACE
  | LAZY
  | INT64 of (int64)
  | INT32 of (int32)
  | INT of (int)
  | INITIALIZER
  | INHERIT
  | INFIXOP4 of (string)
  | INFIXOP3 of (string)
  | INFIXOP2 of (string)
  | INFIXOP1 of (string)
  | INFIXOP0 of (string)
  | INCLUDE
  | IN
  | IF
  | GREATERRBRACE
  | GREATER
  | FUNCTOR
  | FUNCTION
  | FUN
  | FOR
  | FLOAT of (string)
  | FALSE
  | EXTERNAL
  | EXCEPTION
  | EQUALGREATER
  | EQUAL
  | EOL
  | EOF
  | END
  | ELSE
  | DOWNTO
  | DOTDOTDOT
  | DOTDOT
  | DOT
  | DONE
  | DO
  | CONSTRAINT
  | COMMENT of (string * Location.t)
  | COMMA
  | COLONGREATER
  | COLONEQUAL
  | COLONCOLONLIDENT of (string)
  | COLONCOLON
  | COLON
  | CLASS
  | CHAR of (char)
  | BEGIN
  | BARRBRACKET
  | BARBAR
  | BAR
  | BANG
  | BACKQUOTE
  | ASSERT
  | AS
  | AND
  | AMPERSAND
  | AMPERAMPER

(* This exception is raised by the monolithic API functions. *)

exception Error

(* The monolithic API. *)

val use_file: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Parsetree.toplevel_phrase list)

val toplevel_phrase: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Parsetree.toplevel_phrase)

val parse_pattern: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Parsetree.pattern)

val parse_expression: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Parsetree.expression)

val parse_core_type: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Parsetree.core_type)

val interface: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Parsetree.signature)

val implementation: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Parsetree.structure)

module MenhirInterpreter : sig
  
  (* The incremental API. *)
  
  include MenhirLib.IncrementalEngine.INCREMENTAL_ENGINE
    with type token = token
  
end

(* The entry point(s) to the incremental API. *)

module Incremental : sig
  
  val use_file: Lexing.position -> (Parsetree.toplevel_phrase list) MenhirInterpreter.checkpoint
  
  val toplevel_phrase: Lexing.position -> (Parsetree.toplevel_phrase) MenhirInterpreter.checkpoint
  
  val parse_pattern: Lexing.position -> (Parsetree.pattern) MenhirInterpreter.checkpoint
  
  val parse_expression: Lexing.position -> (Parsetree.expression) MenhirInterpreter.checkpoint
  
  val parse_core_type: Lexing.position -> (Parsetree.core_type) MenhirInterpreter.checkpoint
  
  val interface: Lexing.position -> (Parsetree.signature) MenhirInterpreter.checkpoint
  
  val implementation: Lexing.position -> (Parsetree.structure) MenhirInterpreter.checkpoint
  
end

end = struct
#1 "reason_parser.ml"

(* This generated code requires the following version of MenhirLib: *)

let () =
  MenhirLib.StaticVersion.require_20160808

module Basics = struct
  
  exception Error = Parsing.Parse_error
  
  type token = 
    | WITH
    | WHILE
    | WHEN
    | VIRTUAL
    | VAL
    | UNDERSCORE
    | UIDENT of (string)
    | TYPE
    | TRY
    | TRUE
    | TO
    | TILDE
    | THEN
    | SWITCH
    | STRUCT
    | STRING of (string * string option)
    | STAR
    | SLASHGREATER
    | SIG
    | SHARPOP of (string)
    | SHARP
    | SEMISEMI
    | SEMI
    | RPAREN
    | REC
    | RBRACKET
    | RBRACE
    | QUOTE
    | QUESTION
    | PUB
    | PRI
    | PREFIXOP of (string)
    | PLUSEQ
    | PLUSDOT
    | PLUS
    | PERCENT
    | OR
    | OPTIONAL_NO_DEFAULT
    | OPEN
    | OF
    | OBJECT
    | NONREC
    | NEW
    | NATIVEINT of (nativeint)
    | MUTABLE
    | MODULE
    | MINUSGREATER
    | MINUSDOT
    | MINUS
    | LPAREN
    | LIDENTCOLONCOLON of (string)
    | LIDENT of (string)
    | LET
    | LESSSLASHIDENTGREATER of (string)
    | LESSSLASHGREATER
    | LESSSLASH
    | LESSMINUS
    | LESSIDENT of (string)
    | LESSGREATER
    | LESSDOTDOTGREATER
    | LESS
    | LBRACKETPERCENTPERCENT
    | LBRACKETPERCENT
    | LBRACKETLESS
    | LBRACKETGREATER
    | LBRACKETBAR
    | LBRACKETATATAT
    | LBRACKETATAT
    | LBRACKETAT
    | LBRACKET
    | LBRACELESS
    | LBRACE
    | LAZY
    | INT64 of (int64)
    | INT32 of (int32)
    | INT of (int)
    | INITIALIZER
    | INHERIT
    | INFIXOP4 of (string)
    | INFIXOP3 of (string)
    | INFIXOP2 of (string)
    | INFIXOP1 of (string)
    | INFIXOP0 of (string)
    | INCLUDE
    | IN
    | IF
    | GREATERRBRACE
    | GREATER
    | FUNCTOR
    | FUNCTION
    | FUN
    | FOR
    | FLOAT of (string)
    | FALSE
    | EXTERNAL
    | EXCEPTION
    | EQUALGREATER
    | EQUAL
    | EOL
    | EOF
    | END
    | ELSE
    | DOWNTO
    | DOTDOTDOT
    | DOTDOT
    | DOT
    | DONE
    | DO
    | CONSTRAINT
    | COMMENT of (string * Location.t)
    | COMMA
    | COLONGREATER
    | COLONEQUAL
    | COLONCOLONLIDENT of (string)
    | COLONCOLON
    | COLON
    | CLASS
    | CHAR of (char)
    | BEGIN
    | BARRBRACKET
    | BARBAR
    | BAR
    | BANG
    | BACKQUOTE
    | ASSERT
    | AS
    | AND
    | AMPERSAND
    | AMPERAMPER
  
end

include Basics

let _eRR =
  Basics.Error
  
open Syntax_util
open Location
open Asttypes
open Longident
open Parsetree
open Ast_helper
open Ast_mapper

(*
   TODO:
   - Remove all [open]s from the top of this file one by one and fix compilation
   failures that ensue by specifying the appropriate long identifiers. That
   will make the parser much easier to reason about.
   - Go back to trunk, do the same (remove [open]s, and fully specify long
   idents), to perform a clean diff.

*)

(**

   location.ml:
   ------------
   let mkloc txt loc = { txt ; loc }
   let rhs_loc n = {
     loc_start = Parsing.rhs_start_pos n;
     loc_end = Parsing.rhs_end_pos n;
     loc_ghost = false;
   }
   let symbol_rloc () = {
     loc_start = Parsing.symbol_start_pos ();
     loc_end = Parsing.symbol_end_pos ();
     loc_ghost = false;
   }

   let symbol_gloc () = {
     loc_start = Parsing.symbol_start_pos ();
     loc_end = Parsing.symbol_end_pos ();
     loc_ghost = true;
   }

   ast_helper.ml:
   ------------
   module Typ = struct
    val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
    let mk ?(loc = !default_loc) ?(attrs = []) d =
       {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
     ..
   end

   parse_tree.mli
   --------------
   and core_type = {
     ptyp_desc: core_type_desc;
     ptyp_loc: Location.t;
     ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
   }

   and core_type_desc =
     | Ptyp_any
           (*  _ *)
     | Ptyp_var of string
           (* 'a *)
     | Ptyp_arrow of label * core_type * core_type
           (* T1 -> T2       (label = "")
              ~l:T1 -> T2    (label = "l")
              ?l:T1 -> T2    (label = "?l")
            *)
     | Ptyp_tuple of core_type list
           (* T1 * ... * Tn   (n >= 2) *)

   reason_parser.mly
   ---------------
   In general:

                                          syntax variant          {pblah_desc: core_blah_desc
                                                                   pblah_loc: {txt, loc}
                                                                   pblah_attributes: ... }
                                         /              \            /       \
   val mkblah: ~loc -> ~attributes ->     core_blah_desc     ->      core_blah
   let mkblah = Blah.mk

*)


let dummy_loc () = {
  loc_start = Lexing.dummy_pos;
  loc_end = Lexing.dummy_pos;
  loc_ghost = false;
}

let mklocation loc_start loc_end = {
  loc_start = loc_start;
  loc_end = loc_end;
  loc_ghost = false;
}

let with_txt a txt = {
    a with txt=txt;
}

let make_real_loc loc = {
    loc with loc_ghost = false
}

let make_ghost_loc loc = {
    loc with loc_ghost = true
}

let ghloc ?(loc=dummy_loc ()) d = { txt = d; loc = (make_ghost_loc loc) }

(**
  * turn an object into a real
  *)
let make_real_exp exp = {
    exp with pexp_loc = make_real_loc exp.pexp_loc
}
let make_real_pat pat = {
    pat with ppat_loc = make_real_loc pat.ppat_loc
}
let make_real_cf cf = {
    cf with pcf_loc = make_real_loc cf.pcf_loc
}

(**
  * turn a object into ghost
  *)
let make_ghost_cf cf = {
    cf with pcf_loc = make_ghost_loc cf.pcf_loc
}
let make_ghost_exp exp = {
    exp with pexp_loc = make_ghost_loc exp.pexp_loc
}

let make_ghost_pat pat = {
    pat with ppat_loc = make_ghost_loc pat.ppat_loc
}

(**
  * change the location state to be a ghost location or real location
  *)
let set_loc_state is_ghost loc =
    if is_ghost then make_ghost_loc loc else make_real_loc loc

let mktyp ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Typ.mk ~loc d

let mkpat ?(attrs=[]) ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Pat.mk ~loc ~attrs d

let mkexp ?(attrs=[]) ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Exp.mk ~loc ~attrs d

let mkmty ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Mty.mk ~loc d

let mksig ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Sig.mk ~loc d

let mkmod ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Mod.mk ~loc d

let mkstr ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Str.mk ~loc d

let mkclass ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cl.mk ~loc d

let mkcty ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cty.mk ~loc d

let mkctf ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Ctf.mk ~loc d

(**
  Make a core_type from a as_loc(LIDENT).
  Useful for record type punning.
  type props = {width: int, height: int};
  type state = {nbrOfClicks: int};
  type component = {props, state};
*)
let mkct lbl =
  let lident = Lident lbl.txt in
  let ttype = Ptyp_constr({txt = lident; loc = lbl.loc}, []) in
  {ptyp_desc = ttype; ptyp_loc = lbl.loc; ptyp_attributes = []}

let mkcf ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cf.mk ~loc d

let mkoption d =
  let loc = {d.ptyp_loc with loc_ghost = true} in
  Typ.mk ~loc (Ptyp_constr(mkloc (Ldot (Lident "*predef*", "option")) loc,[d]))

let simple_ghost_text_attr ?(loc=dummy_loc ()) txt =
  let loc = set_loc_state true loc in
  [({txt; loc}, PStr [])]

let mkExplicitArityTuplePat ?(loc=dummy_loc ()) pat =
  (* Tell OCaml type system that what this tuple construction represents is
     not actually a tuple, and should represent several constructor
     arguments.  This allows the syntax the ability to distinguish between:

     X (10, 20)  -- One argument constructor
     X 10 20     -- Multi argument constructor
  *)
  mkpat
    ~loc
    ~attrs:(simple_ghost_text_attr ~loc "explicit_arity")
    pat

let mkExplicitArityTupleExp ?(loc=dummy_loc ()) exp =
  mkexp
    ~loc
    ~attrs:(simple_ghost_text_attr ~loc "explicit_arity")
    exp

let is_pattern_list_single_any = function
  | [{ppat_desc=Ppat_any; ppat_attributes=[]} as onlyItem] -> Some onlyItem
  | _ -> None

let set_structure_item_location x loc = {x with pstr_loc = loc};;

let mkoperator name =
  let loc = name.loc in
  Exp.mk ~loc (Pexp_ident(mkloc (Lident name.txt) loc))


(*
  Ghost expressions and patterns:
  expressions and patterns that do not appear explicitly in the
  source file they have the loc_ghost flag set to true.
  Then the profiler will not try to instrument them and the
  -annot option will not try to display their type.

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  How to tell whether your location must be ghost:
  A location corresponds to a range of characters in the source file.
  If the location contains a piece of code that is syntactically
  valid (according to the documentation), and corresponds to the
  AST node, then the location must be real; in all other cases,
  it must be ghost.

  jordwalke: Noticed that ghost expressions are often used when inserting
   additional AST nodes from a parse rule. Either an extra wrapping one, or an
   additional inner node. This is consistent with the above description, I
   believe.
*)


let ghunit ?(loc=dummy_loc ()) () =
  mkexp ~ghost:true ~loc (Pexp_construct (mknoloc (Lident "()"), None))

let mkinfix arg1 name_operator arg2 =
  mkexp (Pexp_apply(mkoperator name_operator, ["", arg1; "", arg2]))

let neg_float_string f =
  if String.length f > 0 && f.[0] = '-'
  then String.sub f 1 (String.length f - 1)
  else "-" ^ f

let mkuminus name arg =
  match name.txt, arg.pexp_desc with
  | "-", Pexp_constant(Const_int n) ->
      mkexp(Pexp_constant(Const_int(-n)))
  | "-", Pexp_constant(Const_int32 n) ->
      mkexp(Pexp_constant(Const_int32(Int32.neg n)))
  | "-", Pexp_constant(Const_int64 n) ->
      mkexp(Pexp_constant(Const_int64(Int64.neg n)))
  | "-", Pexp_constant(Const_nativeint n) ->
      mkexp(Pexp_constant(Const_nativeint(Nativeint.neg n)))
  | ("-" | "-."), Pexp_constant(Const_float f) ->
      mkexp(Pexp_constant(Const_float(neg_float_string f)))
  | _ ->
      let name = {name with txt=("~" ^ name.txt)} in
      mkexp(Pexp_apply(mkoperator name, ["", arg]))

let mkFunctorThatReturns functorArgs returns =
  List.fold_left (
    fun acc (n, t) -> mkmod (Pmod_functor(n, t, acc))
  ) returns functorArgs

let mkuplus name arg =
  let desc = arg.pexp_desc in
  match name.txt, desc with
  | "+", Pexp_constant(Const_int _)
  | "+", Pexp_constant(Const_int32 _)
  | "+", Pexp_constant(Const_int64 _)
  | "+", Pexp_constant(Const_nativeint _)
  | ("+" | "+."), Pexp_constant(Const_float _) -> mkexp desc
  | _ ->
      let name = {name with txt=("~" ^ name.txt)} in
      mkexp(Pexp_apply(mkoperator name, ["", arg]))

let mkexp_cons consloc args loc =
  mkexp ~loc (Pexp_construct(mkloc (Lident "::") consloc, Some args))

let mkexp_constructor_unit consloc loc =
  mkexp ~loc (Pexp_construct(mkloc (Lident "()") consloc, None))

let ghexp_cons consloc args loc =
  mkexp ~ghost:true ~loc (Pexp_construct(mkloc (Lident "::") loc, Some args))

let mkpat_cons consloc args loc =
  mkpat ~loc (Ppat_construct(mkloc (Lident "::") loc, Some args))

let ghpat_cons consloc args loc =
  mkpat ~ghost:true ~loc (Ppat_construct(mkloc (Lident "::") loc, Some args))

let simple_pattern_list_to_tuple ?(loc=dummy_loc ()) lst =
  match lst with
    | [] -> assert false
    | _ -> mkpat ~loc (Ppat_tuple (List.rev lst))

let mktailexp_extension loc seq ext_opt =
  let rec handle_seq = function
    [] ->
      let base_case = match ext_opt with
        | Some ext ->
          ext
        | None ->
          let loc = make_ghost_loc loc in
          let nil = { txt = Lident "[]"; loc } in
          Exp.mk ~loc (Pexp_construct (nil, None)) in
      base_case
  | e1 :: el ->
      let exp_el = handle_seq el in
      let loc = mklocation e1.pexp_loc.loc_start exp_el.pexp_loc.loc_end in
      let arg = mkexp ~ghost:true ~loc (Pexp_tuple [e1; exp_el]) in
      ghexp_cons loc arg loc in
  handle_seq seq

let mktailpat_extension loc seq ext_opt =
  let rec handle_seq = function
    [] ->
      let base_case = match ext_opt with
        | Some ext ->
          ext
        | None ->
          let loc = make_ghost_loc loc in
          let nil = { txt = Lident "[]"; loc } in
          mkpat ~loc (Ppat_construct (nil, None)) in
      base_case
  | p1 :: pl ->
      let pat_pl = handle_seq pl in
      let loc = mklocation p1.ppat_loc.loc_start pat_pl.ppat_loc.loc_end in
      let arg = mkpat ~ghost:true ~loc (Ppat_tuple [p1; pat_pl]) in
      ghpat_cons loc arg loc in
  handle_seq seq

let makeFrag loc body =
  let attribute = ({txt = "JSX"; loc = loc}, PStr []) in
  { body with pexp_attributes = [attribute] @ body.pexp_attributes }


(* Applies attributes to the structure item, not the expression itself. Makes
 * structure item have same location as expression. *)
let mkstrexp e attrs =
  { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }

let ghexp_constraint loc e (t1, t2) =
  match t1, t2 with
  | Some t, None -> mkexp ~ghost:true ~loc (Pexp_constraint(e, t))
  | _, Some t -> mkexp ~ghost:true ~loc (Pexp_coerce(e, t1, t))
  | None, None -> assert false

let array_function ?(loc=dummy_loc()) str name =
  ghloc ~loc (Ldot(Lident str, (if !Clflags.fast then "unsafe_" ^ name else name)))

let syntax_error_str loc msg =
  if !Reason_config.recoverable then
    Str.mk ~loc:loc (Pstr_extension (Syntax_util.syntax_error_extension_node loc msg, []))
  else
    raise(Syntaxerr.Error(Syntaxerr.Other loc))

let syntax_error () =
  raise Syntaxerr.Escape_error

let syntax_error_exp loc msg =
  if !Reason_config.recoverable then
    Exp.mk ~loc (Pexp_extension (Syntax_util.syntax_error_extension_node loc msg))
  else
    syntax_error ()

let unclosed opening closing =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(opening.loc, opening.txt,
                                           closing.loc, closing.txt)))

let unclosed_extension closing =
  Syntax_util.syntax_error_extension_node closing.loc ("Expecting \"" ^ closing.txt ^ "\"")

let unclosed_mod opening closing =
  if !Reason_config.recoverable then
    mkmod(Pmod_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_cl opening closing =
  if !Reason_config.recoverable then
    mkclass(Pcl_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_mty opening closing =
  if !Reason_config.recoverable then
    mkmty(Pmty_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_cty opening closing =
  if !Reason_config.recoverable then
    mkcty(Pcty_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_exp opening closing =
  if !Reason_config.recoverable then
    mkexp(Pexp_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_pat opening closing =
  if !Reason_config.recoverable then
    mkpat(Ppat_extension (unclosed_extension closing))
  else
    unclosed opening closing

let expecting nonterm =
    raise Syntaxerr.(Error(Expecting(nonterm.loc, nonterm.txt)))

let expecting_pat nonterm =
  if !Reason_config.recoverable then
    mkpat(Ppat_extension (Syntax_util.syntax_error_extension_node nonterm.loc ("Expecting " ^ nonterm.txt)))
  else
    expecting nonterm

let not_expecting start_pos end_pos nonterm =
    raise Syntaxerr.(Error(Not_expecting(mklocation start_pos end_pos, nonterm)))

let bigarray_function ?(loc=dummy_loc()) str name =
  ghloc ~loc (Ldot(Ldot(Lident "Bigarray", str), name))

let bigarray_untuplify = function
    { pexp_desc = Pexp_tuple explist; pexp_loc = _ } -> explist
  | exp -> [exp]

let bigarray_get ?(loc=dummy_loc()) arr arg =
  let get = if !Clflags.fast then "unsafe_get" else "get" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array1" get)),
                       ["", arr; "", c1]))
  | [c1;c2] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array2" get)),
                       ["", arr; "", c1; "", c2]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array3" get)),
                       ["", arr; "", c1; "", c2; "", c3]))
  | coords ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Genarray" "get")),
                       ["", arr; "", mkexp ~ghost:true ~loc (Pexp_array coords)]))

let bigarray_set ?(loc=dummy_loc()) arr arg newval =
  let set = if !Clflags.fast then "unsafe_set" else "set" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array1" set)),
                       ["", arr; "", c1; "", newval]))
  | [c1;c2] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array2" set)),
                       ["", arr; "", c1; "", c2; "", newval]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array3" set)),
                       ["", arr; "", c1; "", c2; "", c3; "", newval]))
  | coords ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Genarray" "set")),
                       ["", arr;
                        "", mkexp ~ghost:true ~loc (Pexp_array coords);
                        "", newval]))

let lapply p1 p2 start_pos end_pos =
  if !Clflags.applicative_functors
  then Lapply(p1, p2)
  else raise (Syntaxerr.Error(Syntaxerr.Applicative_path (mklocation start_pos end_pos)))

let exp_of_label label =
  mkexp ~loc:label.loc (Pexp_ident {label with txt=Lident(Longident.last label.txt)})

let pat_of_label label =
  mkpat ~loc:label.loc (Ppat_var {label with txt=(Longident.last label.txt)})

let check_variable vl loc v =
  if List.mem v vl then
    raise Syntaxerr.(Error(Variable_in_scope(loc,v)))

let varify_constructors var_names t =
  let rec loop t =
    let desc =
      match t.ptyp_desc with
      | Ptyp_any -> Ptyp_any
      | Ptyp_var x ->
          check_variable var_names t.ptyp_loc x;
          Ptyp_var x
      | Ptyp_arrow (label,core_type,core_type') ->
          Ptyp_arrow(label, loop core_type, loop core_type')
      | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
      | Ptyp_constr( { txt = Lident s }, []) when List.mem s var_names ->
          Ptyp_var s
      | Ptyp_constr(longident, lst) ->
          Ptyp_constr(longident, List.map loop lst)
      | Ptyp_object (lst, o) ->
          Ptyp_object
            (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)
      | Ptyp_class (longident, lst) ->
          Ptyp_class (longident, List.map loop lst)
      | Ptyp_alias(core_type, string) ->
          check_variable var_names t.ptyp_loc string;
          Ptyp_alias(loop core_type, string)
      | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
          Ptyp_variant(List.map loop_row_field row_field_list,
                       flag, lbl_lst_option)
      | Ptyp_poly(string_lst, core_type) ->
          List.iter (check_variable var_names t.ptyp_loc) string_lst;
          Ptyp_poly(string_lst, loop core_type)
      | Ptyp_package(longident,lst) ->
          Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
      | Ptyp_extension (s, arg) ->
          Ptyp_extension (s, arg)
    in
    {t with ptyp_desc = desc}
  and loop_row_field  =
    function
      | Rtag(label,attrs,flag,lst) ->
          Rtag(label,attrs,flag,List.map loop lst)
      | Rinherit t ->
          Rinherit (loop t)
  in
  loop t

(**
  I believe that wrap_type_annotation will automatically generate the type
  arguments (type a) (type b) based on what was listed before the dot in a
  polymorphic type annotation that uses locally abstract types.
 *)
let wrap_type_annotation newtypes core_type body =
  let exp = mkexp(Pexp_constraint(body,core_type)) in
  let exp =
    List.fold_right (fun newtype exp -> mkexp (Pexp_newtype (newtype, exp)))
      newtypes exp
  in
  let typ = mktyp ~ghost:true (Ptyp_poly(newtypes,varify_constructors newtypes core_type)) in
  (exp, typ)


let struct_item_extension (ext_attrs, ext_id) structure_item =
  mkstr ~ghost:true (Pstr_extension ((ext_id, PStr [structure_item]), ext_attrs))

let extension_expression (ext_attrs, ext_id) item_expr =
  mkexp ~ghost:true ~attrs:ext_attrs (Pexp_extension (ext_id, PStr [mkstrexp item_expr []]))

(* There's no more need for these functions - this was for the following:
 *
 *     fun % ext [@foo] arg => arg;
 *
 *   Becoming
 *
 *     [%ext  (fun arg => arg) [@foo]]
 *
 *   Which we no longer support.
 *)
(* Applies the attributes to the body, then wraps entire thing in an extension
 * expression, whose payload consists of a single structure item that is body
 *)
(* let wrap_exp_attrs body (ext, attrs) = *)
(*   (* todo: keep exact location for the entire attribute *) *)
(*   let body = {body with pexp_attributes = attrs @ body.pexp_attributes} in *)
(*   match ext with *)
(*   | None -> body *)
(*   | Some id -> mkexp ~ghost:true (Pexp_extension (id, PStr [mkstrexp body []])) *)

(* Why not just mkexp with the right attributes in the first place? *)
(* let mkexp_attrs d attrs = *)
(*   wrap_exp_attrs (mkexp d) attrs *)

let mkcf_attrs ?(loc=dummy_loc()) d attrs =
  Cf.mk ~loc ~attrs d

let mkctf_attrs d attrs =
  Ctf.mk ~attrs d

let add_nonrec rf attrs =
  match rf.txt with
  | Recursive -> attrs
  | Nonrecursive ->
      let name = { txt = "nonrec"; loc = rf.loc } in
        (name, PStr []) :: attrs

type let_binding =
  { lb_pattern: pattern;
    lb_expression: expression;
    (* The meaning of lb_leading_attributes and lbs_extension are dependent on
     * the context of the let binding (module/expression etc) *)
    lb_attributes: attributes;
    (* lb_docs: docs Lazy.t; *)
    (* lb_text: text Lazy.t; *)
    lb_loc: Location.t; }

type let_bindings =
  { lbs_bindings: let_binding list;
    lbs_rec: rec_flag;
    lbs_extension: string Asttypes.loc option;
    (* In Reason, we use this field to represent
       extension attributes attached to the extension on a series of "let/and"
       bindings As in: let [@extAttrs ] [%id] [@attribute] x = ...; It only
       makes sense to have [lbs_attributes] when there is an [lbs_extension].
     *)
    lbs_attributes: attributes;
    lbs_loc: Location.t }

let mklb (p, e) attrs loc =
  { lb_pattern = p;
    lb_expression = e;
    (* Only some individual let bindings are allowed to have attributes
     * depending on the context *)
    lb_attributes = attrs;
    lb_loc = loc; }

let mklbs (extAttrs, extId) rf lb loc =
  { lbs_bindings = [lb];
    lbs_rec = rf;
    lbs_extension = extId ;
    lbs_attributes = extAttrs;
    lbs_loc = loc; }

let addlb lbs lb =
  { lbs with lbs_bindings = lb :: lbs.lbs_bindings }

let val_of_let_bindings lbs =
  let bindings =
    List.map
      (fun lb ->
         Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
           (* ~docs:(Lazy.force lb.lb_docs) *)
           (* ~text:(Lazy.force lb.lb_text) *)
           lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
  let str = mkstr(Pstr_value(lbs.lbs_rec, List.rev bindings)) in
  (* Note that for value bindings, when there's an extension, the
   * lbs_attributes are attributes on the extension *)
  match (lbs.lbs_extension) with
    | None -> str
    | Some ext_id -> struct_item_extension (lbs.lbs_attributes, ext_id) str

let expr_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         (* Individual let bindings in an *expression* can't have item attributes. *)
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
  (* The location of this expression unfortunately includes the entire rule,
   * which will include any preceeding extensions. *)
  let item_expr = mkexp (Pexp_let(lbs.lbs_rec, List.rev bindings, body)) in
  (* Note that for let expression bindings, when there's an extension, the
   * lbs_attributes are attributes on the entire [let ..in x] expression. *)
  match lbs.lbs_extension with
    | None -> item_expr
    | Some ext_id -> extension_expression (lbs.lbs_attributes, ext_id) item_expr

let class_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    if lbs.lbs_extension <> None then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "extension")));
    if lbs.lbs_attributes <> [] then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "attributes")));
    mkclass(Pcl_let (lbs.lbs_rec, List.rev bindings, body))

(*
 * arity_conflict_resolving_mapper is triggered when both "implicit_arity" "explicit_arity"
 * are in the attribtues. In that case we have to remove "explicit_arity"
 *
 * However, if we simply remove explicit_arity, we would end up with a
 * wrapping tuple which has only one component (inner tuple).
 * This is against the invariance where tuples must have 2+ components.
 * Therefore, in the case we have to remove explicit_arity, we also need to
 * unwrap the tuple to expose the inner tuple directly.
 *
 *)
let arity_conflict_resolving_mapper =
{ default_mapper with
  expr = begin fun mapper expr ->
    match expr with
      | {pexp_desc=Pexp_construct(lid, args);
         pexp_loc;
         pexp_attributes} when attributes_conflicted "implicit_arity" "explicit_arity" pexp_attributes ->
         let new_args =
           match args with
             | Some {pexp_desc = Pexp_tuple [sp]} -> Some sp
             | _ -> args in
         default_mapper.expr mapper
         {pexp_desc=Pexp_construct(lid, new_args); pexp_loc; pexp_attributes=
          normalized_attributes "explicit_arity" pexp_attributes}
      | x -> default_mapper.expr mapper x
  end;
  pat = begin fun mapper pattern ->
    match pattern with
      | {ppat_desc=Ppat_construct(lid, args);
         ppat_loc;
         ppat_attributes} when attributes_conflicted "implicit_arity" "explicit_arity" ppat_attributes ->
         let new_args =
           match args with
             | Some {ppat_desc = Ppat_tuple [sp]} -> Some sp
             | _ -> args in
         default_mapper.pat mapper
         {ppat_desc=Ppat_construct(lid, new_args); ppat_loc; ppat_attributes=
          normalized_attributes "explicit_arity" ppat_attributes}
      | x -> default_mapper.pat mapper x
  end;
}

(* NB: making this a function might have parse-time performance penalties *)
let default_mapper_chain () =
  let chain = [default_mapper; arity_conflict_resolving_mapper;
               reason_to_ml_swap_operator_mapper;
               unescape_stars_slashes_mapper]
  in
  (*if !Reason_config.add_printers then chain @ [create_auto_printer_mapper]
  else *) chain

let rec string_of_longident = function
    | Lident s -> s
    | Ldot(longPrefix, s) ->
        s
    | Lapply (y,s) -> string_of_longident s

let built_in_explicit_arity_constructors = ["Some"; "Assert_failure"; "Match_failure"]

let jsx_component module_name attrs children loc =
  let firstPart = (List.hd (Longident.flatten module_name)) in
  let lident = if String.get firstPart 0 != '_' && firstPart = String.capitalize firstPart then
    (* firstPart will be non-empty so the 0th access is fine. Modules can't start with underscore *)
    Ldot(module_name, "createElement")
  else
    Lident firstPart
  in
  let ident = mkloc lident loc in
  let body = mkexp(Pexp_apply(mkexp(Pexp_ident ident) ~loc, attrs @ children)) ~loc in
  let attribute = ({txt = "JSX"; loc = loc}, PStr []) in
  { body with pexp_attributes = attribute :: body.pexp_attributes }

let ensureTagsAreEqual startTag endTag loc =
  if startTag <> endTag then
     let startTag = (String.concat "" (Longident.flatten startTag)) in
     let endTag = (String.concat "" (Longident.flatten endTag)) in
     let _ = Location.raise_errorf ~loc "Syntax error: Start tag <%s> does not match end tag </%s>" startTag endTag in
     ()

type object_record =
  | Object_open
  | Object_closed
  | Record

type core_type_object =
  | Core_type of core_type
  | Record_type of label_declaration list

let only_core_type t loc =
  match t with
  | Core_type ct -> ct
  | Record_type _ -> Location.raise_errorf ~loc "Record type is not allowed"

let only_labels l =
  let rec loop label_declarations result =
    match label_declarations with
    | hd :: tail ->
      let (l, a) = hd in
      if (List.length a > 0) then
        syntax_error ()
      else
        loop tail (result @ [l] )
    | [] -> result
  in
  loop l []


module Tables = struct
  
  include Basics
  
  let token2terminal : token -> int =
    fun _tok ->
      match _tok with
      | AMPERAMPER ->
          129
      | AMPERSAND ->
          128
      | AND ->
          127
      | AS ->
          126
      | ASSERT ->
          125
      | BACKQUOTE ->
          124
      | BANG ->
          123
      | BAR ->
          122
      | BARBAR ->
          121
      | BARRBRACKET ->
          120
      | BEGIN ->
          119
      | CHAR _ ->
          118
      | CLASS ->
          117
      | COLON ->
          116
      | COLONCOLON ->
          115
      | COLONCOLONLIDENT _ ->
          114
      | COLONEQUAL ->
          113
      | COLONGREATER ->
          112
      | COMMA ->
          111
      | COMMENT _ ->
          110
      | CONSTRAINT ->
          109
      | DO ->
          108
      | DONE ->
          107
      | DOT ->
          106
      | DOTDOT ->
          105
      | DOTDOTDOT ->
          104
      | DOWNTO ->
          103
      | ELSE ->
          102
      | END ->
          101
      | EOF ->
          100
      | EOL ->
          99
      | EQUAL ->
          98
      | EQUALGREATER ->
          97
      | EXCEPTION ->
          96
      | EXTERNAL ->
          95
      | FALSE ->
          94
      | FLOAT _ ->
          93
      | FOR ->
          92
      | FUN ->
          91
      | FUNCTION ->
          90
      | FUNCTOR ->
          89
      | GREATER ->
          88
      | GREATERRBRACE ->
          87
      | IF ->
          86
      | IN ->
          85
      | INCLUDE ->
          84
      | INFIXOP0 _ ->
          83
      | INFIXOP1 _ ->
          82
      | INFIXOP2 _ ->
          81
      | INFIXOP3 _ ->
          80
      | INFIXOP4 _ ->
          79
      | INHERIT ->
          78
      | INITIALIZER ->
          77
      | INT _ ->
          76
      | INT32 _ ->
          75
      | INT64 _ ->
          74
      | LAZY ->
          73
      | LBRACE ->
          72
      | LBRACELESS ->
          71
      | LBRACKET ->
          70
      | LBRACKETAT ->
          69
      | LBRACKETATAT ->
          68
      | LBRACKETATATAT ->
          67
      | LBRACKETBAR ->
          66
      | LBRACKETGREATER ->
          65
      | LBRACKETLESS ->
          64
      | LBRACKETPERCENT ->
          63
      | LBRACKETPERCENTPERCENT ->
          62
      | LESS ->
          61
      | LESSDOTDOTGREATER ->
          60
      | LESSGREATER ->
          59
      | LESSIDENT _ ->
          58
      | LESSMINUS ->
          57
      | LESSSLASH ->
          56
      | LESSSLASHGREATER ->
          55
      | LESSSLASHIDENTGREATER _ ->
          54
      | LET ->
          53
      | LIDENT _ ->
          52
      | LIDENTCOLONCOLON _ ->
          51
      | LPAREN ->
          50
      | MINUS ->
          49
      | MINUSDOT ->
          48
      | MINUSGREATER ->
          47
      | MODULE ->
          46
      | MUTABLE ->
          45
      | NATIVEINT _ ->
          44
      | NEW ->
          43
      | NONREC ->
          42
      | OBJECT ->
          41
      | OF ->
          40
      | OPEN ->
          39
      | OPTIONAL_NO_DEFAULT ->
          38
      | OR ->
          37
      | PERCENT ->
          36
      | PLUS ->
          35
      | PLUSDOT ->
          34
      | PLUSEQ ->
          33
      | PREFIXOP _ ->
          32
      | PRI ->
          31
      | PUB ->
          30
      | QUESTION ->
          29
      | QUOTE ->
          28
      | RBRACE ->
          27
      | RBRACKET ->
          26
      | REC ->
          25
      | RPAREN ->
          24
      | SEMI ->
          23
      | SEMISEMI ->
          22
      | SHARP ->
          21
      | SHARPOP _ ->
          20
      | SIG ->
          19
      | SLASHGREATER ->
          18
      | STAR ->
          17
      | STRING _ ->
          16
      | STRUCT ->
          15
      | SWITCH ->
          14
      | THEN ->
          13
      | TILDE ->
          12
      | TO ->
          11
      | TRUE ->
          10
      | TRY ->
          9
      | TYPE ->
          8
      | UIDENT _ ->
          7
      | UNDERSCORE ->
          6
      | VAL ->
          5
      | VIRTUAL ->
          4
      | WHEN ->
          3
      | WHILE ->
          2
      | WITH ->
          1
  
  and error_terminal =
    0
  
  and token2value : token -> Obj.t =
    fun _tok ->
      match _tok with
      | AMPERAMPER ->
          Obj.repr ()
      | AMPERSAND ->
          Obj.repr ()
      | AND ->
          Obj.repr ()
      | AS ->
          Obj.repr ()
      | ASSERT ->
          Obj.repr ()
      | BACKQUOTE ->
          Obj.repr ()
      | BANG ->
          Obj.repr ()
      | BAR ->
          Obj.repr ()
      | BARBAR ->
          Obj.repr ()
      | BARRBRACKET ->
          Obj.repr ()
      | BEGIN ->
          Obj.repr ()
      | CHAR _v ->
          Obj.repr _v
      | CLASS ->
          Obj.repr ()
      | COLON ->
          Obj.repr ()
      | COLONCOLON ->
          Obj.repr ()
      | COLONCOLONLIDENT _v ->
          Obj.repr _v
      | COLONEQUAL ->
          Obj.repr ()
      | COLONGREATER ->
          Obj.repr ()
      | COMMA ->
          Obj.repr ()
      | COMMENT _v ->
          Obj.repr _v
      | CONSTRAINT ->
          Obj.repr ()
      | DO ->
          Obj.repr ()
      | DONE ->
          Obj.repr ()
      | DOT ->
          Obj.repr ()
      | DOTDOT ->
          Obj.repr ()
      | DOTDOTDOT ->
          Obj.repr ()
      | DOWNTO ->
          Obj.repr ()
      | ELSE ->
          Obj.repr ()
      | END ->
          Obj.repr ()
      | EOF ->
          Obj.repr ()
      | EOL ->
          Obj.repr ()
      | EQUAL ->
          Obj.repr ()
      | EQUALGREATER ->
          Obj.repr ()
      | EXCEPTION ->
          Obj.repr ()
      | EXTERNAL ->
          Obj.repr ()
      | FALSE ->
          Obj.repr ()
      | FLOAT _v ->
          Obj.repr _v
      | FOR ->
          Obj.repr ()
      | FUN ->
          Obj.repr ()
      | FUNCTION ->
          Obj.repr ()
      | FUNCTOR ->
          Obj.repr ()
      | GREATER ->
          Obj.repr ()
      | GREATERRBRACE ->
          Obj.repr ()
      | IF ->
          Obj.repr ()
      | IN ->
          Obj.repr ()
      | INCLUDE ->
          Obj.repr ()
      | INFIXOP0 _v ->
          Obj.repr _v
      | INFIXOP1 _v ->
          Obj.repr _v
      | INFIXOP2 _v ->
          Obj.repr _v
      | INFIXOP3 _v ->
          Obj.repr _v
      | INFIXOP4 _v ->
          Obj.repr _v
      | INHERIT ->
          Obj.repr ()
      | INITIALIZER ->
          Obj.repr ()
      | INT _v ->
          Obj.repr _v
      | INT32 _v ->
          Obj.repr _v
      | INT64 _v ->
          Obj.repr _v
      | LAZY ->
          Obj.repr ()
      | LBRACE ->
          Obj.repr ()
      | LBRACELESS ->
          Obj.repr ()
      | LBRACKET ->
          Obj.repr ()
      | LBRACKETAT ->
          Obj.repr ()
      | LBRACKETATAT ->
          Obj.repr ()
      | LBRACKETATATAT ->
          Obj.repr ()
      | LBRACKETBAR ->
          Obj.repr ()
      | LBRACKETGREATER ->
          Obj.repr ()
      | LBRACKETLESS ->
          Obj.repr ()
      | LBRACKETPERCENT ->
          Obj.repr ()
      | LBRACKETPERCENTPERCENT ->
          Obj.repr ()
      | LESS ->
          Obj.repr ()
      | LESSDOTDOTGREATER ->
          Obj.repr ()
      | LESSGREATER ->
          Obj.repr ()
      | LESSIDENT _v ->
          Obj.repr _v
      | LESSMINUS ->
          Obj.repr ()
      | LESSSLASH ->
          Obj.repr ()
      | LESSSLASHGREATER ->
          Obj.repr ()
      | LESSSLASHIDENTGREATER _v ->
          Obj.repr _v
      | LET ->
          Obj.repr ()
      | LIDENT _v ->
          Obj.repr _v
      | LIDENTCOLONCOLON _v ->
          Obj.repr _v
      | LPAREN ->
          Obj.repr ()
      | MINUS ->
          Obj.repr ()
      | MINUSDOT ->
          Obj.repr ()
      | MINUSGREATER ->
          Obj.repr ()
      | MODULE ->
          Obj.repr ()
      | MUTABLE ->
          Obj.repr ()
      | NATIVEINT _v ->
          Obj.repr _v
      | NEW ->
          Obj.repr ()
      | NONREC ->
          Obj.repr ()
      | OBJECT ->
          Obj.repr ()
      | OF ->
          Obj.repr ()
      | OPEN ->
          Obj.repr ()
      | OPTIONAL_NO_DEFAULT ->
          Obj.repr ()
      | OR ->
          Obj.repr ()
      | PERCENT ->
          Obj.repr ()
      | PLUS ->
          Obj.repr ()
      | PLUSDOT ->
          Obj.repr ()
      | PLUSEQ ->
          Obj.repr ()
      | PREFIXOP _v ->
          Obj.repr _v
      | PRI ->
          Obj.repr ()
      | PUB ->
          Obj.repr ()
      | QUESTION ->
          Obj.repr ()
      | QUOTE ->
          Obj.repr ()
      | RBRACE ->
          Obj.repr ()
      | RBRACKET ->
          Obj.repr ()
      | REC ->
          Obj.repr ()
      | RPAREN ->
          Obj.repr ()
      | SEMI ->
          Obj.repr ()
      | SEMISEMI ->
          Obj.repr ()
      | SHARP ->
          Obj.repr ()
      | SHARPOP _v ->
          Obj.repr _v
      | SIG ->
          Obj.repr ()
      | SLASHGREATER ->
          Obj.repr ()
      | STAR ->
          Obj.repr ()
      | STRING _v ->
          Obj.repr _v
      | STRUCT ->
          Obj.repr ()
      | SWITCH ->
          Obj.repr ()
      | THEN ->
          Obj.repr ()
      | TILDE ->
          Obj.repr ()
      | TO ->
          Obj.repr ()
      | TRUE ->
          Obj.repr ()
      | TRY ->
          Obj.repr ()
      | TYPE ->
          Obj.repr ()
      | UIDENT _v ->
          Obj.repr _v
      | UNDERSCORE ->
          Obj.repr ()
      | VAL ->
          Obj.repr ()
      | VIRTUAL ->
          Obj.repr ()
      | WHEN ->
          Obj.repr ()
      | WHILE ->
          Obj.repr ()
      | WITH ->
          Obj.repr ()
  
  and default_reduction =
    (16, "\000\000\000\000\000\000\002U\001\129\001x\000\000\000\000\001e\000\000\000\000\002V\001f\000\001|\000\000\002U\000\000\003l\000\000\000\000\000\000\000\000\000\000\003.\003-\003,\003+\003*\002\003)\003(\003'\003&\003%\003\024\003$\003#\003\"\003!\003 \003\031\003\030\003\029\003\028\003\027\003\026\003\025\002\003\023\003\022\003\021\003\020\003\019\003\018\003\017\003\016\003\015\003\014\003\r\003\012\003\011\003\n\003\t\003\b\003\007\003\006\003\005\003\004\003\003\003\002\003\001\003\000\002\000\000\000\000\001T\000\000\000\000\002s\000\000\000\000\000\156\000\000\001\001\000\155\000\000\000\158\000\000\000\157\000\000\000\000\000\000\159\000\000\000\000\000\000\002Q\000\000\000\000\000\000\000\000\002O\000\000\000\000\000\000\002P\002\000\000\000\000\000\143\000\000\000\000\001e\000\000\000\000\001f\000\142\000\000\000\141\000\000\000\000\000\143\000\000\000\000\000\000\000\142\000\000\001\001\000\141\000\000\000\000\000\000\000\000\000\153\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000\000\003a\000\000\002\150\000\000\000\000\000\150\000\000\000\000\000\000\002t\002c\000\000\002v\000\000\000\000\000\000\000\000\001\129\000\000\000\000\000\000\000\000\001x\000\000\000\000\000\001|\000\000\002\135\002\129\001\127\000\000\003l\000\000\000\000\000\000\000\000\000\000\000\000\001I\001H\003F\003E\000\000\002\143\000\000\000\000\002\144\002\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\022\000\000\001\027\000\000\000\000\003b\000\000\002\002\002\002\002\000\000\002\002\002\002\002\000\000\001\022\000\000\003a\001\027\000\000\000\000\003b\001\127\002{\002\132\000\000\002\002\002\002\002\000\000\000\000\001)\000\000\000\000\000\000\001+\001*\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002d\000\144\002\000\000\000\151\000\000\000\000\000\152\002f\002e\000\000\002\000\145\002\000\000\002\000\000\002\147\000\000\000\000\000\000\002n\002l\000\154\002I\002m\002i\002h\000\000\000\139\002k\001\151\001\150\000\000\000\000\000\000\002H\002G\000\000\000\000\000;\001J\000\000\000\000\001K\002F\003G\000\000\001W\003H\002\000\000\000\150\000\000\000\000\000\149\000\000\000\000\000\000\000\147\000\000\000\146\000\000\000\000\000\000\000\148\000\000\002t\000\000\002v\000\000\002y\000\000\001\001\000\000\002u\000\000\002x\000\000\000\000\000\000\002w\000\144\000\145\000\000\002n\002l\000\154\002I\002m\000\000\000\000\000\000\000\000\000\000\000\000\002i\002h\000\000\000\000\000\000\000\000\003.\003-\003,\003+\003*\002\003)\003(\003'\003&\003%\003\024\003$\003#\003\"\003!\003 \003\031\003\030\003\029\003\028\003\027\003\026\003\025\002\003\023\003\022\003\021\003\020\003\019\003\018\003\017\003\016\003\015\003\014\003\r\003\012\003\011\003\n\003\t\003\b\003\007\003\006\003\005\003\004\003\003\003\002\003\001\003\000\002\000\000\000\000\001T\001\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001{\001z\001v\001y\001\128\001w\000\000\000\003n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\002\154\000\000\000\000\002\002\153\000\000\000\000\000\000\000\000\002\002\002\002\002\000\000\000\000\000\000\001)\000\000\000\000\001+\001*\000\000\000\000\000\000\002a\002`\002\134\000\000\002\145\002\136\000\000\000\000\001~\000\000\001\000\000\000\000\001\000\000\001\029\001\028\000\000\000\000\000\000\002\152\001\001\000\000\000\000\000\000\000\000\001{\001z\001v\002\130\002\128\002\127\002~\002}\000\000\002\146\001y\001\128\000\000\001w\000\000\002d\001\020\001\021\000\000\000\000\000\001\024\002\000\000\000\000\000\000\001\026\000\000\000\000\002V\002\002\001,\001\025\002@\002?\002\000\000\000\000\002\002\002>\002\142\002\139\002|\002\140\002\141\000\000\000\000\000\000\000\000\000\000\000\000\002\131\002\133\000\000\003m\000\000\000\001$\000\000\000\000\001~\000\000\002\156\000\000\001\031\001\030\000\000\000\000\000\000\000\000\000\000\000\002\002\002<\000\000\000\000\000\000\000\000\001\029\001\028\000\000\000\000\000\000\001$\000\000\000\000\000\000\001\020\001\021\000\000\000\000\000\001\024\002\000\000\000\000\000\000\001\026\000\000\002\002\001,\001\025\002@\002?\002\000\000\000\000\002\002\002>\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003m\000\002\000\000\000\000\000\000\000\000\002\002\002<\002\002=\000\000\001%\001#\000\000\001(\002k\001\151\001\150\000\000\000\000\000\000\002H\002G\000\000\000\000\000;\000\000\001'\001&\002F\000\002\000\000\001%\001#\000\000\001(\000\000\001'\001&\000\000\000\000\000\000\000\001\031\001\030\001!\000\000\000\000\000\000\000\000\001\"\001 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001!\000\000\000\000\001\"\001 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\001\000\000\000\000\000\000\000\000\000\000\000w\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002a\002`\000y\000\000\002\001\012\000\127\0026\002]\0025\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\001\000\000\000\000\001\000\000\002\000\001\001\000\000\0021\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\001\000\000\000\000\001\000\001\001\000\000\0021\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\001\001\001\000\000\000\000\001\000\000\000\000\003o\000\000\001\002\001\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000q\000\000\000J\000\000\002\002\002\0022\000\000\000\000\002.\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\001\001\001\000\000\000\000\001\000\000\000\000\003o\000\000\001\002\001\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000q\000\000\000J\000\000\002\002\002\0022\000\000\000\000\002.\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\001\001\000E\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\005\002\004\000\000\000D\000\000\000\000\000\000\000\000\000P\000\000\000\000\000\000\001\000\000\000\000\003R\000\000\003Q\000\000\000\000\003T\001\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\003R\000\000\003Q\000\000\000\000\003T\000\000\000\000\000\001\007\000\000\000\000\001\n\000\000\000\000\001\b\000\000\000\000\001\t\001\011\000\000\000\000\000\000\000\000\000\000\000w\000\000\000\000\000\000\000\000\001\007\000\000\000\000\001\n\000\000\000\000\001\b\000\000\000\000\001\t\001\011\000\000\000z\001\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\156\000\000\000\155\000\000\000\158\000\000\000\157\000\000\000\000\000\000\159\002\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\140\000\000\001\153\001\152\000\000\001\000\000\000\000\001\000\000\001\140\000\000\000\000\001\144\000\000\000\000\000\000\000\000\001\141\000\000\000\000\001\143\000\000\000\000\001\142\000\000\000\000\000\000\001\135\000\000\000\000\001\139\000\000\000\000\000\000\001\136\000\000\000\000\001\138\000\000\000\000\001\137\003Y\000\000\001\149\003[\000\000\000\000\001\148\003\\\000\000\000\000\000\000\000\000\000\000\003^\003_\000\000\000\000\000\000\000\000\003`\003]\003Z\001\134\000\000\000\000\000\000\000\000\001\130\001\133\000\000\002\002\000\000\000\000\001\134\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\0011\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\001W\000\000\001\000\000\000\000\001\000\000\001\000\000\000\000\000\000\001\000\000\001\000\000\000\000\000\000\000\000\001\000\000\001\000\000\000\000\000\000\001\000\000\001\000\000\000\000\000\000\001\000\000\001\000\000\0030\000\000\003/\000\000\002\000\000\003z\000\000\000\000\001r\000\000\003g\003h\000\000\001t\000\000\000\000\000\000\001i\000\000\000%\000$\000\000\000\000\000\000\000\000\000\000\000\000\003v\000\000\000\000\000\000\000\000\003w\000\000\000,\000\000\000\000\003x\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003j\000\000\000\000\000\000.\002\000\002D\000\000\000\000\000\000\000\000\000\000\000-\000\000\000\000\000\000\001u\001d\000'\000\000\000\000\000\000\000\000\000+\000&\002+\000\000\000\000\000\000\001\131\000\000\000/\001l\000\000\0000\0001\000\000\000\000\001o\002)\001k\001n\000\000\000\000\000\000\001B\003c\003e\002E\001s\000\000\002\026\000\000\001r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\155\001\158\001\156\000A\000\000\000\000\000\000\002\021\000\000\000\000\000\000\000\000\002\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\r\000\000\000\000\000\000\001\157\000\000\000@\002\012\002-\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\017\000\000\002\000\000\001a\000\000\000\000\000\000\000\000\000\000\001p\001]\000\018\000\000\000\000\0002\000\000\000\015\002'\002#\000!\002&\000\r\000\000\000\000\000)\001g\001^\000\000\000\000\002\t\002\018\000\000\002\n\000\019\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003s\000\000\000\023\000\000\000\000\000\000\000\000\000\000\000\000\003q\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\002D\000\000\000\000\000\000\000\000\000\000\001\155\001\158\002K\000\000\000\024\000\000\000\000\000\025\000\000\000\000\000\000\000\027\000\000\000\000\000\000\000\000\002\000\000\000\022\000\000\000\000\000\026\001h\001_\000\000\000\028\000\029\000\000\000\000\002\002\"\000\021\000\000\002;\002$\000\000\000\000\001O\002\019\000\000\0004\0003\000\000\0008\0007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001X\000\011\002*\000\t\000\000\000\000\000\n\000\000\0006\0005\000\000\000\000\000\000\001t\000\000\000\000\000%\000$\000\000\000\000\001u\001d\000'\000\000\000\000\000\000\000&\002+\000\000\000\000\000\000\000\000\000\000\000\000\001X\000\011\002*\000\t\000\000\000\000\000\n\000\000\000\000\000\000\001\132\001`\000\000\000\000\000\000\000\000\000\000\000\000\000\133\000\000\000\000\000\000\002g\000\000\002,\000\031\000\030\002%\001Z\001Y\002(\000\000\002\022\001.\000\000\000\000\003A\0013\0014\000\000\000\000\000\000\000\000\000y\000\000\002\001\012\000\127\0026\002]\0025\000\000\000\000\000\134\000\129\001\015\000\000\001\014\000\000\000\000\000\000\000\000\000\000\003\130\000\000\003|\000\000\001\134\000\000\000\000\000\000\000\000\001\130\001\133\000\000\000\000\000\000\000\000\000\000\000\000\002Q\000\000\000\000\000\000\000\000\000\000\002O\000\000\000\000\000\000\002P\000\000\000\000\000\000\000\000\000\000\003\128\003\127\001\r\000\000\000\000\000\136\002\002j\002_\001\018\002:\0029\0028\000\000\000\000\000\000\000\000\000\000\000\000\002z\000\000\000\000\000\000\000\000\000\134\000\129\001\015\000\000\000\000\000\000\000\000\000\000\000\000\003|\000\000\001\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\128\003\127\000\000\000\000\000\136\002\002j\002_\001\018\002:\0029\0028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\001\0019\003D\003C\000\000\000\000\000\000\000\000\002\002\000\000\000\000\001\134\000\000\000\000\001R\002!\000\000\000\000\000\000\001Q\002\031\000\000\000\000\000\000\001N\002\027\000\000\000\000\000\000\001L\002\023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001O\002\019\002\t\002\018\000\000\001-\002\n\000\000\001=\001>\000\000\0010\002C\002B\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\001\000\000\002\000\000\000\000\000\000\001r\000\000\000\000\000\000\000\000\002\026\000\000\001r\000\000\000\000\001\\\000\000\002\024\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000u\002\\\0027\000\000\000v\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\028\000\002\000\000\000\000\000\000\000\000\000\000\000\000\001R\002!\000\000\000\000\000\000\001P\002\029\000\000\000\000\000\000\001N\002\027\000\000\000\000\000\000\001M\002\025\000\000\000\000\002A\000\000\001\017\001\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002X\002W\002q\002[\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\0024\000\000\000\000\002\030\000\000\0015\000\000\003B\000\000\001\002 \000\000\000\000\002\000\000\000\000\000\000\000\000\002\002\002\000\000\000\000\003d\000\000\001\017\001\016\000\000\001\014\001\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\005\001\004\000\000\001<\000\000\001\003\000\000\000z\001\006\000\000\000\000\001\005\001\004\000\000\001\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\001\000\000\001\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\001\002\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\000E\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\005\002\004\000\000\000D\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\001\000\000\001\003\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\156\000A\000\000\000\000\000\000\000\000\000\000\000\000\002\014\000\000\000\000\000\000\000\000\000\000\002\r\000\000\000\000\000\000\001\157\000\000\000@\002\012\002-\000\000\002\017\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\0039\000\000\000\002\000\000\000\000\003<\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002X\002W\000\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0020\002/\000\000\002[\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0024\003;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0020\002/\000\000\000\000\002\002\000\000\000G\002\007\002\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000I\000\000\000\000\000H\000\000\000\001\000\000\000\000\001\000\000\000~\000\000\000}\000\000\000|\000\000\000{\000\000\000\000\0018\0017\000\000\001\002z\000\000\001U\000\139\000\000\000\000\000\000\002\002\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000~\000\000\000}\000\000\000|\000\000\000{\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000P\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000G\000\000\001U\000\000\000\000\000\000\001\000\000\002y\000\000\002u\000\000\002x\000\000\000\000\002w\000\000\000\000\000\147\000\000\000\146\000\000\000\000\000\000\000\148\000\000\000\149\000\000\000\151\000\000\000\000\000\152\000\000\000\000\000\000\000\000\000\000\000\000\002\002\000\000\000\000\002\000\000\000\000\000\000\000\153\000\000\000\140\000\000\000\000\001\000\000\000\000\001\140\000\000\000\000\001\144\000\000\000\000\000\000\000\000\001\141\000\000\000\000\001\143\000\000\000\000\001\142\000\000\000\000\000\000\001\135\000\000\000\000\001\139\000\000\000\000\000\000\001\136\000\000\000\000\001\138\000\000\000\000\001\137\003Y\000\000\001\149\003[\000\000\000\000\001\148\003\\\000\000\000\000\000\000\000\000\000\000\003^\003_\000\000\000\000\000\000\000\000\003`\003]\003Z\001\134\000\000\000\000\000\000\000\000\002 \000\000\000\000\000\000\000\000\000\000\000\000\0034\0033\0035\0032\0031\000\000\001\000\000\001\000\000\001\000\000\000\000\001\001\001\000\000\000\000\000I\000\000\000\000\000H\000\000\000\000\000\000\000\000\003?\003>\000\000\001\000\001\000\000\000\000\000\000\002\000\000\001\000\002\000\000\000\003\000\000\002\000\000\000\004\000\000\002\000\000\000\000\002\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\000\000\001\000\000\000\000\0034\0033\0035\0032\0031\000\000\000\000\003O\003J\003K\003N\003L\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0018\0017\000\000\000\000\000\000\001<\000\000\000\000\000\000\000\000\000\000\000\000\0011\000\000\000\000\0030\000\000\003/\001@\000\000\000\000\001r\000\000\000\000\000\000\000\000\0008\0007\000\000\000\000\0006\0005\000\000\000\000\0004\0003\000\000\001a\000\000\000\000\000\000\000\000\000\000\001p\001]\000\018\000\000\000\000\0002\000\000\000\015\002'\002#\000!\002&\000\r\000\000\000\000\000\000\000\000\000\000\001\132\001`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\030\002%\001Z\001Y\002(\000\000\002\022\000\006\000\000\001A\001.\000\000\001?\0013\0014\000\000\000\000\002q\000\000\000\000\002\030\000\000\0015\0019\003D\003C\000\000\000\000\000\000\000\000\001Q\002\031\000\000\000\000\000\000\000\000\001L\002\023\000\000\000\000\001-\000\000\001=\001>\000\000\0010\002C\003P\002B\000\000\001C\000\007\000\000\000\000\001E\000\000\000\000\001D\003k\001F\001G")
  
  and error =
    (130, "≠\128\000\0263釜\n\031\136\000\006\028(xL.F\012蹊\002\135\000\001\135\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\139\130\003k\143臺x\000\001\ts\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H \000 \006\n\012h\000\001\128\000\000\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000 \000\000\000\002\000\000\000\000\000\000\000 \000\002\000\b\000\000\000\000\128 \000\000\000\000H \000 \006\n\012h\000\001\128\000\000\134\000\018\b\000\b\001\130\147\026;\128\000`\000\000!\129A\004\0230\000\001\0249\028p\020\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\030(\002K\145;?\128§\002\000畫A\004\0230\000\001\0249\028p\020\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000(x\t.F\012蹊\002\135\000\003\135\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000 \000\012\000\000\000h \000\001\000\000\000 \000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000 \000\012\000\000\000h \000\001\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000 \000\012\000\000\000h \000\001\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000L\000\000\000\000\002\000\000\000\n\001\000\000@2\000@\144\000\003\128\028(\000\000 \004\001\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000\b$\b!\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\n\000p\000\000\000\000\000\000\0000\000@\128\000#\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\031\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0028\001\128\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\004\000\000\024\000\000\002\000\000\000\000\006\130\b\000\016\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000 \000\000\000\000\000\000\000\000\000\000 \000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\0000\000@\128\000\002\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000@\128\000\002\128\028(\000\000\000\000\000\000\128\012\000\016\000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\n\000p\000\000\000\000\000\002\0000\000@\128\000\002\128\028(\000\000\000\000\000\002\128\000\000\000@\000\016 \000\000\000\000\000\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000@\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\031q\004\016_`\000\004`膰qPr\135\138\000\146k偉(~\000\0008p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H \000 \006\n\012h\000\001\128\000\000\134\000\016\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\004\130\000\002\000`て\142\000\024\000\000\b`!b\128\000\0241ｘ\002\030\000\000\002\156\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\022.\b\015閃\131?\159)\000\004%\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\b\b\b\001\130\131\026;\128\000`\000\000!\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\024)1８\000\006\000\000\002\024\bX\b,\006:\012h\000\135\128 \000\135\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\000\000\000\000\000\000 \000\000\000\004\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\001\000\000\001\b\000\bX\000,\006:\012h\000\135\128\000\000\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\022.\b\015閃\131?\159)\000\005%\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\128\0241ｘ\002\030\000\000\002\028\bX ,\006:\012h\000\135\128\000\000\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000 \001\000\128\000\016\000\000\000\000\001@\000 \000\000\b\000@ \000\004\000\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!}\016A\005\012\000\000F\014{\135\028\005\007(x\t.F\012蹊\002\135\000\003\135\0002\b@\001\000\134\128\018/\128\000h\000\000 \128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\014\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0009 ?\002\003H|!\000\020\1500\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\b\000\000\0008\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\012\000\000\027\000\000\002\000\000\000\000\004\130\000\000\002\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000誓\001\002\000\000\n\000p\000\000\000\000\000\n\0000\000@\128\000\002\128\028(\000\000\000\000\000\000\128\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\002\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000@\128\000\002\128\028(\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\001C\000\005\000\000(\001\128\000\128h\005\128#\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0310\000@\128\000\003\128\028(\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\016\000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\n\000p\000\000\000\000\000\002\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000(\000\001\002\000\000\n\000p\000\000\000\000\000\002\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\012\000\016 \000\000\007\n\000\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000@\128\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\016 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\016\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\001n\000\000\n\000s\000\000\026\001`(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\004\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\003\000\005\000\000(\001\128\000\000h\005\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003}\016A\005\012\000\000F\014{\135\028\005\007(x\t.F\012蹊\002\135\000\003\135\007q\004\016_`\000\004`膰qPp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bx\000,F\012蹊\002\135\b\001\135\007q\004\016_`\000\004`膰qPp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000}\016A}\131\000\000\017\131\158畴\001A\030(\002K\145;?\128§\000\000畧\006\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\128\b\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\015\004\000\000\000\000\b\004\002\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\002\000\016\b\000\001\000\000\000\000\000\020\000\002\000\000\000\128\004\002\000\000@\000\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028\000@\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\002\000\000\000\000\128\000\000\000\b\000\002\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\138\000\002c\143\bx\002\000\bp\001 \128\000\128\024(1８\000\006\000\000\002\024)X\004F\012\128\135\128!\000\135\136\018\014O\143\131暹\159\b`\002\023\140\133\138\000\002c\143\bx\000\000\bp!b\128\000\0241ｘ\002\030\000\000\002\156\bX\b,\006:\012h\000\135\128 \000\135\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H \000 \006\n\012h\000\001\128\000\000\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127H \000 \006\n\012h\000\001\128\000\000\134\007\004\000\000\000\000\000\000\n\000\000\000\000\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028\000\000\000\000\000\000\002\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\004\000\000\004\000\000\128\000\000\000\000\000\b\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nV(\001;\145;?!\b@!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000脆!\016\004B\154\000H\000\001\000\000\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\bh\001\"\000\006\128\000\002\b\000!\000\004\002\026\000H\000\001\000\000\000\000\000\000\000\000\128\000\000\003\128\000@\000\000\000\000\000\000\000\000\000 \000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0009 ?\002\003H|!\000\020\1500\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\b\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\003\000\000\006\000\000\128\0000\000\000\001 \128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000 \000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\134\128\018/\128\000h\000\000(\128\012\130\016\128@!\004\139\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000@\000\b0\000\001\000\000\000\128\000\000\000\000\000\000\000\000\002\000\000\000@\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000@\000\000\000\000\000\000\000\000\000\004 \000\003 \132\000\016\bh\001\"\000\006\128\000\002\b\000!\000\004\002\026\000H\000\001\128\000\000\130\0002\014H\015成\128/\159\bh\000\004%\140\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\130\016\000@!\004\139\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\002\000\000@!\000\000\000\000\016\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\027\000\000\000\000\000@\000\000\000\000\017\138 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?2\b[\001\000\134\128\018k\128\000`\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\131 \132\000\016\bh\001\"\000\006\128\000\002\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\027\000\000\000\000\000@\000\000\000\000\017\138\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\024\000?\0000\003\000\000| \000\000\016\0200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\000\004\002\026\000H\000\001\000\000\130\0002\bB\001\000\134\128\018/\128\000h\000\000 \128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\0002\b@\001\000\134\128\018/\128\000h\b\000 \128\012\130\016\000@!\004\139\000\026\000\000\b \128\000\001 \000\000\000\000\000\000\000\000\000\000\000 \000!\000\004\002\026\000H\000\001\000\000\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\018\000\000\000\000\000\000\000\000\000\000\016\002\002\000\000\004\128\000\000\000\000\000\000\000\000\000\004\000\128\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\bh\001\"\000\006\000\000\002\b\0009 ?\002\003H|!\000\016\1500\000\000\b\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000!\000\004\002\026\000H\000\001\000\000\130\0002\b@\001\000\134\128\018/\128\000h\000\000 \128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\002\000\000@!\000\000\000\000\016\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\026\000\000\000\000\000@\000@\006\128\017\130 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\019 \133\016\bh\001&\004\006h\001\026*\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127猗!\000\004\002\026\000H\000\001\000\000\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\006\128\000\000\000\000\016\000\016\001\004`\136\128\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\015\012\000\000\031\b\000\000\004\005\012\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\134\128\018/\128\000h\000\000 \128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?0\000@\128\000\003\128\028(\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b0\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\001\000 ?\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\012\130\016\000@!\004\139\000\026\000\000\b \128\000\001\000\000\000\000\000\000\000\000\000\000\001\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\001\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\012\130\016\000@!\004\139\000\026\000\000\b \000\000\000\000\000\000\000\000\004\000\000\000\000\001\016\002\000!\000\004\002\026\000H\000\001\000\000\130\b\000\000\b\000\000\000\000\000@\000\000\000\000\001\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018k\128\000b\000\011\014\131\146\003+4\139臑\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000d\000\002\128\014\131\146\003+4\139臑\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000d\000\002\128\012\130\016\000@!\004\138\000\024\000\000\b \003 \132\000\018\bx\001\"\000\006`\000*\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\012\1300\000@!\004\138\000\025\000\128 \000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127@\000\000\000\000\n\000\b\000\000\000\000\000\000\002\022.\000\015閃\131?\159)\000\004%\004\000\000\000\000\000\128\004\002\000\000@\000\000\000\000≠\128\016\0263釜\n\031\128\000\006\028\000!\016\004\002\154\000H\000\001\000\000\130\007q\004\016_`\000\004`膰qPr\135\138\000\146k偉(~\000\0008p}\016A\005\012\000\000F\014{\135\028\005\007(x\t.F\012蹊\002\135\000\003\135\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\004\130\000\002\000`\142\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\004\130\000\002\000`\142\000\024\000\000\b`@\000\000\000\000\n\000\000\000\000\000\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!\004\130\000\002\000`\142\000\024\000\000\b`\001 \140\000\128\024(1８\000\006\000 \002\024?\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\0002\b@\001\000\135\128\018+\128\000`\000\002\"\128\014\131\146\003+4\139臑\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000d\000\002\128\014\131\146\003+4\139臑\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000d\000\002\128\133\138\000\002c\143\bx\000\000\bp\003 \132\000\016\bh\001\"\000\006\128\000\002\b\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\b\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\000@0\000\000\000\000\000\000\000\000\000\004\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\004\1300\002\000`\142\000\024\000\128\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\004\000\000\000\000\000\000\142\000\000\000\000\000\000\000!b\000\026=ｙ\158\000\000B\\@\000\000\000\000\b\000@ \000\004\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\012\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\128\004\002\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016@\000`\000\000\b\000C \000\000\026\000\000\000@P\000\b\000\000\002\000\016\b\000\001\000\000\000\000\000\133\138\000\002c\143\bx\000\000\bp!b\128\026=ｙ\158\000\000R\\@\000\000\000\000\b\000@ \000\004\000\000\000\000\000\016\000\b\000\000\002\000\016H\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\004\000\000\024\000\000\002\000\000\000\000\006\130\b\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\016\000\024\000\000\002\000\016\000\000\006\130\000\128\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bX ,\006:\012h\000\135\128\000\000\135\002\022(\b\011\001\142\131\026?\128!\000\000!\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\007\004\130\000\002\000`\142\000\024\000\000\b`\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\024*1８\000\006\000\000\002\024\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\1300\002\000`\142\000\024\000\128\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\004\1300\002\000`\142\000\024\000\128\b`\127X\000,\006:\012h\000\135\128\000\000\135\0002\b@\001\000\135\128\018+\128\000`\000\002\"\128\014\131\146\003+4\139臑\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000d\000\002\128\014\131\146\003+4\139臑\026\000\001\tc\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000d\000\002\128\133\138\000\002c\143\bx\000\000\bp\003 \132\000\016\bh\001\"\000\006\128\000\002\b\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\b\000\018\b\000\b\001\130\131\026;\128\000`\000\000!\128\000@0\000\000\000\000\000\000\000\000\000\004\128\000\000\001 \128\000\128\024(1８\000\006\000\000\002\024\000H#\000 \006\n\012h\000\001\128\b\000\134\007\004\130\000\002\000`\142\000\024\000\000\b`\127X\000,\006:\012h\000\135\128\000\000\135\007\004\000\000\000\000\000\000\n\000\000\000\000\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028\000H \000 \006\n\012h\000\001\128\000\000\134\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\b\000\b\001\130\026;\128\000`\000\000!\128\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!\001\000\000\000\000\000(\000\002\128\000\000\000\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\018\b\000H\001\130\131\026;\128\000`\000\000!\128\004\130\000\002\000`\142\000\024\000\000\b`\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\030\000\000\002\028?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\015\133\138\000\002c\143\bx\000\000\bp\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001 \128\004\128\024(1８\000\006\000\000\002\024\000H \000 \006\n\012h\000\001\128\000\000\134\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\016\000\000\000\000\002\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\030\000\000\002\028\031\022(\000\011\001\142\131\026?\128!\000\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\000\000\006\000G\012\000@\031\b\000\000\004\132\012\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\007\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\007\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\007\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\007\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\007\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\007\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\128\000\000\135\002\022(\000\011\001\142\131\026?\128!\000\000!\127X\000,\006:\012h\000\135\128\000\000\135\007\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\007\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\007\000\001\128\017\003\0000\016\007\000\000\001!\003!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\158\000\000\002\028\bX\000,\006:\012h\000\135\128\000\000\135\015!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!!b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!\128\000`\132|\000\012\004\001\128\000\000@@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\133\138\000\002c\143\bx\000\000\bpX\000,\006:\012h\000\135\128\000\000\135\b\000\006\002G\012\000@\031\b\000\000\004\004\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000X\000,\006:\012h\000\135\128\000\000\135\015\133\138\000\002c\143\bx\000\000\bp\000\000`\020|\000\012\004\001\128\000\000@@\022(\000\011\001\142\131\026?\128!\000\000!X\000,\006:\012h\000\135\128\000\000\135\015\128\000`\132|\000\012\004\001\128\000\000@@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\133\138\000\002c\143\bx\000\000\bp\127X\000,\006:\012h\000\135\128\000\000\135\b\000\006\002G\012\000@\031\b\000\000\004\004\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127X\000,\006:\012h\000\135\128\000\000\135\007\133\138\000\002c\143\bx\000\000\bp\000\000`\020|\000\012\004\001\128\000\000@@\022(\000\011\001\142\131\026?\128!\000\000!\127X\000,\006:\012h\000\135\128\000\000\135\007\000\000a|\000\012\012\001\128H\001a脆!\000\004\130\030\000H\000\001\152\000\n\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\130\000\002\000`\142\000\024\000\000\b`\003 \140\000\016\bx\001\"\000\006@ *\b\000\001\002\000\000\n\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\004\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\000\000a|\000\012\012\001\128H\001a\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000d\000\002\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\134\128\018/\128\000h\000\000 \128@\000\000\000\000\000\000\000\000\000\000\001\000\000\000\128\016\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\000\000\006\000G\012\000@\031\b\004\000\004\004\012\133\138\000\002c\143\bx\000\000\bp\000\000a|\000\012\012\001\128H\001aX\000,\006:\012h\000\135\128\000\000\135\000\000\006\027G\012\000誓\031\b\004\128\028\134\029\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000d\000\002\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\024\001\031\0000\003\001\000| \000\000P\0162\022(\000\011\001\142\131\026?\128!\000\000!\000\001\130\017\003\0000\016\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H   \006\n\012h\000\001\128\000\000\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\133\138\000\002c\143\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?0\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\b\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\128\0241ｘ\002\030\000\000\002\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000`\132|\000\012\004\001\128\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000≠\128\016\0263釜\n\031\128\000\006\028\000@\000\000\000\000\b\000@ \000\004\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\001\000\000\000\000\001\000\000\000\000\000 \001\000\128\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\016\000\027\000\000\002\000\016\000\000\004\128\000\128\016\020\000\002\000\000\000\128\004\002\000\000@\000\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028\000\000\024!\031\0000\003\001\000| \000\0002\0160\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 @\000 \000\000\b\000A \000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\000\000\000\000\138\000@ \000\000\000\000\000\000\012\000\000\b\000\000\002\000\000@\000\000\004\002\000\128\002\002\000\000@\004\b\016\b@\000 \006\000\000\016\000\127@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\016\000\004\003 \004\t\000\0008\001\128\000\002\000@\016 \000\001B\000 \n\000s\000\000\002\t\002\b@0\000@\128\000\002\128\028(\000\000\000\000\000\000\000\012\000\020 \000\000\007:\000\000\000 \016 \132\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000@\128\000#\128\028(\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\020 \000\000\007:\000\000\000 \016 \132\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\b\004\b!\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\128\016 \000\000\007\n\000\000\b\000\000@\128\003\000\004\136\000\0028\001\128\000\000\000\000\000\000\000\001B\000 \n\000s\000\000\002\001\002\bG\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\b\004\b!\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\020 \002\000\007:\000\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\002\000\000\000\000\000 \000\001\000\000\012\000\020 \002\000\007:\000\000\000 \016 \132\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000P\128\b\002\128\028\000\000\000\128@\130\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\0000\000P\128\b\002\128\028\000\000\000\128@\130\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001B\000 \n\000s\000\000\002\001\002\bG\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000\b\004\b!\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\b\004\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000 \016\000\132\000\000\001\000\000\000\000\000\b\000\000\000\b\004\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \000\000\000\016\000\004\001 \000\001\000\000 \000\000\128\000\002\000@\016 \000\001B\000 \n\000s\000\000\002\001\002\b@\018\000\000\000\000\002\000\000\b\000\000 \000\001\002\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\016 \000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\128\000\000\000\128@\000\016\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\001\000@\000\000\000\b\000\000\000(\004\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\128\000\000\000\128@\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031q\004\016_`\000\004`膰qPr\135\138\000\146k偉(~\000\0008p\000\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000 \000 L\000\000\000\000\002\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\128\000\000\000\000\128\000\000\000\000\b\000\000@\000\131\000\0058\000\128(\001\128\000\000(\000\b \000H\000\000\000\000\b\000\000\128\000\000\128\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b0\000S\128\000\002\128\028\000\000\000\128@\130\016\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\012\000\020\002\000\007:\000\000\000\000 \128\001 \000\000\000\000 \000\002\000\000\002\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\b0\000S\128\b\002\128\028\000\000\002\128\000\130\000\004\128\000\000\000\000\128\000\b\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000(\000\b \000H\000\000\000\000\b\000\000\128\000\000\128\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b0\000S\128\b\002\128\028\000\000\002\128\000\130\000\004\128\000\000\000\000\128\000\b\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\136\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 @\001\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\128\016\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132\000\001\019\000\000\000\002\016\002\000\000\000\004\000\002\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\016\000\004L\000\000\000\b@\b\000\000\000\016\000\000\b\000\000\000\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\015\000\000\000 \000\000\000\000\000\000\000\000\000\128\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000 \004\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \001n\000\000\n\000s\000\000\002\000\000\000H0\000[\128\000\002\128\028\000\000\000\128\000\000\018\000\000\004@\000\000\000\0000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\012\000\000\000\b\000\000\001\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\b\016\bx\001\"\000\006 \000*\b\000\000\000\002\000\002\000\000\000\014\000\001\000\000\000\000\000\000\000\000\128\000\128\000\000\003\128\000@\000\000\000\000\004\000\000\000\000\000\004\002\000\000@\000\000\016\000\001\000\000\000\000\000(\001\000\128\000\016\000\000\004\000!@\000\004\000\011\000!\128\004\000\001\001\000\1282\bD\001\000\134\128\018/\128\000h\000\000 \128\012\130\016\000@!\004\139\000\026\000\000\b \003 \132\000\016\bx\001&\000\006 \000*\0009 ?\002\003H|!\000\016\1500\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\bx\001\"\000\006@\000*\b\0009 ?\002\003H|!\000\016\1500\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\bx\001\"\000\006@\000*\b\bX\000,\006:\012h\000\135\128\000\000\135\007\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000@\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\000\000\006\017G\012\000誓\031\b\000\128\004\006\028\012\130\016\000@!\004\138\000\025\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\128\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\024E\031\0000\003\003\000| \002\000\016\024p\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\001\000\000\000\b\000\000\000\000\000\000\000\000\000 \000\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\000\004\002\030\000H\000\001\144\000\n\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\b\000\006\b\1280\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028\031\000\000\000\000\000\000\000\000\000\000\000\002\000\000\002\000\133\138\000\002c\143\bx\000\000\bp\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\000\004\002\030\000H\000\001\128\000\b\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\130\016\000@!\004\138\000\025\000\000\136 \001\000\000\000\000\000(\001\000\128\000\016\000\000\004\000\000@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\b0\000[\128\000\002\128\028\000\000\000\128\000\1282\012\000\022\000\000\007:\000\000\000 \000 \012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\004\130\006\000`狷鉦\000\024 \000l\129 \129\128\02481\000\006\b\000:\027\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\027\000\000\000\000\000\000\000\000\128\000\1280\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\000\004\002\026\000H\000\001\000\000\130\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\018\020\000\000L \000\012B\024\000@\000\016\016\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\000\000\004\000\000\000\132\001\128\000\000\001\000\000\000\128\000\000\000\000@\128\000\000\000\000\000\000\000\001\000\000\000\000\000\000\016 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\002\000\000\004@\000\000\000\000 \000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016 \000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\128\000\001\016\000\000\000\000\b\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\002 \000!b\128\000\0241ｘ\002\030\000\000\002\028 \000\024E\031\0000\003\003\000| \000\000\016\0160\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\128\000a\020|\000\012\012\001\128\000\000@@\000\000\000\000\000\002\000\000\000\000\000\000\000\000\004\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\130\016\000@!\004\138\000\025\128\000 !b\128\000\0241ｘ\002\030\000\000\002\028?\022(\000\011\001\142\131\026?\128!\000\000!\000\001\132Q\003\00000\007\000\000\001\001\003\003\128\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\b\000\006\017G\012\000誓\031\b\000\000\004\004\012\000\000\000 \000\000\000\000\000\000\000\000\000\128\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\128\000a\020|\000\012\012\001\128\000\000@@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\bx\001\"\000\006@\000*\b\000\001\002\000\000\n\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\004\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\128\000a4|\000\012\012\001\128\b\000@A\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\n\000@ \000\004\000\000\001\004\000\016\000\000\000\000\002\128\016\b\000\001\000\000\000@\002\000\000\004@\000\000\000\0000\000\000\000\000\000\000\b\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\001\016\000\000\000\000\000\000\000\000\000\000\000\000!\000\000\004\000\000\000\132\001\128\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\bh\001\"\000\006\128\000\002\b\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\002\000\000\000\000\000\016\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000@\128\001\003\128\028(\000\000\000\000\000\000\000\004\000\000\000\000\000 \004\002\000\000\000\000\000\000\000\128\000\000\128\000\000\000\000\004\000\000\000\000\000\000\000\000\001\003\000\000\n\000p\000\000\000\000\000\000\0000\000@\128\000\002\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\001\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\016\000\000\000\0000\000@\128\001\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\001\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000L\000\000\000\000\003\000\000\000\002\000\000\000@0\000@\128\001\003\128\028(\000\000\000\000\000\000\000\004\000\000\000\000\000 \004\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\000\000D\000\000\000\132\000\128\000\000\001\000\000\136\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000X\128\000\002\128\028\000\000\006\128\000\000\016\012\000\022 \000\000\007:\000\000\001\000\000\004\000\000\001\128\000\000\000\000\012\000\000\000 \000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\0160\000\000\007\n\000\000\000\000\000\000\000\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\016\000\000\000\0000\000@\128\001\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\001\000\000\000\000\003\000\004\b\000\0168\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\016\000\000\000\0000\000@\128\001\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000@\000\000\000\000\n\000@ \000\004\000\000\001\000\b\000\000\019\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\000\004\002\030\000H\000\001\144\000\n\130\000\016\000\000\000\000\002\128\016\b\000\001\000\000\000@\002\000\000\004\000\000\000\0000\000\000\000 \000\000\004\001\000\000\000\000\000(\001\000\128\000\000\000\000\000\000\000\001\002\000\004\014\000p\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000@\000\000\000\000\n\000@ \000\004\000\000\001\000\b\000\000\019\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\004\000\000\000\000\000\000\000\000 \000\000\000≠\1280\0263釜\n\031\136\000\006\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\002\000\000\016\000\000\000\000\002\000\016\b\000\001\000\000\000\000\002\004\000\004\000\000\128\0042\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000@\000l\000\000\b\000C \000\000\018\b\002\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\000\000\000\000\138\000@ \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000\000 \000\000\000\000\001\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\002\000\004\000\000\012\000\016$\000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000\000l\000\000\000\000\003\000\000\000\018\001\000\000@0\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000  @\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000\027\000\000\002\000\000\000\000\004\130\000\000\016\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000\027\000\000\000\000\000\000\000\004\130\000\000\016\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000 \000\012\000\000\000H \000\001\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000 \000\012\000\000\000H \000\001\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000  \000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000\027\000\000\000\000\000\000\000\004\130\000\000\019\000\000\006\000\000\000\0000\000\000\001 \000\000\004\000\128\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\0000\000\000l\000\000\000\000\003\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\004\000\000\000\000\b\004\002\000\000\000\000\000\000\000\128\128\000\016\001\002\004\002\016\000\b\001\128\000\004\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000`\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\001\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127 \000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000 \000@\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000`\000\000\000\000\003\000\000\000\026\001\000\000@\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\129\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000`\000\000\000\000\003\000\000\000\026\b\000\000@\000\000\000\000\000\000\000\000\000\000\000\002\002\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\001\128\000\000\000\000\012\000\000\000h \000\001\016\000\000`\000\000\000\000\003\000\000\000\026\000\000\000@\b\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\138\000@ \000\000\000\000\000\000\004\000\000\024\000\000\000\000\000\000\000\006\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007q\004\016_`\000\004`膰qPr\135\138\000\146k偉(~\000\0008p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\019\000\000\000\000\000\000\000\000\000\128\000\000\016\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000L\000\000\000\000\002\000\000\000\n\001\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\004\000\000\000\000 \000\000\000 \016\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\004\000\000\000\000\000\000\000\000 \000\000\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\000\000\000\000\b\000\000\001\002\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000L\000\000\000\000\000\000\000\000\002\000\000\000@\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\012\130\016\000@!\004\139\000\026\000\000\b \000\000\000\000\000\000\000\000\004\000\000\000 \000\024\"\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\b\000\000\b\002\022(\000\011\001\142\131\026?\128!\000\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bx\000,F\012蹊\002\135\000\001\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001A\004\0230\000\001\0249\028p\020\028≠\128$\0263釜\n\031\128\000\014\028\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\b\004\002\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\003\000\004\b\000\0008\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\004\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\128\000\000\000\000\128\000\000\000\000\b\000\000@\000\003\000\005\b\000\128(\001\128\000\000\000\000\b \031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\020 \002\000\007:\000\000\000\000\000 \128\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\020 \002\000\007:\000\000\000\000\000 \128\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000P\128\b\002\128\028\000\000\000\000\000\130\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001B\000 \n\000s\000\000\000\000\002\b\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\136\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000 \000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\004\000\000\000\000\000\002\000\000\000\000\004\000\000\000\000\000 \004\002\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\012\000\000\000\b\000\000\001\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\004\000\016\000\000\000\000\000\000\000\002\000\0000\000@\128\001\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\002\002\000\000@\004\b\016\b@\000 \006\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000 \000\b\000\000@\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\004\000\000\000\000\b\004\002\000\000\000\000\000\000\000@\000\000\128\000\000\000\000\004\000\000\000@\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\002\000\000\016\000\000\000\000\"\128\016\b\000\000\000\000\000\000\001\000\000\004\000\000\000\000\0000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\016\000\000@\000\000\000\000\003\000\000\000\016\000\000\000G\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\016\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\127\000\000\016\000\000\000\000\000\128\000\000\002\128@\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\016\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\004\b\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\128\000\000\000\000\004\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\016\000\000\000\000\"\128\016\b\000\000\000\000\000\000\001\000\000\006\000\000\000\000\0000\000\000\001\000\000\004@\000\000\000\000\000\000\000\004\000\000\000`\000\000\000\000@\000\000\000\000\b\000@ \000\004\000\000\000\000\b\016\000\019\000\000\002\000\016\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\001\000\000 \000\001\000\000\000\000\000 \001\000\128\000\016\000\000\000\000 @\000L\000\000\b\000C \000\000\002\000\000\000@\016\000\000\000\000\"\128\016\b\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\016\000\000\001\000\000\000\000\001\000\000\000\000\000 \001\000\128\000\016\000\000\000\000 @\000L\000\000\b\000C \000\000\002\000\000\000D\000\000\000\000\000\000\000\000@\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\135\138\000鯛k偉(~ \000\024p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000H\000\000@\000\b\000\000\000\000\000\128\000\004\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\128\000\000\000\000\128\000\000\000\000\b\000\000@\128\001 \000\000\000\000 \000\000\000\000\002\000\000\016\000\031\018\000\000\000\000\002\000\000\000\000\000 \000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\004\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\016\000\000 \000\000\000\000\001\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\004\000\000\000\000\b\004\002\000\000\000\000\000\000\000\000\001\000\000\000\000\012\000\000\000H\000\000\0000\000\000 \000\000\000\000\001\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\128\000\000 \001\004\128\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\b\004\002\000\000\000\000\000\000\000\000\000\128\000\000\000\000\004\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\002\000\000\000\000\000\016\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\016\000\000\000\000\016\000\000\000\000\002\000\016\b\000\001\000\000\000\000\001\004\000\006\000\000\000\128\0042\000\000\001\000 \004\001\000\000\000\000\000 \001\004\128\000\000\000\000\b\000 @\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\002\022(\000\011\001\142\131\026?\128!\000\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\004\002\000b\128\000\0241ｘ\002\030\000\000\002\156\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bX\000,\006:\012h\000\135\128 \000\135\002\022(\000\011\001\142\131\026?\128!\000\000!\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000@\000\002\022(\002\011\001\142\131\026?\128!\b\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\001\000\000\001\000\000 \000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\016\000\000\b\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\001\000\000\000\000\000\000\000\000\000\000\016\000\002\004\000\000@\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000B\000\002\022(\000\011\001\142\131\026?\128!\000\000!\000\001\128Q\003\0000\016\007\000\000\005\001\003\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\b\000\bX\000,\006:\012h\000\135\128\000\000\135\b\000\006\001G\012\000@\031\b\000\000\020\004\014\000\001\134剞\003\00000\007\000 \007#\135\003\000\004\b\000\000(\001\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\016\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!\000\001\134剞\003\00000\007\000 \007#\135\003 \132\000\016\bx\001\"\000\006@\000*\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\000\000\006\000G\012\000@\031\b\004\000\004\004\012\133\138\000\002c\143\bx\000\000\bp\128\000a|\000\012\012\001\128\b\001悲X\000,\006:\012h\000\135\128\000\000\135\b\000\006\027G\012\000誓\031\024\000\128\028\142\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000d\000\002\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\024!\031\0000\003\001\000| \000\000\016\0160\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\128\000`$|\000\012\004\001\128\000\000@@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\022(\000\011\001\142\131\026?\128!\000\000!\000\001\128Q\003\0000\016\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\b\000A \000\000\000\000\002\000\b\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\128\000\000\000\000\000\000\000\000\000\000\000\000\001\000\128 \000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0241ｘ\002\030\000\128\002\028\bX\000,\006:\012h\000\135\128\000\000\135\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\001\000\000\bX\b,\006:\012h\000\135\128 \000\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\004\000\000\004\000\000\128\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000@\000\000 \000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0008\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\024M\031\0000\003\003\000| \002\000\016\016p\000\000\000\128\000\000\000\000\000\000\000\000\002\000\000\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\130\016\000@!\004\138\000\025\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\000\000\000\001\000\000\000\000\000\000\000\000\000\000\016\000\000\004\002\000@\000\000 \000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\001\b\000\bX\000,\006:\012h\000\135\128\000\000\135\b\000\006\001G\012\000@\031\b\000\000\020\004\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\001\000\000 \000 \004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0261ｘ\002\030\000\000\002\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000 \000\001\000\000\000\000\000 \001\000\128\000\016\000\000\000\000\000@\000@\000\000\b\000C \000\000\002\000\000\000@\016\000\000\000\000\"\128\016\b\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\016\000\000\001\128\000\000\000\001\000\000\000\000\000 \001\000\128\000\016\000\000\000\000\000@\000@\000\000\b\000C \000\000\002\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\002\022(\000\011\145\026?\128!\000\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bX\000,F\012h\000\135\128\000\000\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000@\000\b\000\000@\000\000\000\000\b\000@ \000\004\000\000\000\000\000\016\000\016\000\000\002\000\016\000\000\000\128\000\000\016\004\000\000\000\000\b\004\002\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\004\000\000\000@\000\000\000\000@\000\000\000\000\b\000@ \000\004\000\000\000\000\000\016\000\016\000\000\002\000\016\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\016\000\000\000\000\002\128\0028\000\000\000\000\000\000\003\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\001\130\017\003\0000\016\007\000\000\001\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\b\000\006\002G\012\000@\031\b\000\000\004\004\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0241ｘ\002\030\000\000\002\028\000\000\024\005\031\0000\003\001\000| \000\000\016\0160\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000\000\000\000\000\128\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\001\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\000\000`\004|\000\012\004\001\128@\000@@X\000.F\012h\000\135\128\000\000\135\0002\bD\001\016\128\018/\128\000h\000\000 \128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\002\022(\000\011\145\026?\128!\000\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\002\000\007\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0261ｘ\002\030\000\000\002\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\138\000\002k案\143\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bX\000.F\012h\000\135\128\000\000\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000@ \b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\024\005\031\0000\003\001\000| \000\000P\0162\022(\000\011\001\142\131\026?\128!\000\000!\000\000\000@\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\b\000\000\000\002\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\130\000\002\000`\142\000\024\000\000\b`\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\006\bG\012\000@\031\b\000\000\012\132\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\000\128\000\000 \001\004\128\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\016\000\027\000\000\002\000\016\000\000\004\128\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000誓\001\002\000\000\014\000p\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000 \000\000\000\000\000\000\000\000\000\000\000\000@\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\0002\b@\001\000\134\128\018/\128\000h\000\000 \128\000\000\000\000\000\000\000\000\016\000\000\000\000\004@\b\003 \132\000\016\bh\001\"\000\006\128\000\002\b \000\000 \000\000\000\000\001\000\000\000\000\000\004\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000 \000\000\000\000\000\000\000\000\000\000\000 \bX\000,\006:\012h\000\135\128\000\000\135\000\000\006\002G\012\000@\031\b\000\000\004\004\012\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\024!\031\0000\003\001\000| \000\0002\0160\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 @\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\004\000\002\000\000\000\128\004\018\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000 \000\000\b\000A \000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\004\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\bX\000,\006:\012h\000\135\128\000\000\135\000\000\006\000G\012\000@\031\b\000\000\020\004\012\133\138\000\002c\143\bx\000\000\bp\000\000`\132|\000\012\004\001\128\000\000@@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\b\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\001\128\017\003\0000\016\007\000\000\005\001\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000@\000\000@\000\b\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H#\000 \006\n\012h\000\001\128\b\000\134\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\001\000\128 \000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!b\128\000\0241ｘ\002\030\000\128\002\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\001\b\000\000\001\002\000\000\014\000p\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000@\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\n\000p\000\000\000\000\000\002\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\012\000\016 \000\000\007\n\000\000\000\000\000\000 \000\000\000 \000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\128\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\001\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\127誓\001\002\000\000\014\000p\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000 \000@\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000C\000\005\000\000(\001\128\000\128h\005\128#\128@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b0\000S\128\000\002\128\028\000\000\000\128@\130\016\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\142\000p\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000\b\004\b!?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\128\016 \000\000\007\n\000\000\b\000\000@\128\003\000\004\136\000\0028\001\128\000\000\000\000\000\000 \001N\000 \n\000s\000\000\002\001\002\bO\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000\b\004\b!?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\012\000\020\002\000\007:\000\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\002\000\000\000\000\000 \000\001\000\002\012\000\020\002\000\007:\000\000\000 \016 \132\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b0\000S\128\b\002\128\028\000\000\000\128@\130\019\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\b0\000S\128\b\002\128\028\000\000\000\128@\130\019\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \001N\000 \n\000s\000\000\002\001\002\bO\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\131\000\0058\000\128(\001\128\000\000\b\004\b!?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\0010\000\000\000\000\b\000\000\000\b\004\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\004\000\000\000\000 \000\000\000 \016\000\132\128\000\0010\000\000\000\000\b\000\000\000\b\004\000!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\004\000\000\000\000 \000\000\000\016\000\004\001 \000\001\000\000 \000\000\128\000\002\000@\016  \001N\000 \n\000s\000\000\002\001\002\b@\018\000\000\000\000\002\000\000\b\000\000 \000\001\002\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\016 \000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\019\000\000\000\000\000\128\000\000\000\128@\000\019\128\000\0010@\000\000\000\b\000\000\000(\004\000\001?\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\001 \000\001\000\000 \000\000\000\000\002\000\000\016 \000H\000\000\000\000\b\000\000\000\000\000\128\000\004\b\000\018\000\000\000\000\002\000\000\000\000\000 \000\001\000\003\001 \000\000\000\000 \000\000\000\000\002\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\128\000\000\000\b\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \128\000\128\024(1８\000\006\000\000\002\024\000\000\011\000\000\000\002\000\000\000\000 \000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\003\000\000\000\000\000\000 \000\000\000\b\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001 \140\000\128\024(1８\000\006\000 \002\024?\030(\003\011\145;?\128§\128\000a\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\001\002\004\002\016\000\b\001\136\000\004\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\016 @!\000\000\128\024\128\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\016 \000\000\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\138\000\002c\143\bx\000\000\bp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\024\001\031\0000\003\001\000| \002\000\016\0160\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\130\016\000@!\004\139\000\026\000\000\b \000\000\000\000\000\000\000\000\000\000\000\000\b\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\135\138\016\002k偉(~ \000\024p\127@\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\004\128\000\004\000\000\128\000\000\000\000\b\000\000@\128\001 \000\000\000\000 \000\000\000\000\002\000\000\016 \000H\000\000\000\000\b\000\000\000\000\000\128\000\004\000\0000\000P\128\b\002\128\028\000\000\002\128\000\130\000\004\128\000\000\000\000\128\000\b\000\000\b\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\005\b\000\128(\001\128\000\000(\000\b \000H\000\000\000\000\b\000\000\128\000\000\128\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\001B\000 \n\000s\000\000\n\000\002\b\000\018\000\000\000\000\002\000\000 \000\000 \000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001B\000 \n\000s\000\000\n\000\002\b\000\018\000\000\000\000\002\000\000 \000\000 \000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001B\000 \n\000s\000\000\n\000\002\b\000\018\000\000\000\000\002\000\000 \000\000 \000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\018\000\000\000\000\002\000\000\000\000\000 \000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000H @\000\000\n\000\000\002\000\000\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000 \128\000\000\001\128\000@\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000 \002\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\001\001\000\000\000\000\002(\001\000\128\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132@\016\nh\001\"\000\006\128\000\002\b\000@\000\000\000\000\b\000@ \000\004\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\0000\000@\128\000\003\128\028(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\128\000\000\000\000\128\000\000\000\000\b\000\000@\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002 \000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\b\016\bx\001\"\000\006 \000*\b\000@\000\000\000\000\n\000@ \000\004\000\000\001\000\000\016\000\000\000\000\002\128\016\b\000\001\000\000\000@\002\000\000\002\000\000\000\000\000\016\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0000\000@\128\001\003\128\028(\000\000\000\000\000\000\002\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\bP\000\0010\128\0021\b`\001\000\000@@\"\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\b@\001\000\135\128\018+\128\000`\000\002 \128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003 \132\000\016\bx\001\"\000\006@\000\"\b\000@\000\000\000\000\n\000@ \000\004\000\000\001\000\000\016\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\012\000\020 \000\000\007:\000\000\000 \000\000\004\003\000\005\b\000\000(\001\128\000\000\b\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \129\000\128\02481\000\006\b\0002\025\000H @ \006\014\012k\000\001\130\000\012\134@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\0000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\128\000\000\016\012\000\016 \000@\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \000\000\000\000@\000\000\000\000\n\000@ \000\004\000\000\001\000\000\000\000\016\000\000\000\000\000\000\000\000\128\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000!\000\004\002\030\000H\000\001\144\000\n\130\000\016\000\000\000\000\002\128\016\b\000\001\000\000\000@\000\000\000\004\000\000\000\000\0000\000\000\000 \000\000\004\001\000\000\000\000\000(\001\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\016\000\000\000\000\002\128\016\b\000\001\000\000\000@\000\000\000\004\000\000\000\000\0000\000\000\000 \000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000\000\000\000\000\b\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000 \000\000\004\000\000\001\000\000\000\000\000\000\000\000\000\b\000\000\001\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\002\000\000\000@\000\000\016\000\000\000\000\000\000\000\000\000\128\000\000\016 \000\000\000\000\000 \000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001!\128\000\0263釜\n\031\128\000\006\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\030(@\011\145;?\128§\128\000a\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\002\000\000\000\002\030(@\011\145;?\128§\128\000a\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\b\000\000\000\bx\000.F\012蹊\002\135\000\001\135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")
  
  and start =
    7
  
  and action =
    ((32, "\000\000D\000\000D\000\000\129\148\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\148\000\000\158\000\000\000\000\000\000\020\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132\000\000\000\000\000\000\129\148\000\000\000\000\000\000\142\000\000楢\000\000\129\148\000\000R\000\000柚\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\022\000\000柚\000\000\000\000\000\000D\000\000hl\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000z\000\000\000\000\000\000\000\000\000\000\000\000\000\000祷\000\000\000\000\000\000z\000\000\000\000\000\000尾\000\000\000\000\000\000z\000\000\000\000\000\000\002\b\000\000x\000\000噺\000\000\000\000\000\000洞\000\000X\000\000\002\b\000\000呆\000\000\000\000\000\000\130\000\000\002\b\000\000\018\000\000\000\000\000\000\000\000\000\000\030\000\000~\000\000\000\000\000\001\005J\000\000J\000\000\000\000\000\000\004\000\000来\000\000\000\000\000\000\000\000\000\000z\000\000\000\000\000\000\002\b\000\000J\000\000\000\000\000\000\158\000\000in\000\000\158\000\000\000\000\000\000仟\000\000\000\000\000\000\000\000\000\000\000\000\000\000\158\000\000補\000\000\012\000\000伐\000\000\000\000\000\000\\\000\0008\000\000\004\000\000\000\000\000\000番\000\000N\000\000\000\000\000\000P\000\000J\000\000J\000\000\000\000\000\000T\000\000\000\000\000\000$\000\000T\000\000\000\000\000\000$\000\000$\000\000R\000\000\000\000\000\000\000\000\000\000l\000\000\000\000\000\000部\000\000jp\000\000柚\000\000D\000\000\000\000\000\000\129\148\000\000萄\000\000R\000\000D\000\000\000\000\000\000\030J\000\000J\000\000\000\000\000\000\000\000\000\000\140\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000R\000\000N\000\000\129\148\000\000\000\000B\000\000]B\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\140\000\000\000\000\000\000>\000\000沮\000\000\000\000\000\000\000\000\000\000L\000\000\136\000\000]B\000\000\001\004\000\000柚\000\000D\000\001\007d\000\000\000\000\000\000in\000\000\000\000\000\000\026\000\000h\000\000\000\000\000\000\136\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000籾\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\000\000\000\000\000\002\b\000\000\000\000\000\000\000\000\000\000\026\000\000甸\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\146\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000椋\000\000$\000\000\000\000\000\000宕\000\000袙\000\000美\000\000\000\000\000\000\000\000\000\000轍\000\000\b\000\000\004\000\000f\000\000\000\000J\000\000\002\b\000\000T\000\000$\000\000仟\000\000\000\000\000\000\000\000\000\000\000\000\000\000\154\000\000\000\000\000\000tz\000\000\156\000\000\000\000\000\000\000\000\000\000\000\000\000\000$\000\000\000\000\000\000\000\000\000\000\000\000\000\000kh\000\000\000\000\000\000\014\000\000\000\000\000\000J\000\000lj\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000ml\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000nn\000\000J\000\000op\000\000\000\000\000\000\000\000\000\000$\000\000仟\000\000\000\000\000\000\000\000\000\000pr\000\000J\000\000\000\000\000\000\000\000\000\000\000\000\000\000jp\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000$\000\000d\000\000\000\000\000\000\132\000\000$\000\000\148\000\000\000\000\000\000\022\000\000\000\000\000\000蓑\000\000$\000\000.\000\000\000\000\000\000浮\000\000\000\000\000\000D\000\000\000\000\000\000硫\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000:\000\000\000\000\000\000\000\000\000\000\000\000標\000\000紡\000\000亮\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000J\000\000\024\000\000v\000\000\000\000\003\012\000\000釟\000\000\000\000\000\000\000\000\000\000\004\016\000\000柚\000\000D\000\000略\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000冩\000\000略\000\000\000\000\000\000\000\000\000\000虹\000\000\000\000\000\000\b\000\000\005\020\000\000柚\000\000D\000\000\000\000kh\000\000z\000\000\005\000\000宕\000\000婁\000\000弄\000\000\136\000\000參\000\000]B\000\000萄\000\000伏\000\000\002\000\000\000\000\000\000\150\000\000\000\000\000\000應\000\000\129\148\000\000毎\000\000\150\000\000]B\000\000涕\000\000應\000\000\129\148\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\148\000\000\000\000\000\000\000\000\000\000qt\000\000\129\148\000\000rv\000\000\004\000\000]B\000\000\b\000\000\000\000\000\000房\000\000鋲\000\000\000\000\000\0002\000\000\000\000\000\000\000\000\000\000\000\000\000\000眠\000\000\000\000\000\000\006\000\000\018\000\000\000\000\000\000\000\000\000\001\007d\000\001\005\150\000\000\146\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\142\000\000\000\000H\000\000\000\000\000\000宕\000\000h\000\000\000\000\000\000\000\000\000\000D\000\000\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\132\000\000\000\000\000\000\000\000\000\001\0068\000\001\0068\000\000\000\000\000\000J\000\000\000\000\000\000l\000\0006\000\000\000\000\000\000\\\000\000\000\000\000\000\000\000\000\000p\000\000J\000\000論\000\000\000\000\000\000\000\000\000\000\000\000\000\000n\000\001\005\150\000\000\b\000\000\142\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000\000\000\000\000\000\000\000\001\005\150\000\000\000\000\000\000z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\b\000\000\000\000\000\000\000\000\000\000\140\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\t\000\000L\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\000\000荀\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\002\000\001\005\150\000\000\000\000\000\000靼\000\000\148\000\000\000\000\000\001\011R\000\000\000\000\000\000\000\000\000\0006\000\000\000\000\000\000\000\000\000\000d\000\000\000\000\000\001\007d\000\001\006\000\000\000\000\000\000\r\006\000\000\000\000\000\000盃\000\000\000\000\000\000\000\000\000\000\158\000\001\005\150\000\001\005\150\000\000l\000\001\005\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000偐\000\000^\000\000J\000\000t\000\000\000\000\000\000\000\000\000\000tz\000\000\012\000\000h\000\000\000\000\000\000\000\001\007d\000\001\007d\000\000\000\000\000\000\000\000\000\000\000\000\000\000sx\000\000tz\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000tz\000\000\000\000\000\000\000\000\000\000u|\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000v~\000\000P\000\000\000\000\000\000\000\000\000\000\000\000\000\000w\128\000\001\007d\000\000\000\000\000\000鬨\000\000\"\000\000\000\000\000\001\011R\000\000勣\000\000\000\000\000\000\000\000\000\000\000\000\000\000x\130\000\000J\000\000\000\000\000\001\007d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\014\000\000\000\000\016\018\000\000\000\000\000\000\000\000\000\000j\000\000z\000\000\000\000\000\000\017\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\026\000\000\000\000\000\000\000\000\000\001\002\004\000\000\000\000\000\000\019\030\000\000\000\000\000\000\000\000\000\000\000\000\000\000r\000\000\r\006\000\000\142\000\000\000\000\000\000\000\000\000\000\000\000\000\000\020\"\000\001\005\150\000\000\\\000\0004\000\000\000\000\000\000\000\000\000\000妨\000\000t\000\000嗄\000\001\007d\000\000f\000\001\005\150\000\000n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\020\"\000\000聾\000\000\000\000\000\000\000\000\000\000 \000\000\012\000\000嘴\000\000J\000\000p\000\000\134\000\000\150\000\000學\000\000p\000\000tz\000\000j\000\000\000\000\000\000\129\148\000\000頽\000\000牟\000\000\000\000\000\000\000\000\000\000\000\000\000\000y\132\000\000\130\000\000|\000\000L\000\000D\000\000\002\000\000柚\000\000D\000\000柚\000\000D\000\000\030J\000\000\030J\000\000\000\000\000\000\000\000\000\000\021&\000\000\030J\000\000\022*\000\000\012\000\000]B\000\000\129\148\000\000\152\000\000\023.\000\000岻\000\000\000\000\000\000\000\000\000\000]B\000\001\007\000\000J\000\000嵎\000\000\000\000\000\000\000\014\000\000怩\000\000愼\000\000\000\000]B\000\001\007d\000\000\140\000\000\129\148\000\000\148\000\000\000\000\000\000\000\000\000\000\129\148\000\000\152\000\000\0242\000\000\000\000\000\000\0256\000\000L\000\000@\000\000L\000\000当\000\000\030\000\000\000\000\000\000\000\000\000\000\000\000\000\000v\000\000補\000\000X\000\000 \000\000L\000\000\000\000\000\000罨\000\000\004\000\000\150\000\000\132\000\000L\000\000\150\000\000\000\000\000\000亂\000\000\000\000\000\000T\000\000\000\000\000\000慍\000\000\150\000\000做\000\000\000\000\000\000\000\000\000\000\000\000\000\000縉\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000v\000\0004\000\000f\000\000L\000\000\150\000\000\001\004\000\000\129\148\000\000z\134\000\000\000\000\000\000`\000\000\000\000\000\000R\000\000P\000\000\000\000\000\000P\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\148\000\000P\000\000{\136\000\000\150\000\001\b\138\000\000孀\000\000V\000\000扞\000\000\140\000\000\150\000\000z\000\000抓\000\000\140\000\000\150\000\001\007d\000\000j\000\000\129\148\000\000\148\000\000\129\148\000\000P\000\000|\138\000\000\129\148\000\000}\140\000\000\150\000\000~\142\000\000\\\000\000]B\000\000\030J\000\000\026:\000\000\000\000\000\000H\000\000\000\000\000\000R\000\000|\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000]B\000\000\027>\000\000呟\000\000]B\000\000\028B\000\000\029F\000\000\000\000\000\000\030J\000\000\000\000\030J\000\000\031N\000\000\000\000\000\000\000\000\000\000\000\000\000\000抂\000\000t\000\000\000\000\000\000\030\000\000\152\000\000\000\000\000\000 R\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0004\000\000]B\000\000!V\000\000]B\000\000\"Z\000\000]B\000\000#^\000\000\000\000\000\000$b\000\000\000\000\000\000%f\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000]B\000\000&j\000\000\000\000\000\000]B\000\000'n\000\000\150\000\000\127\144\000\000\128\146\000\000\000\000\000\000\129\148\000\000P\000\000\129\148\000\000\130\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000拈\000\000楓\000\000\000\000\000\000\156\000\000\144\000\000\000\000\000\000\131\152\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000>\000\000\150\000\000\132\154\000\000\150\000\000\133\156\000\000\150\000\000\134\158\000\000\000\000\000\000\135\000\000\000\000\000\000\136\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\150\000\000\137\000\000\000\000\000\000\150\000\000\138\000\000\150\000\000L\000\000\150\000\000\139\000\000\150\000\000\140\000\000\150\000\000\141\000\000\150\000\000\142\000\000\150\000\000\143\000\000\150\000\000\144\000\000\150\000\000\145\000\000\150\000\000\146\000\000\150\000\000\147\000\000\150\000\000\148\000\000\150\000\000\149\000\000\150\000\000\150\000\000\150\000\000\151\000\000\144\000\000\150\000\000\152\000\000\153\000\000\150\000\000\154\000\000\150\000\000\155\000\000\150\000\000\156\000\000\150\000\000\157\000\000\150\000\000\158\000\000閧\000\000]B\000\000(r\000\000]B\000\000)v\000\000]B\000\000*z\000\000]B\000\000+~\000\000]B\000\000,\130\000\000]B\000\000-\134\000\000]B\000\000.\138\000\000]B\000\000/\142\000\000]B\000\0000\146\000\000]B\000\0001\150\000\000]B\000\0002\154\000\000]B\000\0003\158\000\000]B\000\0004\000\000]B\000\0005\000\000D\000\000]B\000\0006\000\0007\000\000]B\000\0008\000\000]B\000\0009\000\000]B\000\000:\000\000]B\000\000;\000\000\026\000\000\000\000\000\000<\000\000]B\000\000=\000\000]B\000\000\142\000\000\000\000\000\000>\000\000]B\000\000?\000\000\150\000\000*\000\000@\000\000]B\000\000A\000\000B\000\000]B\000\000C\000\000D\000\001\000\"\000\000\000\000\000\000\159\000\000\150\000\000\000\000]B\000\001\000\150\000\000\000\000\000\000《\000\000\150\000\000\000\000\150\000\001\b\000\000Ｘ\000\000\150\000\000ぺ\000\000ボ\000\000\150\000\000\000\000о\000\000,\000\000\156\000\000\000\000\000\000\129\148\000\000*\000\000J\000\000北\000\000\150\000\000\002\000\000\000\000\000\000\140\000\000\000\000\000\000\000\000\000\000\000\000\000\001\007d\000\000闘\000\000塘\000\000\150\000\000L\000\000\150\000\000聊\000\000\150\000\000膊\000\000W*\000\000\000\000\000\000\000\000\000\000\140\000\000\000\000\000\000\000\000閧\000\000\150\000\000L\000\000\000\000\000\001\001\030\000\000<\000\000]B\000\000\000\000\000\000E\000\000\000\000\000\000\000\000\000\000\000\000\000\000F\000\000\000\000\000\000\000\000\000\000\000\000霊\000\000\000\000\000\000D\000\000\000\000\000\000搦\000\000\000\000\000\000G\000\000\000\000\000\000\000\000\000\000J\000\000\000\000\000\000J\000\000\000\000\000\000\000\000J\000\000\000\000\000\000\000\000\000\000\000\000\150\000\000\000\000\000\000補\000\000撓\000\000\000\000\000\000補\000\000厠\000\000\000\000\000\000補\000\000\002\000\000\000\000\000\000\000\000\000\000D\000\000\136\000\000当\000\000免\000\000\136\000\000\000\000\000\000\156\000\000n\000\000\150\000\000*\000\000\000\000\000\000補\000\000\006\000\000\000\000\000\000補\000\000|\000\000\000\000\000\000補\000\000\b\000\000\000\000\000\000\000\000\000\000薬\000\000\000\000\000\000\000\000\000\000宕\000\000\150\000\000\158\000\000v\000\000hl\000\000坎\000\000\000\000\000\000\000\000仟\000\000\000\000\000\000\148\000\000\000\000\000\000仟\000\000\000\000\000\000\030\000\000\000\000\000\000仟\000\000\000\000\000\000\000\000\000\000n\000\000T\000\001\015\000\000in\000\001\0172\000\000J\000\000\000\000\000\000\158\000\000鰐\000\000毀\000\000\000\000\000\000J\000\000\000\000\000\000\000\000\000\000J\000\000\000\000\000\001\011\152\000\000J\000\000\000\000\000\000jp\000\000\000\000\000\001\007\000\000jp\000\000\000\000\000\000Z\000\000l\000\001\007\000\000jp\000\000\000\000\000\001\007\000\000jp\000\000\000\000\000\001\007\000\000jp\000\000\000\000\000\000俐\000\001\007\000\000jp\000\000\000\000\000\001\007\000\000jp\000\000\000\000\000\000\n\000\001\007\000\000jp\000\000\000\000\000\001\007\000\000jp\000\000\000\000\000\001\007\000\000jp\000\000\000\000\000\000\000\000\000\000\\\000\000\000\000\000\000\000\000\000\000@\000\000呂\000\000\000\000\000\000\000\000\000\000j\000\000,\000\001\007\000\000\134\000\000\012\000\000\000\000\000\000\000\000\000\000扨\000\000@\000\000標\000\000\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000儻\000\000J\000\000\132\000\000J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000n\000\000\000\000\000\000悧\000\000\000\000\000\000\000\000\000\000柚\000\000D\000\0006\000\000b\000\000J\000\000\136\000\000弄\000\000弄\000\000\000\000\000\000H\000\000\000\000\000\000H\000\000\000\000\000\000嬌\000\001\011\000\000鉄\000\000\140\000\000應\000\000I\000\000\000\000\000\000I\000\000\000\000\000\000\000\000\000\000\000\001\012`\000\000\000\000\000\000\000\000I\000\000\000\000\000\001\012\000\000鉄\000\000I\000\000\000\000\000\000I\000\000\000\000\000\000\030\000\001\r6\000\000鉄\000\000I\000\000\000\000\000\000I\000\000\000\000\000\001\r\000\000鉄\000\000I\000\000\000\000\000\000I\000\000\000\000\000\001\014\014\000\000鉄\000\000I\000\000\000\000\000\000I\000\000\000\000\000\000H\000\000\000\000\000\000H\000\000\000\000\000\000J\000\000\000\000\000\000\154\000\000\000\000\000\000\154\000\000攝\000\000\000\000\000\000\132\000\000\000\000\000\000\000\000\000\000葎\000\000\000\000\000\000\004\000\000J\000\000.\000\000\000\000\000\000嚮\000\000\000\000\000\000\000\000\000\000(\000\000牟\000\000@\000\000牟\000\000v\000\000\000\000\000\000\000\000\154\000\000牟\000\000|\000\000\000\000\000\000\000\000H\000\000\000\000\000\000~\000\000\000\000\000\000\000\000|\000\000\000\000\000\000牟\000\000\128\000\001\006n\000\000z\000\000J\000\000,\000\000仟\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000|\000\000牟\000\000\140\000\001\006n\000\000H\000\000\000\000\000\000葎\000\000拔\000\000址\000\000\000\000\000\000\000\000\000\000\000\000\000\001\016N\000\001\016\146\000\000呀\000\000H\000\000\000\000\000\000\000\000\000\000\000\000\000\000J\000\000挌\000\000\000\000\000\000\000\000H\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000\000\000\000\000K\000\000M\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000n\000\000Z\000\000仟\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\0006\000\000\000\000\000\000\000\000喙\000\000^\000\000J\000\000J\000\001\016\000\000\002\000\001\007d\000\000詈\000\000Z\000\0008\000\000|\000\001\001\000\000\030\000\000F\000\000\128\000\001\001\000\000\150\000\000\000\000J\000\000l\000\000\150\000\000L\000\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000b\000\0004\000\0004\000\000\000\000\000\000掵\000\000J\000\000攝\000\000\150\000\000\000\000\000\000閧\000\000仟\000\000J\000\000洋\000\000J\000\000摶\000\000\150\000\000\000\000\000\000撓\000\000\150\000\000芋\000\000\000\000\000\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000h\000\000J\000\000\000\000\000\150\000\000鉛\000\000魔\000\000\150\000\000廻\000\000\000\000\000\000\000\000\000\000\000\000\000\000P\000\000\000\000\000\001\t\148\000\000J\000\000J\000\001\014\134\000\001\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\152\000\000B\000\000\000\000\000\000\\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\007d\000\000\024\000\000\000\000\000\000\000\000\000\000\000\000\000\000z\000\001\016\000\000\000\000\000\000\000\000\000\000^\000\000\000\000\000\000\000\000\000\000n\000\000X\000\000@\000\000牟\000\000搆\000\000\000\000$\000\000\000\000\000\000H\000\000\000\000\000\000~\000\000嘖\000\000牟\000\000摧\000\000\000\000幄\000\000\000\000\000\000牟\000\000T\000\000]B\000\000鰆\000\000\026\000\000]B\000\000j\000\000妨\000\000\024\000\000牟\000\000撩\000\001\006n\000\000\000\000\000\000^\000\000]B\000\000N\006\000\000]B\000\000龠\000\000鑚\000\0004\000\000\018\000\000J\000\000$\000\000]B\000\000\146\000\000坎\000\000J\000\000\000\000\000\000&\000\000]B\000\000&\000\000\000\000\000\000\000\000\000\000\000\000\000\000p\000\000J\000\0004\000\000]B\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000妨\000\000H\000\000\000\000\000\000*\000\000]B\000\000O\n\000\000\000\000\000\000泡\000\000J\000\000X\000\000\134\000\000\000\000\000\000H\000\000\000\000\000\000J\000\000H\000\000\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000\000\000\000\000V\000\000n\000\000\000\000\000\000\000\000\000\000\000\000\000\0002\000\000\000\000\000\000\000\000\000\001\007d\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\014\000\000\000\000\000\000\000\000\000\000猥\000\000葎\000\000面\000\000眄\000\000J\000\000r\000\000猥\000\000垪\000\000猥\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000猥\000\000\000\000\000\000l\000\000\000\000\000\000\000\000\000\000渙\000\001\004\000\000\130\000\000\000\000\000\000\004\000\000&\000\000\000\000\000\000\000\000\000\000\030\000\000學\000\000\000\000\000\000\000\000\000\000\000\000\000\001\017t\000\001\017\000\000墟\000\000\000\000\000\000\000\000\000\000l\000\000J\000\000n\000\001\004\000\000\n\000\001\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\000\001\004\000\000\000\000\000\0000\000\000J\000\000l\000\000\000\000\000\000\000\000\000\001\002D\000\000J\000\000|\000\0004\000\001\004\000\000敲\000\000\000\000\000\000>\000\000J\000\000r\000\000\000\000\000\000D\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000\000\000\000\000\030\000\000D\000\000\000\000\000\000\000\000\000\000\000\000\000\000國\000\000当\000\000\136\000\000桀\000\000\000\000\000\001\020\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000補\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000`\000\000\000\000\000\000\138\000\000\004\000\000\000\000匹\000\000\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\144\000\000J\000\000@\000\000\000\000\000\000\000\000\000\000\000\000曁\000\000p\000\000暼\000\000h\000\000\002\b\000\000T\000\000\000\000\000\000`\000\000\000\000\000\000\000\002\b\000\000姜\000\000\000\000\000\001\001\000\000\002\b\000\000(\000\000\000\000\000\000墺\000\000暼\000\000Z\000\000蹂\000\000\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000宕\000\000嗹\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000*\000\000補\000\000v\000\000虹\000\000tz\000\000釜\000\000\000\000\000\000劍\000\000仟\000\000缶\000\000補\000\000\000\000\000\000\000\000\000\000\000\000\000\000砧\000\000尨\000\000\004\000\000\000\000l\000\000J\000\000\000\000\000\000J\000\000\000\000\000\000\022\000\000\n\000\000.\000\000\002\b\000\000\024\000\0000\000\000\002\b\000\000羮\000\000X\000\000尨\000\000\000\000\000\000\000\000\000\000補\000\000\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0006\000\000<\000\000J\000\000\000\000\000\000\000\000柚\000\000D\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\154\000\000x\000\000P\014\000\000Q\018\000\000\000\000\000\000\000\000\000\000P\014\000\000\030\000\000\000\000\000\000h\000\000H\000\000\000\000\000\000\000\000\000\000焙\000\000國\000\000H\000\000\000\000\000\000\000\000\000\000z\000\000\154\000\000H\000\000\000\000\000\000\000\000\000\000緘\000\000\154\000\000H\000\000\000\000\000\000\000\000\000\000R\022\000\001\007d\000\000r\000\000J\000\000x\000\000]B\000\000S\026\000\000姜\000\000]B\000\000T\030\000\000H\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000D\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000\000\000\000\000O\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000柚\000\000D\000\000\016\000\000\000\000\000\000補\000\000砧\000\000\000\000\000\0006\000\000h\000\000J\000\000\142\000\000勿\000\000勿\000\000\000\000\000\000\000\000\000\000\000\000幵\000\000\000\000jp\000\000\000\000\000\000\000\000jp\000\000\000\000\000\000$\000\000\000\000jp\000\000\000\000\000\000\000\000jp\000\000\000\000\000\000\000\000jp\000\000\000\000\000\000\000\000\000\000\000\000r\000\000\154\000\000暉\000\000\000\000\000\000d\000\000\130\000\000~\000\000\000\000\000\000\000\000暘\000\000\000\000\000\000\132\000\001\004\000\000\000\000\000\000\000\000\000\000\000\000:\000\000v\000\000\000\000\000\000\000\000\000\000\000\000\000\000\022\000\000\\\000\000忖\000\000\134\000\000補\000\000楼\000\000\\\000\000補\000\000N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\\000\000\000\000\000\000tz\000\000釜\000\000\000\000\000\000\000\000\000\000\000\000b\000\000\138\000\000補\000\000,\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000壓\000\000弸\000\000\000\000\000\000n\000\000\000\000\000\000\000\000\000\000\000\000n\000\000b\000\000\000\000\000\000\000\000\000\000\000\000崑\000\000\154\000\000\000\000\000\000\000\000\000\000\000\000廴\000\000\154\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Z\000\000\000\000\000\000\000\000\000\0006\000\000擴\000\000補\000\000~\000\000N\000\000\136\000\000渣\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\142\000\000\136\000\000酊\000\000補\000\000歴\000\000\136\000\001\006\132\000\000砧\000\000\000\000\000\000\000\000\000\000\000\000\000\000國\000\000H\000\000\000\000\000\000H\000\000\000\000\000\000D\000\000\000\000\000\000F\000\000\000\000\000\000\000\000\000\000:\000\000\028\000\000\000\000\000\000編\000\000幵\000\000\144\000\000幵\000\000\000\000\000\000\000\000\000\000\000\000\000\000舉\000\000彎\000\000\000\000\000\000v\000\000\000\000\000\000\000\000\000\000,\000\000\000\000\000\000\000\000\000\000\156\000\000補\000\000^\000\000旙\000\000宕\000\000\156\000\000喟\000\000\000\000\000\000\000\000\000\000U\"\000\000\000\000\000\000h\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000宕\000\000@\000\000\000\000\000\000\000\000\000\000嫋\000\000\000\000\000\000咢\000\000L\000\000\002\000\000躍\000\000\n\000\000\000\000\000\000p\000\000\000\000\000\000敲\000\000\150\000\000\000\000\000\000\146\000\000\000\000\000\0002\000\000\000\000\000\000\150\000\000\000\000\000\000V&\000\000\000\000\000\000\000\000\000\000]B\000\000\000\000\000\000侮\000\000\002\000\000\000\000\000\000H\000\000\000\000\000\000\000\000\000\000應\000\000\150\000\000v\000\000\000\000\000\000物\000\000枉\000\000\000\000\000\000x\000\000\000\000\000\000\000\000\000\000鋲\000\000房\000\000廨\000\000\000\000\000\000\000\000\000\000\132\000\000\000\000\000\000\150\000\000旆\000\000J\000\000\000\000\000\000X\000\000|\000\000\000\000\000\000\006\000\000]B\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000旒\000\000J\000\000\000\000\000\000\012\000\000]B\000\000b\000\000猥\000\000J\000\000\130\000\000]B\000\000瓲\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000.\000\000\150\000\000閧\000\000]B\000\000|\000\000]B\000\000R\000\000W*\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000X.\000\001\002\000\000\000\000\000\000]B\000\001\003F\000\000\000\000\000\000\150\000\001\t\000\000\000\000\000\000\000\000\000\000Y2\000\000\144\000\000\000\000\000\000\146\000\000\000\000\000\000\146\000\000\000\000\000\000*\000\0000\000\000\000\000\000\000\154\000\000\000\000\000\000彳\000\000\000\000\000\000Z6\000\000\000\000\000\000\000\000\000\000]B\000\000侮\000\000\148\000\000\000\000\000\000\000\000\000\000N\000\000\150\000\000\154\000\000\000\000\000\000T\000\000~\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000鋲\000\000房\000\000\030\000\000\000\000\000\000\000\000\000\000\n\000\000\000\000\000\000T\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\0004\000\000\002\000\000J\000\000\020\000\000]B\000\000\000\000\000\000,\000\000怱\000\000J\000\000\028\000\000]B\000\000\000\000\000\000\030\000\000]B\000\000[:\000\000\000\000\000\000p\000\000\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000\150\000\000\030\000\000L\000\000\000\000]B\000\000\000\000\000\000\000\000.\000\000里\000\000\000\000\000\000朞\000\000\000\000\000\000\000\000\000\000\b\000\000里\000\000\000\000\000\000\000\000\000\000X\000\000\000\000\000\000\000\000\000\000j\000\000\000\000\000\000\000\000\000\000悧\000\000\000\000\000\000\000\000\000\000\154\000\000虹\000\000tz\000\000釜\000\000枉\000\000]B\000\000\000\000\000\000桙\000\000\134\000\000L\000\0006\000\000補\000\000楼\000\000L\000\000嫋\000\000\000\000\000\000\000\000\000\000\000\000枡\000\000]B\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\>\000\000]B\000\000\000\000\000\000]B\000\000\000\000\000\000O\n\000\000^F\000\000]B\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000P\000\000L\000\000\130\000\000補\000\000\"\000\000L\000\000F\000\000\000\000\000\000\000\000\000\000_J\000\000両\000\000`N\000\000應\000\000\000\000\000\000\000\000\000\001\003\000\000\000\000\000\000]B\000\001\004N\000\000\000\000\000\000\150\000\001\nl\000\000\000\000\000\000\000\000\000\000\000\000\000W*\000\000f\000\000\150\000\000\150\000\000\150\000\000\018\000\000\000\000\000\000\000\000\000\000曩\000\000虹\000\000tz\000\000釜\000\000柢\000\000\150\000\000\000\000\000\000椈\000\000\134\000\000\000\000框\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000\148\000\000\150\000\000\000\000\000\000\150\000\000\000\000\000\000\152\000\000\154\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\150\000\000\000\000\000\000僊\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000侮\000\000\024\000\000\000\000\000\000\000\000\000\000F\000\000\150\000\000\030\000\000柆\000\000\000\000\000\000\014\000\000\000\000\000\000\000\000\000\000\"\000\000\000\000\000\000\000\000\000\0006\000\000\000\000\000\000\000\000\000\000L\000\000\000\000\000\000\000\000\000\0002\000\000\014\000\000\000\000\000\000W*\000\000悳\000\000\000\000\000\000\000\000\000\000怱\000\000\000\000\000\000R\000\000朞\000\000\000\000\000\000\000\000\000\000\000\000垳\000\000\000\000\000\000婉\000\000\000\000\000\000\016\000\000\000\000\000\000蔕\000\000aR\000\000\000\000\000\000\000\000\000\000梵\000\000\000\000\000\000\000\000\000\000梍\000\000\000\000\000\000\000\000\000\000bV\000\000\000\000cZ\000\000\000\000\000\000\000\000\000\000\012\000\000\b\000\000\000\000\000\000椢\000\000枷\000\001\007d\000\000d\000\001\005\150\000\000\128\000\000\000\000\000\000\000\000\000\000,\000\000\150\000\000L\000\000椢\000\000\000\000\000\000N\000\000\000\000\000\000z\000\000\000\000\000\000>\000\000\000\000\000\000粮\000\000\000\000\000\000\026\000\000\000\000\000\000弩\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\000枹\000\000\150\000\001\b\000\000\150\000\000閧\000\000\000\000\000\000\018\000\000\000\000\000\000\n\000\000\000\000\000\000d^\000\000\000\000\000\000\000\000\000\000\156\000\000\000\000\000\000\000\000\000\000\000\000房\000\000(\000\000\000\000\000\000\000\000\000\000P\000\000\158\000\000\000\000\000\000柆\000\000\000\000\000\000eb\000\000\000\000\000\000侮\000\000戌\000\000\000\000\000\000\000\000\000\000檜\000\000\000\000\000\000t\000\000\000\000\000\000N\000\000\000\000\000\000\024\000\000W*\000\000\\\000\000\000\000\000\000\020\000\000\000\000\000\000\136\000\000b\000\000jp\000\000\000\000\000\000慍\000\000\000\000\000\000蓉\000\000\000\000\000\000*\000\000\000\000\000\000標\000\000\"\000\000\000\000\000\000$\000\000\128\000\000\000\000\000\000@\000\000\000\000\000\000h\000\000$\000\000慚\000\000\000\000\000\000 \000\000\000\000\000\000\138\000\000\000\000\000\000tz\000\000憔\000\000\000\000\000\0008\000\000\156\000\000J\000\000\000\000J\000\000植\000\000\000\000\000\000\000\000\000\000x\000\0008\000\000\000\000\000\000躙\000\000補\000\0000\000\000\000\000\000\0002\000\000\000\000\000\001\015\140\000\000\000\000\000\000\000\000J\000\000I\000\000\000\000\000\001\011\000\000I\000\000\000\000\000\000R\000\001\000\000\001\011\000\000I\000\000\000\000\000\001\011\000\000I\000\000\000\000\000\001\011\000\000I\000\000\000\000\000\000P\000\001\011\000\000I\000\000\000\000\000\001\011\000\000I\000\000\000\000\000\0002\000\001\011\000\000I\000\000\000\000\000\001\011\000\000I\000\000\000\000\000\001\011\000\000I\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000箴\000\000&\000\000\000\000\000\000\000\000\000\000\012\000\000剖\000\001\011\000\000俘\000\0008\000\000\000\000\000\000\000\000\000\000栲\000\000@\000\000標\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000驀\000\000P\014\000\000溥\000\000H\000\000\000\000\000\0000\000\000\028\000\000編\000\000嬌\000\000ff\000\000嬌\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000H\000\000\000\000\000\000\016\000\000\000\000\000\000\142\000\000\000\000\000\000\129\148\000\000\142\000\000\000\000\000\000\000\000\000\000\000\000\000\000葡\000\000\128\000\000\000\000\000\000W*\000\000R\000\000\000\000\000\000世\000\000\152\000\000gj\000\000D\000\000\000\000\000\000\000\000\000\000杣\000\000\000\000\000\000\000\000\000\000\150\000\000X\000\000\150\000\000\000\000\000\000枩\000\000\000\000\000\000\000\000\000\000J\000\000\000\000\000\000杪\000\000\000\000\000\000\150\000\000\000\000\000\000\150\000\000\000\000\000\001\007d\000\000闘\000\000\000\000\000\000\000\000\000\000\144\000\000hl\000\000坎\000\000R\000\000\028\000\000編\000\000徭\000\001\018F\000\000X\000\000\132\000\000N\000\000jp\000\000\000\000\000\001\018\146\000\000X\000\000jp\000\000\000\000\000\000f\000\001\019\024\000\000X\000\000jp\000\000\000\000\000\001\019d\000\000X\000\000jp\000\000\000\000\000\001\019\000\000X\000\000jp\000\000\000\000\000\000薦\000\000徭\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000仟\000\000楓\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\156\000\000b\000\000kh\000\000仟\000\000\154\000\000補\000\000砧\000\000\000\000\000\000\000\000\000\000\002\000\000L\000\000\144\000\000\000\000\000\0006\000\000朧\000\000J\000\000檜\000\000勿\000\000\000\000\000\000\000\000徭\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000r\000\000:\000\000\000\000\000\000@\000\000T\000\000J\000\000R\000\000\000\000\000\000\000\000\000\000猥\000\000恃\000\000\000\000\000\000\000\000\000\001\016\000\000V\000\000\000\000\000\000\000\000\000\000P\000\000\000\000\000\001\n\000\000T\000\000\158\000\001\014\000\001\0206\000\000\000\000\000\000\000\000\000\000\000\000\000\000P\000\000蝴\000\000\000\000\000\000r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\148\000\001\004\000\000桙\000\000T\000\000l\000\000\000\000\000\000\000\000\000\001\004\000\000T\000\000|\000\0004\000\000梟\000\000T\000\000畋\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\130\000\000\000\000\000\000\000\000\000\000\140\000\000\000\000\000\000\000\000\000\000\000\000\000\000|\000\000\134\000\000\000\000\000\000|\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000役\000\000J\000\000|\000\000\000\000\000\000\000\000\000\000\000\000\134\000\000\152\000\000\154\000\000\000\000\000\000\000\000\000\000\000\000\146\000\000\144\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\152\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000N\000\000\000\000\000\000\000\000\000\000懆\000\000N\000\000\000\000\000\000\002\000\000N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"), (16, "\n\137\n\137\n\137\n\137\n\137\n\137\001J\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\001N\n\137\n\137\n\137\n\137\n\137\n\137\001^\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\001n\001~\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\tE\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\007y\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\0025\0025\0025\0025\0025\0025\001\001\130\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\001\0025\0025\0025\0025\0025\0025\001\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\001\0025\003\130\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\003\"\003\004\0025\0025\0025\0025\004\0025\005\n\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\002=\002=\002=\002=\002=\002=\001\001\130\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\001\002=\002=\002=\002=\002=\002=\001\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\001\002=\003\130\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\003\"\003\004\002=\002=\002=\002=\004\002=\005\n\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\146\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\006\134\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\b\146\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\006\134\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\006\158\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\007y\r\r\r\r\r\r\r\r\r\r\r\r\007\157\r\r\r\r\007\157\r\r\r\r\r\r\r\r\r\r\r\r\r\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\bn\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004e\004e\004e\004e\004e\004e\003z\000B\004e\004e\002\146\004e\004e\004e\004e\004e\002\004e\004e\004e\004e\003~\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\007j\004e\004e\004e\004e\004e\004e\004e\004e\002\004e\004e\004e\004e\007n\b\026\004e\002\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\003\"\004e\004e\007\004e\004e\004e\007\004e\007\004e\b\030\b\"\b&\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\bF\bJ\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\bR\004e\004e\004e\004e\004e\bV\004e\004e\004e\004e\004e\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\b\146\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\004a\004a\004a\004a\004a\004a\003z\000B\004a\004a\002\146\004a\004a\004a\004a\004a\002\004a\004a\004a\004a\003~\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\007j\004a\004a\004a\004a\004a\004a\004a\004a\002\004a\004a\004a\004a\007n\b\026\004a\002\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\003\"\004a\004a\007\004a\004a\004a\007\004a\007\004a\b\030\b\"\b&\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\bF\bJ\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\bR\004a\004a\004a\004a\004a\bV\004a\004a\004a\004a\004a\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\005\146\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\b\n\n\n\n\n\n\n\n\n\n\b\n\n\n\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\t&\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\nJ\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\nN\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\nR\002\133\002\133\002\133\002\133\002\133\tF\002\133\002\133\002\133\002\133\002\133\002\133\002\133\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nj\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nz\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nj\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n\138\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\n\142\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\n\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\n\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\n\002\133\002\133\002\133\002\133\002\133\tF\002\133\002\133\002\133\002\133\002\133\002\133\002\133\n\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\n\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\002\137\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\t&\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\n\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011\011\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\011\011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\011\0011\0011\0011\011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\011\011\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\011\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\012.\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\011\011\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\011\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\011\011\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\r\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\0031\0031\0031\0031\0031\0031\0031\000B\0031\0031\002\146\0031\0031\0031\0031\0031\002\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\002\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\002\002\0031\0031\0031\0031\0031\002\0031\002\0031\0031\0031\0031\0031\000N\0031\0031\0031\0031\003\"\006\0031\006\0031\0031\0031\006\007&\007J\0031\b\030\b\"\b&\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\bF\bJ\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\bR\0031\0031\0031\0031\011\158\bV\0031\0031\0031\0031\0031\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\011\011\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\011\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001\005\001\005\001\005\001\005\001\005\001\005\001\005\000B\001\005\001\005\002\146\001\005\001\005\001\005\001\005\001\005\002\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\002\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\002\002\001\005\001\005\001\005\001\005\001\005\002\r\002\001\005\001\005\001\005\001\005\001\005\000N\002\001\005\001\005\001\005\003\"\006\001\005\006\001\005\001\005\001\005\006\007&\007J\001\005\b\030\b\"\b&\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\bF\bJ\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\r\r\001\005\001\005\bR\001\005\001\005\001\005\001\005\011\158\bV\001\005\001\005\001\005\001\005\001\005\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\011\011\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\011\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\001\t\001\t\001\t\001\t\001\t\001\t\001\t\000B\001\t\001\t\002\146\001\t\001\t\001\t\001\t\001\t\002\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\002\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\002\002\001\t\001\t\001\t\001\t\001\t\002\r\002\001\t\001\t\001\t\001\t\001\t\000N\002\001\t\001\t\001\t\003\"\006\001\t\006\001\t\001\t\001\t\006\007&\007J\001\t\b\030\b\"\b&\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\bF\bJ\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\r\r\001\t\001\t\bR\001\t\001\t\001\t\001\t\011\158\bV\001\t\001\t\001\t\001\t\001\t\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014*\014f\001\001\001\001\001\001\001\001\001\001\014n\001\001\001\015\015\015\015\015\001\001\001\001\001\001\001\001\001\001\015\016\002\001\001\001\001\001\001\001\001\001\001\016\n\016\"\001\001\001\001\001\001\001\005\146\001\001\001\001\001\001\001\001\001\0142\015\016\018\016\026\016*\001\001\001\001\0162\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016Z\001\001\001\001\001\001\001\016B\001\001\001\001\001\001\016J\016R\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\005\146\001i\001i\001i\001i\001i\001i\001i\001i\001i\0142\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\005\146\001U\001U\001U\001U\001U\001U\001U\001U\001U\0142\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\003-\003-\003-\003-\003-\003-\003-\000B\003-\003-\002\146\003-\003-\003-\003-\003-\002\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\002\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\002\002\003-\003-\003-\003-\003-\002\003-\002\003-\003-\003-\003-\003-\000N\003-\003-\003-\003-\003\"\006\003-\006\003-\003-\003-\006\007&\007J\003-\b\030\b\"\b&\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\bF\bJ\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\bR\003-\003-\003-\003-\011\158\bV\003-\003-\003-\003-\003-\004I\004I\004I\004I\004I\004I\004I\000B\004I\004I\002\146\004I\004I\004I\004I\004I\002\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\002\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\002\002\004I\004I\004I\004I\004I\002\004I\002\004I\004I\004I\004I\004I\000N\002\004I\004I\004I\003\"\006\004I\006\004I\004I\004I\006\007&\007J\004I\b\030\b\"\b&\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\bF\bJ\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\bR\004I\004I\004I\004I\011\158\bV\004I\004I\004I\004I\004I\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\005\146\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\005\146\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\0142\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014*\014f\001\001\001\001\001\001\001\001\001\001\014n\001\001\001\015\015\015\015\015\001\001\001\001\001\001\001\001\001\001\015\016\002\001\001\001\001\001\001\001\001\001\001\016\n\016\"\001\001\001\001\001\001\001\005\146\001\001\001\001\001\001\001\001\001\0142\015\016\018\016\026\016*\001\001\001\001\0162\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016Z\001\001\001\001\001\001\001\016B\001\001\001\001\001\001\016J\016R\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\014*\014f\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\015\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\005\146\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\0142\015\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\005\146\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\0142\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\005\146\001M\001M\001M\001M\001M\001M\001M\001M\001M\0142\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\014*\014f\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\015\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\005\146\001]\001]\001]\001]\001]\001]\001]\001]\001]\0142\015\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\014*\014f\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\015\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\005\146\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\0142\015\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\014*\014f\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015\015\015\015\015\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015\016\002\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\016\n\016\"\001u\001u\001u\001u\001u\001u\001u\005\146\001u\001u\001u\001u\001u\001u\001u\001u\001u\0142\015\016\018\016\026\016*\001u\001u\001u\001u\0162\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\016B\001u\001u\001u\001u\001u\001u\016J\016R\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\014*\014f\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\015\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\005\146\001e\001e\001e\001e\001e\001e\001e\001e\001e\0142\015\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\014*\014f\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\015\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\005\146\001a\001a\001a\001a\001a\001a\001a\001a\001a\0142\015\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\014*\014f\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\015\015\015\015\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\015\016\002\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\005\146\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\0142\015\016\018\016\026\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\014*\014f\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\015\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\005\146\001I\001I\001I\001I\001I\001I\001I\001I\001I\0142\015\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\014*\014f\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\015\015\015\015\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\015\016\002\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\005\146\001E\001E\001E\001E\001E\001E\001E\001E\001E\0142\015\016\018\016\026\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\014*\014f\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015\015\015\015\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015\016\002\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\016\n\001m\001m\001m\001m\001m\001m\001m\001m\005\146\001m\001m\001m\001m\001m\001m\001m\001m\001m\0142\015\016\018\016\026\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\014*\014f\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015\015\015\015\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015\016\002\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\016\n\001A\001A\001A\001A\001A\001A\001A\001A\005\146\001A\001A\001A\001A\001A\001A\001A\001A\001A\0142\015\016\018\016\026\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\014*\014f\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015\015\015\015\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015\016\002\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\016\n\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\005\146\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\0142\015\016\018\016\026\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\014*\014f\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015\015\015\015\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015\016\002\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\016\n\001q\001q\001q\001q\001q\001q\001q\001q\005\146\001q\001q\001q\001q\001q\001q\001q\001q\001q\0142\015\016\018\016\026\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\014*\014f\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015\015\015\015\015\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015\016\002\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\016\n\016\"\001y\001y\001y\001y\001y\001y\001y\005\146\001y\001y\001y\001y\001y\001y\001y\001y\001y\0142\015\016\018\016\026\016*\001y\001y\001y\001y\0162\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\016B\001y\001y\001y\001y\001y\001y\016J\016R\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\014*\014f\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015\015\015\015\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015\016\002\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\016\n\016\"\001}\001}\001}\001}\001}\001}\001}\005\146\001}\001}\001}\001}\001}\001}\001}\001}\001}\0142\015\016\018\016\026\016*\001}\001}\001}\001}\0162\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\016J\016R\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\014*\014f\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015\015\015\015\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015\016\002\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\016\n\016\"\001\129\001\129\001\129\001\129\001\129\001\129\001\129\005\146\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\0142\015\016\018\016\026\016*\001\129\001\129\001\129\001\129\0162\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\016J\016R\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\014*\014f\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\014n\001\133\001\133\001\133\015\015\015\015\015\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015\016\002\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\016\n\016\"\001\133\001\133\001\133\001\133\001\133\001\133\001\133\005\146\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\0142\015\016\018\016\026\016*\001\133\001\133\001\133\001\133\0162\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\016Z\001\133\001\133\001\133\001\133\001\133\001\133\001\133\016B\001\133\001\133\001\133\001\133\001\133\001\133\016J\016R\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\016n\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014*\014f\001\001\001\001\001\001\001\001\001\001\014n\001\001\001\015\015\015\015\015\001\001\001\001\001\001\001\001\001\001\015\016\002\001\001\001\001\001\001\001\001\001\001\016\n\016\"\001\001\001\001\001\001\001\005\146\001\001\001\001\001\001\001\001\001\0142\015\016\018\016\026\016*\001\001\001\001\0162\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016Z\001\001\001\001\001\001\001\016B\001\001\001\001\001\001\016J\016R\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\016\134\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014*\014f\001\001\001\001\001\001\001\001\001\001\014n\001\001\001\015\015\015\015\015\001\001\001\001\001\001\001\001\001\001\015\016\002\001\001\001\001\001\001\001\001\001\001\016\n\016\"\001\001\001\001\001\001\001\005\146\001\001\001\001\001\001\001\001\001\0142\015\016\018\016\026\016*\001\001\001\001\0162\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016Z\001\001\001\001\001\001\001\016B\001\001\001\001\001\001\016J\016R\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\016\154\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014*\014f\001\001\001\001\001\001\001\001\001\001\014n\001\001\001\015\015\015\015\015\001\001\001\001\001\001\001\001\001\001\015\016\002\001\001\001\001\001\001\001\001\001\001\016\n\016\"\001\001\001\001\001\001\001\005\146\001\001\001\001\001\001\001\001\001\0142\015\016\018\016\026\016*\001\001\001\001\0162\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016Z\001\001\001\001\001\001\001\016B\001\001\001\001\001\001\016J\016R\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\016\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014*\014f\001\001\001\001\001\001\001\001\001\001\014n\001\001\001\015\015\015\015\015\001\001\001\001\001\001\001\001\001\001\015\016\002\001\001\001\001\001\001\001\001\001\001\016\n\016\"\001\001\001\001\001\001\001\005\146\001\001\001\001\001\001\001\001\001\0142\015\016\018\016\026\016*\001\001\001\001\0162\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\016Z\001\001\001\001\001\001\001\016B\001\001\001\001\001\001\016J\016R\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\005\146\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\014*\014f\006\006\006\006\006\006\006\006\006\006\014n\006\006\006\015\015\015\015\015\006\006\006\006\006\006\006\006\006\006\015\016\002\006\006\006\006\006\006\006\006\006\006\016\n\016\"\006\006\006\006\006\006\006\005\146\006\006\006\006\006\006\006\006\006\0142\015\016\018\016\026\016*\006\006\006\006\0162\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\154\016Z\006\006\017\006\006\006\006\016B\006\006\006\006\006\006\016J\016R\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\017\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\017\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\014*\014f\006\006\006\006\006\017\006\006\006\006\014n\006\006\006\015\015\015\015\015\006\006\006\006\006\006\006\006\006\006\015\016\002\006\006\006\006\006\006\006\006\006\006\016\n\016\"\006\006\006\006\006\006\006\005\146\006\006\006\006\006\006\006\006\006\0142\015\016\018\016\026\016*\006\006\006\006\0162\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\016Z\006\006\017\006\006\006\006\016B\006\006\006\006\006\006\016J\016R\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\006\134\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005\146\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\r\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\r\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\0021\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\022~\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\nm\nm\nm\nm\nm\021\130\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\021\022\006\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\011\138\nm\nm\nm\nm\011\146\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\022\030\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\022R\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\014*\014f\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\014n\006e\006e\006e\015\015\015\015\015\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\015\016\002\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\016\n\016\"\006e\006e\006e\006e\006e\006e\006e\005\146\006e\006e\006e\006e\006e\006e\006e\006e\006e\0142\015\016\018\016\026\016*\006e\006e\006e\006e\0162\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\016Z\006e\006e\006e\006e\006e\006e\006e\016B\006e\006e\006e\006e\006e\006e\016J\016R\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\014*\014f\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\014n\011\r\011\r\011\r\015\015\015\015\015\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\015\016\002\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\016\n\016\"\011\r\011\r\011\r\011\r\011\r\011\r\006\134\005\146\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\0142\015\016\018\016\026\016*\011\r\011\r\011\r\011\r\0162\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\016Z\011\r\011\r\011\r\011\r\011\r\011\r\011\r\016B\011\r\011\r\011\r\011\r\011\r\011\r\016J\016R\n\137\n\137\n\137\n\137\n\137\n\137\001J\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\001N\n\137\n\137\n\137\n\137\n\137\n\137\001^\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\001n\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\141\n\141\n\141\n\141\n\141\n\141\001J\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\001N\n\141\n\141\n\141\n\141\n\141\n\141\001^\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\001n\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\029\158\004\004\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\014*\014f\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\014n\b=\b=\b=\015\015\015\015\015\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\015\016\002\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\016\n\016\"\b=\b=\b=\b=\b=\b=\b=\005\146\b=\b=\b=\b=\b=\b=\b=\b=\b=\0142\015\016\018\016\026\016*\b=\b=\b=\b=\0162\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\016Z\b=\b=\b=\b=\b=\b=\b=\016B\b=\b=\b=\b=\b=\b=\016J\016R\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\014*\014f\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\014n\b9\b9\b9\015\015\015\015\015\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\015\016\002\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\016\n\016\"\b9\b9\b9\b9\b9\b9\b9\005\146\b9\b9\b9\b9\b9\b9\b9\b9\b9\0142\015\016\018\016\026\016*\b9\b9\b9\b9\0162\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\016Z\b9\b9\b9\b9\b9\b9\b9\016B\b9\b9\b9\b9\b9\b9\016J\016R\011\r\011\r\011\r\011\r\011\r\011\r\011\r\000B\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\018N\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\003\"\011\r\011\r\011\r\011\r\006\134\005\146\011\r\011\r\0182\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r!.\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\014*\014f\006\006\006\006\006!2\006\006\006\006\014n\006\006\006\015\015\015\015\015\006\006\006\006\006\006\006\006\006\006\015\016\002\006\006\006\006\006\006\006\006\006\006\016\n\016\"\006\006\006\006\006\006\006\005\146\006\006\006\006\006\006\006\006\006\0142\015\016\018\016\026\016*\006\006\006\006\0162\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\016Z\006\006\017\006\006\006\006\016B\006\006\006\006\006\006\016J\016R\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001\021\017:\001\021\001\021\001\021\001\021\001\021\001\021\001\021\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\014*\014f\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015\015\015\015\015\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015\016\002\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\016\n\016\"\001-\001-\001-\001-\001-\001-\001-\005\146\001-\001-\001-\001-\001-\001-\001-\001-\001-\0142\015\016\018\016\026\016*\001-\001-\001-\001-\0162\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\016B\001-\001-\001-\001-\001-\001-\016J\016R\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\011\011\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\011\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\"\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\014*\014f\006\006\006\006\006\"\006\006\006\006\014n\006\006\006\015\015\015\015\015\006\006\006\006\006\006\006\006\006\006\015\016\002\006\006\006\006\006\006\006\006\006\006\016\n\016\"\006\006\006\006\006\006\006\005\146\006\006\006\006\006\006\006\006\006\0142\015\016\018\016\026\016*\006\006\006\006\0162\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\016Z\006\006\017\006\006\006\006\016B\006\006\006\006\006\006\016J\016R\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\014*\014f\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\014n\b)\b)\b)\015\015\015\015\015\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\015\016\002\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\016\n\016\"\b)\b)\b)\b)\b)\b)\b)\005\146\b)\b)\b)\b)\b)\b)\b)\b)\b)\0142\015\016\018\016\026\016*\b)\b)\b)\b)\0162\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\016Z\b)\b)\b)\b)\b)\b)\b)\016B\b)\b)\b)\b)\b)\b)\016J\016R\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni$>\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\029\158\ni\ni\nm\nm\000\n\nm\nm\nm\nm\000B\nm\000F\002\146\nm\nm\nm\002\150\nm\002\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\002\nm\002\002\005\154\nm\nm\nq\nm\nm\nm\002\002\nm\007N\nm\002\002\002\nm\003\030\007V\nm\nm\nm\nm\000N\002\nm\nm\nm\003\"\006\nm\006\nm\nm\nm\006\007&\007J\011\154\b\030\b\"\b&\nm\nm\nm\nm\nm\nm\nm\nm\nm\011\nm\nm\nm\nm\011\012\002\bF\bJ\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\bR\nm\nm\nm\nm\011\158\bV\r\134\nm\nm\nm\nm\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni$V\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005$\154\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\007\r\r\r\r\007\r\r\r\r\r\r\r\r\r\r\r\r\r\011\r\027n\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\006\134\005\146\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\028\018\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nj\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\nj\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000'\014\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\014*\014f\006\006\006\006\006'\018\006\006\006\006\014n\006\006\006\015\015\015\015\015\006\006\006\006\006\006\006\006\006\006\015\016\002\006\006\006\006\006\006\006\006\006\006\016\n\016\"\006\006\006\006\006\006\006\005\146\006\006\006\006\006\006\006\006\006\0142\015\016\018\016\026\016*\006\006\006\006\0162\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\016Z\006\006\017\006\006\006\006\016B\006\006\006\006\006\006\016J\016R\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011\011\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\006\134\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r)b\011\r\011\r\011\r\011\r\011\r\011\r\011\r\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\011\011\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\011\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\001>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\0025\0025\0025\0025\0025\001\001\130\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\001\0025\0025\0025\0025\0025\0025\002\002\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\002\018\0025\002N\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\000^\002R\002^\0025\0025\0025\0025\002j\0025\002n\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\0025\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\002\138\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\ny\ny\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\ny\005U\005U\005U\005U\005U\005U\ny\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\004>\005U\005U\005U\005U\005U\005U\005U\005U\005U\ny\ny\ny\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\ny\ny\ny\005U\005U\005U\002\138\ny\005U\ny\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\ny\005U\002=\002=\002=\002=\002=\001\001\130\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\001\002=\002=\002=\002=\002=\002=\002\002\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002\018\002=\002N\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\000^\002R\002^\002=\002=\002=\002=\002j\002=\002n\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\002=\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\154\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\002\138\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\005U\004\005U\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\007\022\011b\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\007\030\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\007\030\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\t\158\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004Y\004e\004e\004e\004e\004e\003.\000\014\004e\004e\000\018\004e\004e\004e\004e\004e\000\022\004e\004e\004e\004e\0032\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\003F\004e\004e\004e\004e\004e\004e\004e\004e\000:\004e\004e\004e\004e\003^\tv\004e\000J\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\000^\004e\004e\007f\004e\004e\004e\t\026\004e\tb\004e\006\006\006\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\006\006\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\004e\007\002\004e\004e\004e\004e\004e\003\004e\004e\004e\004e\004e\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\006\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\004a\004a\004a\004a\004a\003.\000\014\004a\004a\000\018\004a\004a\004a\004a\004a\000\022\004a\004a\004a\004a\0032\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\003F\004a\004a\004a\004a\004a\004a\004a\004a\000:\004a\004a\004a\004a\003^\tv\004a\000J\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\000^\004a\004a\007f\004a\004a\004a\t\026\004a\tb\004a\006\006\006\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\006\006\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\004a\007\002\004a\004a\004a\004a\004a\003\004a\004a\004a\004a\004a\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\002\138\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\002\n\n\n\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\002\133\n\"\002\133\002\133\002\133\002\133\002\133\n*\002\133\002\133\002\133\002\133\002\133\002\133\002\133\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\011v\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\005\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\007\022\011b\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\007\030\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\007\022\011b\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\r&\0011\0011\0011\007\030\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0011\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\007\022\011b\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\007\030\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\0019\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\007\022\011b\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\007\030\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\007\022\011b\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\r~\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\0031\0031\0031\0031\0031\0031\000\014\0031\0031\000\018\0031\0031\0031\0031\0031\000\022\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\000\026\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\000\030\000:\0031\0031\0031\0031\0031\000>\0031\000J\0031\0031\0031\0031\0031\000N\0031\0031\0031\0031\000^\002\154\0031\002\0031\0031\0031\002\002\006\0031\006\006\006\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\006\006\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\0031\007\002\0031\0031\0031\0031\007\006\003\0031\0031\0031\0031\0031\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\007\022\011b\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\007\030\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001\005\001\005\001\005\001\005\001\005\001\005\000\014\001\005\001\005\000\018\001\005\001\005\001\005\001\005\001\005\000\022\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\000\026\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\000\030\000:\001\005\001\005\001\005\001\005\001\005\000>\014\130\000J\001\005\001\005\001\005\001\005\001\005\000N\000Z\001\005\001\005\001\005\000^\002\154\001\005\002\001\005\001\005\001\005\002\002\006\001\005\006\006\006\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\006\006\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\001\005\014\150\014\154\001\005\001\005\007\002\001\005\001\005\001\005\001\005\007\006\003\001\005\001\005\001\005\001\005\001\005\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\007\022\011b\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\007\030\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\b\029\001\t\001\t\001\t\001\t\001\t\001\t\000\014\001\t\001\t\000\018\001\t\001\t\001\t\001\t\001\t\000\022\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\000\026\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\000\030\000:\001\t\001\t\001\t\001\t\001\t\000>\014\130\000J\001\t\001\t\001\t\001\t\001\t\000N\000Z\001\t\001\t\001\t\000^\002\154\001\t\002\001\t\001\t\001\t\002\002\006\001\t\006\006\006\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\006\006\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\001\t\014\150\014\154\001\t\001\t\007\002\001\t\001\t\001\t\001\t\007\006\003\001\t\001\t\001\t\001\t\001\t\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\015\014\001\001\001\001\001\001\001\001\001\001\015\022\001\001\001\015\030\0156\015>\015&\015F\001\001\001\001\001\001\001\001\001\001\015N\015V\001\001\001\001\001\001\001\001\001\001\015^\015v\001\001\001\001\001\001\001\002\138\001\001\001\001\001\001\001\001\001\014\015.\015f\015n\015~\001\001\001\001\015\134\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015\001\001\001\001\001\001\001\015\150\001\001\001\001\001\001\015\158\015\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\002\138\001i\001i\001i\001i\001i\001i\001i\001i\001i\014\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001i\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\002\138\001U\001U\001U\001U\001U\001U\001U\001U\001U\014\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\001U\003-\003-\003-\003-\003-\003-\000\014\003-\003-\000\018\003-\003-\003-\003-\003-\000\022\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\000\026\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\000\030\000:\003-\003-\003-\003-\003-\000>\003-\000J\003-\003-\003-\003-\003-\000N\003-\003-\003-\003-\000^\002\154\003-\002\003-\003-\003-\002\002\006\003-\006\006\006\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\006\006\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\003-\007\002\003-\003-\003-\003-\007\006\003\003-\003-\003-\003-\003-\004I\004I\004I\004I\004I\004I\000\014\004I\004I\000\018\004I\004I\004I\004I\004I\000\022\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\000\026\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\000\030\000:\004I\004I\004I\004I\004I\000>\004I\000J\004I\004I\004I\004I\004I\000N\000Z\004I\004I\004I\000^\002\154\004I\002\004I\004I\004I\002\002\006\004I\006\006\006\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\006\006\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\004I\007\002\004I\004I\004I\004I\007\006\003\004I\004I\004I\004I\004I\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\002\138\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001\157\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\002\138\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\014\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001Q\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\014\015\014\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\015&\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\002\138\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\014\015.\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\137\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\002\138\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\014\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001\141\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\002\138\001M\001M\001M\001M\001M\001M\001M\001M\001M\014\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001M\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\014\015\014\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\015&\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\002\138\001]\001]\001]\001]\001]\001]\001]\001]\001]\014\015.\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001]\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\014\015\014\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\015&\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\002\138\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\014\015.\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001Y\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\014\015\014\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015\030\0156\015>\015&\015F\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015N\015V\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015^\015v\001u\001u\001u\001u\001u\001u\001u\002\138\001u\001u\001u\001u\001u\001u\001u\001u\001u\014\015.\015f\015n\015~\001u\001u\001u\001u\015\134\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\001u\015\150\001u\001u\001u\001u\001u\001u\015\158\015\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\014\015\014\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\015&\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\002\138\001e\001e\001e\001e\001e\001e\001e\001e\001e\014\015.\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001e\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\014\015\014\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\015&\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\002\138\001a\001a\001a\001a\001a\001a\001a\001a\001a\014\015.\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001a\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\014\015\014\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\015\030\0156\015>\015&\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\015N\015V\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\002\138\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\014\015.\015f\015n\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001\145\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\014\015\014\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\015&\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\002\138\001I\001I\001I\001I\001I\001I\001I\001I\001I\014\015.\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001I\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\014\015\014\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\015\030\0156\015>\015&\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\015N\015V\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\002\138\001E\001E\001E\001E\001E\001E\001E\001E\001E\014\015.\015f\015n\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001E\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\014\015\014\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015\030\0156\015>\015&\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015N\015V\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\015^\001m\001m\001m\001m\001m\001m\001m\001m\002\138\001m\001m\001m\001m\001m\001m\001m\001m\001m\014\015.\015f\015n\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001m\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\014\015\014\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015\030\0156\015>\015&\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015N\015V\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\015^\001A\001A\001A\001A\001A\001A\001A\001A\002\138\001A\001A\001A\001A\001A\001A\001A\001A\001A\014\015.\015f\015n\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001A\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\014\015\014\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015\030\0156\015>\015&\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015N\015V\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\015^\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\002\138\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\014\015.\015f\015n\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001\149\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\014\015\014\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015\030\0156\015>\015&\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015N\015V\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\015^\001q\001q\001q\001q\001q\001q\001q\001q\002\138\001q\001q\001q\001q\001q\001q\001q\001q\001q\014\015.\015f\015n\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001q\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\014\015\014\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015\030\0156\015>\015&\015F\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015N\015V\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015^\015v\001y\001y\001y\001y\001y\001y\001y\002\138\001y\001y\001y\001y\001y\001y\001y\001y\001y\014\015.\015f\015n\015~\001y\001y\001y\001y\015\134\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\001y\015\150\001y\001y\001y\001y\001y\001y\015\158\015\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\014\015\014\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015\030\0156\015>\015&\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015N\015V\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015^\015v\001}\001}\001}\001}\001}\001}\001}\002\138\001}\001}\001}\001}\001}\001}\001}\001}\001}\014\015.\015f\015n\015~\001}\001}\001}\001}\015\134\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\001}\015\158\015\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\014\015\014\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015\030\0156\015>\015&\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015N\015V\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015^\015v\001\129\001\129\001\129\001\129\001\129\001\129\001\129\002\138\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\014\015.\015f\015n\015~\001\129\001\129\001\129\001\129\015\134\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\001\129\015\158\015\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\014\015\014\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015\022\001\133\001\133\001\133\015\030\0156\015>\015&\015F\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015N\015V\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015^\015v\001\133\001\133\001\133\001\133\001\133\001\133\001\133\002\138\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\014\015.\015f\015n\015~\001\133\001\133\001\133\001\133\015\134\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015\001\133\001\133\001\133\001\133\001\133\001\133\001\133\015\150\001\133\001\133\001\133\001\133\001\133\001\133\015\158\015\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\015\014\001\001\001\001\001\001\001\001\001\001\015\022\001\001\001\015\030\0156\015>\015&\015F\001\001\001\001\001\001\001\001\001\001\015N\015V\001\001\001\001\001\001\001\001\001\001\015^\015v\001\001\001\001\001\001\001\002\138\001\001\001\001\001\001\001\001\001\014\015.\015f\015n\015~\001\001\001\001\015\134\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015\001\001\001\001\001\001\001\015\150\001\001\001\001\001\001\015\158\015\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\016\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\003q\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\015\014\001\001\001\001\001\001\001\001\001\001\015\022\001\001\001\015\030\0156\015>\015&\015F\001\001\001\001\001\001\001\001\001\001\015N\015V\001\001\001\001\001\001\001\001\001\001\015^\015v\001\001\001\001\001\001\001\002\138\001\001\001\001\001\001\001\001\001\014\015.\015f\015n\015~\001\001\001\001\015\134\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015\001\001\001\001\001\001\001\015\150\001\001\001\001\001\001\015\158\015\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\016\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\003y\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\015\014\001\001\001\001\001\001\001\001\001\001\015\022\001\001\001\015\030\0156\015>\015&\015F\001\001\001\001\001\001\001\001\001\001\015N\015V\001\001\001\001\001\001\001\001\001\001\015^\015v\001\001\001\001\001\001\001\002\138\001\001\001\001\001\001\001\001\001\014\015.\015f\015n\015~\001\001\001\001\015\134\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015\001\001\001\001\001\001\001\015\150\001\001\001\001\001\001\015\158\015\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\016\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\003\129\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\015\014\001\001\001\001\001\001\001\001\001\001\015\022\001\001\001\015\030\0156\015>\015&\015F\001\001\001\001\001\001\001\001\001\001\015N\015V\001\001\001\001\001\001\001\001\001\001\015^\015v\001\001\001\001\001\001\001\002\138\001\001\001\001\001\001\001\001\001\014\015.\015f\015n\015~\001\001\001\001\015\134\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015\001\001\001\001\001\001\001\015\150\001\001\001\001\001\001\015\158\015\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\016\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\003]\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\014\015\014\001\001\001\001\001\001\001\001\001\001\015\022\001\001\001\015\030\0156\015>\015&\015F\001\001\001\001\001\001\001\001\001\001\015N\015V\001\001\001\001\001\001\001\001\001\001\015^\015v\001\001\001\001\001\001\001\002\138\001\001\001\001\001\001\001\001\001\014\015.\015f\015n\015~\001\001\001\001\015\134\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\015\001\001\001\001\001\001\001\015\150\001\001\001\001\001\001\015\158\015\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\002\138\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001\153\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\014\015\014\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015\030\0156\015>\015&\015F\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015N\015V\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015^\015v\001-\001-\001-\001-\001-\001-\001-\002\138\001-\001-\001-\001-\001-\001-\001-\001-\001-\014\015.\015f\015n\015~\001-\001-\001-\001-\015\134\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\001-\015\150\001-\001-\001-\001-\001-\001-\015\158\015\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\017\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\rI\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\n\137\n\137\n\137\n\137\n\137\018\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\018\n\137\n\137\n\137\n\137\n\137\n\137\018\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\018\001~\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\tE\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\141\n\141\n\141\n\141\n\141\018\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\018\n\141\n\141\n\141\n\141\n\141\n\141\018\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\018\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\141\n\137\n\137\n\137\n\137\n\137\018\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\018\n\137\n\137\n\137\n\137\n\137\n\137\018\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\018\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\n\137\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\020J\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\014\015\014\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\015\022\006e\006e\006e\015\030\0156\015>\015&\015F\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\015N\015V\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\015^\015v\006e\006e\006e\006e\006e\006e\006e\002\138\006e\006e\006e\006e\006e\006e\006e\006e\006e\014\015.\015f\015n\015~\006e\006e\006e\006e\015\134\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\006e\015\006e\006e\006e\006e\006e\006e\006e\015\150\006e\006e\006e\006e\006e\006e\015\158\015\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\014\015\014\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\015\022\b)\b)\b)\015\030\0156\015>\015&\015F\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\015N\015V\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\015^\015v\b)\b)\b)\b)\b)\b)\b)\002\138\b)\b)\b)\b)\b)\b)\b)\b)\b)\014\015.\015f\015n\015~\b)\b)\b)\b)\015\134\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\b)\015\b)\b)\b)\b)\b)\b)\b)\015\150\b)\b)\b)\b)\b)\b)\015\158\015\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\014\015\014\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\015\022\b=\b=\b=\015\030\0156\015>\015&\015F\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\015N\015V\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\015^\015v\b=\b=\b=\b=\b=\b=\b=\002\138\b=\b=\b=\b=\b=\b=\b=\b=\b=\014\015.\015f\015n\015~\b=\b=\b=\b=\015\134\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\b=\015\b=\b=\b=\b=\b=\b=\b=\015\150\b=\b=\b=\b=\b=\b=\015\158\015\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\014\015\014\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\015\022\b9\b9\b9\015\030\0156\015>\015&\015F\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\015N\015V\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\015^\015v\b9\b9\b9\b9\b9\b9\b9\002\138\b9\b9\b9\b9\b9\b9\b9\b9\b9\014\015.\015f\015n\015~\b9\b9\b9\b9\015\134\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\b9\015\b9\b9\b9\b9\b9\b9\b9\015\150\b9\b9\b9\b9\b9\b9\015\158\015\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\020J\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\006\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\020J\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\028b\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\028v\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\020J\002\138\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\028\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\020J\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r Z\011\r\011\r\011\r\011\r\011\r\011\r\011\r\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\014\015\014\006\006\006\006\006\006\006\006\006\006\015\022\006\006\006\015\030\0156\015>\015&\015F\006\006\006\006\006\006\006\006\006\006\015N\015V\006\006\006\006\006\006\006\006\006\006\015^\015v\006\006\006\006\006\006\006\002\138\006\006\006\006\006\006\006\006\006\014\015.\015f\015n\015~\006\006\006\006\015\134\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\017\015\006\006\017\006\006\006\006\015\150\006\006\006\006\006\006\015\158\015\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni%6\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\025\ni\ni\nm\002\nm\nm\nm\nm\000\014\nm\006\000\018\nm\nm\nm\006\nm\000\022\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\000\026\nm\002\002\005\154\nm\nm\nq\nm\nm\nm\000\030\000:\nm\007N\nm\002\002\012r\nm\012$\nm\nm\nm\nm\000N\000Z\nm\nm\nm\000^\002\154\nm\002\nm\nm\nm\002\002\006\012\006\006\006\nm\nm\nm\nm\nm\nm\nm\nm\nm\r\026\nm\nm\nm\nm\r*\rR\006\006\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\007\002\nm\nm\nm\nm\007\006\003\rn\nm\nm\nm\nm\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\014\015\014\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\015\022\011\r\011\r\011\r\015\030\0156\015>\015&\015F\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\015N\015V\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\015^\015v\011\r\011\r\011\r\011\r\011\r\011\r\020J\002\138\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\014\015.\015f\015n\015~\011\r\011\r\011\r\011\r\015\134\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\015\011\r\011\r\011\r\011\r\011\r\011\r\011\r\015\150\011\r\011\r\011\r\011\r\011\r\011\r\015\158\015\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni%N\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\ni\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006'\026\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\006\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\007\022\011b\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\007\030\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\0015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\007\022\011b\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\007\030\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\003\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\020J\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r*\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\020J\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r*\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\000\014\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\012j\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\000^\011\r\011\r\011\r\011\r\020J\002\138\011\r\011\r\011\130\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\011\r\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\004\025\004\004\005\004\002v\023:\007-\007-\002~\005\018\t\133\005\000\014\ne\006\146\n\003\005\005\005\r\149\005\005\000B\005\002v\002\146\021R\005\007-\005\ne\t\133\005\005\005\005\005\005\n\028F\021V\000*\017F\005\005\002\138\028V\003\005\005\005\005\005\028\001~\001b\000\"\bM\005\005\005\005\029\n\005\005\020\138\005\029\005\005\005\005\005\007-\005\005\005\001f\007>\005\005\005\005\005\030\014\020\142\006\011\006\005\021Z\018\150\t\001V\005\005\030\026\030>\004*\012>\n\011\129\007-\n\002\003\"\001\018\005\030\0192\bJ\tE\012\018\158\005\005\005\006\030\138\005\001\007\005\005\n\005\005\000\n\002\002\b\005\005\000B\r\149\000F\002\146\012B\018\154\017V\002\150\021R\002\002\002\007U\n\007\022\011b\027*\002\019B\002J\002N\001\146\021V\000\014\006\002\002\003\002\003\006\003\n\003\014\000^\002R\002^\027R\007B\002\002\002j\003\018\002n\012\012\002\006\003\030\000R\b\018\150\002\001V\000N\002\007\007\n\153\003\"\006\007U\006\000\014\003\"\019R\006\007&\007J\011\154\b\030\b\"\b&\018\158\030\158\b*\b.\b2\b6\b:%\000V\011\n\b>\007U\019^\011\012\002\bF\bJ\007\n\019j\tF\000R\003\007\000\014\007\022\011b\001\001\007\030\021(b\007\"\002\158\0022\b\n&\006*'\bR\005\022\003\b\007\017\134\bV\r\134\000\n\001\b\b$\000B$\000F\002\146\007U\rY\002v\002\150\n*\002\002\002\012\018\t\133)\146\011\021\007\003\150(r\005n\003\130\007\022\011b\030%\002\002\003\002\003\006\003\n\003\014\003\"\003\004\t.\001\002\002\004\012v\005\n\012\012\002\007\003\030\002\138\006z\004Q!\rY\000N\002\007\007\021\003\"\006\007\030\006\t2\003(\130\006\007&\007J\011\154\b\030\b\"\b&\027\018\031\022\b*\b.\b2\b6\b:\004Q\028v\011\018\b>\rY(\142\011\012\002\bF\bJ&\130\030(\154\rY\t .\004Q\023\154\012\012\001\001\130\tu\004Q\002*\n\002\012\022\004Q\b\007\030\012\rY\007\bR\007\001\b\n!\017\134\bV\r\134\000\n\002\002\b\b\002r\000B\n\000F\002\146\003\026\019\000B\002\150\0192\002\002\002\021>\007(6\007\021B\002v\002\018\002J\002N\tu\002\138\018.\t\133\002\002\003\002\003\006\003\n\003\014\000^\002R\002^\004\018\004\030\002\002\002j\011~\002n\012\012\002\002\"\003\030\012\001\138\019\006\028\000N\002\007\007\bB\003\"\006\003\006\r\001r\003\"\006\007&\007J\011\154\b\030\b\"\b&\011)\0182\b*\b.\b2\b6\b:\002z'\011\tu\b>\003\001v\011\012\002\bF\bJ\019\n\018:\0192\019R\000\n\024\030\002.\004\022\007\000B\007\000F\002\146\b\018\000\014\000\014\002\150\b\002\002\002\tF\bR\019\019^\b\007\017\134\bV\r\134\007\146\019j\b\b\002\002\003\002\003\006\003\n\003\014\001\142\004*\019\007^\003\002\002\n\n\0126\000J\012\012\002\007\003\030\002:\005\022\003\022\001\000N\002\007\007\011%\003\"\006\n\t\006\n]\003\"\000^\006\007&\007J\011\154\b\030\b\"\b&\022\011\130\b*\b.\b2\b6\b:\019R\003\011\nY\b>\012>)\011\012\002\bF\bJ\019\023\012:\000\014\005\002\138*\n*\025\000.\019^\002F*\005\014\007\022\011b\007U\019j\b\r!\003\003\003\bR\002\007\150\b\023\017\134\bV\r\134\002v\025\b\b\000\006\005\000\n\t\133\003\007\031\000B\001:\000F\002\146\n\n\002\134\000J\002\150\000R\002\000\014\027~\0002\000\018\011\014\0052)\n]\031\012\012\005\003*&\138)\002\027\134\002\002\005\154*\000.\006v\002v\005B\005\146\002\002\011\018\006\142\t\133\002\002\002\007U\003\030\011\134&\142*\005\018\005.\000N\002*R\r!\011\138\003\"\006\007\030\006\011\146!B\006\006\007&\007J\011\154\b\030\b\"\b&\nY\003J\nQ*V\011z\nQ\000J\0186\003>\011\002\026\0166\025\005\146\011\012\002\bF\bJ\020R\020~\"\002\005\146\012\"\"\"\006\005I\r\005I\003N\003R\003V\001\158\005I\005I\005I\005I\0212\021:\bR\005I'N\005I\nQ\011\158\bV\r\134\012V\003Z\r\r\027V\005I\002\n'\"\005I+b\b\005I\n\005I\005I\005I\024N\000^\005I\b\007\158\b\005I\005I\002\005I\028B\005I\005I\005I\b\005I\005I+f\021\n!j\005I\005I\n\nQ\005I\005I\005I\007\005I\005I\r\r\005I\005I\005I\005I\005I\005I\005I\n\153\n\153\012>\007*\n\nQ\nY\005I\n\153\005I)\006\001\142\002V(b\005I\005I\005I\005I\005I\005I\r\r\005\146\r\n\005\146\011-\n\000\157\001.\000\n\003\142\020\014\000\157)\n\000B\n]\000F\002\146\005I\005I\005I\002\150\n\153\006\n\153\005I\005I\005I$v\r\001F\024\146)\014\002v\000\157\n\153\n\006\000\157\000\157\002\t\133\002\002\005\154\n\153\017\nq$~+j\017\002\002\001\007N\011%\002\002\002\006z\007R\007V\025b\002\138\n\153\b\150\000N\002\027j\027n\000\157\003\"\006\nY\006\000\157)>(\130\006\007&\007J\011\154\b\030\b\"\b&\000\157\000\157\n\n)\022\000J\n\153\017\030\028\014\000\014\011\n\006z\0072(\142\011\012\002\bF\bJ\023\n(\154\tF\006z\0122\000\157\002\000\n%\154!\150\000\157\021\134\000B\000\157\000F\002\146\003\r1\000\029\002\150!6\006\bR\n*!V!~!\146\011\158\bV\r\134\024\022\001\142\000\157\005\146\0022\000\157\000\157\002\018\138\002\002\005\154\000\029\030.\nq\000B\000\014\007\002\002\011\029\007N\021\154\002\002\002\003\007R\007V\011f\004\028\018\018\142\000N\002\003\012>\000\157\003\"\006\n\006\000\157\003b\007\006\007&\007J\011\154\b\030\b\"\b&\000\157\000\157\028v\005v!\154\005\146\018N\012j\004\158\011\r\r\r1\011\029\011\012\002\bF\bJ\014\003\"\000^\003f\003j\003n\001\005\146\002\138#v\0182\011\130\001R\018B\000\157\r\r\007r\r\r\r]\027r\003r\bR\004\002\138\000\014\011\029\011\158\bV\r\134\024\022\000b\000f\000j\000n\000r\004\000v\000z\000~\000\130\000\134\012~\000\138\000\142\000\146\007v\007z\007~\000\150\001\002\138&V\018\146 \000\154\001V\007\027\r\r\000\158!\031N\r]\007\130\000.\000\012j\000\000\000\000\000\021\000\000'\007-\028\031\000^\000\000\nM\nM\rY\002\138\r\n\011\130\r\012B\012F\019\002v\r]\027\012\n\nM\007-\007-\t\133\000\006\r]\nM\000\000\rY\012J\001\rY\rY\000\000\000\007\r\000\000\000\000\r]\000\000\000\001~\nM\nM\nM\000\001\002\001\006\012\130\n*\000\014\001\n\001\014\001\018\006A\nM\nM\nM\007\007-\007-\001\022\nM\001\026\nM\012\023f\012\rY\001\030\001\"\001&\005\158\005\005\005\005\001\130\005\005\005\005\005#\130\005\005\005\b\150\007-\007-\005\007-\012\b\012\002\005\tE\001\006A\rY\005\030\005\007-\017\006\005J\002\001\005\rY\005\005\005\005\005\001\005\005\007-\n\004F\000\014\021^\005\006\002\000\014\000\014\rY\nY\006\0122\006A$\158\003\"\002 \134\027n\001\001\tQ\006A\005z\021b\n\006\006#\002!6\tQ\006\n\006\014!V!~!\146\019j\027\006\018\006\022\006\026\006A \138\006\030\006\"\006&\006*\012j\006.\0062\0066\006E\011\0022\007\006:\006>\006B\002\001\012\000^\006F\006J\006N#\134\001\002\138\n\005\"\011\130\002\006R\"N\006V\"Z\000\014*2\006\000\018\006Z\006^\006b\006\011\029\000\022\028v \002\005\146\011\"*\006\007}\nY\n\001\001\006E\001\017\020f\000\026\006I\002\002\005\154!\154\011\029\028F\030\011\029\011\029\000\030\000:\001*\028\018\002\002\012r\nY\012+\002\001\138\006\001\007\142\000N\000Z\006E&j\029\n\000^\002\154&\002\029\007\006E\002\002\006\012\006\006\006\011%\006I\005:\011%\000M\019j\011\029+\006\002\138\r\026\006E\015\138\nY\000\014\r*\rR\006\006+\018+.\002\nY\011a+C J\000\014*2\006\000\018\ta\007}\000M\006\006I\000\022'\150\028$\018\011\029*+F\007\002\006I\011%\t\030\025\150\007\006\003\rn\011a\000\026\001\130\002\002\005\154\019j\012j\028F\b\002\003>\006I\000\030\000:\011&*\012\134\002\002\012r\000^\012+\002\002\026\005\146\ta\002\138\000N\000Z\011\130\004\029\n\000^\002\154\002\006\002\029\005\"\011%\002\002\006\012\006\006\006)\006\0262\019n(b\017\019z\n+\006\007-\r\026#~\ta\000^\011%\r*\rR\006\006+\018+.\011%\0266\002\n,\003z\000B\0112\"\002\146\n\007-\007-\n\002\n\002\002\002&\150\ta\003~+F\007\002\003\150)\014\007\019\134\007\006\003\rn\004\003\154\002\003\158\003\003\n\003\014\007\001\150\000.\n\011\001\005\006\002\t\006\003\011)\007\007\007\134(\n\002\001\146\004\021>\t:\007-\007-\030\142\007\007\004*\003\"\n\007\007\n\t\018(\130\007\019\150\007\b\022\b\030\b\"\b&\000.\n\b*\b.\b2\b6\b:\n\017\002>\007-\007-\b>\007-(\142\002\138\019\bF\bJ\tI\bN(\154\003B\n\005I\007-%r\r\007r\005I\005I\005I\005I\rQ\tF\012>\005I\b\005I&r\007-\002\138\bR(\022\b\b\002\b\bV\ne\028Z\011M\b\b\005I\004\005I\005I\007v\007z\007~\005I\n*\004*\002\001\005I\005I\ne\005I\023\022\005I\005I\005I!\005I\005I\n\007\130\rQ\t\022\005I\005I,\134$\002\005I\005I\005I\tF\005I\005I\n\000\014\005I\005I\005I\005I\005I\005I\005I\000\014#\130$\n\ne*\tj(*\005I\tE\005I\t\134\rQ\n]\012\005I\005I\005I\005I\005I\005I\020\014\ne\017:\t~\003z\000B\000.\018\002\146\006j\tE\tE\tn\002\001\002\002\002\007\rQ\003~\005I\005I\002\r\130\001\146\0022\005I\005I\005I\018\003\154\002\003\158\003\003\n\003\014\n\018\001~\006\000\000B$\134\002\016\007\138\016\007\007\007\134\n\n\002\000J\000\014\004Q\018\030\tE\tE\018\130\007\007 \003\"\000\012\007\rZ\000\002\026\007\003\146\007\b\022\b\030\b\"\b&\007\018\b*\b.\b2\b6\b:\004Q\006\tE\tE\b>\tE\001\130\000.\t\022\bF\bJ\tE\bN\r\003\"\007\018\004Q\029\012>\n*\nQ\nQ\0182\004Q\006\134\005\146\r\150\004Q\b\002\n\n\tE\016v\bR\016\142\nQ\b\001V\b\bV\002b\018:\nQ\b\b\003z\000B\011B\026\002\146\0262\007\000}\n~\n\002\002\002\018r\018\"\003~\000^\004\003\150\nQ \nQ\002\138 \027n\0266\003\154\002\003\158\003\003\n\003\014\nQ\nQ\nQ\002\t\027n\024v\002\nQ\003\nQ\007\007\007\134\021v\002 \tQ\r\153\025\030\r\154\000}\002\138\007\007\tQ\003\"\002\t\002\t\007\002\t\002\t\028\007\003J\007\b\022\b\030\b\"\b&\024\021z\b*\b.\b2\b6\b:\012\"\142\n\025\b>\028v\000}\t\137\002\026\bF\bJ\0116\bN\002V\005\146\nQ\004\003N\003R\003V\003z\000B\011\018v\002\146\002\t\005\146\012\031\b\002\002\002\000}\bR\003~\003Z\b\003\150\b\bV\011f\028\018\031\130\b\b\003\154\002\003\158\003\003\n\003\014\r\157\002\n\028\018\002\005\027n\002\t\002\012\154\003\024.\007\007\007\134\027&\002'\003b&\022\018\001\146'\002\138\007\007\002\026\003\"\002\005\002\005\007\002\005\002\005 \026\007\024r\007\b\022\b\030\b\"\b&\021\t\133\b*\b.\b2\b6\b:\003f\003j\003n\028\b>\019\006\002\n\000\029\000\029\bF\bJ\002\bN#\150\012n\025\000B\020.\022*\003r\003z\000B\011\002\n\002\146\002\005\005\146\007\022\011b\b\002\002\002\018.\bR\003~'\b\003\150\b\bV\002\138\025!N\b\b\003\154\002\003\158\003\003\n\003\014\000\029\002\138\028\018\028v\000\014\002\005\002\006\003\026\030\007\007\007\134\004*\002\025\011:\025\004*\024\003\"\027\007\007\002\138\003\" \154$\007\0182\000\029\027\007\026\"\007\b\022\b\030\b\"\b&\006\019\n\b*\b.\b2\b6\b:&\030+Z\018:\000\"\b>\028v\026\018\002\026\004\bF\bJ\000\014\bN\000\029\000^\007\030\020\130\031N\027\020\003z\000B\r2+z\002\146\002\138\001\146\te \b\002\002\002\002\138\bR\003~\011F\b\003\150\b\bV\028z+\138\011J\b\b\003\154\002\003\158\003\003\n\003\014\002\n\028\012j\r\026>\001\142\002\020\003\026z\007\007\007\134!R\002\000^+\154\007\022\011b\026N\te\002\138\007\007\011\130\003\"\r\028\154\007\027\r\026B\007\004\007\b\022\b\030\b\"\b&\n\029\b*\b.\b2\b6\b:&\007\001\142\028\b>\020\te\002\026\000\014\bF\bJ\000\014\bN\002\138,\158\002\138\n\003\001\n*\n\003z\000B\rB'~\002\146\r\021\n\001\007\b\002\002\002\te\bR\003~\005i\b\003\150\b\bV\026\130\002\138\026\154\b\b\003\154\002\003\158\003\003\n\003\014\002\n\007\012j\024b\r\007\030\002\003\025\003\028\007\007\007\134\001\142\002\000^\030B\006\002\r\030N\001\002\138\007\007\011\130\003\"\011\r\007\005i\002\138\r\007\030\007\b\022\b\030\b\"\b&\027~\011\b*\b.\b2\b6\b:& \027n!\b>\031*\001\002\026\028\134\bF\bJ\000\014\bN\030Z\031\005i(\158\tF!\030(\003z\000B\022\031n\002\146 \r\001 z\b\002\002\002\001\bR\003~\0292\b\003\150\b\bV\031\005i\"\b\b\003\154\002\003\158\003\003\n\003\014\002\n!\138\012j ~\024\134\030j\002(\003&\007\007\007\134\031\130\002\000^\002\026\031R\005\146\001\146\001\002\138\007\007\011\130\003\"\030v\003\021\007\029B*J\030\007*b\007\b\022\b\030\b\"\b&+r\"\158\b*\b.\b2\b6\b:\028\018!\031\014%\b>(\001!\"%\bF\bJ%\142\bN\021\"\002\n\031V+v r'.\003z\000B\022\011\002\146\"\022(*r!\b\002\002\002\001\bR\003~\011\b\003\150\b\bV#\n!\142#\b\b\003\154\002\003\158\003\003\n\003\014#$\001\001\130\0236'\002\018R\003\000B\007\007\007\134\"\002\nY#\014\001#*\134'\134%\007\007\023Z\003\"\018\130#\007!\"#'n\007\031\150\007\b\022\b\030\b\"\b&#>*\150\b*\b.\b2\b6\b:\002\018\002J\002N\"\b>\017:\006\rU'2\bF\bJ#\bN\000^\002R\002^$'\002\003\"\002j\"&\002n\000\014\011\006\000\018'Z\0182\b\006'\000\022%\146\bR\r]%\b(\002\b\bV,\007$\b\b%\018:\000\026%f\002\002\rU,\"\011M%\000\014\r]\000\030\000:\r]\r]%\002\002\012r%\012\017:'r'+\130%\000N\000Z\012R'(F\000^\002\154\012Z\002%\rU\012^\002\002\006\012\006\006\006\020\014%\012\142\012\150),V+\134\012j\005\"\r\026\r]\012\000-\000\r*\rR\006\006\rU\000B\000^\005\133\002\146,^\012-\007\002\138!Z\002\011\130\012\r6\007\022\011b\004*\000-\000--\003\000-\000-)\002\007\002\r]\003\002\r:\007\006\003\rn\rF\rJ\r]\r\r'^\002\002\014\002\000\002\138\014\"\014\158\002\r\002\014\005\133\002\138\005\"\r]\000N\002\019\n\"\138\004*\003\"\006\017\142\006\017\000-\000-\006\007&\007J\018\018\b\030\b\"\b&\018*\000\018f\018~\019\138\019F\019\019\0005\005\133\017:\020\022\020Z\020b\020\000B\bF\bJ\002\146\021J\tI\021n\021\146\000-\002\021\021\021\000\007\030\005\0005\0005\022\018\0005\0005\005\133\r\r\000-\002\bR\tI\tI\022&\022Z\011\158\bV\022\154\000-\000-\002\002\005\022\022\005\005\002\r\002\022\022\023\002\023F\023N\000N\002\023n\001\150\023z\003\"\006\023\006\022\0005\0005\006\007&\007J\024Z\b\030\b\"\b&\024~\024\158\tI\tI\024\024\024\024\025J\025f\005\137\026J\026\005\005\146\026\bF\bJ\026\n]\027\000\n\027\0005\027\027\000B\028>\000F\002\146\028\158\tI\tI\002\150\tI\002\028\r\r\0005\tI\bR\001\001\130\029\026\005\011\158\bV\029\0005\0005\002\030\n\002\002\005\137\002\138\001\030\"\030*\030^\tI\002\002\002\002\030\150\030\002\002\002\030\003\030\005\030\031.\0312\031\000N\002 : F n\003\"\006 \146\006\002\018\005\137\002N\006\007&\007J\011\154\b\030\b\"\b& \158 !\002\000^\002R\002^!\n!b!v\011\002j!\002n!\011\012\002\bF\bJ\005\137\002\"r\"z\"\130\"\150\000\014\"\006\000\018\"#&#.\006\ta\000\022#F#R###\000B#\bR#\n]$*$\011\158\bV\r\134\000\026%\n\002\002%\022%\"\ta%%\ta\ta\000\030\000:'&\006\003\002\002\012r&>\012&J&v&z&&\000N\000Z&&'\006\000^\002\154\018N\002'F'f'\142\002\002\006\012\006\006\006'\003\"'(\014(>(\ta\005\146(v\r\026\0182)\030)*)R\r*\rR\006\006)~)\134)\002)))*\011\000\014!Z\006\000\018*>*v+\026\006+\"\000\022\nV+N\ta+,\n\007\002\001\001\130,;\n]\007\006\003\rn,G\000\000\000\026\000\000\002\002\000\000\000\000\003\000\000\000\000\000\000\000\000\000\030\000:\001\ta\000\000\002\002\012r\000\000\012\000\000\000\000\000\000\000\000\000\000\000N\000Z\000\000\000\000\000\000\000^\002\154\000\000\002\001\005n\003\130\002\002\006\012\006\006\006\000\000\000\000\000\000\003\"\003\004\000\000\000\000\000\000\r\026\004\000\000\005\n\000\000\r*\rR\006\006\000\000\000\000\000\000\005!\000\000\000\000\000\000\000\000\005!\"\005!\005!\000\000\000\000\000\000\005!\000}\005!\000\000\000\000\000\000\000\000\000\000\007\002\000\000\n\r\000\000\000\000\007\006\003\rn\000\000\000\000\005!\000\000\005!\005!\000\000\000\000\000}\000}\000\000\000}\000}\005!\005!\000\000\000\000\000\000\005!\005!\005!\000\000\005!\000\000\000\000\000\000\000\000\000\000\005!\005!\000\000\000\000\000\000\005!\005!\000\000\005!\000\000\000\000\000\000\005!\005!\005!\005!\005!\005!\005!\000\000\000\000\000\000\000\000\000\000\000\000\000}\005\146\000\000\005!\000\000\000\000\000\000\000\000\005!\005!\005!\005!\000\000\000\000\005\029\000\000\000\000\000\000\000\000\005\029\000\000\005\029\005\029\000\000\000\000\000\000\005\029\r\005\029\000\000\000\000\000\000\000}\000\000\000\014\005!\n\t\000\000\000\000\000\000\005!\005!\005!\000\000\005\029\000\000\005\029\005\029\000}\r\r&\000\000\000\000\000\000\005\029\005\029\000\000\000}\000}\005\029\005\029\005\029\000\000\005\029\000\000\000\000\000\000\000\000\000\000\005\029\005\029\000\000\000\000\000\000\005\029\005\029\012j\005\029\000\000\000\000\000\000\005\029\005\029\005\029\005\029\005\029\005\029\005\029\000\000\000^\004\000\000\000\000\r\r\002\138\000\000\005\029\011\130\000\000\000\000\000\000\005\029\005\029\005\029\005\029\000\000\000\n\000\000\000\000\000\000\000\000\000B\004\000F\002\146\004\004\005i\002\150\te\002\r\r\000\000\r\000\000\000B\000\000\005\029\000\000\001\142\000\000\rY\005\029\005\029\005\029\002\000\000\002\002\005i&\te\005i\005i\te\te\002\002\000\000\000\000\r\002\002\002\rY\003\030\000\000\rY\rY\000\000\000\000\000N\002\000\000\011\021\000\000\003\"\006\018N\006\000\000\000\000\000\000\006\007&\007J\011\154\b\030\b\"\b&\000\000\003\"\000\000\000\000\005i\005\146\te\005\146\004\011\0182\000\000\000\000\000\000\011\012\002\bF\bJ\011\129\rY\r\021\000\000\000\000\000\000\000\000\r\021\018\r\021\r\021\000\000\000\000\000\000\r\021\000\000\r\021\029.\005i\000\000\te\000\000\000\000\bR\n\021%\130\000\000\011\129\011\158\bV\r\134\001\r\021\rY\r\021\r\021\000\000\000\000\000\000\028F\000\000\000\000\rY\r\021\r\021\005i\028V\te\r\021\r\021\r\021\000\000\r\021\028\000\000\004\000\000\000\000\r\021\r\021\rY\000\000\029\n\r\021\r\021\000\000\r\021\029\000\000\000\000\r\021\r\021\r\021\r\021\r\021\r\021\r\021\000\000\004\000\000\000\000\004\004\000\000\030\014\000\000\r\021\000\000\000\000\000\000\000\000\r\021\r\021\r\021\r\021\030\026\030>\r\017\000\000\000\000\000\000\000\000\r\017\000\000\r\017\r\017\000\000\000\000\000\000\r\017\000\000\r\017\000\000\000\000\000\000\000\000\000\000\030\138\r\021\n\017\000\000\000\000\000\000\r\021\r\021\r\021\000\000\r\017\000\000\r\017\r\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\r\017\r\017\000\000\000\000\000\000\r\017\r\017\r\017\000\000\r\017\000\000\006A\000\000\000\000\000\000\r\017\r\017\004\000\000\000\000\r\017\r\017\000\000\r\017\000\000\000\000\000\000\r\017\r\017\r\017\r\017\r\017\r\017\r\017\006A\006\000\000\006A\006A\000\000\000\000\001\001\130\r\017\029b\000\000\000\000\000\000\r\017\r\017\r\017\r\017\014*\014f\000\000\000\000\001\000\000\006\006\000\000\006\006\002\002\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\000\000\r\017\000\000\000\000\025\006A\r\017\r\017\r\017\015\016\002\002\018\025\002N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\n\016\"\000\000\000^\002R\002^\000\000\000\000\006\005\146\002j\000\000\002n\000\000\000\000\000\000\006A\000\000\000\0142\015\016\018\016\026\016*\000\000\006A\000\000\006\0162\000\000\000\000\000\000\000\000\001\001\000\000\000\000(b(\154\000\000\006\000\000\000\006A\000\000\000\000\006\003\000\000\000\000\006\006\016Z\000\000\001\006\000\000(n\000\000\006\016B\006\000\000\014*\014f\000\000\006\016J\016R\006\006\000\000\006\006\000\000\014n(r\005n\003\130\015\015\015\015\015\000\000\000\005\146\000\000\000\000\003\"\003\004\000\000\000\000\015\016\002\004\000\000\005\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\006\005\146\000\000\000\000\000\000\000(\130\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000(\000\000\006\0162\000\000\000\000\000\000\000\000\001\018(\142\000\000\0192\000\000\000\006\000\000(\154\000\000\000\000\000\000\000\000\b\001\001\000\000\000\000\006\006\016Z\000\000\002\002\006\000\000\019>\000\000\006\016B\006\000\000\014*\014f\000\000\006\016J\016R\b\001\b\001\000\000\b\001\b\001\000\000\014n\019B\002J\002N\015\015\015\015\015\000\000\000\000\001\001\130\000\000\000^\002R\002^\000\000\000\000\015\016\002\002j\000\000\002n\000\000\000\000\001\000\000\000\000\000\000\000\000\016\n\016\"\002\002\025\000\000\000\000\000\000\000\000\b\001\005\146\000\000\000\000\000\000\000\000\019R\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\002\018\019\002N\b\001\0162\000\000\000\000\000\000\000\000\000\000\000\000\019^\000\000\000^\002R\002^\b\001\000\000\019j\000\000\002j\000\000\002n\007\000\000\000\000\000\000\b\001\b\001\016Z\000\014\000\000\b\001\000\018\000\000\000\000\b\001\016B\b\001\000\022\014*\014f\000\000\b\001\016J\016R\007\007\000\000\007\007\000\000\014n\000\000\000\000\000\026\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\030\000:\000\000\000\000\000\000\015\016\002\000>\000\000\000J\000\000\011\011\000\000\000\000\000N\000Z\016\n\016\"\000\000\000^\002\154\000\000\002\000\000\007\005\146\002\002\006\000\000\006\006\006\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\000\000\007\0162\000\000\000\000 \000\000\006\006&&\000\000\000\000\000B\000\000\007\000\000\000B\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\007\016Z\000\000 \007\000\000\007\002\018\142\007\016B\007\007\006\003\000\000\000\000\007\016J\016R\002\153\000\000\000\000\003.\000\014\000\000\000\000\000\018\000\000\000\000\000\000\018N\000\000\000\022\000\000\018N\000\000\000\000\0032\000\000\002\153\002\153\000\000\002\153\003\"\000\000\000\000\000\000\003\"\000\000\005\146\000\000\003F\0182\005\146\001\001\0182\000\000\000\000\000\000\000:\000B\000\000\000\000\000\000\003^\tv\011N\000J\000\000\000\000\006E\000\000\000\000\000\000\000\000\000\000\001\001\000^\001\001\007f\000\000\000\000\002\153\t\026\000\000\tb\000\000\006\006\006\000\000\006E& \006E\006E\000\000\018\146\002\153\000B\000\000\018N\000\000\005\000\000\000\000\006\006\005\000\000\002\153\002\153\000\000\002\153\003\"\000\000 \000\000\000\000\001\005\146\000\000\000\000\0182\002\153\000\000\005\017\006\002\153\002\153\005\007\002\000\000\005\005\002\153\006E\003\000\000\002\153\014\015\014\018N\000\000\000\000\000\000\006\006\001\006\006\001\015\022\000\000\000\000\003\"\015\030\0156\015>\015&\015F\005\146\004\000\000\0182\005\000\000\001\006E\000\000\005\015N\015V\r\r\000\000\000\000\006E\001\000\000\000\000\005\000\000\015^\015v\004\000\000\000\000\004\004(\154\006\002\138\000\000\000\000\006E\r\r\000\000\r\r\004\014\015.\015f\015n\015~\000\000 \004\005\000\000\015\134\005\000\000\000\000\004\005\000\000\000\000\000\000\000\000\006\000\000\000\000\006\004\000\000\000\000\004\004\021f\000\000\004\005\004\005\000\000\006\006\015\000\000\000\000\006\000\000\r\r\000\000\015\150\006\000\000\014\015\014\000\000\006\015\158\015\006\006\000\000\006\006\004\005\015\022\000\000\000\000\004\015\030\0156\015>\015&\015F\000\000\000\000\r\004\005\000\000\r\000\000\000\000\004\005\004\005\015N\015V\004\005\000\000\027\154\000\000\000\000\000\000\000\000\000\000\000\000\029v\015^\015v\000\000\000\000\000\000\000\000\000\000\000\000\006\002\138\r\004\000\000\000\000\000\000\004\005\004\005\000\000\004\005\014\015.\015f\015n\015~\006\000\000\002\025\000\000\015\134\000\000\000\000\000\000\000\014\000\000\004\005\r\000\000\006\029\138\000\000\006\000\000\000\000\000\000\000\000\004\005\000\000\000\000\002\025\002\025\000\000\006\006\015\000\000\000\000\006\r\r\000\000\000\000\015\150\006\000\000\014\015\014\000\000\006\015\158\015\b\001\b\001\000\000\b\001\b\001\012j\015\022\000\000\000\000\000\000\015\030\0156\015>\015&\015F\000\000\000\000\005\000^\000\000\000\000\000\000\021\130\002\025\002\138\015N\015V\011\130\000\000\000\000\000\000\000\000\r\r\000\000\000\000\000\000\015^\015v\000\000\005\000\000\000\000\000\000\005\b\001\002\138\021\022\006\000\000\000\000\000\000\002\025\002\025\000\000\002\025\014\015.\015f\015n\015~\r\r\tM\r\015\134\000\000\000\000\000\000\000\000\001\142\000\000\000\000\000\000\b\001\000\000\000\000\b\001\000\000\011\138\000\000\000\000\002\025\000\000\011\146\tM\tM\000\000\b\001\b\001\015\r\000\000\b\001\000\000\022\030\000\000\000\000\015\150\b\001\000\000\014\015\014\000\000\b\001\015\158\015\007\007\000\000\007\007\001\015\022\000\000\000\000\000\000\015\030\0156\015>\015&\015F\000\000\000\000\000\000\000\000\022R\000\000\002\000\000\tM\tM\015N\015V\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015^\015v\000\000\000\000\002\002\000\000\002\007\002\138\000\000\000\000\000\000\000\000\000\000\tM\tM\000\000\tM\014\015.\015f\015n\015~\tM\000\000\001\000\000\015\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\000\000\007\000\000\000\000\000\000\000\000\tM\000\000\000\000\001\001\002\138\007\007\015\000\000\000\000\007\000\000\000\000\000\000\000\000\015\150\007\000\000\002\153\000\000\002\007\015\158\015\003z\000B\000\000\000\000\002\146\000\000\000\000\000\000\002\002\002\002\000\000\000\000\000\000\003~\000\000\002\153\002\153\000\000\002\153\002\153\002\001\001\000\000\002\002\000\000\007j\000\000\000\000\000\000\002\000\000\002\025\002\025\002\002\000\000\000\000\000\000\000B\007n\b\026\000\000\002\000\000\000\000\000\000\000\000\000\000\001\001\000\000\001\000\000\003\"\002\025\002\025\007\002\025\002\025\002\153\007\000\000\007\000\000\b\030\b\"\b&\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\028\000\000\000\000\018N\000\014\bF\bJ\000\018\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000\000\003\"\007\022\011b\000\000\000-\002\025\005\146\002\153\000\000\0182\014\134\002\153\002\153\000\026\bR\000\000\002\153\000\000\002\153\000\000\bV\000\000\002\153\000\000\000\030\000:\001\001\130\000\000\000\000\000\000\000>\014\130\000J\002\025\011\011\002\025\000\000\000N\000Z\001\000\000\000\000\000^\002\154\000\000\002\002\002\000-\000-\002\002\006\000\000\006\006\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\022\000\000\000\000\000\000\002\018\002J\002N\000\014\006\006\000\018\000\000\000\000\000\000\000\000\000-\000\022\000^\002R\002^\000\000\007\030\006I\0005\002j\000\000\002n\000\000\000\000\014\150\014\154\000\000\000\026\007\002\000\000\000\000\000\000\000\000\007\006\003\000\000\000\000\000-\000\030\000:\006I\000\000\000\000\006I\006I\000>\014\130\000J\000\000\000\000\000\000\000\000\000\000\000N\000Z\000\000\000\000\000\000\000^\002\154\005\133\002\000\000\0005\0005\002\002\006\000\000\006\006\006\000\000\000\000\002!\000\000\000\000\000\000\000\000\001\001\130\000\000\000\000\005\133\000\000\006I\005\133\005\133\006\006\000\000\000\000\000\000\000\000\001\0005\002!\002!\000\000\002!\002!\002\002\002!\000\000\000\000\000\000\000\000\007-\007-\014\150\014\154\000\000\000\000\007\002\000\000\000\000\000\000\006I\007\006\003\000\000\000\000\0005\002\018\000\000\002N\006I\000\000\005\133\005\146\007-\007-\000\000\007-\007-\000\000\000^\002R\002^(\154\000\000\002!\002!\002j\006I\002n\000\000\000\000\003.\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\001~\000\022\000\000\005\133\002!\000\000\0032\000\000\000\000\000\000\000\000\000\000\000\000\002!\002!\000\000\002!\000\000\007-\007-\003F\000\000\000\000\000\000\000\000\002!\005\137\002!\002!\000:\005\133\000\000\000\000\000\000\003^\011.\011N\000J\002!\002\000\000\000\000\002!\002!\002!\000\000\000\000\007-\000^\005\137\007-\007f\005\137\005\137\004M\t\026\tE\tb\000\000\006\006\006\002\002\000\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003.\000\014\006\006\000\018\000\000\000\000\004M\000\000\000\000\000\022\000\000\000\000\000\000\000\000\0032\000\000\000\000\005\137\005\146\000\000\017\000\000\017\006\004M#\026\000\000\007\002\000\000\003F\000\000\004M\005\146\003\000\000\004M\nQ\nQ\000:\000\000\000\000\000\000\000\000\003^\022\011N\000J\000\000\000\000\000\000\005\137\nQ\000\000\000\000\000\000\000\000\004\000^\nQ\000\000\007f\000\000\000\000\004M\t\026\000\000\tb\000\000\006\006\006\000\000\000\000\000\000\002\000\000\000\000\005\137\002\002\nQ\000\000\nQ\002\000\000\002\000\000\006\006\002\000\000\000\000\004M\nQ\nQ\nQ\006y\000\000\000\000\000\000\nQ\000\000\nQ\000\000\000\000\000\000\017\000\000\017\006\004M\0232\000\000\007\002\014*\014f\000\000\004M\000\000\003\006y\004M\000\000\006y\006y\000\000\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\016\002\001\001\000\000\000\000\000\000\000\000\002V\000\000\nQ\000\000\016\n\016\"\000\000\028v\000\000\000\000\000\000\000\000\006y\005\146\000\000\000\000\000\000\001\001\b\001\001\000\000\0142\015\016\018\016\026\016*\000\000\002\t\002\t\000\000\0162\000\000\000\000\000\000\014*\014f\000\000\000\000\000\000\000\000\b\000\000\006y\b\b\000\000\014n\000\000\000\000\000\000\015\015\015\015\015\016Z\000\000\000\000\000\000\000\000\001\001\000\000\016B\000\000\015\016\002\000\000\000\000\006y\016J\016R\002\t\002\138\000\000\000\000\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\b\005\146\000\000\002%\001\000\000\000\000\001\001\001\130\000\000\0142\015\016\018\016\026\016*\028\002\t\000\000\002\t\0162\000\000\000\000\001\000\000\002%\002%\000\000\002%\002%\002\002\002%\b\000\000\028\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016Z\002\t\000\000\000\000\000\000\000\000\000\000\002\018\016B\002N\000\000\000\000\000\000\000\000\b\016J\016R\000\000\000\000\000\000\000^\002R\002^\000\000\000\000\002%\002%\002j\000\000\002n\000\000\001\001\130\000\000\000\000\000\000\000\000\000\000\r\r\000\000\000\000\000\000\000\000\000\000\002%\001\000\000\002%\002%\000\000\002%\002%\001\002%\002%\000\000\002%\000\000\000\000\000\000\r\r\000\000\r\r\002%\000\000\002%\002%\000\000\000\000\000\000\000\000\000\000\001\000\000\003\130\000\000\002%\000\000\000\000\000\000\002%\002%\002%\000\000\000\000\003\"\003\004\001\000\000\002%\002%\004\000\000\005\n\000B\000\000\000\000\000\000\000\000\002!\002!\000\000\r\r\000\000\001\001\130\000\000\000\000\000\000\001\000\000\000\000\001\001\000\000\000\000\000\000\002%\002%\001\002%\002!\002!\000\000\002!\002!\001\000\000\000\000\002%\r\002%\002%\r\000\000\000\000\018N\000\000\000\000\027\002%\000\000\002%\000\000\000\000\000\000\002%\002%\001\003\"\003\130\000\000\000\000\000\000\001\005\146\000\000\000\000\0182\000\000\r\003\"\003\004\000\000\000\000\002!\002!\004\000\000\005\n\014\015\014\000\000\000\000\000\000\000\000\006y\017\130\000\000\011\005\006y\000\000\015\022\000\000\000\000\001\015\030\0156\015>\015&\015F\000\000\000\000\000\000\002!\002!\000\000\002!\000\000\000\000\000\000\015N\015V\000\000\000\000\000\000\002!\000\000\002!\002!\000\000\000\000\001\015^\015v\000\000\000\000\002!\000\000\002!\000\000\006y\002\138\002!\002!\000\000\000\000\001\001\130\024\000\000\000\000\014\015.\015f\015n\015~\000\000\000\000\000\000\000\000\015\134\001\000\000\000\000\014\015\014\000\000\000\000\023Z\017N\b&\006y\000\000\b\000\000\015\022\000\000\000\000\000\000\015\030\0156\015>\015&\015F\015\000\000\000\000\015\000\000\002\018\002J\002N\015\150\006y\015N\015V\000\000\000\000\006y\015\158\015\000\000\000^\002R\002^\000\000\015^\015v\000\000\002j\000\000\002n\000\000\rU\b\002\138\000\000\000\000\000\000\000\000\007\007\000\000\000\000\007\014\015.\015f\015n\015~\007\000\000\000\000\000\000\015\134\007\rU\000\000\000\000\rU\rU\000\000\000\000\"\030\000\000\000\000\b\000\000\000\000\007\000\000\000\000\011V\000\000\000\000\000\000\000\000\017z\007\015\000\000\000\000\015\007\007\007\007\015\150\b\000\000\002\000\000\000\000\b\015\158\015\000\000\007\000\000\000\000\007\rU\000\000\000\000\007\000\000\007\000\000\007\007\007\007\007\002\002\007\002\002\000\000\000\000\000\000\007\000\000\000\000\000\000\007\022\011b\007\007\000\000\000\000\007\011Z\rU\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\027\154\000\000\000\000\000\000\000\000\000\000\007\007\007\000\000\007\000\000\007\007\007\007\007\005\146\rU\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\001\001\130\007\000\000\028v\000\000\007\000\000\007\000\000\007\007\007\000\000\000\000\001\000\000\000\000\019F\000\000\000\000\000\000\002\002\026r\007\007\002\005\002\005\007\007\007\000\000\002\007\007\000\000\b\002\000\000\007\002\022\002\007\030\002\002\018\002J\002N\002\000\000\000\000\007\rQ\007\007\007\000\000\017\n\000^\002R\002^\007\000\000\007\000\000\002j\000\000\002n\007\007\007\007\002\005\002\138\000\000\rQ\000\000\000\000\rQ\rQ\000\000\000\000\007\000\000\000\000\007\000\000\000\000\000\000\007\000\000\007\000\000\007\007\007\007\007\000\000\000\000\007\028\002\005\000\000\002\005\000\000\007\000\000\000\000\000\000\007\022\011b\007\007\000\000\000\000\007\017\014\000\000\000\000\rQ\tE\tE\000\000\011]\007\000\000\000\000\000\000\024J\000\000\002\005\000\000\007\007\007\000\000\007\000\000\007\007\007\007\007\tE\tE\000\000\tE\tE\000\000\000\000\011]\rQ\007\024\025:\007\002\000\000\000\000\007\027\154\007\000\000\007\007\007\000\000\000\000\000\000\000\000\027\000\000\000\000\000\000\000\000\r\002\002\rQ\002\000\000\000\000\007\007\000\000\011\138\007\000\000\tE\tE\011\146\000\000\014*\014f\000\000\007\030\000\000\000\000\r\000\000\025F\025V\r\007\014n\007\000\000\007\015\015\015\015\015\007\000\000\000\000\000\000\tE\000\000\000\000\tE\000\000\002\138\015\016\002\000\000\tE\000\000\000\000\000\000\000\000\000\000\025r\000\000\000\000\016\n\016\"\000\000\002\000\000\000\000\000\000\000\000\r\005\146\000\000\000\000\tE\000\000\r\002\002\000\000\002\0142\015\016\018\016\026\016*\000\000\000\000\000\000\000\000\0162\002\000\000\014*\014f\t\002\000\000\000\000\r\000\000\000\000\002\r\000\000\014n\002\000\000\000\000\015\015\015\015\015\000\000\016Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016B\015\016\002\000\000\000\000\000\000\000\000\016J\016R\000\000\000\000\000\000\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\r\005\146\000\000\000\000\000\000\000\000\t1\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\000\000\000\000\0162\000\000\000\000\014*\014f\000\000\000\000\000\000\000\000\t1\000\000\000\000\000\000\t1\000\000\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\016Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016B\015\016\002\000\000\000\000\000\000\000\000\016J\016R\000\000\000\000\000\000\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\t1\005\146\000\000\000\000\000\000\000\000\t5\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\000\000\000\000\0162\000\000\000\000\014*\014f\000\000\000\000\000\000\000\000\t5\000\000\000\000\000\000\t5\000\000\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\016Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016B\015\016\002\000\000\000\000\000\000\000\000\016J\016R\000\000\000\000\000\000\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\t5\005\146\000\000\000\000\000\000\000\000\t-\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\000\000\000\000\0162\000\000\000\000\014*\014f\000\000\000\000\000\000\000\000\t-\000\000\000\000\000\000\t-\000\000\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\016Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016B\015\016\002\000\000\000\000\000\000\000\000\016J\016R\000\000\000\000\000\000\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\t-\005\146\007-\007-\000\000\000\000&\014\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\000\000\000\000\0162\000\000\000\000\014*\014f\007-\007-\000\000\007-\007-\018Z\000\000\000\000\000\000\000\000\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\016Z\000\000\000\000\000\000\000\000\000\000\000\000\001\150\016B\015\016\002\000\000\000\000\000\000\000\000\016J\016R\000\000\000\000\000\000\000\000\016\n\016\"\000\000\000\000\007-\007-\000\000\000\000\000\000\005\146\000\000\000\000\000\000\000\000&\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\000\000\000\000\0162\000\000\000\000\014*\014f\007-\000\000\000\000\007-\000\000\018\006\000\000\000\000\000\000\tI\014n\000\000\000\000\000\000\015\015\015\015\015&\018\016Z\000\000\000\000&\026\000\000\000\000\000\000\000\000\016B\015\016\002\000\000\000\000\000\000\000\000\016J\016R\000\000\000\000\000\000\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\146\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\000\000\000\000\0162\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0115\0115\000\000\000\000\0115\000\000\000\000\000\000\0115\0115\0115\000\000\0115\000\000\000\000\0115&\016Z\0115\007Z&\000\000\000\000\0115\000\000\016B\000\000\007Z\000\000\0115\000\000\000\000\016J\016R\000\000\000\000\000\000\0115\0115\000\000\007^\nu\000\000\0115\0115\000\000\0115\000\000\007^\000\000\000\000\0115\0115\000\000\0115\000\000\000\000\0115\000\000\000\000\0115\000\000\000\000\000\000\0115\0115\0115\0115\0115\0115\0115\000\000\0115\000\000\0115\0115\0115\0115\0115\000\000\000\000\000\000\000\000\000\000\000\000\014\015\014\0115\0115\000\000\0115\000\000\018\006\000\000\000\000\0115\0115\015\022\0115\000\000\000\000\015\030\0156\015>\015&\015F\000\000\000\000\000\000\000\000\000\000\000\000\0115\000\000\000\000\000\000\015N\015V\0115\000\000\0115\000\000\000\000\000\000\000\000\000\000\0115\000\000\015^\015v\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\015.\015f\015n\015~\000\000\000\000\000\000\000\000\015\134\000\000\000\000\014\015\014\000\000\000\000\000\000\000\000$\018Z\000\000*\027\016\150\000\000\015\022\000\000\000\000\000\000\015\030\0156\015>\015&\015F\018\n\015\000\000\000\000\018\022\000\000\000\000\000\000\000\000\015\150\015N\015V\000\000\001\001\130\000\000\015\158\015\000\000\000\000\000\000\000\000\015^\015v\000\000\000\000\000\000\000\000\001\000\000\000\000\002\138\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\014\015.\015f\015n\015~\000\000\000\000\000\000\000\000\015\134\003.\000\014\000\000\000\000\000\018\000\000\002\018\000\000\002N\000\000\000\022\000\000\000\000\000\000\000\000\0032\000\000\000\000\000\000\000^\002R\002^\r\149\018^\015\000\000\002j\018j\002n\022\000\000\000\000\015\150\000\000\000\000\000\000\000\000\000\000\000:\015\158\015\000\000\000\000\022\tv\011N\000J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000^\000\000\000\000\007f\000\000\000\000\000\000\t\026\000\000\tb\000\000\006\006\006\003.\000\014\000\000\000\000\000\018\000\000\000\000\004\000\000\003\000\022\000\000\000\000\000\000\000\000\0032\006\006\000\000\000\000\000\000\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\017\006\000:\026*\000\000\007\002\000\000\003^\011>\011N\000J\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000^\000\000\000\000\007f\000\000\000\000\000\000\t\026\000\000\tb\007\006\006\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014*\014f\000\000\006\006\000\000\000\000\024\024\000\000\007\000\000\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\000\000\000\000\017\006\000\000\024\000\000\007\002\000\000\000\000\015\016\002\000\000\003\000\000\000\000\000\000\000\000\000\000\t\000\000\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\146\000\000\000\000\000\000\000\000\014*\014f\000\000\000\000\000\000\0142\015\016\018\016\026\016*\t\000\000\014n\000\000\0162\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\016\002\000\000\000\000\000\000\000\000\007\000\000\016Z\012\000\000\000\000\016\n\016\"\000\000\000\000\016B\000\000\000\000\000\000\000\000\005\146\000\000\016J\016R\000\000\014*\014f\000\000\000\000\000\000\0142\015\016\018\016\026\016*\012\000\000\014n\000\000\0162\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\016\002\000\000\000\000\000\000\000\000\007\000\000\016Z\t\000\000\000\000\016\n\016\"\000\000\000\000\016B\000\000\000\000\000\000\000\000\005\146\000\000\016J\016R\000\000\014*\014f\000\000\000\000\000\000\0142\015\016\018\016\026\016*\t\000\000\014n\000\000\0162\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\016\002\000\000\000\000\000\000\000\000\012\000\000\016Z\006\000\000\000\000\016\n\016\"\000\000\000\000\016B\000\000\000\000\000\000\000\000\005\146\000\000\016J\016R\000\000\014*\014f\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\014n\000\000\0162\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\016\002\000\000\000\000\000\000\000\000\012\000\000\016Z\000\000\000\000\000\000\016\n\016\"\000\000\000\000\016B\000\000\000\000\000\000\000\000\005\146\000\000\016J\016R\000\000\003.\000\014\000\000\000\000\000\018\0142\015\016\018\016\026\016*\000\022\000\000\000\000\006\0162\0032\000\000\000\000\000\000\000\000\000\000\000\000\r\149\000\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000:\016Z\000\000\000\000\000\000\022\tv\011N\000J\016B\000\000\000\000\000\000\000\000\000\000\000\000\016J\016R\000\000\000^\000\000\000\000\007f\000\000\000\000\000\000\t\026\000\000\tb\000\000\006\006\006\000\000\000\000\000\000\000\000\000\000\000\000\000B\000\000\000\000\002\146\000\000\000\000\000\000\000\000\000\000\002\006\006\000\000\000\000\000\000+V\000\000\t\000\000\000\000\000\000\000\000\r\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\017\006\000\000+\000\000\007\002\002\002\000\000\000\000\000\000\003\000\000\002\000\000\002\000\000\000\000\000\000\000\000\000\000\000N\002\000\000\000\000\000\000\003\"\006\000\000\006\000\000\000\000\000\000\006\007&\007J\000\000\b\030\b\"\b&\000\000\000\000\000\000\000\000\000\000\003.\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\bF\bJ\000\000\000\000\0032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\tI\tI\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\bR\000\000\000:\001\001\130\011\158\bV\003^\011>\011N\000J\tI\tI\000\000\tI\tI\000\000\000\000\001\000\000\007\021\000^\000\000\000\000\007f\002\002\000\000\000\000\t\026\000\000\tb\000\000\006\006\006\003.\000\014\018\027\000\018\000\000\000\000\000\000\000\000\000\000\000\022\000\000\002\018\000\000\002N\0032\006\006\000\000\000\000\024\tI\tI\000\000\000\000\000^\002R\002^\000\000\003F\007\021\007\021\002j\000\000\002n\000\000\000\000\017\006\000:\025\022\000\000\007\002\000\000\003^\011\011N\000J\003\000\000\000\000\tI\000\000\000\000\tI\000\000\000\000\000\000\000^\000\000\tI\007f\000\000\000\000\000\000\t\026\000\000\tb\000\000\006\006\006\003.\000\014\000\000\000\000\000\018\000\000\000\000\019\022\000\000\tI\000\022\000\000\000\000\007\021\000\000\0032\006\006\000\000\000\000\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\017\006\000:!\000\000\007\002\000\000\003^\r>\011N\000J\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000^\000\000\000\000\007f\000\000\000\000\000\000\t\026\016f\tb\000\000\006\006\006\014\001\014\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014*\014f\000\000\000\000\014\001\006\006\016j\000\000\rN\000\000\014\001\014n\000\000\027\130\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\017\006\000\000\017\022\000\000\007\002\015\016\002\014\001\014\001\014\001\003\000\000\000\000\000\000\000\000\016~\000\000\016\n\016\"\000\000\014\001\014\001\014\001\000\000\000\000\000\000\005\146\014\001\000\000\014\001\000\000\000\000\014*\014f\000\000\000\000\0142\015\016\018\016\026\016*\016\130\000\000\000\000\014n\0162\000\000\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\016\002\000\000\000\000\000\000\000\000\000\000\016Z\000\000\000\000\000\000\000\000\016\n\016\"\000\000\016B\000\000\000\000\000\000\000\000\000\000\005\146\016J\016R\000\000\000\000\016\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\000\000\000\000\0162\000\000\000\000\014*\014f\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\016Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016B\015\016\002\000\000\000\000\000\000\000\000\016J\016R\000\000\000\000\016\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\146\000\000\000\000\000\000\000\000\000\000\014*\014f\000\000\000\000\0142\015\016\018\016\026\016*\016\000\000\000\000\014n\0162\000\000\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\016\002\001\001\130\000\000\000\000\000\000\016Z\000\000\000\000\000\000\000\000\016\n\016\"\000\000\016B\000\000\001\000\000\000\000(v\005\146\016J\016R\002\002\000\000\000\000\000B\000\000\000\000\002\146\0142\015\016\018\016\026\016*\002\000\000\000\000\000\000\0162\000\000(6\000\000\t\000\000\002\018\002J\002N\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000^\002R\002^\000\000\002\002\016Z\002j\000\000\002n\000\000\002\000\000\002\016B\000\000\000\000\000\000\000\000\000N\002\016J\016R\000\000\003\"\006\000\000\006\000\000\000\000\000\000\006\007&\007J\000\000\b\030\b\"\b&\000\000\000\000\000\000\000\000\000\000\003.\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\bF\bJ\000\000\000\000\0032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\tM\tM\000\000\000\000\000\000\003F\000\000\000\000\000\000\n\000\000\000\000\bR\000\000\000:\001\001\130\011\158\bV\003^\022\011N\000J\tM\tM\000\000\tM\tM\000\000\000\000\003\000\000\000\000\000^\000\000\000\000\007f\001\000\000\000\000\t\026\000\000\tb\000\000\006\006\006\003.\000\014\000\000\027\000\018\000\000\000\000\000\000\000\000\000\000\000\022\000\000\001\005n\003\130\0032\006\006\000\000\000\000\023\006\tM\tM\000\000\000\000\003\"\003\004\000\000\003F\000\000\000\000\004\000\000\005\n\000\000\000\000\017\006\000:\023\014\000\000\007\002\000\000\003^\tv\011N\000J\003\000\000\000\000\tM\000\000\000\000\tM\000\000\000\000\000\000\000^\000\000\tM\007f\000\000\000\000\000\000\t\026\016f\tb\000\000\006\006\006\001\001\130#\030\000\000\000\000\000\000\000\000\000\000\000\000\tM\000\000\014*\014f\000\000\000\000\001\006\006\"J\000\000\026\000\000\023Z\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\017\006\000\000\026\000\000\007\002\015\016\002\002\018\002J\002N\003\000\000\000\000\000\000\000\000\016~\000\000\016\n\016\"\000\000\000^\002R\002^\000\000\000\000\000\000\005\146\002j\000\000\002n\000\000\000\000\014*\014f\000\000\000\000\0142\015\016\018\016\026\016*\"V\000\000\000\000\014n\0162\000\000\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\016\002\000\000\000\000\000\000\000\000\000\000\016Z\000\000\000\000\000\000\000\000\016\n\016\"\000\000\016B\000\000\000\000\000\000\000\000\000\000\005\146\016J\016R\000\000\000\000\016\000\000\000\000\000\000\000\000\0142\015\016\018\016\026\016*\000\000\000\000\000\000\000\000\0162\000\000\000\000\014*\014f\000\000\000\000\000\000\000\000\000\000$\000\000\000\000\000\000\000\000\014n\000\000\000\000\000\000\015\015\015\015\015\000\000\016Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016B\015\016\002\000\000\000\000\000\000\000\000\016J\016R\000\000\000\000\016\000\000\016\n\016\"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\146\000\000\000\000\000\000\000\000\000\000\014*\014f\000\000\000\000\0142\015\016\018\016\026\016*$\000\000\000\000\014n\0162\000\000\000\000\015\015\015\015\015\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\016\002\001\001\130\000\000\000\000\000\000\016Z\000\000\000\000\000\000\000\000\016\n\016\"\000\000\016B\000\000\001\000\000\000\000\000\000\005\146\016J\016R\002\002\000\000\003.\000\014\000\000\000\000\000\018\0142\015\016\018\016\026\016*\000\022\000\000\000\000\026.\0162\0032\000\000\000\000\000\000\000\000\002\018\026n\002N\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\000\000\000^\002R\002^\000\000\000\000\000:\016Z\002j\000\000\002n\003^\tv\011N\000J\016B\000\000\000\000\000\000\000\000\007\021\000\000\016J\016R\000\000\000^\001\001\130\007f\000\000\000\000\000\000\t\026\000\000\tb\000\000\006\006\006\000\000\000\000\001\000\000\007\021\000\000\000\000\007\021\007\021\001\000\000\000\000\000\000\000\000\000\000\000\000\006\006\000\000\b+\001\000\000\000\000\000\000\003z\000B\000\000\000\000\002\146\000\000(V\000\000\003\130\000\000\002\000\000\017\006\000\000,\002\003~\007\002\000\000\000\000\003\"\003\004\003\000\000\007\021\007\021\004\000\000\005\n\007j\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\007n\007\134\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\021\003\"\000\000\000\000\007\000\000\tE\000\000\007\007\021\007\b\022\b\030\b\"\b&\000\000\020\000\000\000\000\000\000\000\000\000\000\007\021\000\000\000\000\003z\000B\007\021\000\000\002\146\000\000\bF\bJ\000\000\bN\002\000\000\000\000\000\000\000\000\003~\000\000\t>\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\001\001\130\007j\000\000\bR\001\011\022\000\000\000\000\000\000\bV\002\000B\000\000\000\000\003\007n\007\134\000\000\002\000\000\000\000\021\000\000\000\000\000\000\000\000\000\000\001\000\000\003\"\001\001\007\000\000\000\000\000\000\007\000\000\007\b\022\b\030\b\"\b&\001\005n\003\130\000\000\000\000\000\000\000\000\000\000\003z\000B\000\000\018N\002\146\003\"\003\004\bF\bJ\002\bN\004\000\000\005\n\003~\003\"\000\000\000\000\000\000\t\030\001\005\146\000\000\000\000\0182\000\000\000\000\000\000\007j\000\000\000\000\000\000\bR\000\000\n\000\000\000\000\002\bV\000\000\000\000\000\000\007n\007\134\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\003\"\000\000\000\000\007\000\000\000\000\000\000\007\t\007\b\022\b\030\b\"\b&\003.\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\001\000\022\000\000\000\000\000\000\000\000\0032\bF\bJ\000\000\bN\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000:\001\001\130\bR\000\000\003^\003v\000\000\000J\bV\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\007\021\000^\000\000\000\000\007f\002\002\000\000\000\000\t\026\000\000\tb\tr\006\006\006\003.\000\014\018\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\000\000\002\018\000\000\002N\0032\006\006\000\000\t\138\000\000\000\000\000\000\000\000\000\000\000^\002R\002^\000\000\003F\007\021\007\021\002j\000\000\002n\000\000\000\000\000\000\000:\000\000\000\000\007\002\000\000\003^\011\011N\000J\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000^\000\000\000\000\007f\000\000\007\021\000\000\t\026\000\000\tb\000\000\006\006\006\007\021\000\000\000\000\000\000\000\000\003.\000\014\019\022\000\000\000\018\000\000\000\000\000\000\007\021\000\000\000\022\006\006\007\021\000\000\0032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\017\006\000\000\000\000\000\000\007\002\000\000\000:\000\000\017:\000\000\003\003^\r.\011N\000J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000^\000\000\000\000\007f\014\015\014\000\000\t\026\000\000\tb\000\000\006\006\006\016\000\000\015\022\000\000\000\000\000\000\015\030\0156\015>\015&\015F\000\000\000\000\000\000\000\000\000\000\006\006\000\000\000\000\000\000\015N\015V\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015^\015v\000\000\000\000\017\006\000\000\000\000\000\000\007\002\002\138\000\000\000\000\017:\000\000\003\000\000\000\000\000\000\000\000\014\015.\015f\015n\015~\000\000\000\000\000\000\000\000\015\134\003.\000\014\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000\000\000\000\000\000\0032\000\000\000\000\000\000\000\000\000\000\000\000&\000\000\015\000\000\000\000\000\000\000\000\003F\000\000\000\000\015\150\000\000\000\000\000\000\000\000\000\000\000:\015\158\015\000\000\000\000\003^\tv\011N\000J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000^\000\000\000\000\007f\014\015\014\000\000\t\026\000\000\tb\000\000\006\006\006\"b\000\000\015\022\000\000\000\000\000\000\015\030\0156\015>\015&\015F\000\000\000\000\000\000\000\000\000\000\006\006\000\000\000\000\023\015N\015V\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015^\015v\000\000\000\000\017\006\000\000\000\000\000\000\007\002\002\138\000\000\000\000\000\000\000\000\003\014\015\014\000\000\000\000\014\015.\015f\015n\015~\000\000$\000\000\015\022\015\134\000\000\000\000\015\030\0156\015>\015&\015F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015N\015V\000\000\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\000\015^\015v\000\000\015\150\000\000\000\000\000\000\000\000\000\000\002\138\015\158\015\000\000\000\000\003.\000\014\000\000\000\000\000\018\014\015.\015f\015n\015~\000\022\000\000\000\000\000\000\015\134\0032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000:\015\000\000\000\000\000\000\003^\tv\011N\000J\015\150\000\000\000\000\000\000\000\000\000\000\000\000\015\158\015\000\000\000^\002\002\007f\000\000\000\000\000\000\t\026\000\000\tb\000\000\006\006\006\000\000\000\000\003\154\002\003\158\b\003\n\003\014\000\000\000\000\000\000\001\001\130\000\000\000\000\000\000\006\006\007\b+\150\000\000\000\000\000\000\000\000\000\000\001\000\000\007\025\000\000\007\007\000\000\002\002\000\000\000\000\000\000\017\006\007\021\000\000\000\000\007\002\000\000\000\000\001\001\130\000\000\003\000\000\b*\b.\b2\b6\b:\000\000\002\018\000\000\002N\b>\001\000\000\007\021\000\000\000\000\007\021\007\021\001\000\000\000^\002R\002^\000\000\000\000\007\025\007\025\002j\000\000\002n\001\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\001\000\000\003\130\b\000\000\b\000\000\000\000\000\000\000\000\b\b\000\000\003\"\003\004\000\000\007\025\007\021\007\021\004\000\000\005\n\001\001\130\000\000\007\025\000\000\000\000\000\000\000\000\000\000\000\000\019\"\000\000\000\000\000\000\000\000\001\007\025\007\025\000\000\000\000\007\025\007\025\001\000\000\000\000\020\134\000\000\007\021\000\000\000\000\000\000\000\000\000\000\001\001\130\000\000\007\021\000\000\000\000\000\000\000\000\000\000\000\000\020\001\000\000\003\130\000\000\001\007\021\007\021\000\000\000\000\007\021\007\021\001\000\000\003\"\003\004\000\000\000\000\007\025\007\025\004\000\000\005\n\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\003\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\"\003\004\000\000\007\025\007\021\007\021\004\000\000\005\n\000\000\007\021\000\000\007\025\000\000\000\000\000\000\001\001\130\000\000\020\000\000\000\000\000\000\000\000\000\000\007\025\000\000\000\000\000\000\000\000\007\025\001\000\000\007\021\020\000\000\007\021\007\021\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\020\000\000\000\000\000\000\000\000\000\000\007\021\000\000\001\000\000\003\130\000\000\007\021\000\000\000\000\000\000\000\000\000\000\001\001\130\000\000\003\"\003\004\000\000\000\000\007\021\007\021\004\000\000\005\n\000\000\000\000\001\000\000\007\021\000\000\000\000\007\021\007\021\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\020\000\000\007\021\000\000\000\000\000\000\001\000\000\003\130\000\000\007\021\000\000\000\000\000\000\000\000\000\000\001\001\130\020\003\"\003\004\000\000\000\000\007\021\007\021\004\000\000\005\n\000\000\000\000\001\000\000\007\021\000\000\000\000\007\021\007\021\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\020\000\000\007\021\000\000\000\000\000\000\001\000\000\003\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000=\000\000\020\003\"\003\004\001\001\130\007\021\007\021\004\000\000\005\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000=\000=\000\000\000=\000=\001\000\000\000\000\000\000\001\001\130\000\000\000\000\000\000\000\000\021\014\000\000\007\021\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000=\001\000\000\003\130\000\000\002\002\000\000\020\000\000\000\000\000\000\000A\000\000\007\021\003\"\003\004\001\001\130\000=\000=\004\000\000\005\n\000\000\000\000\000\000\002\018\000\000\002N\000\000\000\000\001\000\000\000A\000A\000\000\000A\000A\001\000^\002R\002^\000\000\000\000\000=\000=\002j\000\000\002n\000\000\000=\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\003\130\000\000\000\000\000\000\000=\000\000\000\000\000\000\000\000\000\000\000\000\003\"\003\004\000=\000=\000A\000A\004\007\029\005\n\000\000\000\000\000\000\000\000\001\001\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000=\007\029\000\000\000\000\007\029\007\029\001\000A\000\000\000\000\001\001\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000A\000\000\001\000\000\007\021\001\000\000\003\130\000\000\002\002\000A\000A\000\000\000\000\000\000\000\000\000\000\000\000\003\"\003\004\018\000\000\007\029\007\029\004\000\000\005\n\000\000\000\000\000\000\018\000\000\002N\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000^\002R\002^\000\000\000\000\007\021\007\021\002j\000\133\002n\000\000\007\029\000\000\000\000\001\001\130\000\000\000\000\000\000\000\000\007\029\000\000\000\000\000\000\000\000\000\000\000\000(N\000\000\001\000\000\000\133\000\133\007\029\000\133\000\133\001\007\021\007\029\000\000\000\000\000\000\000\137\tE\000\000\000\000\007\021\000\000\001\001\130\000\000\000\000\000\000\019\022\000\000\000\000\000\000\000\000\001\007\021\003\130\000\000\000\000\001\007\021\000\137\000\137\000\000\000\137\000\137\001\003\"\003\004\000\000\000\000\000\133\000\133\004\000\000\005\n\000\000\000\000\000\000\000\000\000\000\000\157\000\000\000\000\000\000\000\000\000\157\001\000\014\003\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\"\003\004\000\133\000\000\000\137\000\137\004\000\157\005\n\000\000\000\157\000\157\000\000\000\000\000\000\000\000\005\154\000\000\000\000\000\000\000\000\000\000\001\001\130\000\000\000\000\000\000\000\000\000\000\000\133\022\000\000\001\022\000\000\000\000\000\137\001\000\000\007\029\000\000\000\000\000\157\003\"\002\002\000\000\000\000\000\157\000\000\000\000\000\000\000\000\022\000\000\000\000\001\001\130\000\157\000\157\000\000\000\000\000\000\000\000\000\137\000\000\000\000\002\018\000\000\002N\000\000\001\023\000\133\000\133\000\000\000\000\000\000\002\002\000\000\000^\002R\002^\000\000\000\000\007\029\007\029\002j\000\000\002n\000\157\000\000\000\000\000\000\001\001\130\000\000\000\000\023\000\000\002\018\000\000\002N\000\000\000\000\000\000\000\000\024\022\000\000\001\000\000\000\137\000\137\000^\002R\002^\002\002\007\029\000\133\000\133\002j\000\000\002n\000\000\000\000\000\000\007\029\000\000\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\000\000\002\018\007\029\002N\000\000\000\000\000\000\007\029\000\000\000\000\000\133\000\133\000\000\000\133\000^\002R\002^\000\000\000\000\000\137\000\137\002j\000\000\002n\001\001\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\133\007\021\000\000\000\000\000\000\000\000\002\002\000\000\000\137\000\137\000\000\000\137\000\000\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\001\001\130\000\000\000\000\000\000\000\000\002\018\000\000\002N\000\000\000\000\000\000\000\000\000\000\000\000\001\000\137\007\021\000\000\000^\002R\002^\002\002\000\000\007\021\007\021\002j\000\000\002n\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\018\000\000\002N\000\000\000\000\000\000\000\000\000\000\000\000\000\000*N\000\000\007\021\000^\002R\002^\000\000\000\000\007\021\007\021\002j\000\000\002n\001\001\130\000\000\000\000\000\000\019\022\000\000\000\000\000\000\000\000\000\000\007\021\000\000\000\000\000\000\001\000\000\007\021\000\000\000\000\000\000\000\000\002\002\000\000\000\000*f\000\000\007\021\000\000\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\001\001\130\000\000\000\000\000\000\019\022\002\018\000\000\002N\000\000\000\000\007\021\000\000\000\000\000\000\001\000\000\007\021\000\000\000^\002R\002^\002\002\000\000\007\021\007\021\002j\000\000\002n\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\018\000\000\002N\000\000\000\000\000\000\000\000\000\000\000\000\000\000*z\000\000\007\021\000^\002R\002^\000\000\000\000\007\021\007\021\002j\000\000\002n\001\001\130\000\000\000\000\000\000\019\022\004\005\004\005\000\000\000\000\000\000\007\021\000\000\004\005\000\000\001\000\000\007\021\000\000\000\000\000\000\000\000\002\002\000\000\000\000*\138\000\000\007\021\000\000\004\005\004\005\000\000\004\005\004\005\018\000\000\000\000\000\000\001\001\130\000\000\000\000\000\000\019\022\002\018\000\000\002N\000\000\000\000\007\021\000\000\000\000\000\000\001\000\000\000A\004\005\000^\002R\002^\002\002\000\000\007\021\007\021\002j\000\000\002n\000\000\000\000\004\005\000\000\000\000\000\000\000\000\004\005\004\005\000\000\000\000\004\005\000\000\000\000\000\000\002\018\000\000\002N\000\000\000\000\000\000\000\000\000\000\000\000\000\000*\154\000\000\007\021\000^\002R\002^\000\000\000\000\000A\000A\002j\004\005\002n\000\000\004\005\000\000\000\000\000\000\019\022\000\000\b\146\000\000\000\000\000\000\007\021\000\000\000\000\000\000\000\000\000\000\004\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000A\004\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000A"))
  
  and lhs =
    (16, "\000\006\000\005\000\004\000\003\000\002\000\001\000\000\0017\0017\0017\0017\0016\0016\0016\0016\0016\0016\0016\0015\0015\0015\0014\0014\0014\0014\0014\0014\0014\0014\0013\0013\0012\0012\0011\0011\0011\0011\0011\0011\0010\0010\001/\001/\001/\001/\001/\001/\001/\001/\001.\001.\001.\001.\001.\001.\001.\001-\001,\001,\001+\001+\001+\001+\001*\001*\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001)\001(\001(\001'\001'\001'\001&\001&\001&\001&\001&\001&\001&\001&\001&\001%\001%\001%\001%\001$\001$\001#\001#\001#\001\"\001\"\001\"\001!\001!\001!\001!\001!\001!\001!\001!\001!\001!\001!\001!\001!\001!\001!\001 \001 \001 \001 \001 \001 \001\031\001\030\001\030\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\028\001\028\001\027\001\027\001\027\001\027\001\026\001\026\001\026\001\026\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\025\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\024\001\023\001\023\001\023\001\023\001\023\001\023\001\023\001\023\001\023\001\023\001\023\001\022\001\022\001\022\001\022\001\022\001\022\001\021\001\020\001\020\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\019\001\018\001\018\001\018\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\017\001\016\001\016\001\016\001\015\001\014\001\014\001\014\001\014\001\014\001\r\001\r\001\012\001\012\001\011\001\n\001\t\001\b\001\007\001\006\001\005\001\004\001\004\001\003\001\002\001\002\001\001\001\000\001\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\159\000\158\000\157\000\156\000\155\000\154\000\153\000\152\000\151\000\150\000\149\000\148\000\147\000\146\000\145\000\144\000\143\000\142\000\141\000\140\000\139\000\138\000\137\000\136\000\135\000\134\000\133\000\132\000\131\000\130\000\129\000\128\000\127\000~\000}\000|\000|\000|\000|\000|\000{\000{\000{\000z\000z\000z\000y\000y\000x\000x\000w\000w\000v\000u\000t\000s\000r\000q\000q\000p\000p\000o\000n\000n\000m\000l\000l\000k\000j\000i\000h\000h\000g\000f\000e\000d\000d\000c\000c\000c\000c\000c\000c\000b\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000a\000`\000`\000_\000_\000^\000^\000]\000]\000\\\000\\\000[\000[\000Z\000Z\000Y\000Y\000X\000X\000W\000V\000U\000U\000T\000T\000S\000R\000R\000Q\000Q\000P\000O\000N\000M\000M\000L\000L\000K\000K\000K\000J\000I\000I\000H\000G\000F\000F\000F\000F\000E\000D\000D\000C\000C\000B\000B\000A\000A\000@\000@\000?\000?\000>\000>\000=\000=\000<\000<\000;\000;\000:\000:\000:\0009\0008\0007\0006\0006\0005\0004\0004\0003\0002\0002\0002\0002\0002\0002\0002\0002\0002\0002\0002\0001\0000\0000\000/\000/\000.\000-\000,\000,\000+\000*\000)\000)\000(\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000'\000&\000&\000%\000%\000%\000%\000$\000#\000#\000\"\000\"\000\"\000!\000!\000 \000 \000 \000 \000 \000 \000\031\000\030\000\029\000\029\000\028\000\028\000\027\000\027\000\027\000\027\000\027\000\027\000\027\000\026\000\025\000\025\000\024\000\024\000\023\000\023\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\021\000\021\000\020\000\019\000\018\000\017\000\017\000\017\000\016\000\016\000\015\000\014\000\014\000\r\000\r\000\012\000\012\000\012\000\012\000\012\000\012\000\011\000\011\000\011\000\n\000\n\000\t\000\t\000\t\000\t\000\b\000\b\000\007\000\007")
  
  and goto =
    ((16, "\006Z\016\134z\000\000\000\000\000\000\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 d\000\000\134\000\000\001o\001[\135.a&\0003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\007\000\127\000\000\000\000\000\000\000U\000\000\000\000\000\000\000\000\000\000\000;\000\000\000\000\000\000\000\018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000o\000\000\000\000\000\000\002\000\n\030\000\000\n\000=\000\000\000\000\000\000\000\000\000\000\001\132\000\000\002\023\000\000\0005\011P\000\136\000\000\001\156\000\000\000\000\000\000\024L\001\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000gV\004\150\000\000\003\030\000\000\000\n\003\"\000\000\t,+\002\000\155\000\000\000\000\001>\000\000\000\000\001\000\024\b*\000\000\135N\000Y}\\&n\000\000\135h\000\000\000\000\000!\128\000\000\000\000\000\000\135h\000\000\132\024&\135\140\002F\000\000:\000\000\000\000\000\000\000\000!\128\000\000\000\000\000\000\000\000\000\000\000\026\nB:\000\000\000\t\130/\136\000\000\0042\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\020\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\003f\000]\000\000g\001\r\028\003\t\004\b\000\000\000\000\000\000\000\000\000\000\003H\004\000\000\000\000\000\000+\000\000\000\000\000\000\000!\000\000\0054\000\000\017N\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004F\000\000\000\000\000\000\000\000\000\000+\000\000\000\000\000\000\000\000\004\000\000\000\000\002|ht\000\000\000\000\000\000\002\154\000\000\000\000\000\000\006n\000\000\029H\000\000\000\000-\142\029\000\000\000\000\000\000\000\000\000\000#\018\000\000\000\000\002\000\000\003f\000\000\000\000\000\000\000r\000\000\000\000\004\150\000\000\000\000\000\000\006\128\000r\000\000\000\000\000\000\000\000%\000\000\000\000\000\000\000\000\000\000\006\130\004F\000\000X\002\016%\000\000\000\000\005h\002\012\t\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\006\000\000\006\001\004^\011N\000\000\007\022\006B\003r$6\000\000\000\000\012\012\r:\000r\006Z\000\000\000\000\000\000\000\000'H\135\152\000\027\000\000;P'\136(b\135\000\000\000\000\000\000\000\000\000\000\000\000\135\000\000\000\000\000\000\136\024\000\000\003^;\003N\000\000\007.\006\000\000\000\000\000\000\000\000\000\000\001\020\000\000\000\000\bN\000\000\000\000(\158)|\000\000\000\000\000\000\000\000\000\000\000\000\000\000\030r\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\007Z\000\000\000\000\000\000\000\000\000\000\000\000\000\000)\002|\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\016\b\130\000\000\000\000\000\000\000\0000\"\bB\030r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\000\000\007\000\000\000\000\000\000\000\000\000\000\002j\000\000\000\000\007\128\000\000\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\021G\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\128/\000\000\007\128\t\132\000\000\t\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000 T\"\b\000\000\t8\000\000\000\000\000\000\000\000\000\0000\1440\000\0001h\000\000\000\000\000\000\000\000\000\000\000\000\002*\000\000\000\000\000\000N4\000\020\000\000\000\000\000\000 E\000\000\000\000\000\000\000\000\004\154\000\000\000\000\007\000\000U\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007_z\000\000\000\000\000\000\007l\130\000\000\007\t\000\000\000\020\000\000\000\000\000\000\000\000\000\000h\000\0001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\014\000\000\000\000\000\000\000\000\000\000z\000\000\000\000\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000iv\000\000\000\000\000\000\000\000\000\000\000\000\nB\000\000\000\000\000\000\000\000\nN1\000\000\000\000\000\000\000\000\000\000\000\000\000\000w\154\007x\144\007\128\000\000\000\000\000\000\011\030\000\000\000\000\000\000j(\000\020\000\000\000\000\005\014\000\020\000\000\000\0007ted\000\000\000\000\136\138\000\000\nl\000\000\000\000\000\000\000\000\011!\015\017&\bN\004\011\004\r\026\136\137\020\000\000\000\000\000\000\137,\000\000\004\022<Z\137\128\137\158\000\000\nz\000\000\000\000<\000\000\020\000\000\000\000X\144\000\020\000\000\000\000j=\0262l\000\000\137\nL\000\000\000\000\137\137\000\000\000\000\000\000\012\000#\012\017p\001\149\n\146\000\000\000\000\000\000\000\000Ir\000\000\000\000\019<\000\000\000+\020=6 d\024\142\000+\000\000\005\006\000\000\000\000\000\000\000\000\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000>2\000\000\138\000\000\000\000\000\000\000\000\132\128\000\000\000\000\1336\000\000\000\000\000\000\000\000\000\000\000\000\138\138\000\000>N(\000\020\000\000\000\000p\000\020\000\000\000\000{>3\026\000\000\138\n\1398\139h\000\000\139\000\000>\000\000\004\138?z\139\000\000\000\000\000\000\000\000\133\000\000\000\000\000\000\000\000\000\000\000\000\000\000?\000\000\004@\024\140\b\000\000\000\0005\014<,>f\000\000\000\000\000\000\000\000\000\000\000X\000\000\000\000\012\000\000\000\025\000\000\000\000\000\000\000\000\000\000@\001VA\000\001VAf\001V\000\000%\000\000P\000\000\000\000\000\000\000\000Ar\001V\000\000A\001VBZ\140R\000\000\000\000=\133$\133\000\000\000\000\000\000\000\000\000\000\002d\000\000\000\000\011\000\000{J\000\000\000\000\000\000\000\000\000\000B\006zB\006zC\140\006z\000\000R\000\000\1348\000\000\000\000\000\000\000\000C\006z\000\000D\012\006zDH\006zD\006zEL\006zE\006zF&\006zF@\006zG\000\006zGt\006zG\128\006zG\006zH2\006zI \006zID\006zI\006zIJ`\006z\006zJ\006zJ\006zKT\006zK\006zL(\006z\006zL\138\001VL\156\001VM~\001VM\001VN0\001VN\152\001VN\001VOx\001VO\134\001VO\001VPt\001VQ&\001VQp\001VQ\001VR\002R\130\001V\001VR\001VS\001VS\001VTJ\001V\001V\000\000\000\000T\148\001VU\b\001V\000\000\000\000U\020\001VU\006z\000\000U\001V\000\000Vp\001V\001V\001V\000\000\000\000V\006zWX\001V\000\000\000\000W\006zX4\006z\000\000X@\006z\000\000X\006z\006z\006z\000\000\000\000\140^\000\000\026p\004FX\006z\000\000|\014\000\000\000\000\000\0003\000\000\000\000Yj\006zY\156\006zZf\006z\000\000\000\000\000|2\000\000\006z\006zZ\138\006z\000\000\137\020\000\0003X\000\000\002ti\000\000\027b\000\000\000\000j\132\000\000\000\000\011\000\0004,\000\000\000\000\000\000\003f\000\000\000\000j\000\000\006\n\000\000\000\000k>\000\000\000\000\000\000\006z\000\000\005x\000\000\000\000\006\006\000\000\000\000\006\000\000\000\000\000\000\018~ \000\n!\016\000\000\000($\014[\028\006z\000\000\b0\000\000\000\000\t^\000\000\000\000\tn\000\000\000\000\000\000\000(\000\000\000\000VR\002H\000\000\025*\011\002\000C\000\000\n\000\000\000\000\000\000\011\014\000\000\000\000\000\000\011\020\000\000\000\000\012\154\011\n\018\128\000k\140\000\000)X\000\000\000\000\000\000k\000\000\000\000k\000\000\000l@\000\000\003\000\000\012\140\004:\000\000\r\024L\012\154\004\000\000\014X\005,\000\000\014f\005n\000\000\000\000\016$\005\000\000\0162\005\000\000\000\000\017\006\b\000\000\017\006$\000\000\0200\0064\000\000\000\000\011\000\000\000\000\000\000\011\000\000\000\000\000\000\000\002\n\001;\000\000\000\000\000\000\000\000\005\018\012\026\000\000\000\000\000\000\000\000\011<\000\000\019\026\000\000l\000\000\000\000\004r\000\000\000\000\000\n\012\011d\000\000\002T\000\000\004\004\r\142\r.\000\000m \000\000\012\r\030\000\000\006\028\000\000\006.\000\000\006\022d\004P\000\000\000\000\006V\000\000\006\128\000\000mn\000\000%m\000\000\006\148\000\000\022\004~\006\152\000\000\006\000\000\000\000\025p\004\006\000\000\006\000\000\0308\005:\006\000\000\007\020\000\000$\b\005R\007$\000\000\0074\000\000\006\132\000\000\007\026\000\000n(\000\000\001l\000\000\004\b\000\000\012\024\002\000\000\000\000\000\000\000\007`n\150\000\000\000\000\000\000\000\000\000\000\000\005\r*\012\000\000n\000\000\014\"\012\000\000o0\000\000\007|\000\000\000\000o\158\000\000\r\000\000\r\018\000\000\"\r\002\000\000\000\000\r\012\000\000o\000\000\007\000\000\000\000\000\000\000\000\014V\rd\000\000#\007\000\000\004\144\000\000\000\000\000\000\000\000\000\000\029%\004\028\b\000\000\000\000\000\000\000:h\000\000p8\000\000\b8\000\000\000\000\bd\000\000\000\000\014F\001\000\000\000\000\000\000\000\000\004\028\000\006\rt\000\000\000\000\000\000\000\000\000\000\b|\000\000\000\000\r0$\002\000\000\000\000\004\026\030V\014*Vp\000\020\000\000\000\000x\000\020\000\000\000\000yb[@\006z\027\018\004F[\006zy\000\000\000\000\000\000\000\000\006\n\014\018\014\020\000\000\000\000q\020\000\0004:\000\000\006z\r\000\000\000\000qP\000\0005\000\000\000\000\000\\.\006z\000\000y\000\000\000\000\000\000\000\000q`\000\000\\<\006z\000\000\\\154\006z\b\000\000\b\000\000,\154\000\000H\000\"\128\006N\030%\000\000\000\000\000\000cR\025\000\000\001\002\000\000\000\000\000\000\000\000\000\000\000\00050\000\000\000\000\000\000\000\000\002/z\000\000\000\000\0140\000\000\000\000\000\128\003.\014\014\014\000\000q\000\000\000\000\b\000\000\014\000\000\014\028\000\000r\142\000\000\000\000\014\030\015r\\\001V\000\000]n\001V\000O\0144\014@\000\000$\146\000\000|]\001V]\001V%\024\014p\000\000r\000\000^\001V\000\000s\024\000\000\000\000_\024\001V\000\000\000\000\000\000z\0068\004F_v\001V\000\000\000\000\000\000\b\000\000\006r\t&\000\000\000\000_\001V\000\000\015\030%\001\002\000\000\000\000\t2\000\000_\t\156\000\000\000\000\000\000\t\000\000\000\000\000\000\002\"\000\000\000\000\000\000\001\002\000\000\000\000*\t\000\000\000\000\000\000\000\000\000\000\001\002\000\000\000\0009~\007\004\028A\020B\004F|\152\004F}&\000\000\000\000\000\000\000\000\004F}x\000\000\000\000\000\000\000\000\001\002}\142\b|\000\000\007d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000*\026\000\r\000\000\000\000R\158Z\004F~\024\004F~d\000\000\000\000\000\000\000\000\004F~z\000\000\000\000'x\001\002\000\000\000\000\001\026.\002\001\002\002\000~\000\000\000\000\000\000. \001\002\000\000\r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\t\000\000\000\000\000\000\018\000\000\000\000\000\000\015\002\000(J\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000ZH%\000\000\000\000\000\000\006\138\000\000\n(\006\136\004\128\015\000\000\000\000s(\000\000sr\014\002\000\000 \018\000\000s\000\000\000\000\014\000\000\t\000\000\t\000\000\000\000\000\000\000\000\000\000\t\000\000\000\000\000\000\t\000\000\000\000\000\000\t\000\000\000\000\015\000\000\000\000\000\000|~\006\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128n2\150\015,\014\t\000\000\000\000\014N\n0\129\\\000\000\000\000\000\000\002\134\n\006\144\005&\015t,\000\000t\014\028\000\000\015\002\000\000\t\000\000\000\000\t\000\000\000\000\015\000\000\000\000\129\002\134\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000u\b\nH\000\000\b\148\014\000\000\000\000\000\000\000\000\000\000\000\000\r\015\000\004\000\000\000\000\0050\015\014N\000\000\n\142\000\000\000\000\014\020\015X\n\154\000\000\000\000\014\020\007\n\000\000\000\000\014\018\b\144\n\000\000\000\000\001*\000\000uJ\000\000`J\001V\000\000`\001V\n\000\000\000\000\000\000\000\000\021\000\000\000\000\n\000\000\000\000\004,\000\000\000\000\000\000\b\015Z\000\000\000\000\129\0060\000\000\016\014\000\000ud\000\000\015\015\000\000\n\000\000\014\138-d\t8\000\0000\tX\000\000\000\0004P\tn\000\0005|\t\000\0006r\t\000\000\n\000\000\t\b\000\000\014`\002\b\158\r\n\000\000\000\000\014f\002\127\004\000\000\0110\000\000\000\000@$\000\000\000\000\000\000\000\000\000\000\000\000\000\130\024\002\134\000\130H\002\134\000\000\000\000\000\000\002t\000\000\015X\011p\000\000\011\132\000\000\015j\000\000\130v\002\134\011\000\000\000\000\000\000\014H\0160\000C\005Z\012\011\000\000\000\000\014V\015\130\011\000\000\000\000\014X\n\011\000\000\000\000\014Z\n\b\011\000\000\000\000\011\000\000\000\000\000\000\000\000\000\000\000\000\002\134\000\000\130\002\134\002\134.\014\000(\000\000\000\000\000\000\000\000\n1\000(\1310\000\0002\000(\002\134\000\000\000\000\000\000\015\012\012\000\000\012\014\000\000\020J\000\000\000\000\000\000\000\000\000\000\016\004\000\000\015\003\012\020\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\138\000\000\000\000\000\000\131:\002\134\000\000\131\142\006\138\006\138\000\000\000\000\000(\000\000\000\000\000\000\000(\000\000\000\000\131\006\138\000\000\000\000\002\134\000\000\n2\000+\000+\n\000\000\000\000\000\000\000\0005t\000\000\nL\000\000\000\000\000\0005\000\000\n\130\000\000\000\000+\144\000\000\0156\134\000\000\000\000\000\000\000\000,\0006\000\000\000\000\015,r\000\000\000\000\000\000\000\000\n\015\000\000\000\000\000\000\000\000\0007D\000\000\000\000\000\000\000\002\000\000\000\000`\001V\000\000\000\000\000\000\000\000\000\000\000\000\004\134\000\000\000\000a\\\001V\001V\127\024\004Fa\001V\127F\000\000\000\000\000\000\000\000b8\006zbf\001Vc$\001V\b\146\000\000\000\000\127\\\000\000\001V\001V\000\000c@\001V\000\000cn\006z\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000+\012\148\000\000\000\000\000\000\000\000\000\000\n\130\000\000\000\000-2\015\000\000\000\000\000\000-7\000\000\000\000\015.\018\000\000\000\000\000\000\000\000\n\016\004\000\000\000\000\000\000\002\128\000\000\000\000\000\000\000\000\000\000\000\000\020\144\015l\000\000u\000\0007\000\000\001V\000\000u\000\0008\000\000\000\000d,\001V\000\000z\000\000\000\000\000\000\012*\000\0009\014\016\012\003\012\000\000dZ\001V\000\000\000\000\012t\000\000\000\000\000\000\000\000\000\000\012\140\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016 \015\012Z\000\000\022\000\000\000\000\003x3:\000+\1322\002\1344\004\000+\000\000\000\000\012f\000\000\023\000\000\000\000\000\000\001\024\000\000\031\b\000\000\006h\016\026\025h\000\000\000\000\000\000\000\000\000\000\000\000\n7\006\000+\132\154\000\0009(\000+\000\000\000\000\000\000\012\000\000\000\000\000\000\000\000\000\001V\000\000d\001V\000\000e4\006z\000\000\000\000\000\000\005\000\000e\136\006z\026\148\014\000\000\000\000\000\000\016,\015\012n\000\000\027F\000\000\000\000\004\012p\000\000\027\000\000\000\000\000\000\002\028r\000\000\031\158\000\000\006z\016$\029$\000\000\000\000\000\000\000\000\000\000\029\000\000\000\014\000\000\000\000\000\000\000\000\000\000\016&\000\000\000\000\000\000\001V9*\016P\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\014\000\000\000\000\000\000\000\000\134R\000\000\000\000\001V\000\000\b0\000\000\t^\000\000\000(\000\000\000(\006\138\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\127\158\000\000\000\000\000\000\000\000\012b\000\000\000\000\000\000z\007{\b\007\128\000\000\000\000\000\000e\006z\000\000\000\000\001V\000\000\005x\000\000\006\006\000\000\000(\000\000\000+\000\000\014`\000\000\000\000\000\000\000\000\000\000f\006zf\006z\000\000\016V\000\000\000\000\000\000\011:\000\000\000\000\000\000\000\000\001V\000\000\016`\000\000\000\000\000\000\140z\000\000\000\000\000\000\000\000\000\000\000\000\016h\000\000\000\000\000\000\000\000\000\000\000\000\000\000.\000\000\000\000\005\000\014\000\000\000\000\000\000\000\000%z\011$\000\000\000\000\000\000\006\020\000\000\000\000\000\000\016x\000\000\000\000#&\000\000\000\000\000\000\000\000\000\000&\128\000\000\000\000\000\000\000\000\000\000\000\000\012\004\000\000\004F\000\000\128\004\000\000\128\000\000\000\000\000\000\000\000\r\028\000\000\000\016,\000\000\000\000\000\000\000\000%v@\000\000f\011\000\000=\\\011\000\000\015\130\023C\002\011\000\000I&\011\000\000L~\012\002\000\000\000\000M\012\024\000\000Qr\012\"\000\000\000\000S.\0128\000\000[\012H\000\000]\012P\000\000\000\000\015j\000\000\000\000\t\015j\000\000\000\000\000\000\003\"\n\000j\000\000\000\000\000\000\000\000\006\016~\000\000\000\000\000\000\000\000\015n\000\000\006\020\015\012\000\000\000\000\016\016\148\002\rP\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\000\140\015\000\000\000\000\000\000\000\000\000\000\000\000\006\002\000\014\000\000\000\000\140\000\000\020\000\000\000\000\000\000\000\000\000\000\023J\000\000K\150\000\000\000\000\000\000\000\000g\000\000\000\000\000\0008N\000\000\006z\000\000/\026\000\000\000\000\000\000\002v\016\144\004\000\000\016\016\158\005-d\b\012\000\000\000\000\012Z\000\0000\011B\012\128\000\000\000\0004P\012\012\152\000\0005|\r&\012\000\0006r\rp\012\000\000\r\134\rL\000\000\000\000\000\000\000\000\000\000\015\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\015\r\132\006\000\000\000\000\014?\006\156\000\000\017T\000\000v\130\000\000\016\r\000\000\r\\\r\000\000\014&\000\000\000\000\t\n\000\000\015&<.X0\001\002\000\000\000\000\128\000\000\000\000\000\0009\000\000\000\000\000\000w\000\000w1,\bn+.\000\000\000\000\000\000\000w{J\000\000\015\134\000\000\000\000\000\000\000\000\000\000\000\000\015\134\129\018\000\0004L\015\134\000\000\000\000w^9\015\134\006\146\000\000D\018\015\134\000\000\000\000\000\000\000\000\000\000\000\000\0142\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\005\140\000\000\016\014b\000\000\014\136\000\000\000\000\000\000\000\000\014H\015\136\016\014\000\000\000\000\014X\015\130\0118\015\000\000\000\000\000\002\022<\000\000\015\b\000\000\000\000\007(\000\000\000\000\000\000\000\000\003\128\000\000\000\000\000\000\003\000\000\000\000\004\000\000\000\000\000\000\000\000"), (16, "\002\002\001\b:\002\024\b\005\000m\000n\007N\000\n\007\007\007\ni\000K\000\142\003o\000b\000i\007\b\005\b\nh\002\024\003*\001\002\007\005\137\000i\002\025\002/\0021\001\003\005\155\000\003p\000Q\007\001\002\027\000g\000i\b\tk\007\006+\000K\tn\tq\002\025\000K\002\026\007\004\004\005\t\003\127\002\003\025\002\027\005\140\001\001\t\0013\006\000k\000i\002\004\004\004\004\004\001\017\000\142\005\156\001\b\t7\b\0028\000\145\002_\002a\006M\005\158\002\146\b.\t%\bt\000t\004\005\r\005\t\000\n\002T\007\003s\b\005\003+\002#\bj\bk\001\r\005\016\bn\002\132\t&\nR\001\014\002$\001\002\t\001K\004\144\001\015\b\005\005\159\005\005\141\002!\006`\003,\002'\002(\006\t\000\000i\t\001\023\002$\005\000K\003+\000\014\003d\t\r\t\014\003u\002d\006\000\005\142\002'\002(\002-\002\144\002U\t\t~\002\002\nT\005\002d\004Q\003,\0030\t\015\007t\000W\007u\003v\006\003\128\002e\003o\004J\000\bu\b\bv\b\000[\by\002g\bq\001\003\136\005\002e\003e\004J\003j\t\018\t^\003p\b\006\000\n\001\r\002g\005\003-\b\b\001\022\007\b\133\b\b\003k\n\t\n\n\002)\007\t\020\007P\b\027\000i\006[\005\148\000_\000\000i\000\136\001\023\000w\bt\001\024\005\030\000~\003\144\003m\002)\002*\002\030\003-\006a\b\000t\b\tt\006\018\006\000N\000\142\002o\003.\006U\t%\bt\0012\0010\000\138\002.\002\030\002p\001J\003s\001\t~\002o\003%\000i\005\011\003\151\001\003/\t&\002q\002r\002p\006b\004Y\002+\002,\003n\000M\t\024\t\025\000\000\006d\005\002q\002r\006\t\nN\006\n9\nE\n<\n>\003\153\002+\002,\003d\t\r\t\014\003u\006k\003/\005\011\001\025\0022\002\145\002V\bu\006\bv\000K\006\by\b\140\001\024\b\142\0031\t\145\000\t\015\007t\b\143\007u\003v\000\128\006e\002\003\001\003\001\bu\004\bv\002\004\004\by\006\001\001\003\136\006g\002\024\003e\003)\003j\t\018\006\000\004n\002s\011\r\011\014\t\027\003^\011\016\011\017\001\000i\t\001K\011\019\003k\011\020\000\002s\000\t\020\002\025\002\029\002\026\002t\002j\000t\003_\006\005\001T\002\027\005\005\155\005\030\006h\003\144\003m\001\154\002t\002j\006\146\000i\001\025\nX\b\t)\006\018\004\005\017\005\t\006\000\0028\006\007<\006\002\002N\002X\005\016\000y\001\006\005\018\002u\002v\004\002T\006\b!\003\151\011\021\000\132\006\006\149\005\156\011\029\001\000i\002u\002v\003n\006\026\t\024\t\025\005\158\bt\b\b\003\157\003\001\002!\003\143\007\007\b\007\t\007\n\003\153\002\006a\006\002$\005\030\000\142\006k\tY\b\017\001U\011\030\011\031\006\000\n\019\001[\002'\002(\002-\005\002U\007\002Z\001\004\127\001\001\0119\003:\002\004\nG\003\159\000\000i\006\150\001X\006b\t\0010\011:\001\003^\011\016\011=\011 \011!\006d\011&\011\019\011'\011\020\011,\006\r\000\006\014\003\006\028\006\151\000\151\001\000\154\003_\b$\b\027\000i\t\001\bu\006\bv\007\011\003\by\t\142\003;\001\003B\011-\011/\007s\005\t\153\t\154\001\001\011<\001f\005\0111\006e\005R\001P\001K\003C\001\007\001\n\002)\011:\0112\003^\011\016\011=\001\154\bm\bk\011\021\011\019\bn\011\020\002\030\011\029\000\006\b\022\003\003E\000\142\002.\002\030\003_\n]\n^\000\003\157\001Y\006\155\t\007\t\b\t\t\004\005\000\004\004\002\007\012\000\001\003\143\bj\bk\001/\0010\bn\011\030\011\031\006h\0074\007\r\003\007\014\005\011\0115\0114\0116\t\028\0011\0010\002+\002,\003F\001\157\003:\000K\011\021\003\159\000\007}\0022\011\029\002V\n\001\001\020\007\001\000i\003\011 \011!\006p\011&\003\157\011'\t4\011,\006\r\000\006\014\003\001G\001K\002\n9\nL\n<\n>\005\016\001\001\001Z\005\018\011\030\011\031\002i\003\005\030\000K\003;\001\003B\011-\011/\000K\t\029\000K\b\005\001\001\011?\003:\005\n\0111\003\159\000\000i\002d\003C\004\006\005\t\011:\0112\003^\011\016\011=\011 \011!\002$\011&\011\019\011'\011\020\011,\006\r\n\143\006\014\003\003\003E\b\016\001\r\002e\003_\004J\007O\001\001\027\001\028\003\143\n\002\002$\002g\003\000\001\003;\000\142\003B\011-\011/\005\137\000i\b\026\000\000i\b\154\001\023\001\031\n\0111\001\003\011@\001\001\003C\0114\0116\000\000i\0112\005\145\003#\003F\t\007\t\b\tG\011\021\001\t\005\030\b\027\000i\011\029\002$\005\140\t$\003\003E\004\0010\003\004\007!\005\t\005l\003\157\000m\007R\007N\000t\005\000\138\t\028\002o\001\156\002\000\001\019\bx\bk\003%\000i\bn\002p\004=\011\030\011\031\004\007\005\t\003\011@\001N\001K\0114\0116\002q\002r\004)\004\132\005\147\003F\005%\003:\005\002$\003\159\005\003\143\001\020\n\005\004{\005\141\004\0010\001\024\002$\003\011 \011!\001\030\011&\001)\011'\0052\011,\006\r\000\138\006\014\003\t\029\005\b\005\001\t7\005\142\003%\000i\t7\002j\002\002\t\007\t\b\011\023\003\005\144\006E\003;\t7\003B\011-\011/\004\001K\t7\003o\006\006\nv\003)\005\0111\006\005\029\006\0059\003C\001\020\004\135\t\028\005\011\0112\005\031\007\134\002s\003p\002\005\011\000m\nQ\007N\b\002\006K\005\020\001\r\005\003\003E\001\025\001%\001\027\001\028\005\001\029\002t\002j\000\138\004\0010\006\138\t\021\005\148\000\007P\003*\003%\000i\000\000i\tS\001\023\001\031\001 \001!\005J\003)\005?\t\141\006\t$\003\011@\006+\007H\0114\0116\n\t\029\005E\b\005\0016\003F\004\0010\002u\002v\003s\t\\\001R\t_\000t\t{\005n\t_\001\r\n\003\011\006\001\003\004\138\001\027\001\028\t\001]\t_\006\002\007I\007J\nn\005\011\t_\006P\011\002\t\148\007P\004\0010\000\000i\000\142\001\023\001\031\000\000\142\003d\006\146\000i\003u\000\138\003+\t\001K\n\n\001\005\011\003)\003%\000i\005L\007K\007X\001\007]\005\030\007b\0113\007g\007t\001\024\007u\003v\003,\005\030\005\004\0010\006\006\149\001\001\"\004|\002\002\004\0010\001\003\136\t$\002\024\003e\001\003j\007v\007y\001\002d\nx\003o\006\006\007E\005\030\005R\007{\006\006\006\005m\003k\007 \005\004\0010\007|\002\025\005\030\002\026\003p\005\030\nI\001K\002e\002y\002{\002\027\004\0010\005\001\024\003\144\003m\002g\0074\004\0010\005\006\150\003)\n_\002\002\003-\005~\001\025\001%\002\031\005\007P\005I\005K\005&\005'\002\024\001&\001.\003o\006\006\007E\006\151\003\143\006\006\003\151\006\005\135\007H\007~\007\127\003\006\005(\005'\005\146\003n\003p\001\007\007\002\025\003s\002\005/\005'\0053\005'\002!\003.\005\002\027\003\011\005\030\003\153\002o\005\137\000i\002$\t\005\007\007I\007J\005\154\002p\001\025\001%\0074\003/\001\002'\002(\002-\0055\005'\004\153\006\002q\002r\003d\000K\006\003u\005:\005'\005\157\007H\001\005\140\006\155\005<\005'\005@\005'\002p\007K\007X\005\007]\003s\007b\005\030\007g\007t\000\138\007u\003v\005B\005'\003\011\n\002#\b\133\003%\000i\005F\005'\000K\003\007I\007J\002$\003\136\005H\005'\003e\002\002\003j\007v\007y\005]\005`\006\143\005`\002'\002(\005\030\003d\001\002\007{\003u\002\023\005\000\n\003k\001\003\005\005\141\006\027\007|\002)\006\146\000i\007K\007X\006N\007]\002s\007b\005\030\007g\007t\002 \007u\003v\003\144\003m\005\030\006\146\000i\005\142\002.\002\030\002\002\002C\t\0013\002t\002j\003\136\006y\006Q\003e\006\149\003j\007v\007y\006\\\003o\006\006\007E\007_\003)\005\030\006\007{\006\003\151\002A\006\149\003k\007~\007\127\007\001\002\007|\n\151\003p\003n\002+\002,\001\003\002)\002K\001\r\005\030\002u\002v\b\141\0022\001\014\003\144\003m\002l\004\156\003\153\001\015\005\030\t\002\002\002\134\004\159\002*\002\030\007\005\148\000\000i\006_\001\023\006\150\001\004\0013\006c\003o\006\006\007E\007\000\007\003\006\006\000\138\006\003\151\007H\001`\006\150\007~\007\127\000\138\003%\000i\006\151\003p\003n\n\006o\003s\003%\000i\005\002+\002,\006\153\005\006\005\030\003\011\007\021\006\151\001\r\003\153\bF\005\030\t\146\007\001\014\007I\007J\002\007\007d\001\015\006\006\006\000i\007D\004\146\006\000i\006\000i\000\000i\003d\001\023\006\003u\bF\005\030\007=\007H\006\006\007\005\030\007.\0071\007*\000i\007K\007X\007B\007]\003s\007b\001\024\007g\007t\006\155\007u\003v\001U\007\129\003\011\001T\007-\000i\001b\001c\003)\001d\001\002\002\007I\007J\006\155\003\136\003)\002\003e\011\011\003j\007v\007y\000\000i\007V\001X\002\151\002\152\002\153\003d\007[\007{\003u\007`\t\005\030\003k\007e\007r\006\005\030\007|\007z\007\147\0010\007K\007X\007\143\007]\007\007b\n\007g\007t\007\007u\003v\003\144\003m\007\150\0010\001\024\006\006\005\002\002\t\001\025\b@\007\154\0010\003\136\005\030\001\002\003e\005\003j\007v\007y\001U\003o\006\006\007E\005+\001[\001\r\006\007{\006\003\151\004\001\026\003k\007~\007\127\n=\000\138\007|\n>\003p\003n\000\000i\007\001X\003%\000i\005\000\000i\007\001\023\001Y\003\144\003m\007\157\0010\003\153\002\005\t\143\002\002\002\154\n@\n9\nM\n<\n>\002\006\007\0010\003\001\025\007\002\003o\006\006\007E\003\007\007\006\006\007\006\003\151\007H\001\020\001\r\007~\007\127\003\130\005\030\n\r\001\026\003p\003n\007\005\030\003s\003\020\005\030\007\002p\007\005\030\005\030\007\003(\003\011\005\030\000\000i\003\153\001\023\005\b\158\005\003\007I\007J\n\023\005\003Y\003)\001Z\002\157\004s\004\004\146\b\004\001Y\004\006\007\002\158\002\003d\001\024\006\003u\ba\001\007\007H\003\143\007\004\006\b\001\b\t\b\011\007K\007X\b\025\007]\003s\007b\004\007g\007t\004\007u\003v\001\r\b\003\011\001\002\b\b\001\027\001\028\005\001\029\001\002\005\002\007I\007J\004\003\136\b\b\003e\004\003j\007v\007y\000\000i\b\001\023\001\031\001 \001!\003d\t\n\007{\003u\t\139\tB\tH\003k\001\024\006\005\001Z\007|\t\156\t\154\005\003\007K\007X\001\025\007]\005\007b\n\155\007g\007t\005\014\007u\003v\003\144\003m\t\0010\006\006\005\005\015\002\002\011)\005\b\005\003\143\003\136\005\001T\003e\005\022\003j\007v\007y\001\r\003o\006\006\007E\004\001\026\001\r\006\007{\006\003\151\004\001\026\003k\007~\007\127\005\028\000\138\007|\005\003p\003n\000\000i\nS\001\023\003%\000i\005\000\000i\001\025\001\023\001\024\003\144\003m\005\030\005\030\003\153\005\027\005\b\156\002\002\001\"\004\004\005\001\004\004\006\005\030\n\000\001\n\n\012\n\n\n\024\005'\003o\006\006\007E\n\027\005'\006\006\n\\\006\003\151\007H\001\020\001U\007~\007\127\002p\005\001V\001[\003p\003n\005T\005\003s\n \005'\005\005\n#\005'\n&\005'\005c\003\011\n\000\000i\003\153\001X\002p\b\014\n*\005'\007I\007J\004\n-\005'\003)\001\025\001%\005d\004\004\146\005h\001\024\006\n1\005'\001&\001.\003d\001\024\006\003u\n4\005'\n\007H\n7\005'\006\nZ\n[\n\152\0010\002p\007K\007X\n\007]\003s\007b\005i\007g\007t\005s\007u\003v\001\r\n\003\011\001\002\n\156\0010\001\027\001\028\005\030\001\029\001\002\005t\007I\007J\005w\003\136\n\0010\003e\005z\003j\007v\007y\000\000i\n\001\023\001\031\001 \001!\003d\011\012\007{\003u\t\137\n\0010\003k\001Y\006\n\001\025\007|\n\0010\005\131\007K\007X\001\025\007]\005\030\007b\005\132\007g\007t\011\026\007u\003v\003\144\003m\n\n\006\006\n\005\002\002\n\n\t\005\005\003\136\011\028\001\002\003e\005\003j\007v\007y\001\r\003o\006\006\007E\004\001\026\001\r\006\007{\006\003\151\004\001\026\003k\007~\007\127\005\000\138\007|\n\003p\003n\000\000i\011$\001\023\003%\000i\005\000\000i\001Z\001\023\001\024\003\144\003m\005\005\003\153\005\005\007F\002\002\001\"\004\004\004\004\004\006\005\011*\006\016\006\021\006\022\0110\006#\003o\006\006\007E\006\031\006$\006\006\006'\006\003\151\007H\001`\001\r\007~\007\127\0060\005\001\021\001\026\003p\003n\006-\005\003s\0067\006W\006\154\b\n\006\006\006\007\002\007\019\003\011\007\020\000\000i\003\153\001\023\007\024\007\130\007$\007&\007I\007J\004\005\007+\003)\001\025\001%\0070\004\003\025\007?\001\024\006\007W\007U\001&\001.\003d\001\024\006\003u\005\007S\007T\007H\007\\\007Z\006\007a\007f\007\136\007\142\007\141\007K\007X\007\007]\003s\007b\007\007g\007t\007\007u\003v\001U\007\003\011\001\002\007\007\001b\001c\005\001d\001\002\007\007I\007J\007\003\136\007\007\003e\007\003j\007v\007y\000\000i\b\b\001X\002\151\002\152\002\153\003d\b\020\007{\003u\b\b\021\005\003k\001\024\003+\005\001\025\007|\b\024\bS\b]\007K\007X\001\025\007]\bb\007b\b\007g\007t\b\007u\003v\003\144\003m\b\b\003,\0030\b\b\002\002\b\t\026\n\015\t@\tA\003\136\tX\001T\003e\tc\003j\007v\007y\001\r\003o\006\006\nu\004\001\026\001\r\006\007{\006\003\151\004\001\026\003k\007~\007\127\ti\000\138\007|\t\003p\003n\000\000i\t\001\023\003%\000i\t\000\000i\001\025\001\023\001Y\003\144\003m\t\n:\003\153\nJ\nO\nV\002\002\002\154\n8\n9\n;\n<\n>\003-\nW\nd\ng\n\142\n\145\n\146\n\003o\006\006\b\n\n\006\006\n\006\003\151\007H\001\020\001U\007~\007\127\n\n\001a\001[\003p\003n\n\011\027\003s\011\025\011%\011#\011+\000\000\000\000\000\000\000\000\000\000\003\011\000\000\000\000i\003\153\001X\000\000\000\000\000\000\000\000\007I\007J\004\000\000\000\000\003)\001Z\002\157\000\000\004\003\025\000\000\001\024\003/\000\000\000\000\002\158\002\003d\001\024\006\003u\000\000\000\000\000\000\007H\000\000\000\000\0031\000\000\000\000\000\000\000\000\000\000\007K\007X\000\000\007]\003s\007b\000\000\007g\007t\000\000\007u\003v\001\r\000\000\003\011\001\002\000\000\000\000\001\027\001\028\000\000\001\029\001\002\000\000\007I\007J\000\000\003\136\000\000\000\000\003e\000\000\003j\007v\007y\000\000i\000\000\001\023\001\031\001 \001!\003d\000\000\007{\003u\b=\000\000\000\000\003k\001Y\003+\000\000\001\025\007|\000\000\000\000\000\000\007K\007X\001\025\007]\000\000\007b\000\000\007g\007t\000\000\007u\003v\003\144\003m\000\000\000\000\003,\0030\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\003\136\000\000\001\002\003e\000\000\003j\007v\007y\001\r\003o\006\006\b/\004\001\026\001\r\006\007{\006\003\151\004\001\026\003k\007~\007\127\000\000\000\000\007|\000\000\003p\003n\000\000i\000\000\001\023\000\000\000\000\000\000\000\000i\001Z\001\023\001\024\003\144\003m\000\000\000\000\003\153\000\000\000\000\000\000\002\002\001\"\001*\000\000\000\000\000\000\000\000\003-\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003o\006\006\006\000\000\000\000\006\006\000\000\006\003\151\007H\001\020\001\r\007~\007\127\000\000\000\000\004\001\026\003p\003n\000\000\000\000\003s\000\000\000\000\000\000\000\000\001+\000\000\000\000\000\000\000\000\003\011\000\000\000\000i\003\153\001\023\000\000\000\000\000\000\000\000\007I\007J\004\000\000\000\000\000\000\001\025\001%\000\000\004\003\025\000\000\001\024\003/\000\000\000\000\001&\001.\003d\001\024\006\003u\000\000\000\000\000\000\007H\000\000\000\000\0031\000\000\000\000\000\000\000\000\000\000\007K\007X\000\000\007]\003s\007b\000\000\007g\007t\000\000\007u\003v\001\r\000\000\003\011\000\000\000\000\000\000\001\027\001\028\000\000\001\029\000\000\000\000\007I\007J\000\000\003\136\000\000\000\000\003e\000\000\003j\007v\007y\000\000i\000\000\001\023\001\031\001 \001!\003d\000\000\007{\003u\003\026\000\000\000\000\003k\001\024\003+\000\000\001\025\007|\000\000\000\000\000\000\007K\007X\001\025\007]\000\000\007b\000\000\007g\007t\000\000\007u\003v\003\144\003m\000\000\001\002\003,\0030\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\003\136\000\000\000\000\003e\000\000\003j\007v\007y\000\000\003o\006\006\b\r\000\000\000\000\000\000\006\007{\006\003\151\000\000\000\000\003k\007~\007\127\000\000\000\000\007|\000\000\003p\003n\b\000\000\000\000\000\000\000\000\001\020\000\000\000\000\004{\001\025\000\000\001\024\003\144\003m\000\000\000\000\003\153\000\000\000\000\000\000\002\002\001\"\005\005\000\000\000\000\000\000\000\000\003-\000\000\000\000\005\b\000\000\000\000\000\000\001\r\003o\006\006\nt\004\001\026\006\006\000\000\006\003\151\007H\000\000\000\000\007~\007\127\000\000\000\000\000\000\000\000\003p\003n\000\000i\003s\001\023\000\000\000\000\000\000\000\000\000\000\004\146\000\000\000\000\003\011\000\000\000\000\000\000\003\153\000\000\000\000\000\000\000\000\000\000\007I\007J\000\000\001\r\000\000\000\000\001\025\001%\000\000\001\027\001\028\000\000\001\029\003/\000\000\000\000\001&\001.\003d\000\000\006\003u\000\000\000\000\000\000\007H\000\000i\0031\001\023\001\031\001 \001!\000\000\007K\007X\000\000\007]\003s\007b\000\000\007g\007t\000\000\007u\003v\000\000\000\000\003\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b1\007I\007J\004\003\136\006\000\000\003e\000\000\003j\007v\007y\000\000\001\024\000\000\000\000\002\002\000\000\003d\000\000\007{\003u\000\000\000\000\000\000\003k\000\000\006\006\000\000\007|\003o\007w\000\000\007K\007X\000\000\007]\006\007b\006\007g\007t\000\000\007u\003v\003\144\003m\000\000\000\000\000\000\003p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\024\003\136\000\000\000\000\003e\000\000\003j\007v\007y\000\000\000\000\001\"\004|\001\001\000\000\000\000\000\000\007{\000\000\003\151\000\000\000\000\003k\007~\007\127\000\000\001\025\007|\003^\011.\003n\000\000\000\000\000\000\006\011\019\006\011\020\000\000\007H\001T\000\000\000\000\003\144\003m\000\000\000\000\003\153\003_\000\000\000\000\000\000\003s\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007I\000\000\001\025\001%\000\000\003\151\001T\000\000\000\000\007~\007\127\000\000\001&\001.\000\000\000\000\003n\000\000\003d\000\000\011\021\003u\000\000\000\000\000\000\011\029\000\000\000\000\000\000\006\000\000\002\002\003\153\007K\007X\000\000\007]\003\157\007b\000\000\000\000\007x\000\000\006\003v\001U\003o\002\000\000\000\000\005+\001[\000\000\000\000\000\000\000\000\000\000\011\030\000\000\000\000\003\136\000\000\000\000\003e\000\000\003j\003p\007y\000\000i\000\000\001X\000\000\b\b\003:\000\000\007{\003\159\000\000\000\000\000\000\003k\001U\000\000\000\000\000\000\007|\005+\001[\000\000\011 \011!\000\000\011&\000\000\011'\000\000\000\000\006\016\000\000\000\000\003\003\144\003m\000\000\000\000i\b\001X\b\000\000\nz\n}\007\000\000\007\000\000\003\000\000\000\000\003;\000\000\003B\000\000\011/\000\000\000\000\003s\000\000\000\000\000\000\000\000\000\000\000\000\0111\000\000\003\151\003\011\000\000\003C\007~\002\002\000\000\0112\000\000\000\000\003n\000\000\005.\000\000\000\000\000\000\007\000\000\000\000\000\000\003o\007\001Y\003\003E\000\000\000\000\003\153\003d\t\r\t\014\003u\001\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003p\000\000\000\000\000\000\000\000\000\000\000\000\b\t\012\000\000\0054\t\015\007t\000\000\007u\003v\007\003\000\000\000\000\001Y\0114\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\003\136\000\000\001\020\003e\000\000\003j\t\018\000\000\000\000\000\000\000\000\b\000\000\b\003\000\000\000\000\007\000\000\007\007\007\003k\000\000\000\000\000\000\001Z\t\020\000\000\000\000\000\000\003s\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\r\000\000\003\011\000\000\003\144\003m\001\027\001\028\000\000\001\029\000\000\000\000\007\000\000\n\127\000\000\000\000\000\000\000\000\000\000\000\000\003\025\007\000\000i\001Z\001\023\001\031\001 \001!\003d\t\r\t\014\003u\000\000\000\000\000\000\000\000\003\151\000\000\000\000\001\r\000\000\000\000\002\002\000\000\001\027\001\028\003n\001\029\t\024\t\025\t\015\007t\000\000\007u\003v\000\000\000\000\003o\000\000\000\000\000\000\000\000i\003\153\001\023\001\031\001 \001!\000\000\000\000\003\136\000\000\000\000\003e\000\000\003j\t\018\003p\000\000\000\000\000\000\000\000\000\000\000\000\b\t\017\000\000\000\000\003\031\000\000\000\000\007\003k\003+\002\002\000\000\t\020\000\000\000\000\000\000\007\b\030\007\000\000\007\001T\000\000\000\000\000\000\003o\000\000\001\024\003\144\003m\000\000\003,\0030\000\000\b\000\000\b\n\017\001\"\004\000\000\000\000\000\000\000\000\000\000\003p\000\000\000\000\000\000\000\000\000\000\000\000\b\t\023\003s\000\000\000\000\000\000\007\000\000\000\000\000\000\003\151\007\003\011\000\000\000\000\000\000\001\024\000\000\000\000\000\000\000\000\003n\000\000\t\024\t\025\000\000\004\001\"\004\000\000\000\000\000\000\002\002\000\000\b\000\000\b\003\153\000\000\003d\t\r\t\014\003u\000\000\000\000\007\001U\000\000\003-\001\025\001%\005+\001[\000\000\003s\000\000\000\000\000\000\000\000\001&\001.\000\000\t\015\007t\003\011\007u\003v\003y\000\000\000\000i\000\000\001X\000\000\000\000\000\000\000\000\007\000\000\007\007\007\003\136\000\000\000\000\003e\000\000\003j\t\018\000\000\001\025\001%\003d\t\r\t\014\003u\001\020\000\000\000\000\000\000\001&\001.\000\000\000\000\003k\000\000\001\001\000\000\t\020\000\000\007\000\000\003/\000\000\t\015\007t\000\000\007u\003v\000\000\007\003^\000\000\000\000\003\144\003m\000\000\0031\003\n\002\024\000\000\000\000\000\000\000\000\003\136\000\000\000\000\003e\003\011\003j\t\018\003_\000\000\000\000\000\000\000\000\000\000\000\000\t<\t=\005;\000\000\000\000\000\000\000\000\002\025\003k\002\"\003\151\000\000\001Y\t\020\000\000\000\000\000\000\002\027\003d\000\000\000\000\003n\000\000\t\024\t\025\001\r\000\000\000\000\001\020\003\144\003m\001\027\001\028\000\000\004G\t>\000\000\tE\003\153\000\000\000\000\000\000\000\000\000\000\007\003\132\001\001\000\000i\000\000\001\023\001\031\000\000\000\000\003\157\003\133\000\000\003\134\000\000\000\000\000\000\003^\003\151\003e\002\003j\000\000\001`\000\000\000\000\004j\000\000\000\000\003n\000\000\t\024\t\025\002#\000\000\000\000\000\000\003_\003k\000\000\000\000\000\000\001Z\002$\t<\tD\003\153\000\000\003:\tK\tL\003\159\000\000\000\000\000\000\000\000\002'\002(\000\000\003l\003m\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\000\000\005\tM\006\r\000t\006\014\003\001\001\000\000\t>\000\000\tE\000\000\000\000\000\000i\000\000\001\023\001\031\000\000\000\000\003\003^\000\000\003;\001\024\003B\tP\000\000\003\157\000\000\001U\000\000\000\000\003n\000\000\000\000\001b\001c\002\001d\005\003_\003C\000\000\005\000\000\000\000\tR\t<\tJ\000\000\000\000\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\000\000\003\003E\002)\003:\tK\tL\003\159\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\000\000\t>\000\000\tE\002*\002\030\000\000\tM\006\r\000\000\006\014\003\000\000\005\003^\003\000\000\001\025\001%\000\000\000\000\003\157\000\000\001\024\000\000\000\000\003F\003\tV\tW\003;\002\003B\tP\003_\000\000\000\000\000\000\000\000\005\000\000\t<\tO\003\002+\002,\005\000\000\000\000\003C\000\000\000\000\000\000\006t\tR\000\000\000\000\000\000\000\000\003:\tK\tL\003\159\001Y\000\000\000\000\000\000\000\000\000\000\000\000\003\003E\000\000\000\000\002\154\004k\t>\000\000\tE\000\000\000\000\000\000\tM\006\r\000\000\006\014\003\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\157\000\000\001\025\001%\000\000\006\001\003\003^\003\003;\002\003B\tP\006\002\000\000\000\000\000\000\001\002\000\000\003F\000\000\tV\tW\000\000\001\003\000\000\000\000\003_\003C\000\000\000\000\000\000\000\000\tR\t<\tU\003\000\000\003:\tK\tL\003\159\001Z\002\157\000\000\000\000\000\000\000\000\000\000\003\003E\000\000\002\158\002\000\000\0017\0013\000\000\000\000\000\000\000\000\tM\006\r\000\000\006\014\003\001\001\000\000\t>\000\000\tE\000\000\000\000\000\000\000\000\000\000\000\000\001\002\000\000\000\000\003\003^\003\003;\001\003\003B\tP\000\000\003\157\000\000\000\000\000\000\000\000\003F\001\r\tV\tW\000\000\002\000\000\001\014\003_\003C\000\000\001T\000\000\001\015\tR\t<\t[\003\000\000\000\000\000\000\000\000\001;\0013\000\000i\000\000\001\023\000\000\000\000\003\003E\000\000\003:\tK\tL\003\159\000\000\000\000\000\000\000\000\000\000\000\000\001T\000\000\000\000\000\000\000\000\000\000\000\000\t>\000\000\tE\000\000\000\000\000\000\tM\006\r\000\000\006\014\003\000\000\001\r\000\000\003\002\024\000\000\000\000\001\014\000\000\003\157\000\000\000\000\000\000\001\015\003F\003\tV\tW\003;\002\003B\tP\000\000\000\000\000\000i\000\000\001\023\001U\000\000\002\025\003\002\026\005\143\001[\000\000\000\000\003C\000\000\000\000\002\027\000\000\tR\000\000\000\000\000\000\000\000\003:\tK\tL\003\159\000\000i\000\000\001X\001\024\000\000\000\000\003\003E\001U\0028\001T\002D\002a\005+\001[\002\000\000\000\000\tM\006\r\000\000\006\014\003\000\000\002T\000\000\002\002\000\000\000\000\000\000\000\000i\000\000\001X\002A\000\000\000\000\003\000\000\003\003;\003o\003B\tP\000t\000\000\000\000\000\000\002!\000\000\003F\000\000\tV\tW\000\000\000\000\000\000\000\000\002$\003C\000\000\003p\006\t\001\024\tR\000\000\000\000\003\t\019\000\000\000\000\002'\002(\002-\002\144\002U\000\000\001\025\000\000\000\000\003\003E\005\000\000\000\000\006\n\005\001U\000\000\000\000\001Y\000\000\005\001[\000\000\006\011\006\r\000\000\006\014\000\000\001\001\000\000\b\000\000\b\000\000\000\000\000\000\000\000\000\000i\005A\001X\003\000\000\003^\000\000\000\000\000\000\000\000\006\015\001Y\003s\000\000\003F\000\000\tV\tW\000\000\000\000\000\000\000\000\003\011\000\000\000\000\003_\005\001\025\000\000\000\000\000\000\003\tQ\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002)\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003d\t\r\005\003u\001Z\001\020\000\000\006\017\006\018\005\000\000\002.\002\030\000\000\000\000\006q\006j\t>\000\000\tE\000\000\000\000\000\000\000\000\007x\000\000\000\000\003v\000\000\000\000\000\000\002d\000\000\000\000\000\000\000\000\001Z\003\157\002\002\000\000\001Y\000\000\003\136\000\000\000\000\003e\002\003j\000\000\000\000\002+\002,\000\000\003o\000\000\000\000\002e\000\000\002f\000\000\0022\002\145\002V\006\001\003k\006k\002g\000\000\002d\t\020\006l\006\002\000\000\003p\003:\tK\000\000\003\159\000\000\000\000\000\000\000\000\001\r\000\000\000\000\003\144\003m\002}\001\027\001\028\002\001\029\000\000\002\136\002e\000\000\002f\000\000\006\016\000\000\000\000\003\002\141\000\000\002g\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\001Z\000\000\003\000\000\003\151\003;\002\132\003B\000\000\000\000\002}\004\146\002m\002\135\000\000\003n\002\136\t\024\000\000\000\000\003s\000\000\002p\000\000\003C\002\141\000\000\000\000\000\000\tR\003\011\000\000\003\153\000\000\000\000\002q\002r\002w\002\144\002\142\000\000\004\146\000\000\000\000\000\000\003\003E\000\000\000\000\000\000\002m\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003d\000\000\002p\003u\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002q\002r\002w\002\144\002\142\000\000\003\003o\b-\001\024\000\000\000\000\003v\006\000\000\000\000\000\000\003F\000\000\tV\001\"\006\000\000\000\000\000\000\000\000\000\000\003p\003\136\006\000\000\003e\000\000\003j\003\000\000\006\006\004\147\000\000\002\002\002s\006\000\000\000\000\000\000\000\000\000\000\000\000\003k\004c\000\000\000\000\004o\004u\003o\000\000\000\000\000\000\002\024\000\000\000\000\002x\002j\000\000\006\006\000\000\000\000\000\000\003\144\003m\000\000\000\000\002A\003p\000\000\000\000\000\000\002s\000\000\000\000\000\000\001\025\001%\002\025\000\000\002\026\003s\000\000\000\000\000\000\000\000\001&\001.\002\027\000\000\000\000\003\011\000\000\002x\002j\002u\002v\003\151\006\000\000\000\000\000\000\000\000\000\000\000\000\002|\002\145\002\143\003n\0028\000\000\000\000\000\000\002I\002N\002X\002\132\000\000\000\000\003d\000\000\000\000\003u\000\000\002T\003\153\000\000\000\000\006\000\000\003s\000\000\000\000\002u\002v\000\000\000\000\005x\000\000\000\000\003\011\000\000\001`\002|\002\145\002\143\003v\000\000\000\000\002!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002$\000\000\000\000\003\136\006\000\000\003e\000\000\003j\003d\000\000\000\000\003u\002'\002(\002-\000\000\002U\000\000\006\000\000\000\000\002\002\000\000\003k\004c\000\000\000\000\t\t\005}\000\000\001\002\006\000\000\003v\000\000\003o\000\000\001\003\000\000\000\000\001\002\000\000\000\000\003\144\003m\000\000\006\001\003\000\000\003\136\000\000\000\000\003e\000\000\003j\003p\000\000\000t\001U\000\000\000\000\000\000\000\000\000\000\001b\001c\000\000\001d\001A\0013\000\000\003k\bB\000\000\000\000\b\b\003\151\t\0013\000\000\000\000i\000\000\001X\002\151\002\152\002\153\003n\005\127\002)\000\000\003\144\003m\000\000\005\000\000\000\000\000\000\005\000\000\000\000\000\000\002A\005x\003\153\000\000\000\000\001\r\001`\000\000\002.\002\030\000\000\001\014\000\000\000\000\003s\001\r\000\000\001\015\000\000\000\000\000\000\001\014\000\000\003\151\003\011\000\000\000\000\001\015\000\000i\000\000\001\023\000\000\000\000\003n\000\000\000\000\000\000\000\000i\002d\001\023\000\000\005\000\000\000\000\005\005\002+\002,\001T\003\153\003d\000\000\005\134\003u\000\000\000\000\0022\000\000\002V\000\000\000\000\000\000\000\000\000\000\002e\000\000\004J\000\000\001Y\000\000\000\000\005\000\000\000\000\002g\000\000\004\146\003v\005\002\154\005\128\000\000\001U\000\000\000\000\005\000\000\000\000\001b\001c\000\000\001d\000\000\003\136\000\000\006\003e\000\000\003j\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001X\002\151\002\152\002\153\005x\005\127\000\000\003k\bB\001`\001\024\bG\bK\000\000\000\000\000\000\000\000\000\000\001U\000\000\001\024\000\000\000\000\005+\001[\006\001\000\000\002o\003\144\003m\005\129\000\000\000\000\006\002\000\000\001Z\002\157\002p\004\000\000\000\000\000\000i\006\001X\002\158\002\000\000\000\000\006\002q\002r\000\000\000\000\000\000\006\t\140\006/\000\000\000\000\000\000\000\000\003\151\000\000\001\000i\006\006\000\000\000\000\000\000\006<\000\000\003n\006\000\000\001\020\006\000\000\000\000\000\000\000\000\007\b\007\t\007\n\001\025\000\000\001U\000\000\001Y\003\153\000\000\000\000\001b\001c\001\025\001d\000\000\000\000\000\000\002\154\005\128\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\005\127\000\000\006<\000\000\000\000\005G\006?\001\020\000\000\000\000\000\000\000\000\002s\000\000\000\000\001Y\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\006\000\000\000\000\002t\002j\000\000\001\r\000\000\007\011\000\000\001T\005\129\001\027\001\028\000\000\001\029\001Z\002\157\000\000\006\002\002\000\000\000\000\000\000\t\002\158\002\000\000\000\000i\000\000\001\023\001\031\001 \001!\000\000\006B\000\000\000\000\000\000\000\000\000\000\002u\002v\000\000\000\000\000\000\000\000\000\000\003\145\003\146\000\000\006\001Y\001\r\003y\006\000\000\000\000\001Z\001\027\001\028\000\000\001\029\002\154\005\128\002d\006\006\005\000\000\007\012\005\000\000\006\000\000\000\000\000\000i\000\000\001\023\001\031\001 \001!\007\r\006B\007\014\001U\000\000\000\000\002\002\002e\001W\004J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002g\000\000\000\000\000\000\003o\001\002\000\000\000\000\000\000i\000\000\001X\001\003\000\000\000\000\003\n\006\000\000\001\024\000\000\000\000\005\129\006\006\003p\003\011\001Z\002\157\000t\001\"\006C\001\000i\000\000\000\000\000\000\002\158\002\000\000\000\000\001\001\000\000\t\0013\000\000\000\000\000\000\000\000\007\b\007\t\007\n\003\148\003d\000\000\000\000\003^\000\000\000\000\000\000\000\000\002o\000\000\000\000\000\000\000\000\005\001\024\000\000\000\000\005\002p\000\000\000\000\000\000\000\000\003_\000\000\001\"\006C\003\149\000\000\000\000\001\r\002q\002r\003s\000\000\006D\001\014\000\000\000\000\000\000\001\025\001%\001\015\003\011\001\001\003e\001Y\003j\000\000\001&\001.\000\000\000\000i\n\001\023\000\000\n\001\003^\000\000\007\015\000\000\000\000\003k\000\000\000\000\005\000\000\007\011\003d\000\000\000\000\003u\000\000\002\002\000\000\000\000\003_\000\000\000\000\n\006D\003\157\003l\003m\000\000\001\025\001%\000\000\003o\000\000\005\002\000\000\000\000\003v\001&\001.\005\000\000\000\000\000\000\000\000\000\000\000\000\006X\000\000\000\000\002s\003p\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\000\000\001Z\003:\000\000\000\000\003\159\000\000\003\150\011\b\000\000\003n\002t\002j\007\012\000\000\003k\bO\000\000\t\000\000\004f\003\157\000\000\000\000\001\024\000\000\007\r\011\t\007\014\003\000\000\002\000\000\000\000\000\000\006\001\003\144\003m\000\000\000\000\000\000\000\000\000\000\006\002\000\000\003\000\000\000\000\003;\000\000\003B\002u\002v\003s\000\000\000t\000\000\000\000\000\000\003:\000\000\000\000\003\159\003\011\001\001\000\000\003C\b\t\003\151\000\000\bE\000\000\000\000\000\000\000\000\011\n\000\000\000\000\003^\003n\000\000\011\007\000\000\004\146\003\000\000\003\003E\000\000\003d\000\000\005\003u\002\000\000\005\003\153\001\025\003_\000\000\003\000\000\000\000\003;\000\000\003B\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003v\000\000\000\000\007i\003\002f\003C\bZ\t}\000\000\000\000\bE\000\000\002g\000\000\003F\003\136\000\000\000\000\003e\000\000\003j\002d\000\000\000\000\000\000\000\000\003\003E\000\000\005\000\000\003\000\000\002}\000\000\000\000\006\003k\bO\007n\tb\006\004f\003\157\000\000\000\000\000\000\002e\002\141\004J\000\000\000\000\000\000\002\000\000\005\000\000\002g\003\144\003m\003\000\000\005\000\000\006\006\000\000\000\000\000\000\006\000\000\003F\000\000\002m\000\000\000\000\001\020\000\000\000\000\004Q\000\000\003:\000\000\002p\003\159\000\000\000\000\002\024\003\000\000\000\000\000\000\003\151\000\000\000\000\000\000\002q\002r\002w\000\000\002\142\000\000\000\000\003n\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\002\025\000\000\002\026\000\000\006\001\002o\000\000\003\153\000\000\000\000\002\027\003\006\002\000\000\003;\002p\003B\000\000\000\000\000\000\000\000\006\000\000\b\000\000\000\000\000\000\000\000\002q\002r\002\024\0028\000\000\003C\bZ\t`\002\002\bE\000\000\000\000\001\r\000\000\000\000\000\000\000\000\002T\001\027\001\028\000\000\001\029\000\000\000\000\000\000\003\003E\002\025\000\000\002\026\000\000\001\002\000\000\000\000\002s\004\000i\002\027\001\023\001\031\001 \001!\002!\004X\000\000\004Z\000\000\000\000\000\000\000\000\000\000\004[\002$\000\000\005\002x\002j\006\0028\003\000\000\000\000\000\000\002\002\002'\002(\002-\000\000\002U\003F\000\000\006\002T\000\000\000\000\000\000\000\000\000\000\002s\005\000\000\002f\000\000\000\000\000\000\000\000\003\000\000\000\000\002g\000\000\000\000\000\000\000\000\002u\002v\000\000\002!\000\000\002t\002j\000\000\000\000\000\000\002|\000\000\002\143\002$\001\r\000\000\002}\000\000\000\000\006\152\001\026\000\000\005\000\000\000\000\005\002'\002(\002-\000\000\002U\002\141\001\024\000\000\000\000\000\000\000\000\000\000i\000\000\001\023\002\004\001\"\004\002u\002v\000\000\000\000\000\000\002)\005\001\002\002f\000\000\000\000\002m\000\000\000\000\t\000\000\002g\000\000\000\000\000\000\000\000\002p\007i\000\000\002f\000\000\002.\002\030\000\000\001\002\000\000\000\000\002g\000\000\002q\002r\002w\002}\002\142\000\000\000\000\000\000\000\000\005\000\000\000\000\t\000\000\000\000\000\000\000\000\000\000\002\141\002}\000\000\000\000\000\000\000\000\000\000\007n\000\000\002)\001\025\001%\000\000\000\000\002+\002,\002\141\000\000\002\002\001&\001.\005\000\000\0022\002m\002V\000\000\000\000\000\000\002.\002\030\001\024\001\r\003o\002p\000\000\001\002\000\000\001\014\000\000\002m\000\000\000\000\001\003\001\015\000\000\000\000\002q\002r\002w\002p\002\142\000\000\003p\001\r\000\000i\001\020\001\023\n\001\026\002s\000\000\002q\002r\002w\000\000\002\142\000\000\002+\002,\000\000\000\000\001\001\001\012\000\000\000\000i\0022\001\023\002V\002x\002j\000\000\000\000\000\000\006n\000\000\003^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007q\000\000\000\000\001\025\000\000\000\000\003_\000\000\000\000\000\000\000\000\001\r\003s\000\000\000\000\000\000\000\000\001\014\000\000\002u\002v\000\000\003\011\001\015\002s\000\000\000\000\001\001\002|\000\000\002\143\001\r\000\000\000\000i\000\000\001\023\001\027\001\028\002s\001\029\000\000\003^\001\024\002x\002j\000\000\002d\000\000\003d\000\000\000\000\003u\000\000\000\000i\000\000\001\023\001\031\001 \002x\002j\003_\000\000\000\000\001\024\000\000\003\157\000\000\000\000\000\000\000\000\000\000\002e\000\000\004J\003v\002\000\000\000\000\000\000\000\000\000\000\002g\002u\002v\000\000\000\000\000\000\000\000\000\000\000\000\003\136\000\000\002|\003e\002\143\003j\000\000\000\000\002u\002v\000\000\000\000\000\000\003:\000\000\000\000\003\159\000\000\002|\000\000\002\143\000\000\003k\bO\000\000\bP\001\025\004f\000\000\000\000\002\002\003\157\001\024\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\002\003\144\003m\000\000\003o\000\000\001\025\000\000\000\000\000\000\002o\000\000\001\024\000\000\003\000\000\000\000\003;\000\000\003B\002p\001\002\000\000\001$\003p\000\000\000\000\000\000\003:\000\000\000\000\003\159\000\000\002q\002r\003\151\003C\bZ\b_\000\000\000\000\bE\001\002\000\000\001\001\003n\000\000\000\000\001=\000\000\000\000\000\000\000\000\000\000\003\000\000\003\003E\005\003^\000\000\000\000\003\153\000\000\000\000\001\025\000\000\000\000\000\000\000\000\003\000\000\000\000\003;\000\000\003B\000\000\000\000\000\000\003_\001?\000\000\000\000\000\000\005\003s\001\025\001%\000\000\000\000\003\000\000\003C\bZ\b\\\003\011\001&\bE\001\r\001\001\003F\000\000\004\001\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002s\003\003E\003^\000\000\000\000\003\001\r\000\000\000\000i\003d\001\023\001\014\003u\000\000\000\000\000\000\004\146\001\015\000\000\002t\002j\003_\000\000\000\000\000\000\000\000\000\000\003\157\000\000i\000\000\001\023\000\000\003\006\005\000\000\003v\002\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\002u\002v\003\000\000\000\000\000\000\003:\000\000\000\000\003\159\000\000\000\000\000\000\000\000\000\000\003k\bO\000\000\b\000\000\004f\000\000\001\001\003\157\000\000\000t\007\000\000\000\000\007\146\006\004\006\003\002\000\000\003\144\003m\003^\000\000\001\024\000t\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\003;\000\000\003B\006\006\000\000\003_\002d\000\000\001\024\003:\000\000\005\003\159\000\000\000\000\005\000\n\003\151\003C\b\b\000\000\000\000\bE\000\000\000\000\005\000\000\003n\000\000\005\000\000\002e\000\000\002f\000\000\003\000\000\000\000\003\003E\000\000\002g\000\000\000\000\003\153\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\n\003;\000\000\003B\n\000\000\000\000\002d\001\025\002}\000\000\000\000\005\003\157\000\000\n\137\n\139\000\000\006\003\003C\b\b\002\002\141\bE\000\000\005\000\000\001\025\003F\000\000\000\000\002e\000\000\002f\000\000\000\000\005\000\000\000\000\003\003E\002g\000\000\005\000\000\003\000\000\002m\000\000\003:\006\005\003\159\n\000\000\000\000\000\000\002p\005\000\000\000\000\000\000\002}\002\024\000\000\006\000\000\000\000\t\000\000\002q\002r\002w\003\002\142\000\000\003\002\141\000\000\n\000\000\006\002\024\000\000\003F\000\000\n\000\000\000\000\002\025\000\000\002\026\003\n\000\000\003;\006\003B\006\001\002\027\000\000\003\002m\000\000\000\000\000t\006\002\000\000\002\025\000\000\002\026\000\000\002p\006\001\003C\b\t\000\000\002\027\bE\002;\006\002\000\000\006\t\000\000\002q\002r\002w\000\000\002\142\000\000\000\000\000\000\000\000\000\000\003\003E\002\024\000\000\0028\000\000\n\000\000\005\000\000\002\006\n\005\000\000\n\002s\000\000\000\000\000\000\002T\000\000\006\011\006\r\000\000\006\014\002!\000\000\000\000\002\025\000\000\002\026\000\000\000\000\001\002\003\002$\002x\002j\002\027\000\000\000\000\000\000\000\000\000\000\002!\003F\000\000\006\015\002'\002(\002-\000\000\000\000\000\000\002$\000\000\000\000\002\024\000\000\0028\000\000\000\000\003\005\000\000\002W\000\000\002'\002(\002-\002s\002U\000\000\000\000\002T\000\000\002u\002v\000\000\000\000\000\000\000\000\000\000\002\025\000\000\002\026\002|\000\000\002\143\005\000\000\002x\002j\002\027\006\017\006\018\005\000\000\000\000\002!\000\000\000\000\006i\006j\000\000\000\000\000\000\000\000\000\000\002$\002\024\001\r\000\000\000\000\0028\000\000\004\001\026\000\000\000\000\002Q\000\000\002'\002(\002-\000\000\002U\000\000\002)\002T\000\000\002u\002v\000\000\000\000i\002\025\001\023\002\026\000\000\000\000\002|\000\000\002\143\000\000\000\000\002\027\002)\000\000\002.\002\030\006\001\000\000\006k\002!\000\000\000\000\000\000\006l\006\002\000\000\000\000\000t\000\000\002$\002d\000\000\0028\002.\002\030\002\024\004\146\000\000\002S\000\000\000\000\000\000\002'\002(\002-\000\000\002U\002T\000\000\000\000\000\000\000\000\000\n\000\000\002+\002,\002e\000\000\002f\000\000\000\000\002\025\000\000\002\026\0022\005\002g\002)\000\000\005\000\000\002\027\002!\002+\002,\000\000\000\000\000\000\000\000\000\000\000\000\007\149\002$\0022\000\000\002V\000\000\002}\002.\002\030\n\001\024\0028\002\140\n\002'\002(\002-\002\002U\000\000\000\000\002\141\000\000\000\000\002d\007\002T\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000\000\002)\000\000\000\000\000\000\000\000\002m\002+\002,\000\000\002e\002!\002f\006\006\000\000\002p\0022\000\000\002V\002g\002$\002.\002\030\n\005\000\000\000\000\000\000\002q\002r\002w\005\002\142\002'\002(\002-\000\000\002U\n\000\000\002}\007\007\007\001\025\007\003\002\004\146\000\000\n\003\025\000\000\000\000\002)\000\000\002\141\n\000\000\000\000\000\000\000\000\002+\002,\n\000\000\000\000\000\000\000\000\000\000\000\000\002d\0022\000\000\002V\002.\002\030\000\000\000\000\000\000\000\000\002m\000\000\006\007\000\000\000\000\006\001\000\000\007\000\000\002p\000\000\000\000\000\000\006\002\000\000\002e\000\000\002f\000\000\002\002\000\000\002q\002r\002w\002g\002\142\002s\000\000\000\000\n\000\000\002)\002+\002,\003o\b\002\003\025\n\b<\000\000\006\007\0022\003+\002V\002}\000\000\002x\002j\000\000\000\000\003V\002.\002\030\003p\000\000\000\000\000\000\002d\000\000\002\141\000\000\000\000\006\006\006\003,\0030\000\000\000\000\000\000\000\000\000\000\007\000\000\007\007\007\000\000\000\000\006\000\000\000\000\000\000\002e\002m\002f\002u\002v\000\000\000\000\000\000\002+\002,\002g\002p\000\000\002|\000\000\002\143\000\000\002s\0022\000\000\002V\000\000\t\002\007\002q\002r\002w\003+\002\142\000\000\000\000\002}\003s\007\000\000\000\000\000\000\004P\002x\002j\002\002\003\011\000\000\000\000\000\000\002\141\001\001\006\003,\0030\003-\003\025\000\000\000\000\003o\000\000\000\000\000\000\000\000\000\000\000\000\003^\000\000\000\000\001\002\000\000\000\000\000\000\003d\002m\000\000\003u\000\000\000\000\003p\000\000\002u\002v\000\000\002p\000\000\003_\000\000\000\000\000\000\000\000\002|\000\000\002\143\000\000\000\000\000\000\002q\002r\002w\003v\002\142\000\000\000\000\000\000\000\000\000\000\002s\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\136\006\000\000\003e\003/\003j\000\000\003-\000\000\000\000\t\006\000\000\002x\002j\000\000\003+\006\000\000\000\000\0031\000\000\000\000\003k\004e\000\000\003s\000\000\004f\000\000\000\000\000\000\001\r\003\157\001\001\003\011\004\001\026\003,\0030\002\002\002\003\144\003m\000\000\000\000\000\000\000\000\003^\000\000\000\n\002u\002v\000\000i\000\000\001\023\002d\000\000\000\000\002s\002|\003d\002\143\000\000\003u\000\000\005\003_\003:\000\000\003/\003\159\003\131\000\000\003y\003\151\000\000\000\000\000\000\000\000\002x\002j\002e\000\000\002f\0031\003n\n\003v\001\001\n\002g\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\001\002\000\000\003\153\003\136\003^\003-\003e\000\000\003j\000\000\003\000\000\002}\003;\000\000\003B\000\000\000\000\006\007\002u\002v\000\000\000\000\000\000\003_\003k\004r\002\141\003\157\002|\004f\002\143\003C\007\153\000\000\003\n\000\000\005\002\000\000\000\000\n\000\000\001\024\000\000\003\011\003\144\003m\000\000\000\000\000\000\000\000\002m\003\003E\000\000\001\001\000\000\000\000\000\000\000\000\002p\000\000\005\000\000\003:\n\000\000\003\159\003/\000\000\003^\003d\n\002q\002r\002w\001\r\002\142\003\151\n\000\000\004\001\026\0031\003\157\003\000\000\000\000\000\000\003n\003_\003\000\000\000\000\002\000\000\003F\000\000\003\132\000\000i\000\000\001\023\000\000\000\000\000\000\003\153\003\000\000\003\135\003;\003\134\003B\003\000\000\000\000\001\025\003e\000\000\003j\000\000\001\002\003:\002\002\003\159\000\000\n\000\000\003C\000\000\000\000\000\000\000\000\005\n\003k\000\000\000\000\003o\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\003\003E\003\157\002s\000\000\000\000\000\000\003l\003m\003p\001\001\002\000\000\000\000\003\000\000\000\000\003;\000\000\003B\000\000\000\000\000\000\002x\002j\003^\000\000\000\000\000\000\000\000\007\156\000\000\000\000\003\000\000\000\000\003C\bD\000\000\003:\001\024\bE\003\159\000\000\003F\003_\000\000\000\000\001\r\000\000\000\000\003n\000\000\004\001\026\000\000\000\000\003\003E\000\000\000\000\003\000\000\002u\002v\000\000\003\001\001\003\025\003s\000\000i\002|\001\023\002\143\000\000\000\000\000\000\000\000\003\011\000\000\003\003^\000\000\003;\000\000\003B\000\000\000\000\000\000\003\002d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\003_\003C\bJ\000\000\003\157\003d\bE\000\000\003u\000\000\000\000\000\000\001\025\000\000\002\002e\003\004J\002\002\000\000\000\000\003\003E\000\000\002g\000\000\000\000\000\000\000\000\000\000\000\000\003v\000\000\003o\000\000\t\031\000\000\000\000\000\000\000\000\003+\003:\001\001\003\159\000\000\000\000\003\136\000\000\007\159\003e\000\000\003j\003p\000\000\003\000\000\000\000\003^\001\024\000\000\003\157\000\000\003,\0030\000\000\003F\000\000\003\003k\bR\002\000\000\000\000\004f\000\000\000\000\000\000\003_\000\000\000\000\000\000\000\000\003\003\002o\000\000\003;\000\000\003B\003\144\003m\000\000\000\000\000\000\002p\001\001\000\000\003:\000\000\000\000\003\159\000\000\000\000\000\000\003C\bX\002q\002r\000\000\bE\003^\000\000\000\000\003s\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\151\003\011\003\003\003E\000\000\000\000\000\000\003_\003-\001\025\003n\000\000\000\000\000\000\000\000\003\157\000\000\003\002\002\003;\000\000\003B\000\000\000\000\002\b\003\153\003d\000\000\000\000\003u\000\000\000\000\003o\006E\003\n\133\000\000\003C\bh\000\000\000\000\000\000\bE\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\003:\003p\003v\003\159\000\000\000\000\001\020\003\003E\000\000\002s\003\000\000\000\000\001\001\003\157\b\003\136\006K\003/\003e\000\000\003j\000\000\000\000\002\003\001\001\003^\002t\002j\000\000\000\000\0031\000\000\000\000\000\000\000\000\003k\003\000\000\003\003^\b\003;\000\000\003B\000\000\003_\000\000\003F\000\000\003:\000\000\000\000\003\159\000\000\000\000\003\025\003\144\003m\003s\003_\003C\b\000\000\000\000\003\bE\002u\002v\003\011\000\000\000\000\000\000\000\000\001\020\000\000\000\000\003\000\000\000\000\001\r\000\000\003\003E\000\000\000\000\001\027\001\028\000\000\006G\000\000\003\151\000\000\003\000\000\b\003;\003d\003B\000\000\003u\000\000\003n\000\000i\000\000\001\023\001\031\003\157\000\000\000\000\000\000\000\000\000\000\000\000\003C\003\000\000\002\003\153\n\134\000\000\003\157\000\000\003v\000\000\t#\003F\000\000\000\000\000\000\003+\002\000\000\000\000\000\000\003\003E\000\000\000\000\003\136\000\000\000\000\003e\003\003j\003:\000\000\000\000\003\159\000\000\000\000\001\r\000\000\003,\0030\000\000\000\000\001\027\001\028\003:\006~\003k\003\159\000\000\000\000\000\000\b\000\000\000\000\003\000\000\000\000\003\000\000\000\000i\000\000\001\023\001\031\000\000\003F\000\000\003\144\003m\000\000\000\000\003\000\000\003\000\000\001\020\003;\000\000\003B\001\024\000\000\000t\003\000\000\000\000\000\000\000\000\003\000\000\000\000\003;\000\000\003B\006\128\000\000\003C\b\000\000\000\000\006\t\bE\003\151\000\000\000\n\002\002\000\000\000\000\003-\003C\th\000\000\003n\000\000\bE\000\000\003\003E\000\000\005\003o\000\000\006\n\005\000\000\000\000\000\000\002\002\003\153\003\003E\006\011\006\r\000\000\006\014\002\002\000\000\000\000\003p\n\000\000\003o\000\000\n\000\000\000\000\000\000\000\000\003\001\024\003o\001\r\001\025\001%\000\000\000\000\006\015\001\027\001\028\003F\001\029\003p\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003p\003/\005\003F\000\000i\003\001\023\001\031\001 \001!\002\002\000\000\000\000\000\000\0031\000\000\000\000\000\000\003\000\000\006\135\000\000\n\000\000\000\000\003o\005\000\000\003s\000\000\000\000\006\017\006\018\005\000\000\000\000\000\000\000\000\003\011\n\006j\000\000\000\000\000\000\000\000\003p\000\000\000\000\n\000\000\000\000\003s\001\025\001%\000\000\n\000\000\000\000\000\000\000\000\003s\003\011\011\000\002\002\000\000\003d\000\000\000\000\003u\003\011\000\000\000\000\000\000\006\130\000\000\000\000\000\000\000\000\003o\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\001\003d\006k\000\000\003u\003v\001\024\006l\006\002\000\000\003d\003p\000\000\003u\000\000\000\000\000\000\001\"\005\150\003s\000\000\003\136\n\000\000\003e\005\153\003j\000\000\003v\003\011\n\002\002\000\000\000\000\000\000\000\000\003v\000\000\000\000\000\000\000\000\000\000\003k\003\136\000\000\000\000\003e\t\003j\000\000\000\000\000\000\003\136\002\002\003e\003d\003j\000\000\003u\000\000\000\000\000\000\003\144\003m\003k\003y\000\000\000\000\003o\t\000\000\003s\000\000\003k\000\000\000\000\000\000\000\000\t\131\001\025\001%\003\011\003v\000\000\000\000\003\144\003m\000\000\003p\001&\001.\000\000\000\000\000\000\003\144\003m\003\151\000\000\003\136\002\002\003e\000\000\003j\000\000\000\000\000\000\003n\000\000\003d\000\000\000\000\003u\000\000\000\000\003o\000\000\000\000\000\000\003\151\003k\000\000\000\000\000\000\003\153\tf\000\000\003\n\003\151\000\000\003n\000\000\000\000\000\000\000\000\003p\003v\003\011\000\000\003n\000\000\003\144\003m\000\000\000\000\000\000\000\000\003\153\002\002\003s\000\000\003\136\000\000\000\000\003e\003\153\003j\000\000\000\000\003\011\000\000\001\001\003o\003d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003k\003\151\000\000\000\000\003^\t,\000\000\000\000\000\000\000\000\003p\000\000\003n\000\000\003d\001T\000\000\003u\003{\000\000\000\000\003\144\003m\003s\003_\000\000\000\000\000\000\000\000\003\153\000\000\000\000\000\000\003\011\000\000\000\000\000\000\003e\000\000\003j\000\000\003v\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\000\000\000\000\003\151\003k\003\136\000\000\000\000\003e\003d\003j\000\000\003u\000\000\003n\000\000\000\000\000\000\000\000\000\000\003s\000\000\000\000\000\000\000\000\003l\003m\003k\000\000\000\000\003\011\003\153\b\146\003\003\157\003\003v\000\000\000\000\000\000\000\000\001U\000\000\000\000\002\000\000\005+\001[\003\144\003m\000\000\000\000\003\136\000\000\000\000\003e\000\000\003j\003d\000\000\000\000\003u\001\001\000\000i\000\000\001X\000\000\000\000\003n\000\000\003:\000\000\003k\003\159\001\001\003^\b\145\000\000\000\000\003\151\000\000\000\000\003v\000\000\000\000\002\002\000\000\000\000\003^\003n\000\000\003\144\003m\002\003_\003\000\000\003\136\000\000\000\000\003e\000\000\003j\002\000\000\000\000\003\153\000\000\003_\000\000\000\000\003\000\000\000\000\003;\000\000\003B\000\000\000\000\003k\003y\001\001\000\000\b|\003\151\000\000\000\000\000\000\000\000\000\000\003:\000\000\003C\000\000\000\000\003n\003^\004\129\000\000\003\144\003m\n\026\000\000\000\000\000\000\000\000\001\001\000\000\000\000\000\000\001Y\003\153\003\003E\003\157\003_\003\000\000\000\000\000\000\000\000\003^\000\000\000\000\002\000\000\000\000\003\003\157\003\000\000\000\000\003\151\000\000\000\000\003;\000\000\003B\002\000\000\003\n\003_\000\000\003n\000\000\000\000\003\000\000\000\000\000\000\003\011\000\000\003:\000\000\003C\003\159\000\000\003F\000\000\000\000\003\153\000\000\000\000\000\000\000\000\000\000\003:\000\000\000\000\003\159\000\000\000\000\000\000\000\000\003\003D\003E\003\157\003d\003\002\002\000\000\000\000\000\000\001Z\000\000\002\000\000\000\000\000\000\000\000\000\000\003\000\000\003\003o\000\000\003;\000\000\003B\000\000\000\000\003\157\000\000\003z\000\000\000\000\000\000\003\000\000\000\000\003;\002\003B\003:\003p\003C\003\159\000\000\003F\000\000\004^\000\000\003e\000\000\003j\000\000\000\000\000\000\000\000\003C\000\000\000\000\002\002\004]\000\000\003\003E\000\000\003:\003\003k\003\159\000\000\000\000\000\000\000\000\000\000\003o\000\000\003\003E\000\000\003\025\000\000\000\000\003\002\002\003;\000\000\003B\003l\003m\000\000\000\000\003\000\000\003p\000\000\003\000\000\000\000\003o\000\000\000\000\003s\000\000\003C\000\000\000\000\003F\003\004A\003\003;\003\011\003B\000\000\000\000\000\000\000\000\000\000\003p\000\000\003F\000\000\000\000\003\003\003E\007\007\007\003C\007\000\000\003n\000\000\004@\000\000\000\000\003\000\000\003d\000\000\000\000\003u\000\000\000\000\000\000\000\000\000\000\n\000\000\003\003E\000\000\003+\000\000\003s\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\003\011\003v\000\000\007\003F\000\000\000\000\000\000\007\000\000\000\000\003,\0030\000\000\000\000\003s\000\000\003\136\000\000\003\003e\003\003j\000\000\000\000\003\011\002\002\003d\000\000\003F\003u\000\000\002\002\000\000\000\000\000\000\000\000\003k\000\000\000\000\003o\007\004-\000\000\000\000\003\000\000\003o\000\000\001\020\000\000\003d\000\000\003v\003u\000\000\000\000\000\000\003\144\003m\003p\000\000\000\000\000\000\000\000\000\000\000\000\003p\000\000\003\136\000\000\000\000\003e\007\003j\007\007\007\003v\003-\000\000\000\000\002\002\000\000\000\000\000\000\000\000\002\002\000\000\003k\003\151\000\000\003\136\000\000\004,\003e\003o\003j\000\000\000\000\000\000\003n\003o\000\000\000\000\007\000\000\000\000\000\000\000\000\003\144\003m\000\000\000\000\003k\007\003p\000\000\003\153\004\025\003s\000\000\003p\000\000\000\000\001\r\000\000\003s\000\000\000\000\003\011\001\027\001\028\000\000\006\132\003\144\003m\003\011\002\002\000\000\000\000\003/\000\000\003\151\000\000\000\000\000\000\000\000i\000\000\001\023\001\031\000\000\003o\003n\000\000\0031\003d\000\000\000\000\003u\000\000\000\000\000\000\003d\000\000\000\000\003u\003\151\000\000\000\000\003\153\000\000\003p\000\000\000\000\000\000\003s\000\000\003n\000\000\000\000\000\000\003s\003v\000\000\007\003\011\000\000\000\000\000\000\003v\000\000\003\011\000\000\000\000\003\153\000\000\000\000\000\000\003\136\001\001\003e\000\000\003j\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\000\000\003d\000\000\003^\003u\000\000\000\000\003d\003k\000\000\003u\000\000\000\000\003\138\000\000\003k\000\000\000\000\000\000\000\000\003\140\003s\000\000\003_\000\000\001\024\000\000\000\000\003v\003\144\003m\003\011\001\020\000\000\003v\000\000\003\144\003m\000\000\000\000\000\000\000\000\000\000\000\000\003\136\000\000\000\000\003e\000\000\003j\003\136\000\000\000\000\003e\000\000\003j\000\000\000\000\000\000\003d\001\001\003u\003\151\000\000\000\000\003k\001\001\000\000\003\151\003\142\003k\000\000\003n\000\000\003^\003\152\000\000\001T\000\000\003n\000\000\003^\000\000\003\157\003v\003\144\003m\000\000\000\000\003\153\000\000\003\144\003m\002\003_\000\000\003\153\000\000\001\025\001%\003\136\003_\000\000\003e\000\000\003j\000\000\000\000\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\000\000\006|\000\000\003\151\000\000\003:\003k\000\000\003\159\003\151\000\000\003\155\000\000\000\000\003n\000\000i\000\000\001\023\001\031\003n\000\000\001\001\000\000\000\000\000\000\003\144\003m\000\000\000\000\003\153\003\000\000\000\000\000\000\000\000\003\153\003^\001U\003\157\000\000\000\000\000\000\005+\001[\000\000\003\157\003\000\000\002\003;\000\000\003B\000\000\000\000\000\000\002\003_\000\000\000\000\003\151\000\000i\000\000\001X\000\000\000\000\000\000\000\000\003C\000\000\003n\000\000\000\000\003\000\000\000\000\003:\001\001\003\159\000\000\000\000\000\000\003:\001\001\003\159\003\153\000\000\003\003E\000\000\000\000\003^\000\000\000\000\000\000\000\000\000\000\000\000\003^\000\000\000\000\003\000\000\001\024\000\000\000\000\000\000\000\000\003\000\000\000\000\003_\001\001\000\000\000\000\003\157\003\003_\000\000\003;\003\003B\000\000\003\000\000\002\003;\003^\003B\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\003C\n\031\000\000\000\000\000\000\003\000\000\003C\000\000\003_\003\001Y\003\000\000\000\000\003:\000\000\000\000\003\159\000\000\000\000\003\003E\000\000\000\000\000\000\000\000\000\000\003\003E\000\000\000\000\000\000\000\000\003\157\000\000\000\000\000\000\000\000\001\025\001%\003\157\003\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\002\001\001\000\n\003\000\000\000\000\003\000\000\000\000\003;\003\003B\000\000\000\000\003F\000\000\003^\000\000\000\000\003\157\003:\003F\000\000\003\159\000\000\000\000\000\000\003:\003C\002\003\159\003\000\000\003\001Z\000\000\003_\000\000\003\000\000\n\000\000\000\000\000\000\n\000\000\000\000\003\000\000\003\003E\001\001\000\000\003\000\000\000\000\003:\000\000\000\000\003\159\000\000\000\000\003\000\000\000\000\003;\003^\003B\000\000\003\000\000\000\000\003;\000\000\003B\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\003\003C\000\000\003_\000\000\000\000\003\000\000\003C\000\000\003F\n\000\000\003\003\157\000\000\003\000\000\000\000\003;\000\000\003B\003\003E\002\001\001\003\000\000\003\003E\000\000\000\000\000\000\000\000\000\000\000\000\n\003C\000\000\000\000\003^\000\000\003\n\002d\000\000\000\000\000\000\000\000\000\000\011\004\003:\000\000\000\000\003\159\003\000\000\000\000\003\003E\003_\000\000\003\000\000\003\157\000\000\003F\000\000\000\000\000\000\002e\000\000\002f\003F\002\001\001\000\000\003\000\000\002g\000\000\000\000\003\000\000\000\000\000\000\000\000\001\001\003\003^\003\000\000\003\000\000\000\000\003;\n\003B\000\000\002k\003:\003F\003^\003\159\n\000\000\000\000\000\000\000\000\003_\000\000\000\000\000\000\000\000\003C\000\000\000\000\000\000\003\003\003\157\000\000\003_\000\000\000\000\000\000\000\000\003\000\000\000\000\002\000\000\000\000\000\000\000\000\003\003E\000\000\000\000\002m\000\000\000\000\000\000\003\000\000\000\000\003;\000\000\003B\002p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003:\000\000\000\000\003\159\002q\002r\002w\003C\000\000\000\000\000\000\003\003\003\157\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\002\001\001\003\157\003\003\003E\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\003\003^\000\000\000\000\003\000\000\000\000\003;\000\000\003B\000\000\000\000\003:\000\000\000\000\003\159\000\000\000\000\000\000\000\000\000\000\003_\000\000\003\000\000\003:\003C\000\000\003\159\000\000\000\000\003\000\000\000\000\003F\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\001\001\002s\000\000\003\003E\001\001\003\003\000\000\000\000\003\000\000\000\000\003;\003^\003B\000\000\000\000\000\000\000\000\003^\002x\002j\003\000\000\000\000\003;\000\000\003B\000\000\000\000\000\000\003C\000\000\003_\000\000\003\003\003\157\000\000\003_\000\000\000\000\000\000\000\000\003C\000\000\003F\002\000\000\003\000\000\002\024\003\003E\000\000\001\001\000\000\000\000\000\000\002u\002v\000\000\003\000\000\003\003E\000\000\002d\000\000\002|\003^\000\000\000\000\000\000\003:\000\000\002\025\003\159\0020\000\000\000\000\000\000\000\000\000\000\000\000\003\002\027\000\000\000\000\000\000\003_\001\001\002e\003\157\004J\003F\000\000\003\000\000\003\157\003\000\000\002g\002\000\000\000\000\003^\000\000\003F\002\000\000\000\000\003\000\000\000\000\000\000\003\000\000\000\000\003;\000\000\003B\000\000\000\000\000\000\003\003_\000\000\000\000\000\000\000\000\003:\000\000\000\000\003\159\000\000\000\000\003:\003C\000\000\003\159\000\000\000\000\003\000\000\000\000\002#\000\000\000\000\000\000\000\000\003\157\000\000\000\000\000\000\000\000\002$\000\000\003\003\003E\002\000\000\002o\003\000\000\000\000\000\000\000\000\002'\002(\000\000\000\000\002p\003\000\000\000\000\003;\000\000\003B\003\000\000\000\000\003;\000\000\003B\002q\002r\003\157\003:\000\000\000\000\003\159\003\000\000\000\000\003C\000\000\002\000\000\000\000\003\003C\000\000\003F\000\000\000\000\003\000\000\001\001\000\000\005\000\000\000\000\000\000\003\003\003E\000\000\001T\003\000\000\003\003E\003^\003:\001\001\003\159\000\000\000\000\003\000\000\000\000\003;\000\000\003B\005\000\000\000\000\000\000\000\000\003^\000\000\003_\000\000\000\000\000\000\002)\000\000\003\000\000\003\003C\000\000\000\000\003\000\000\003\000\000\000\000\003F\003_\000\000\000\000\002s\000\000\003F\003\002*\002\030\003;\000\000\003B\003\003E\000\000\000\000\003\000\000\000\000\007\026\000\000\000\000\003\000\000\002t\002j\000\000\000\000\003C\000\000\000\000\000\000\000\000\003\000\000\001U\000\000\001\001\006\003\005+\001[\000\000\000\000\003\157\000\000\003\002+\002,\003\003E\000\000\000\000\003^\002\001\001\003F\000\000i\000\000\001X\003\157\000\000\002u\002v\000\000\000\000\000\000\000\000\000\000\003^\002\003_\003\000\000\000\000\000\000\000\000\000\000\000\000\007\027\003:\003\000\000\003\159\000\000\007\028\b8\000\000\000\000\003_\000\000\000\000\003F\006\004\003%\000i\000\000\000\000\003:\000\000\000\000\003\159\000\000\000\000\001\001\000\000\003\000\000\003\000\000\000\000\0075\0076\0077\000\000\000\000\000\000\000\000\000\000\003^\000\000\000\000\003\000\000\003\003;\000\000\003B\000\000\000\000\000\000\000\000\003\157\000\000\000\000\000\000\000\000\n\"\000\000\003_\003\000\000\002\003;\003C\003B\000\000\001Y\000\000\003\003\157\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\003C\000\000\000\000\003\003E\003\000\000\000\000\003:\001\001\003\159\003)\000\000\000\000\000\000\001\001\000\000\000\000\000\000\003\003E\0078\000\000\003^\003:\000\000\000\000\003\159\000\000\000\000\003^\000\000\000\000\003\000\000\003\000\000\003\157\000\000\000\000\000\000\000\000\000\000\003_\000\000\000\000\003F\002\000\000\003\003_\003\003;\003\003B\000\000\000\000\000\000\001Z\000\000\000\000\001\001\003\003F\000\000\000\000\003\000\000\000\000\003;\003C\003B\000\000\000\000\003:\003\003^\003\159\000\000\000\000\003\000\000\000\000\000\000\0079\000\000\000\000\000\000\003C\000\000\000\000\003\003E\003\000\000\000\000\003_\007:\000\000\007;\000\000\003\001\001\003\157\000\000\000\000\000\000\000\000\003\003E\003\157\000\000\000\000\002\000\000\000\000\003\003^\000\000\003;\002\003B\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\nz\n|\007\000\000\007\003F\000\000\003_\003C\000\000\000\000\003:\003\003\003\159\000\000\000\000\000\000\003:\000\000\000\000\003\159\003\003F\000\000\000\000\000\000\003\157\000\000\003\003E\000\000\000\000\000\000\000\000\001\001\002\003\000\000\003\000\000\007\000\000\000\000\003\000\000\007\000\000\000\000\000\000\003^\000\000\000\000\003\000\000\000\000\003;\000\000\003B\000\000\003\000\000\003\003;\003:\003B\000\000\003\159\003\157\000\000\003_\000\000\000\000\003F\000\000\003C\000\000\000\000\002\000\000\003\007\003C\002\002\001T\000\000\003\000\000\000\000\003\003\002\002\000\000\000\000\003\003E\000\000\003o\000\000\000\000\000\000\003\003E\000\000\003:\003\003o\003\159\003;\000\000\003B\007\000\000\007\007\007\000\000\003p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003p\003C\003\000\000\003\157\003\003\000\000\000\000\003\000\000\000\000\000\000\003F\002\000\000\000\000\000\000\000\000\007\003F\003\003\003E\003;\000\000\003B\000\000\000\000\007\003\000\000\000\000\000\000\000\000\001U\000\000\003\000\000\000\000\005+\001[\003:\003C\000\000\003\159\000\000\000\000\003\000\000\000\000\000\000\000\000\003s\000\000\000\000\003\000\000\000\000i\000\000\001X\003s\003\011\003\003E\000\000\003F\000\000\003\000\000\000\000\003\011\000\000\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\003\003\000\000\000\000\003;\000\000\003B\003d\000\000\003o\003u\000\000\000\000\000\000\003\000\000\003d\007\000\000\003u\000\000\000\000\000\000\003C\000\000\003F\000\000\000\000\003\003p\000\000\000\000\000\000\000\000\003v\002\002\000\000\000\000\000\000\000\000\000\000\003\003v\003\003E\000\000\001T\000\000\000\000\003\136\003o\000\000\003e\000\000\003j\n%\000\000\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\001Y\000\000\000\000\000\000\000\000\003p\003k\000\000\000\000\000\000\000\000\003\003\000\000\000\000\003k\002\002\000\000\002d\003\000\000\000\000\003F\000\000\003s\000\000\003\144\003m\000\000\000\000\000\000\003o\000\000\000\000\003\011\003\144\003m\000\000\000\000\003\000\000\000\000\000\000\000\000\002e\000\000\002\000\000\000\000\000\000\000\000\003p\000\000\000\000\002g\000\000\000\000\000\000\001U\000\000\003\151\000\000\003d\005+\001[\003u\003s\002\002\003\151\000\000\003n\000\000\000\000\001Z\000\000\003\011\000\000\000\000\000\000\003n\000\000i\003o\001X\000\000\000\000\000\000\003\153\003v\002\002\000\000\000\000\000\000\000\000\000\000\003\153\000\000\000\000\000\000\000\000\000\000\003p\003d\003\136\003o\003u\003e\000\000\003j\000\000\000\000\003s\000\000\002o\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\011\000\000\002p\003p\003k\000\000\000\000\000\000\003v\003\000\000\000\000\000\000\000\000\000\000\002q\002r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\136\003\144\003m\003e\003d\003j\000\000\003u\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\n)\000\000\003s\000\000\000\000\000\000\003k\000\000\000\000\000\000\001Y\003\003\011\000\000\000\000\003v\002\002\000\000\003\151\000\000\000\000\000\000\002\002\003s\000\000\003\144\003m\000\000\003n\003\136\003o\000\000\003e\003\011\003j\000\000\000\000\003o\003d\000\000\000\000\003u\000\000\000\000\000\000\003\153\000\000\000\000\000\000\000\000\003p\003k\000\000\002s\000\000\000\000\003\003p\000\000\003\151\000\000\003d\000\000\000\000\003u\003v\000\000\000\000\000\000\000\000\003n\000\000\003\144\003m\002t\002j\000\000\002\002\000\000\000\000\003\136\000\000\001Z\003e\000\000\003j\003\153\003v\000\000\000\000\000\000\000\000\003o\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003k\003\136\000\000\003\151\003e\003\003j\000\000\000\000\003s\003p\002u\002v\000\000\003n\000\000\003s\000\000\000\000\003\011\000\000\003\144\003m\003k\000\000\000\000\003\011\000\000\003\000\000\000\000\003\153\000\000\000\000\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\003\144\003m\000\000\003d\000\000\000\000\003u\000\000\000\000\003o\003d\003\151\000\000\003u\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003n\000\000\000\000\000\000\000\000\000\000\003s\003p\003v\000\000\000\000\000\000\003\151\000\000\000\000\003v\003\011\003\153\002\002\000\000\000\000\000\000\003n\003\136\000\000\000\000\003e\000\000\003j\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\000\000\000\000\003\153\000\000\000\000\000\000\003d\000\000\003k\003u\000\000\000\000\000\000\004\000\000\000\003k\003y\000\000\000\000\000\000\004\002\000\000\002\002\000\000\000\000\000\000\000\000\000\000\003\144\003m\003s\000\000\003v\000\000\000\000\003\144\003m\003o\000\000\000\000\003\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\000\000\000\000\003p\002\002\000\000\000\000\003\151\000\000\000\000\000\000\000\000\001T\003d\003\151\003k\003u\000\000\003n\003o\004\004\000\000\003\n\000\000\000\000\003n\000\000\000\000\000\000\002\002\000\000\003\011\000\000\000\000\003\153\003\144\003m\000\000\003p\003v\000\000\003\153\000\000\000\000\003o\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\136\000\000\000\000\003e\003d\003j\000\000\000\000\003s\003p\000\000\000\000\000\000\000\000\003\151\000\000\000\000\000\000\003\011\000\000\002\002\003k\000\000\000\000\003n\000\000\004\006\000\000\000\000\000\000\003\147\000\000\000\000\001U\000\000\003o\000\000\000\000\005+\001[\000\000\003\153\003\144\003m\003s\003d\000\000\000\000\003u\003e\000\000\003j\000\000\000\000\003\011\003p\000\000i\000\000\001X\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003k\000\000\003s\000\000\003v\000\000\000\000\000\000\003\151\000\000\000\000\000\000\003\011\000\000\003d\002\002\003u\000\000\003n\003\136\003l\003m\003e\000\000\003j\000\000\000\000\000\000\000\000\000\000\003o\000\000\000\000\000\000\000\000\003\153\001\020\000\000\000\000\003d\003v\003k\003u\000\000\002\002\004\b\000\000\003s\000\000\003p\000\000\000\000\000\000\000\000\000\000\003\136\000\000\003\011\003e\003o\003j\003\144\003m\000\000\003n\003v\001\001\n,\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003k\001Y\003p\000\000\003\136\004\n\000\000\003e\003d\003j\000\000\003u\000\000\000\000\000\000\000\000\000\000\000\000\003\151\003\003\003\144\003m\000\000\000\000\003\003k\000\000\000\000\003n\001T\004\012\000\000\000\000\003s\003v\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\003\011\006\003\153\003\144\003m\000\000\000\000\003\136\000\000\000\000\003e\003\151\003j\000\000\000\000\000\000i\000\000\001\023\001\031\003s\000\000\003n\000\000\000\000\000\000\000\000\000\000\003d\003k\003\011\003u\001Z\000\000\004\016\000\000\000\000\003\151\000\000\003\153\000\000\002\002\002\000\000\000\000\000\000\000\000\003n\000\000\003\144\003m\000\000\002\000\000\003v\000\000\003o\003d\000\000\000\000\003u\000\000\000\000\001U\003\153\002\002\000\000\005+\001[\003\136\000\000\000\000\003e\000\000\003j\003p\000\000\000\000\003\003:\003o\000\000\003\151\003v\000\000\000\000i\000\000\001X\000\000\000\000\003k\000\000\003n\000\000\000\000\004\015\000\000\000\000\003\136\003p\000\000\003e\000\000\003j\001\024\003\000\000\000\000\000\000\003\153\000\000\003\144\003m\000\000\000\000\000\000\000\000\002\002\000\000\003k\000\000\000\000\000\000\003;\004\018\003B\000\000\000\000\000\000\000\000\000\000\000\000\003o\000\000\000\000\003s\000\000\000\000\000\000\000\000\003\144\003m\003C\000\000\003\151\003\011\000\000\000\000\000\000\000\000\000\000\000\000\003p\002\002\003n\000\000\000\000\000\000\000\000\003s\000\000\000\000\003D\003E\n0\000\000\000\000\000\000\003o\003\011\000\000\003\153\003d\003\151\001Y\003u\000\000\001\025\001%\000\000\000\000\000\000\000\000\000\000\003n\000\000\000\000\000\000\003p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003d\000\000\003v\003u\003\153\000\000\000\000\003\000\000\000\000\003F\000\000\000\000\002\002\000\000\003s\000\000\003\136\002\002\003e\000\000\003j\000\000\000\000\003\011\003v\000\000\003o\000\000\000\000\000\000\000\000\000\000\003o\000\000\000\000\000\000\000\000\003k\000\000\000\000\003\136\000\000\004\020\003e\000\000\003j\003p\000\000\000\000\001Z\003s\003d\003p\000\000\003u\000\000\000\000\000\000\003\144\003m\003\011\000\000\003k\000\000\000\000\000\000\000\000\004\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003v\000\000\000\000\000\000\000\000\003\144\003m\000\000\000\000\000\000\003d\001\001\003u\003\151\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\000\000\000\000\003n\000\000\003^\000\000\000\000\003s\000\000\000\000\000\000\000\000\000\000\003s\003v\003k\003\151\003\011\000\000\003\153\004\024\000\000\000\000\003\011\003_\002\002\003n\000\000\000\000\003\136\000\000\002d\003e\000\000\003j\003\144\003m\000\000\000\000\000\000\003o\000\000\000\000\003\153\003d\000\000\000\000\003u\000\000\000\000\003d\003k\000\000\003u\000\000\000\000\004\029\002e\000\000\002n\003p\000\000\000\000\000\000\000\000\000\000\000\000\002g\000\000\003\151\000\000\003v\003\144\003m\000\000\000\000\000\000\003v\000\000\000\000\003n\000\000\000\000\000\000\000\000\003\157\000\000\003\136\002\002\003e\000\000\003j\003\136\000\000\002\003e\003\153\003j\000\000\000\000\000\000\000\000\000\000\003o\006\003\151\000\000\000\000\003k\000\000\000\000\000\000\000\000\004\031\003k\000\000\003n\000\000\000\000\004#\000\000\003s\003:\003p\000\000\003\159\000\000\002o\000\000\003\144\003m\003\011\000\000\003\153\000\000\003\144\003m\002p\000\000\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\002q\002r\000\000\000\000\000\000\003^\000\000\000\000\000\000\003d\000\000\000\000\003u\003\151\000\000\003\006\000\000\003;\003\151\003B\000\000\006\b*\003n\003_\000\000\000\000\000\000\000\000\003n\001\000i\000\000\000\000\003s\003v\003C\000\000\000\000\000\000\003\153\004%\000\000\000\000\003\011\000\000\003\153\000\000\007\b\007\t\007\n\003\136\002\002\003e\000\000\003j\003\003E\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003o\000\000\000\000\000\000\003d\003k\000\000\003u\000\000\000\000\004(\002s\000\000\000\000\000\000\000\000\000\000\000\000\003\157\000\000\003p\001\001\003\000\000\000\000\003\144\003m\002\000\000\000\000\003v\002t\002j\003F\000\000\000\000\003^\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\003\136\000\000\000\000\003e\003\003j\000\000\007\011\000\000\003:\003_\000\000\003\159\003\151\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003k\000\000\003n\002u\002v\004+\000\000\000\000\001`\000\000\000\000\000\000\000\000\003s\003\000\000\000\000\000\000\000\000\003\153\000\000\003\144\003m\003\011\000\000\001\001\000\000\000\000\000\000\003\001\001\003;\000\000\003B\000\000\000\000\000\000\000\000\000\000\003^\000\000\000\000\000\000\000\000\000\000\003^\000\000\007\012\003\157\003d\003C\000\000\003u\003\151\000\000\0041\000\000\000\000\002\003_\007\r\000\000\007\014\000\000\003n\003_\000\000\000\000\000\000\000\000\002d\003\003E\000\000\000\000\000\000\003v\000\000\000\000\000\000\000\000\003\153\000\000\000\000\001U\000\000\003:\001\001\003\159\001b\001c\003\136\001d\000\000\003e\002e\003j\004J\000\000\000\000\000\000\000\000\003^\000\000\003\002g\000\000i\000\000\001X\002\151\002\152\003\003k\000\000\003F\000\000\000\000\0043\000\000\003\157\000\000\003_\001\001\000\000\003\157\000\000\003\000\000\002\003;\003\003B\003\144\003m\002\000\000\000\000\003^\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003C\000\000\000\000\000\000\000\000\0047\000\000\000\000\003:\003_\000\000\003\159\000\000\000\000\003:\000\000\002o\003\159\003\151\000\000\000\000\003\003E\000\000\000\000\000\000\002p\001\001\003n\000\000\000\000\000\000\000\000\003\157\003\000\000\000\000\000\000\002q\002r\003\000\000\003^\002\000\000\003\153\000\000\001Y\000\000\000\000\003\001\001\003;\003\003B\003\000\000\t\149\003;\000\000\003B\003_\000\000\000\000\003F\000\000\003^\000\000\000\000\003\157\003:\003C\000\000\003\159\000\000\000\000\0049\003C\000\000\002\000\000\003\004<\000\000\000\000\000\000\003_\000\000\000\000\b\129\000\000\000\000\003\003E\000\000\000\000\000\000\003\003\003E\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003:\000\000\000\000\003\159\b\132\000\000\003\000\000\000\000\003;\002s\003B\000\000\000\000\001Z\002\157\003\157\000\000\000\000\003\000\000\000\000\000\000\000\000\002\158\003\002\003\003C\000\000\003F\002t\002j\004?\000\000\000\000\003F\000\000\000\000\000\000\000\000\003\157\000\000\003\001\001\003;\003\003B\003\003E\002\000\000\003\003:\000\000\000\000\003\159\000\000\000\000\003^\007\026\001\001\000\000\003C\000\000\000\000\000\000\000\000\004I\002u\002v\000\000\000\000\000\000\000\000\000\000\003^\003:\003_\003\003\159\003\000\000\000\000\003\003E\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\003\003_\000\000\003;\000\000\003B\000\000\000\000\000\000\003\000\000\000\000\000\000\001\020\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003C\003\000\000\003\007\027\004S\003;\000\000\003B\000\000\007\028\007\003F\000\000\000\000\000\000\001\001\000\000\003%\000i\003\003E\003\157\000\000\003C\000\000\000\000\000\000\003\004U\000\000\003^\002\001\001\000\000\0075\0076\0077\000\000\003\157\000\000\000\000\000\000\000\000\003\003E\000\000\000\000\003^\002\003_\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\003:\000\000\000\000\003\159\000\000\003F\000\000\000\000\001\r\003_\000\000\000\000\000\000\000\000\001\027\001\028\000\000\006\158\003:\003\000\000\003\159\003\000\000\001\001\000\000\003\000\000\000\000\003F\000\000i\000\000\001\023\001\031\000\000\000\000\000\000\003)\003^\000\000\000\000\003\000\000\003\003;\003\003B\000\000\0078\000\000\000\000\003\157\000\000\000\000\000\000\000\000\000\000\000\000\003_\003\000\000\002\003;\003C\003B\001T\000\000\000\000\004W\003\157\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\003C\000\000\000\000\003\003E\004`\000\000\000\000\003:\001\001\003\159\000\000\000\000\000\000\000\000\001\001\000\000\000\000\000\000\003\003E\000\000\000\000\003^\003:\000\000\000\000\003\159\000\000\0079\003^\000\000\000\000\003\000\000\003\000\000\003\157\001\024\000\000\000\000\000\000\007:\003_\007;\000\000\003F\002\000\000\003\003_\003\003;\003\003B\000\000\000\000\000\000\000\000\000\000\001U\001\001\003\003F\005+\001[\003\000\000\000\000\003;\003C\003B\000\000\000\000\003:\004\150\003^\003\159\000\000\000\000\003\000\000\000\000i\000\000\001X\000\000\000\000\003C\000\000\000\000\003\003E\005\000\000\000\000\003_\000\000\000\000\000\000\000\000\003\002\002\003\157\000\000\000\000\000\000\000\000\003\003E\003\157\001\025\001%\002\000\000\000\000\003\003o\000\000\003;\002\003B\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\003p\003C\000\000\000\000\003:\003\005\003\159\000\000\000\000\000\000\003:\000\000\000\000\003\159\003\003F\000\000\000\000\000\000\003\157\000\000\003\003E\000\000\000\000\n3\000\000\002\002\002\003\000\000\003\000\000\000\000\001Y\000\000\003\000\000\000\000\000\000\000\000\000\000\003o\000\000\000\000\003\000\000\000\000\003;\000\000\003B\000\000\003\000\000\003\003;\003:\003B\000\000\003\159\003s\000\000\003p\000\000\000\000\003F\000\000\003C\000\000\000\000\003\011\000\000\005\000\000\003C\002\002\001T\000\000\005\000\000\000\000\003\003\002\002\000\000\000\000\003\003E\000\000\003o\000\000\000\000\000\000\003\003E\000\000\003d\003\003o\003u\003;\000\000\003B\000\000\000\000\000\000\000\000\001Z\000\000\003p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003p\003C\003\000\000\003s\003v\005\000\000\000\000\003\000\000\000\000\000\000\003F\003\011\000\000\000\000\000\000\000\000\000\000\003F\003\136\003\003E\003e\000\000\003j\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\001U\000\000\003\000\000\000\000\005+\001[\003d\003k\000\000\003u\000\000\000\000\006&\000\000\000\000\000\000\000\000\003s\000\000\000\000\003\000\000\000\000i\000\000\001X\003s\003\011\003\144\003m\000\000\003F\000\000\003v\000\000\000\000\003\011\000\000\000\000\000\000\000\000\002\002\000\000\000\000\000\000\000\000\000\000\003\003\136\000\000\000\000\003e\000\000\003j\003d\000\000\003o\003u\000\000\000\000\000\000\003\151\000\000\003d\000\000\000\000\003u\000\000\000\000\000\000\003k\000\000\003n\000\000\000\000\006)\003p\000\000\000\000\000\000\000\000\003v\002\002\000\000\000\000\000\000\000\000\000\000\003\153\003v\003\144\003m\000\000\000\000\000\000\000\000\003\136\003o\000\000\003e\000\000\003j\n6\000\000\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\001Y\000\000\000\000\000\000\000\000\003p\003k\000\000\000\000\000\000\000\000\0062\003\151\000\000\000\000\003k\002\002\000\000\002d\0064\000\000\000\000\003n\000\000\003s\000\000\003\144\003m\000\000\000\000\000\000\003o\000\000\000\000\003\011\003\144\003m\000\000\000\000\003\153\000\000\000\000\000\000\000\000\002e\000\000\002z\000\000\000\000\000\000\000\000\003p\000\000\000\000\002g\000\000\000\000\001\020\000\000\000\000\003\151\000\000\003d\000\000\000\000\003u\003s\002\002\003\151\000\000\003n\000\000\000\000\001Z\000\000\003\011\000\000\000\000\000\000\003n\000\000\000\000\003o\000\000\000\000\000\000\000\000\003\153\003v\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\153\000\000\000\000\000\000\000\000\000\000\003p\003d\003\136\000\000\003u\003e\000\000\003j\000\000\000\000\003s\000\000\002o\000\000\000\000\000\000\000\000\000\000\002\002\003\011\000\000\002p\000\000\003k\000\000\000\000\000\000\003v\006;\000\000\000\000\001\r\000\000\003o\002q\002r\000\000\001\027\001\028\000\000\001\029\000\000\000\000\003\136\003\144\003m\003e\003d\003j\000\000\003u\000\000\000\000\003p\000\000i\000\000\001\023\001\031\001 \001!\003s\000\000\000\000\000\000\003k\000\000\000\000\000\000\000\000\006A\003\011\000\000\000\000\003v\002\002\000\000\003\151\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\144\003m\000\000\003n\003\136\003o\000\000\003e\000\000\003j\000\000\000\000\000\000\003d\000\000\000\000\003u\000\000\000\000\000\000\003\153\002\002\000\000\000\000\003p\003k\000\000\002s\003s\000\000\006I\000\000\000\000\003\151\000\000\000\000\003o\000\000\003\011\003v\001\001\000\000\000\000\003n\000\000\003\144\003m\002t\002j\000\000\000\000\000\000\000\000\000\000\003\136\003p\000\000\003e\001\024\003j\003\153\000\000\000\000\000\000\000\000\003d\002\002\003u\001\"\005\150\000\000\000\000\000\000\na\003@\003k\006^\000\000\003\151\000\000\006T\003o\000\000\000\000\003s\000\000\002u\002v\000\000\003n\000\000\003v\000\000\000\000\003\011\000\000\003\144\003m\000\000\000\000\000\000\003p\000\000\000\000\000\000\000\000\003\153\003\136\000\000\000\000\003e\000\000\003j\000\000\000\000\000\000\003s\000\000\000\000\002\002\000\000\003d\000\000\000\000\003u\003\011\000\000\000\000\003k\003\151\000\000\001\025\001%\007m\003o\002\000\000\000\000\000\000\000\000\003n\001&\001.\000\000\000\000\002\000\000\000\000\003v\003\144\003m\000\000\000\000\003d\003p\000\000\003u\003\153\000\000\000\000\000\000\000\000\003s\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\000\000\003\011\003:\001\001\000\000\000\000\000\000\000\000\003v\000\000\000\000\003\151\000\000\000\000\003k\000\000\000\000\000\000\003^\007p\000\000\000\000\003n\000\000\003\136\002\002\003e\003d\003j\000\000\003u\000\000\000\000\000\000\003\144\003m\000\000\003_\003\153\000\000\003o\000\000\000\000\003s\000\000\003k\003;\000\000\003B\000\000\bp\000\000\000\000\003\011\003v\000\000\000\000\000\000\000\000\000\000\003p\000\000\000\000\000\000\000\000\003C\003\144\003m\003\151\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\000\000\000\000\003n\000\000\003d\000\000\000\000\003u\000\000\003D\003E\000\000\000\000\000\000\000\000\003k\000\000\000\000\000\000\003\153\b{\000\000\003\157\003\151\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003v\002\000\000\003n\000\000\003\144\003m\000\000\000\000\000\000\000\000\002\002\000\000\003s\000\000\003\136\000\000\000\000\003e\003\153\003j\000\000\003F\003\011\002\002\003o\000\000\003:\000\000\000\000\003\159\000\000\002\002\000\000\000\000\003k\003\151\000\000\003o\000\000\b\128\000\000\000\000\000\000\003p\001\001\003n\000\000\003d\000\000\000\000\003u\003\000\000\000\000\003\144\003m\003p\000\000\000\000\003^\000\000\000\000\003\153\005\000\000\003y\000\000\003\000\000\000\000\003;\000\000\003B\000\000\003v\000\000\000\000\000\000\000\000\003_\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\151\003C\003\136\000\000\000\000\003e\b\135\003j\000\000\000\000\000\000\003n\000\000\000\000\000\000\000\000\003s\000\000\000\000\000\000\000\000\000\000\003\003E\003k\000\000\003\011\000\000\003\153\b\137\003s\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\n\003\011\000\000\000\000\000\000\000\000\003\144\003m\000\000\000\000\003\011\002\002\000\000\003\157\003d\000\000\003\003u\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\003o\003F\003d\000\000\000\000\003u\000\000\002\002\000\000\000\000\003d\000\000\003\151\000\000\003v\000\000\000\000\003\000\000\003p\000\000\000\000\003o\003n\003:\000\000\000\000\003\159\003v\000\000\003\136\000\000\000\000\003e\000\000\003j\000\000\003\132\000\000\000\000\003\153\000\000\003p\000\000\003\136\000\000\000\000\003e\003\135\003j\003\134\003\003k\000\000\000\000\000\000\003e\b\139\003j\000\000\000\000\000\000\002\002\000\000\000\000\003k\003\000\000\000\000\003;\b\149\003B\003\144\003m\003k\000\000\000\000\003o\000\000\000\000\003s\000\000\000\000\000\000\000\000\000\000\003\144\003m\003C\000\000\003\011\000\000\000\000\b\152\000\000\003l\003m\003p\000\000\000\000\000\000\000\000\000\000\003s\000\000\000\000\003\151\000\000\000\000\003\003E\000\000\000\000\003\011\001\001\000\000\003n\003d\000\000\003\151\003u\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003^\003n\000\000\000\000\003\153\000\000\000\000\000\000\000\000\002d\003n\003d\000\000\003\003u\003v\000\000\000\000\003\153\000\000\003_\000\000\000\000\000\000\003F\000\000\001\001\000\000\003s\000\000\003\136\000\000\000\000\003e\002e\003j\002\003v\003\011\000\000\003\003^\000\000\000\000\002g\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003k\003\136\000\000\000\000\003e\b\003j\000\000\000\000\003_\001\001\000\000\000\000\003d\000\000\000\000\003u\000\000\000\000\000\000\003\144\003m\003k\000\000\000\000\003^\000\000\b\003\157\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\003v\000\000\000\000\003\144\003m\003_\000\000\000\000\000\000\000\000\000\000\000\000\002o\000\000\003\151\000\000\003\136\000\000\000\000\003e\000\000\003j\002p\000\000\000\000\003n\003:\000\000\000\000\003\159\003\157\000\000\000\000\000\000\000\000\002q\002r\003\151\003k\000\000\002\000\000\003\153\t/\000\000\000\000\000\000\000\000\003n\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\003\144\003m\000\000\000\000\000\000\000\000\003\153\000\000\003\157\003:\003\000\000\003\159\003;\000\000\003B\000\000\000\000\002\000\000\000\000\000\000\001\001\000\000\000\000\000\000\000\000\001\001\000\000\000\000\003C\000\000\003\151\000\000\003\t2\003^\000\000\000\000\000\000\000\000\000\000\003^\003n\003:\000\000\000\000\003\159\000\000\000\000\003\003\003E\003;\002s\003B\003_\000\000\000\000\000\000\003\153\000\000\003_\000\000\000\000\001\020\000\000\000\000\000\000\000\000\000\000\003\003C\000\000\000\000\002t\002j\t9\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\003\000\000\000\000\003;\000\000\003B\003\003E\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003C\001\020\000\000\000\000\003\t\002u\002v\000\000\003\157\000\000\000\000\000\000\000\000\000\000\003\157\000\000\000\000\003\002\000\000\003\003E\000\000\000\000\002\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\000\000\001\029\000\000\000\000\003\003:\000\000\000\000\003\159\001\020\000\000\003:\000\000\003\003\159\004\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\001\r\003\000\000\000\000\003\001`\001\027\001\028\000\000\001\029\000\000\003\000\000\000\000\003;\000\000\003B\003\000\000\000\000\003;\000\000\003B\000\000i\000\000\001\023\001\031\001 \001!\000\000\n\129\000\000\003C\000\000\000\000\000\000\000\000\t\003C\000\000\000\000\000\000\000\000\t\000\000\000\000\000\000\000\000\000\000\001\r\000\000\000\000\000\000\003\003E\001\027\001\028\000\000\001\029\003\003E\000\000\000\000\000\000\001\020\000\000\000\000\000\000\000\000\001\024\000\000\000\000\000\000i\000\000\001\023\001\031\001 \001!\n\017\001\"\004\001U\000\000\000\000\000\000\000\000\003\001b\001c\000\000\001d\000\000\003\000\000\000\000\000\000\000\000\003F\000\000\001\020\000\000\000\000\000\000\003F\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\001\024\003\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\001\"\n\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001`\001\r\000\000\001\025\001%\000\000\000\000\001\027\001\028\000\000\001\029\000\000\000\000\001&\001.\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\024\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\001\"\n\130\000\000\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\000\000\001\029\000\000\001\025\001%\000\000\000\000\001`\000\000\000\000\000\000\001Y\000\000\001&\001.\000\000i\000\000\001\023\001\031\001 \001!\002\154\t\152\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001U\000\000\000\000\000\000\000\000\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\000\000\000\000\001`\000\000\000\000\000\000\000\000\001\025\001%\000\000\000\000i\000\000\001X\002\151\002\152\002\153\001&\001.\000\000\000\000\000\000\000\000\000\000\000\000\001\024\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\"\001-\000\000\001U\001Z\002\157\000\000\002d\000\000\001b\001c\000\000\001d\000\000\002\158\002\000\000\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\001\024\000\000i\000\000\001X\002\151\002\152\002\153\002e\000\000\004J\001\"\002\138\000\000\000\000\000\000\000\000\000\000\002g\001U\000\000\000\000\000\000\000\000\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\000\000\000\000\000\000\001`\000\000\000\000\000\000\001\025\001%\001Y\000\000i\000\000\001X\002\151\002\152\002\153\001&\001.\000\000\002\154\002\000\000\002d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\025\001%\000\000\000\000\002o\000\000\002e\000\000\004J\000\000\001&\001.\001\020\000\000\002p\000\000\002g\000\000\001Y\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002q\002r\002\154\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001U\000\000\000\000\001Z\002\157\000\000\001b\001c\b\001d\000\000\000\000\000\000\002\158\002\001\020\000\000\000\000\000\000\000\000\000\000\001Y\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\002\154\004h\000\000\000\000\000\000\000\000\000\000\002o\000\000\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002p\000\000\000\000\001\r\000\000\001\020\001Z\002\157\000\000\001\027\001\028\000\000\001\029\002q\002r\000\000\002\158\002\001\020\000\000\002s\000\000\000\000\000\000\000\000\000\000\000\000i\b\001\023\001\031\001 \001!\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002t\002j\000\000\001\r\000\000\000\000\001Z\002\157\000\000\001\027\001\028\000\000\001\029\000\000\000\000\000\000\002\158\002\001\020\000\000\000\000\000\000\000\000\000\000\b\129\001Y\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\002\154\004m\000\000\000\000\002u\002v\001\r\000\000\000\000\000\000\b\131\000\000\001\027\001\028\000\000\001\029\002s\000\000\001\020\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\b\001\029\000\000i\000\000\001\023\001\031\001 \001!\000\000\002t\002j\000\000\000\000\001\024\000\000i\002d\001\023\001\031\001 \001!\000\000\000\000\000\000\001\"\004y\000\000\000\000\000\000\000\000\000\000\000\000\001\r\000\000\000\000\000\000\001Z\002\157\001\027\001\028\000\000\001\029\002e\000\000\002f\000\000\002\158\002\001\020\002u\002v\000\000\002g\000\000\001\024\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\001\"\004~\000\000\001\r\000\000\000\000\000\000\000\000\002\128\001\027\001\028\000\000\001\029\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\025\001%\000\000\000\000i\001\024\001\023\001\031\001 \001!\001&\001.\000\000\000\000\001\020\000\000\001\"\004\001\024\000\000\000\000\000\000\000\000\000\000\000\000\002m\000\000\000\000\000\000\001\"\004\000\000\000\000\000\000\000\000\002p\000\000\000\000\001\r\000\000\000\000\001\025\001%\000\000\001\027\001\028\000\000\001\029\002q\002r\002w\001&\001.\001`\000\000\000\000\000\000\000\000\000\000\001\024\000\000\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\001\"\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\025\001%\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&\001.\001\r\001\025\001%\001\024\000\000\000\000\001\027\001\028\000\000\001\029\000\000\001&\001.\000\000\001\"\004\001`\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\000\000\000\000\000\000\002s\000\000\000\000\001U\000\000\000\000\001\025\001%\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\001&\001.\001\020\000\000\000\000\002x\002j\000\000\000\000\001\024\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\000\000\001\"\005\007\000\000\000\000\000\000\000\000\001\025\001%\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&\001.\000\000\000\000\000\000\000\000\001U\000\000\000\000\002u\002v\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\002|\000\000\001\020\000\000\000\000\000\000\000\000\000\000\001\024\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\001\"\005\024\000\000\000\000\000\000\000\000\001\r\000\000\000\000\000\000\001\025\001%\001\027\001\028\000\000\001\029\000\000\000\000\000\000\000\000\001&\001.\001`\000\000\000\000\000\000\000\000\000\000\001Y\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\002\154\005*\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001`\001\r\000\000\000\000\001\025\001%\000\000\001\027\001\028\000\000\001\029\000\000\000\000\000\000\001&\001.\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001Y\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\002\154\005-\000\000\000\000\000\000\000\000\001U\000\000\000\000\001Z\002\157\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\002\158\002\001`\000\000\000\000\000\000\000\000\000\000\001\024\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\001\"\005N\000\000\000\000\000\000\000\000\001U\000\000\000\000\000\000\000\000\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\000\000\000\000\001`\000\000\000\000\000\000\000\000\001Z\002\157\000\000\000\000i\000\000\001X\002\151\002\152\002\153\002\158\002\000\000\000\000\000\000\000\000\000\000\000\000\001\024\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\"\005[\000\000\000\000\000\000\001`\001U\000\000\000\000\001\025\001%\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\001&\001.\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001Y\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\000\000\002\154\005f\000\000\000\000\000\000\001U\000\000\000\000\000\000\000\000\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\025\001%\001Y\000\000i\002d\001X\002\151\002\152\002\153\001&\001.\000\000\002\154\005k\000\000\005\000\000\000\000\001U\000\000\000\000\000\000\000\000\000\000\001b\001c\000\000\001d\000\000\002d\002e\000\000\004J\000\000\000\000\000\000\000\000\000\000\001Z\002\157\002g\000\000i\000\000\001X\002\151\002\152\002\153\002\158\002\001\020\000\000\000\000\000\000\000\000\002e\001Y\004J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002g\000\000\002\154\005p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001Z\002\157\000\000\000\000\001\020\000\000\000\000\000\000\000\000\000\000\002\158\002\001\020\000\000\000\000\000\000\000\000\000\000\001Y\000\000\000\000\000\000\000\000\000\000\000\000\002o\000\000\000\000\000\000\002\154\005|\000\000\000\000\000\000\000\000\002p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002q\002r\002o\000\000\001\r\001`\000\000\001Z\002\157\001Y\001\027\001\028\002p\001\029\000\000\000\000\000\000\002\158\002\005\002\154\005\152\000\000\000\000\000\000\002q\002r\000\000i\000\000\001\023\001\031\001 \001!\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\001\r\001\029\000\000\001Z\002\157\000\000\001\027\001\028\000\000\001\029\005\000\000\000\000\002\158\002\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\000\000\000\000\004K\000\000\000\000\002s\000\000\000\000\001U\001Z\002\157\000\000\000\000\005\001b\001c\000\000\001d\000\000\002\158\002\000\000\000\000\000\000\004N\000\000\002t\002j\000\000\000\000\002s\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\001`\000\000\000\000\000\000\001\024\000\000\000\000\000\000\000\000\000\000\000\000\002t\002j\000\000\000\000\001\"\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002u\002v\000\000\000\000\000\000\000\000\000\000\000\000\001\024\000\000\000\000\001\020\000\000\000\000\000\000\000\000\001\024\000\000\000\000\001\"\005\000\000\000\000\005\000\000\002u\002v\001\"\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001`\001U\001\025\001%\000\000\000\000\001Y\001b\001c\000\000\001d\000\000\001&\001.\000\000\000\000\000\000\002\154\006\024\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\001\025\001%\000\000\000\000\000\000\001`\001\r\000\000\001\025\001%\001&\001.\001\027\001\028\000\000\001\029\000\000\000\000\001&\001.\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\001\r\001`\000\000\000\000\000\000\000\000\001\027\001\028\001U\001\029\000\000\001Z\002\157\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\002\158\002\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001U\001Y\000\000\000\000\000\000\000\000\001b\001c\000\000\001d\000\000\000\000\002\154\006!\000\000\001\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\000\000\000\000\001U\000\000\000\000\000\000\001\024\000\000\001b\001c\000\000\001d\000\000\000\000\000\000\000\000\000\000\001\"\0069\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\000\000\000\000\000\000\000\000\001\024\000\000\000\000\000\000\000\000\000\000\001Z\002\157\001Y\000\000\000\000\001\"\006>\000\000\000\000\000\000\002\158\002\000\000\002\154\006\000\000\001\020\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\000\000\001\029\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\025\001%\001Y\000\000i\000\000\001\023\001\031\001 \001!\001&\001.\001\020\002\154\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\025\001%\000\000\000\000\001Y\000\000\000\000\000\000\001Z\002\157\001&\001.\000\000\001\020\000\000\002\154\006\000\000\002\158\002\000\000\000\000\000\000\000\000\000\000\001\r\001\020\000\000\000\000\000\000\000\000\001\027\001\028\000\000\001\029\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001Z\002\157\000\000\000\000i\000\000\001\023\001\031\001 \001!\002\158\002\001\020\001\r\000\000\000\000\000\000\000\000\001\024\001\027\001\028\000\000\001\029\000\000\000\000\000\000\000\000\000\000\000\000\001\"\007#\000\000\000\000\000\000\001Z\002\157\000\000i\000\000\001\023\001\031\001 \001!\000\000\002\158\002\001\r\001\020\000\000\000\000\000\000\000\000\001\027\001\028\000\000\001\029\000\000\000\000\000\000\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\000\000\001\029\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001\023\001\031\001 \001!\000\000\001\r\001`\000\000\001\025\001%\001\024\001\027\001\028\000\000\001\029\000\000\000\000\000\000\001&\001.\000\000\001\"\007%\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\000\000\001\020\001\r\000\000\000\000\001\024\000\000\000\000\001\027\001\028\000\000\001\029\000\000\000\000\000\000\000\000\001\"\007A\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001\023\001\031\001 \001!\000\000\000\000\000\000\000\000\000\000\000\000\001\024\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001U\001\025\001%\001\"\007k\001\024\001b\001c\000\000\001d\000\000\001&\001.\000\000\000\000\000\000\001\"\007\138\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001X\002\151\002\152\002\153\000\000\000\000\000\000\001\r\001\025\001%\001\024\000\000\000\000\001\027\001\028\000\000\001\029\000\000\001&\001.\000\000\001\"\b\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\002d\001\023\001\031\001 \001!\000\000\000\000\000\000\000\000\001\025\001%\000\000\000\000\001\024\000\000\000\000\000\000\000\000\000\000\001&\001.\000\000\001\025\001%\001\"\b\002e\000\000\004J\000\000\002d\000\000\001&\001.\002d\000\000\002g\000\000\000\000\000\000\000\000\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\025\001%\000\000\002e\001Y\002f\000\000\002e\000\000\004J\001&\001.\000\000\002g\002d\002\154\n\021\002g\000\000\000\000\000\000\000\000\n\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\001\025\001%\001\024\000\000\000\000\002e\000\000\004J\000\000\002o\001&\001.\000\000\001\"\n\002g\000\000\000\000\000\000\002p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002q\002r\000\000\000\000\000\000\000\000\000\000\002m\000\000\000\000\000\000\002o\001Z\002\157\000\000\000\000\000\000\002p\000\000\002\000\000\002p\002\158\002\000\000\000\000\000\000\n\000\000\002\002q\002r\002w\002\024\002q\002r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002o\001\025\001%\000\000\000\000\000\000\000\000\000\000\n\000\000\002p\001&\001.\003:\000\000\002\025\n\002\026\000\000\000\000\000\000\000\000\000\000\002q\002r\002\027\002d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002s\000\000\000\000\000\000\003\000\000\n\000\000\000\000\000\000\002\000\000\000\000\n\000\000\003\002e\003\004J\000\000\000\000\002t\002j\003;\000\000\003B\002g\000\000\000\000\000\000\002s\000\000\000\000\000\000\002s\011\005\000\000\011\006\000\000\n\000\000\000\000\003C\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002!\002x\002j\000\000\000\000\002t\002j\000\000\002d\000\000\002$\002u\002v\003D\003E\000\000\000\000\002s\000\000\000\000\n\000\000\000\000\002'\002(\002-\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002e\000\000\004J\002o\002t\002j\000\000\002u\002v\011\007\002g\002u\002v\002p\000\000\000\000\000\000\002|\000\000\n\000\000\000\000\002d\000\000\003F\000\000\002q\002r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002d\000\000\000\000\000\000\n\000\000\002u\002v\000\000\000\000\002e\000\000\004J\000\000\000\000\000\000\000\000\000\000\002d\000\000\002g\000\000\000\000\000\000\000\000\000\000\002e\000\000\004J\000\000\000\000\002)\000\000\002o\000\000\000\000\002g\n\000\000\000\000\005\000\000\000\000\002p\002e\000\000\004J\000\000\000\000\000\000\000\000\000\000\002.\002\030\002g\000\000\002q\002r\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002s\000\000\000\000\000\000\000\000\000\000\000\000\005\000\000\005\000\000\000\000\000\000\002o\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002t\002j\002p\002+\002,\000\000\000\000\000\000\002o\000\000\000\000\000\000\000\000\0022\000\000\002q\002r\000\000\002p\005\000\000\000\000\000\000\000\000\000\000\000\000\002o\002d\000\000\000\000\000\000\002q\002r\000\000\000\000\000\000\002p\000\000\000\000\000\000\002u\002v\000\000\000\000\000\000\000\000\002d\002s\000\000\002q\002r\000\000\000\000\002e\005\004J\005\001`\002\024\000\000\000\000\000\000\000\000\002g\000\000\000\000\000\000\005\002t\002j\000\000\000\000\002e\000\000\002f\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002g\005\002\025\000\000\002\026\000\000\000\000\000\000\001\001\000\000\000\000\002\027\002s\000\000\000\000\000\000\000\000\000\000\006E\005\t\005\000\000\000\000\000\000\002u\002v\000\000\002s\000\000\000\000\000\000\t\002t\002j\005\000\000\005\000\000\000\000\000\000\002o\000\000\003\000\000\000\000\002s\000\000\000\000\002t\002j\002p\001U\006J\000\000\006K\000\000\000\000\001b\001c\002m\001d\000\000\000\000\002q\002r\000\000\002t\002j\000\000\002p\000\000\002!\002u\002v\000\000i\000\000\001X\002\151\002\152\000\000\002$\002q\002r\002w\000\000\000\000\000\000\002u\002v\002d\000\000\000\000\000\000\002'\002(\002-\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\002d\002u\002v\000\000\000\000\000\000\000\000\000\000\000\000\002\006E\002e\000\000\004J\000\000\000\000\000\000\000\000\002d\000\000\000\000\002g\000\000\000\000\000\000\000\000\002e\000\000\004J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002g\003:\002s\000\000\000\000\000\000\000\000\000\000\002e\b\004J\006K\000\000\000\000\000\000\000\000\000\000\000\000\002g\000\000\000\000\002s\000\000\002t\002j\001Y\000\000\000\000\003\000\000\000\000\000\000\000\000\002)\000\000\000\000\002\156\000\000\000\000\003\001\020\003\002x\002j\000\000\000\000\002o\003;\000\000\003B\000\000\006\000\000\000\000\002.\002\030\002p\000\000\000\000\000\000\000\000\002o\000\000\002u\002v\000\000\003C\000\000\000\000\002q\002r\002p\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002o\002d\000\000\002u\002v\002q\002r\000\000\003D\003E\002p\000\000\000\000\002|\000\000\002+\002,\000\000\000\000\000\000\000\000\001Z\002\157\002q\002r\0022\000\000\002e\000\000\004J\000\000\002\158\001\020\000\000\006\000\000\000\000\002g\000\000\001\r\006\007\006\004K\000\000\000\000\001\027\001\028\000\000\006~\001\000i\001\001\003F\000\000\000\000\000\000\004K\000\000\000\000\000\000\000\000\000\000i\004M\001\023\001\031\007\b\007\t\007\n\002s\000\000\000\000\001\020\000\000\004K\000\000\000\000\000\000\004L\000\000\000\000\000\000\000\000\001\020\002s\t\003@\000\000\000\000\000\000\002t\002j\000\000\000\000\000\000\006\128\004\\\002o\000\000\000\000\000\000\000\000\002s\000\000\000\000\002t\002j\002p\000\000\001\r\000\000\000\000\000\000\000\000\000\000\001\027\001\028\000\000\006~\000\000\002q\002r\000\000\002t\002j\000\000\000\000\000\000\000\000\001\002u\002v\000\000i\000\000\001\023\001\031\000\000\000\000\000\000\007\011\000\000\000\000\000\000\000\000\002u\002v\000\000\002\000\000\001\r\000\000\001\020\001\024\000\000\000\000\001\027\001\028\002\006~\000\000\001\r\000\000\002u\002v\000\000\006\128\001\027\001\028\000\000\006\000\000\006E\000\000i\000\000\001\023\001\031\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\003:\001\023\001\031\000\000\001\020\000\000\000\000\000\000\000\000\000\000\006\131\000\000\000\000\000\000\002s\001\020\000\000\000\000\007\012\000\000\000\000\006\128\000\000\006L\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\r\006\007\014\000\000\002t\002j\000\000\001\024\000\000\001\020\000\000\001\025\001%\001\r\000\000\003;\000\000\003B\000\000\001\027\001\028\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\130\003C\000\000\000\000i\000\000\001\023\001\031\000\000\000\000\000\000\002u\002v\000\000\000\000\001\024\000\000\006\129\001\r\000\000\001\020\000\000\003D\003E\001\027\001\028\001\024\006\000\000\001\r\001\020\000\000\000\000\000\000\000\000\001\027\001\028\006\006\000\000\000\000\000\000i\000\000\001\023\001\031\002d\000\000\000\000\001\025\001%\000\000\000\000i\001\r\001\023\001\031\002d\006\134\000\000\001\027\001\028\000\000\006\000\000\000\000\000\000\003F\000\000\006\000\000\006\130\002e\000\000\004J\006\000\000\000\000i\000\000\001\023\001\031\002g\002e\000\000\004J\006\000\000\000\000\000\000\001\025\001%\000\000\002g\000\000\001\024\000\000\001`\001\r\000\000\000\000\001\025\001%\000\000\001\027\001\028\000\000\006\001\r\000\000\000\000\006\006\130\000\000\001\027\001\028\000\000\b~\000\000\000\000\000\000\000\000i\006\001\023\001\031\000\000\000\000\000\000\000\000\000\000\000\000i\001\024\001\023\001\031\000\000\000\000\006\000\000\000\000\000\000\000\000\002o\001\024\000\000\000\000\000\000\001\020\000\000\000\000\000\000\000\000\002p\002o\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002p\000\000\002q\002r\000\000\001\024\001\025\001%\000\000\000\000\000\000\001U\006\002q\002r\000\000\000\000\001b\001c\000\000\001d\000\000\000\000\006\000\000\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001X\002\151\002\152\000\000\000\000\000\000\000\000\001\025\001%\000\000\000\000\006\001\024\000\000\000\000\000\000\000\000\b\129\001\025\001%\000\000\000\000\001\024\000\000\007\026\001\r\001\020\000\000\b\129\006\000\000\001\027\001\028\000\000\001\029\000\000\000\000\000\000\000\000\b\130\006\000\000\000\000\001\025\001%\002s\000\000\000\000\000\000i\b\144\001\023\001\031\001 \000\000\007\002s\001\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\002t\002j\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002t\002j\000\000\000\000\000\000\001\020\000\000\000\000\000\000\007\027\001\025\001%\001Y\000\000\000\000\007\028\007\000\000\000\000\000\000\001\025\001%\000\000\t\151\003%\000i\000\000\001\r\000\000\002u\002v\000\000\006\001\027\001\028\000\000\001\029\000\000\000\000\000\000\002u\002v\0075\0076\0077\000\000\000\000\000\000\000\000\000\000\000\000i\000\000\001\023\001\031\001 \000\000\000\000\001\r\000\000\000\000\000\000\000\000\001\024\001\027\001\028\007\026\006~\000\000\000\000\000\000\000\000\000\000\000\000\n\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000i\001\r\001\023\001\031\000\000\001Z\002\157\001\027\001\028\000\000\006\000\000\000\000\000\000\000\000\002\158\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003)\000\000i\007\026\001\023\001\031\000\000\000\000\007\026\000\000\006\128\0078\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\027\000\000\000\000\000\000\000\000\000\000\007\028\007\029\000\000\000\000\001\025\001%\006\000\000\001\024\003%\000i\000\000\000\000\000\000\001&\000\000\000\000\000\000\000\000\n\007\000\000\000\000\000\000\000\000\000\000\000\000\007\026\0075\0076\0077\000\000\000\000\000\000\000\000\000\000\000\000\007\027\000\000\000\000\001\024\000\000\007\027\007\028\0073\000\000\000\000\0079\007\028\007\133\000\000\007\026\003%\000i\000\000\000\000\000\000\003%\000i\000\000\007:\000\000\007;\000\000\000\000\001\024\000\000\000\000\000\000\000\000\0075\0076\0077\000\000\007\026\0075\0076\0077\000\000\000\000\000\000\000\000\000\000\n\001\025\001%\000\000\000\000\000\000\007\027\000\000\003)\000\000\000\000\001&\007\028\007\000\000\000\000\000\000\000\000\000\000\0078\000\000\003%\000i\000\000\000\000\n\000\000\000\000\000\000\000\000\007\027\000\000\001\025\001%\000\000\000\000\007\028\007\007\026\0075\0076\0077\000\000\000\000\000\000\003%\000i\000\000\000\000\000\000\003)\000\000\000\000\007\027\006\130\003)\000\000\001\025\001%\007\028\007\0078\000\000\0075\0076\0077\0078\000\000\003%\000i\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\000\000\000\000\000\0079\007\026\000\000\0075\0076\0077\007\026\000\000\000\000\000\000\000\000\000\000\000\000\007:\000\000\007;\000\000\007\027\000\000\003)\000\000\000\000\000\000\007\028\007\000\000\000\000\000\000\000\000\000\000\0078\000\000\003%\000i\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0079\003)\000\000\000\000\000\000\0079\006\000\000\0075\0076\0077\000\000\0078\007:\000\000\007;\000\000\000\000\007:\000\000\007;\b\000\000\000\000\000\003)\000\000\007\027\007\028\b\003\000\000\000\000\000\000\007\028\b&\000\000\0078\003%\000i\000\000\000\000\000\000\003%\000i\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0079\000\000\0075\0076\0077\006\000\000\0075\0076\0077\000\000\000\000\000\000\007:\000\000\007;\006\000\000\000\000\003)\000\000\000\000\006\b)\0079\000\000\t\003@\000\000\000\000\0078\001\000i\000\000\000\000\000\000\007\026\007:\000\000\007;\000\000\000\000\000\000\001\001\000\000\000\000\0079\000\000\007\b\007\t\007\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007:\000\000\007;\000\000\000\000\003)\000\000\006\000\000\000\000\003)\000\000\000\000\006\b5\000\000\0078\000\000\003>\003@\000\000\0078\001\000i\000\000\000\000\000\000\000\000\007\026\002\000\000\000\000\000\000\000\000\0079\000\000\000\000\000\000\007\027\002\007\b\007\t\007\n\000\000\007\028\t\004\000\000\007:\000\000\007;\000\000\000\000\001\003%\000i\000\000\000\000\000\000\000\000\000\000\007\026\000\000\000\000\007\011\000\000\001\001\003:\000\000\000\000\000\000\0075\0076\0077\001\001\000\000\000\000\000\000\000\000\0079\002\000\000\000\000\000\000\0079\000\000\000\000\000\000\000\000\t!\002\000\000\007:\000\000\007;\007\028\b\003\007:\000\000\007;\003\000\000\001\000\000\003%\000i\000\000\000\000\003A\003@\000\000\000\000\003;\007\011\003B\000\000\000\000\000\000\003:\000\000\000\000\007\027\0075\0076\0077\000\000\007\012\007\028\n\000\000\000\000\003C\000\000\003)\001\001\003%\000i\000\000\007\r\000\000\007\014\000\000\000\000\0078\000\000\001\001\000\000\000\000\000\000\000\000\003D\003E\0075\0076\0077\000\000\000\000\000\000\000\000\000\000\002\000\000\003;\000\000\003B\000\000\000\000\003h\003@\002\002\000\000\000\000\000\000\000\000\007\012\000\000\000\000\000\000\002\003\003C\000\000\003)\000\000\000\000\000\000\000\000\007\r\000\000\007\014\000\000\000\000\000\000\0078\003F\000\000\000\000\003:\000\000\001\001\003D\003E\000\000\000\000\0079\003:\000\000\000\000\000\000\000\000\000\000\001\001\003)\000\000\000\000\000\000\007:\000\000\007;\000\000\000\000\000\000\003\0078\000\000\000\000\000\000\002\000\000\000\000\001\001\000\000\003\000\000\000\000\000\000\002\000\000\002\000\000\003;\000\000\003B\003F\t\129\003@\000\000\000\000\002\003;\000\000\003B\000\000\000\000\0079\000\000\001\001\000\000\003C\001\001\000\000\000\000\003:\nq\000\000\007:\003C\007;\000\000\000\000\000\000\000\000\000\000\000\000\003:\000\000\000\000\000\000\003D\003E\000\000\000\000\000\000\000\000\0079\000\000\000\000\003D\003E\000\000\np\000\000\002\000\000\nj\000\000\000\000\007:\000\000\007;\000\000\003\002\000\000\000\000\002\000\000\000\000\003;\000\000\003B\000\000\000\000\000\000\000\000\002\000\000\001\001\000\000\003;\000\000\003B\003F\000\000\002\000\000\003C\000\000\000\000\003:\000\000\003F\001\001\002\000\000\000\000\000\000\003C\000\000\000\000\000\000\003:\000\000\000\000\002\002\003D\003E\000\000\000\000\002\nc\000\000\000\000\002\003\000\000\000\000\003D\003E\002\003:\001\001\002\000\000\000\000\t\001\001\000\000\000\000\000\000\000\000\003;\000\000\003B\000\000\000\000\000\000\t\000\000\000\000\000\000\000\000\000\000\000\000\003;\003:\003B\000\000\003F\003:\003C\000\000\001\001\000\000\t\000\000\000\000\000\000\000\000\003F\tw\000\000\003C\003;\000\000\003B\000\000\000\000\000\000\002\003D\003E\000\000\000\000\000\000\001\001\000\000\000\000\002\000\000\000\000\003C\003D\003E\002\000\000\t5\001\001\003;\000\000\003B\000\000\003;\002\003B\000\000\003\n\000\000\000\000\000\000\000\000\003D\003E\000\000\000\000\003:\003\011\003C\000\000\001\000\000\003C\000\000\003F\002\000\000\000\000\000\000\000\000\000\000\002\003:\001\000\000\002\000\000\003F\000\000\003D\003E\002\000\000\003D\003E\003d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\000\000\003F\002\000\000\000\000\000\000\003;\003:\003B\000\000\000\000\000\000\002\003:\000\000\000\000\002\002\000\000\000\000\000\000\000\000\003;\000\000\003B\003C\002\000\000\003F\000\000\000\000\000\000\003F\000\000\002\003e\002\003j\000\000\002\003:\003C\000\000\000\000\000\000\000\000\003D\003E\000\000\002\000\000\000\000\b\155\003;\003k\003B\000\000\000\000\000\000\003;\000\000\003B\003D\003E\003:\000\000\000\000\002\002\000\000\000\000\000\000\003C\000\000\000\000\003l\003m\003:\003C\002\002\000\000\000\000\000\000\000\000\000\000\003;\000\000\003B\000\000\000\000\003F\000\000\003D\003E\000\000\002\000\000\000\000\003D\003E\000\000\000\000\002\000\000\003C\002\003F\000\000\000\000\003;\000\000\003B\000\000\003\n\002\000\000\000\000\000\000\000\000\003n\001\001\003;\003\011\003B\003D\003E\000\000\003C\000\000\000\000\000\000\000\000\003:\000\000\002\002\003F\000\000\000\000\000\000\003C\000\000\003F\000\000\000\000\000\000\001\001\003D\003E\003d\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\003D\003E\003\n\000\000\000\000\001\001\000\000\003F\002\002\002\003\011\000\000\003\n\000\000\000\000\003;\000\000\003B\000\000\003\004\000\000\000\000\003\011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\003e\003C\003j\000\000\000\000\003d\003\b\000\000\000\000\000\000\003F\003\t\000\000\000\000\000\000\000\000\000\000\003d\000\000\003k\000\000\002\003D\003E\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\003\n\000\000\000\000\000\000\003l\003m\000\000\000\000\000\000\000\000\003\011\000\000\002\000\000\000\000\003e\000\000\003j\000\000\000\000\000\000\000\000\002\003:\000\000\000\000\000\000\003e\000\000\003j\000\000\003F\002\000\000\003k\000\000\000\000\003\n\003d\000\000\001\001\002\001\001\000\000\003k\003\011\000\000\003n\003:\001\001\000\000\000\000\003l\003m\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003l\003m\003;\003:\003B\000\000\000\000\000\000\003d\0039\001\001\003H\000\000\000\000\000\000\000\000\003e\000\000\003j\003I\003C\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003;\000\000\003B\000\000\003n\000\000\000\000\003k\000\000\000\000\000\000\001\001\003D\003E\000\000\003n\003X\000\000\003C\003;\000\000\003B\000\000\000\000\003e\000\000\003j\003l\003m\000\000\000\000\000\000\000\000\000\000\001\001\000\000\000\000\003C\003D\003E\002\000\000\003k\002\000\000\003Z\000\000\000\000\000\000\000\000\002\002\000\000\002\000\000\000\000\003F\000\000\003D\003E\000\000\002\000\000\003l\003m\000\000\000\000\000\000\000\000\003[\000\000\003n\000\000\000\000\000\000\000\000\000\000\002\003:\000\000\000\000\003:\000\000\003F\000\000\000\000\000\000\002\000\000\003:\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\000\000\002\002\000\000\003F\000\000\000\000\000\000\002\003n\000\000\000\000\000\000\000\000\002\002\003:\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\003;\000\000\003B\003;\000\000\003B\000\000\002\000\000\003]\000\000\003;\003c\003B\000\000\000\000\000\000\002\000\000\003C\000\000\003:\003C\000\000\000\000\003t\001\001\000\000\000\000\003C\000\000\001\001\000\000\000\000\000\000\003;\000\000\003B\003D\003E\000\000\003D\003E\003:\001\001\000\000\000\000\000\000\003D\003E\000\000\000\000\000\000\003C\000\000\000\000\000\000\000\000\000\000\003\158\000\000\000\000\000\000\000\000\003;\004E\003B\000\000\002\000\000\000\000\003\n\000\000\000\000\003D\003E\000\000\000\000\002\t\000\000\003\011\003F\003C\003\n\003F\000\000\000\000\003;\000\000\003B\000\000\000\000\003F\003\011\000\000\001\001\000\000\000\000\000\000\000\000\002\002\003D\003E\003:\003C\000\000\003d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\002\003d\000\000\000\000\000\000\000\000\002\003D\003E\000\000\002\nf\000\000\000\000\000\000\000\000\002\nr\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\002\003;\000\000\003B\003e\000\000\003j\000\000\003:\000\000\000\000\000\000\000\000\000\000\003:\000\000\000\000\003e\000\000\003j\003C\000\000\003F\003k\000\000\000\000\000\000\000\000\003:\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003k\000\000\000\000\000\000\000\000\003D\003E\002\003l\003m\000\000\000\000\000\000\003\n\000\000\000\000\000\000\002\003;\000\000\003B\003l\003m\003\011\003;\000\000\003B\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003C\003;\000\000\003B\000\000\000\000\003C\000\000\003:\000\000\000\000\000\000\000\000\003F\003d\000\000\003n\000\000\000\000\000\000\003C\003D\003E\000\000\000\000\000\000\000\000\003D\003E\003n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003D\003E\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003;\000\000\003B\000\000\000\000\000\000\003e\000\000\003j\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\003F\003C\000\000\000\000\000\000\000\000\000\000\003k\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003D\003E\000\000\000\000\000\000\000\000\003l\003m\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003F\000\000\000\000\000\000\000\000\000\000\003n"))
  
  and semantic_action =
    [|
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_type) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.class_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.class_type) =       (
        let core_type_loc = mklocation _startpos__3_ _endpos__3_ in
        let ct = only_core_type _3 core_type_loc in
        mkcty(Pcty_arrow("?" ^ _1, mkoption ct, _5))
       ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.class_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.class_type) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_type_loc in
        mkcty(Pcty_arrow(_1, ct, _4))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.class_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_type) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        mkcty(Pcty_arrow("", ct, _3))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Asttypes.label * Parsetree.expression) list) = Obj.magic _2 in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_expr) =       ( mkclass(Pcl_apply(_1, List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_expr) =       ( Cl.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.class_expr) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                          (
      mkclass(Pcl_constr(_2, []))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.core_type list) = Obj.magic _3 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_expr) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                            (
      mkclass(Pcl_constr(_2, List.rev _3))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =       ( mkclass(Pcl_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_structure) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =                                      ( mkclass(Pcl_structure _1)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =                (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.class_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_expr) =                                                (
    class_of_let_bindings _1 _3
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Ast_helper.attrs) = Obj.magic _5 in
        let _4 : (string option) = Obj.magic _4 in
        let _3 : (Parsetree.class_expr) = Obj.magic _3 in
        let _2 : (Asttypes.override_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.class_field) =       ( mkcf_attrs (Pcf_inherit (_2, _3, _4)) _5 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Asttypes.loc * Asttypes.mutable_flag * Parsetree.class_field_kind) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_field) =       ( mkcf_attrs (Pcf_val _2) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Asttypes.loc * Parsetree.class_field_kind) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_field) =       ( let (a, b) = _2 in mkcf_attrs (Pcf_method (a, Public, b)) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Asttypes.loc * Parsetree.class_field_kind) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_field) =         ( let (a, b) = _2 in mkcf_attrs (Pcf_method (a, Private, b)) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Parsetree.core_type * Parsetree.core_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_field) =       ( mkcf_attrs (Pcf_constraint _2) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.class_field) =       ( mkcf_attrs (Pcf_initializer _3) _4 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_field) =       ( mkcf_attrs (Pcf_extension _1) _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_field) =       ( mkcf (Pcf_attribute _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let _1 : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_expr) =       ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let _1 : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_expr) =       ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.class_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_expr) =       ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let _1 : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_expr) =       ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.class_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkcty(Pcty_constr (_1, [])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.core_type list) = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkcty(Pcty_constr (_1, List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.class_signature) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_type) =       ( mkcty(Pcty_signature _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.class_signature) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.class_type) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_cty (with_txt _1 "{") (with_txt _3 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_type) =       ( Cty.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_type) =       ( mkcty(Pcty_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.pattern) = let _endpos = _endpos__0_ in
        let _symbolstartpos = _endpos in
            (
    let loc = mklocation _symbolstartpos _endpos in
    mkpat (Ppat_var (mkloc "this" loc))
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_type_field) =       ( mkctf_attrs (Pctf_inherit _2) [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Parsetree.attribute) = Obj.magic _3 in
        let _2 : (Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.class_type_field) =       ( mkctf_attrs (Pctf_inherit _2) (_3::_4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string * Asttypes.mutable_flag * Asttypes.virtual_flag *
  Parsetree.core_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_type_field) =                                         (
      mkctf_attrs (Pctf_val _2) _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Ast_helper.attrs) = Obj.magic _6 in
        let _5 : (Parsetree.core_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Asttypes.virtual_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.class_type_field) =          (
          mkctf_attrs (Pctf_method (_3, Private, _2, _5)) _6
         ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Ast_helper.attrs) = Obj.magic _6 in
        let _5 : (Parsetree.core_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Asttypes.virtual_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.class_type_field) =        (
        mkctf_attrs (Pctf_method (_3, Public, _2, _5)) _6
       ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Parsetree.core_type * Parsetree.core_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_type_field) =        ( mkctf_attrs (Pctf_constraint _2) _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_type_field) =        ( mkctf_attrs (Pctf_extension _1) _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_type_field) =       ( mkctf(Pctf_attribute _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.class_expr) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            ( mkclass(Pcl_constr(_1, [])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_expr) =                                            ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.class_expr) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            ( unclosed_cl (with_txt _1 "{") (with_txt _3 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.class_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.class_expr) =       ( mkclass(Pcl_constraint(_2, _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Parsetree.class_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.class_expr) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_cl (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.class_expr) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_cl (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.class_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.class_expr) =       ( mkclass(Pcl_constraint(_4, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Asttypes.label) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Core_type (mktyp(Ptyp_alias(ct, _4)))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (core_type_object) =       (
      match _2, _5 with
      | Core_type ct, Core_type ct2 -> Core_type (mktyp(Ptyp_arrow("?" ^ _1 , mkoption ct, ct2)))
      | _ -> syntax_error()
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       (
      match _2, _4 with
      | Core_type ct, Core_type ct2 -> Core_type (mktyp(Ptyp_arrow(_1, ct, ct2)))
      | _ -> syntax_error()
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (core_type_object) =       (
      match _1, _3 with
            | Core_type ct, Core_type ct2 ->
                Core_type (mktyp(Ptyp_arrow("", ct, ct2)))
            | _ -> syntax_error()
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         let (l, o, p) = _1 in mkexp ~loc (Pexp_fun(l, o, p, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) =       ( mkexp(Pexp_newtype(_3, _5)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Asttypes.label * Parsetree.expression) list) = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =       ( mkexp(Pexp_apply(_1, List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =                                        (
      let (l,o,p) = _2 in
      mkexp (Pexp_fun(l, o, p, _3))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Parsetree.expression) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (string) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_newtype(_4, _6)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.case list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_function(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.case list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_match(_2, List.rev _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.case list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_try(_2, List.rev _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) =       ( syntax_error_exp (mklocation _startpos__4_ _endpos__4_) "Invalid try with") in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            (
      if List.mem (string_of_longident _1.txt)
         built_in_explicit_arity_constructors then
        (* unboxing the inner tupple *)
        match _2 with
          | {pexp_desc=Pexp_tuple [inner]; pexp_loc; pexp_attributes} -> mkexp (Pexp_construct(_1, Some inner))
          | _ -> assert false
      else
        mkExplicitArityTupleExp (Pexp_construct(_1, Some _2))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : (Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =     (
      mkexp(Pexp_variant(_1, Some _2))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) =       ( mkexp(Pexp_ifthenelse(_2, _3, Some _5)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_ifthenelse(_2, _3, None)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_while(_2, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Parsetree.expression) = Obj.magic _7 in
        let _6 : (Parsetree.expression) = Obj.magic _6 in
        let _5 : (Asttypes.direction_flag) = Obj.magic _5 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.expression) =       ( mkexp(Pexp_for(_2, _4, _6, _5, _7)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc_colon = mklocation _startpos__2_ _endpos__2_ in
        let loc = mklocation _symbolstartpos _endpos in
        mkexp_cons loc_colon (mkexp ~ghost:true ~loc (Pexp_tuple[_5;_7])) loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : (string) = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : (string) = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : (string) = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : (string) = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "/>" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : (string) = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "+" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "+." )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "-" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "-." )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "*" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "<" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( ">" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "or" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "||" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "&" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "&&" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( ":=" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "+=" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "%" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "<..>" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _200;
            MenhirLib.EngineTypes.startp = _startpos__200_;
            MenhirLib.EngineTypes.endp = _endpos__200_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( ">>" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        mkuminus _1 _2
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        mkuplus _1 _2
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_setfield(_1, _3, _5)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "Array" "set")),
                         ["",_1; "",_4; "",_7])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "String" "set")),
                         ["",_1; "",_4; "",_7])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        bigarray_set ~loc _1 _4 _7
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_setinstvar(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_assert _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_lazy _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) =                                   (
      (* Should use ghost expressions, but not sure how that would work with source maps *)
      (* So ? will become true and : becomes false for now*)
      let loc_question = mklocation _startpos__2_ _endpos__2_ in
      let loc_colon = mklocation _startpos__4_ _endpos__4_ in
      let fauxTruePat =
        Pat.mk ~loc:loc_question (Ppat_construct({txt = Lident "true"; loc = loc_question}, None)) in
      let fauxFalsePat =
        Pat.mk ~loc:loc_colon (Ppat_construct({txt = Lident "false"; loc = loc_colon}, None)) in
      let fauxMatchCaseTrue = Exp.case fauxTruePat _3 in
      let fauxMatchCaseFalse = Exp.case fauxFalsePat _5 in
      mkexp (Pexp_match (_1, [fauxMatchCaseTrue; fauxMatchCaseFalse]))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =       ( Exp.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((string Asttypes.loc * Parsetree.module_type option) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_expr) =                                           (
      mkFunctorThatReturns _1 _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.module_expr) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((string Asttypes.loc * Parsetree.module_type option) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.module_expr) =                                                                         (
      let loc = mklocation _startpos__5_ _endpos__5_ in
      mkFunctorThatReturns _1 (mkmod ~loc (Pmod_constraint(_5, _3)))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.module_type) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Parsetree.module_type) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.module_type) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkmty(Pmty_functor(_2, Some _4, _6)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_type) =       ( mkmty(Pmty_functor(mkloc "*" (mklocation _startpos__1_ _endpos__1_), None, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_expr) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.module_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : ((string Asttypes.loc * Parsetree.module_type option) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.module_expr) =       ( mkFunctorThatReturns _2 _4 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.module_expr) = Obj.magic _2 in
        let _1 : (Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.module_expr) =       ( mkmod (Pmod_apply(_1, _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (Parsetree.module_expr) = Obj.magic _3 in
        let x0 : unit = Obj.magic x0 in
        let _1 : (Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.module_expr) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _2 "(") (with_txt _4 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.module_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.module_expr) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.module_expr) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.module_expr) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.module_expr) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _4 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.module_expr) =       ( Mod.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.with_constraint list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_type) =                                       (
    (* See note above about why WITH constraints aren't considered
     * non-arrowed.
     * We might just consider unifying the syntax for record extension with
     * module extension/WITH constraints.
     *
     *    mod MyModule = {
     *       ModuleToInclude...
     *    };
     *
     *    let module CreateFactory
     *               (Spec: ContainerSpec)
     *               :{DescriptorFactoryIntf.S with
     *                  type props = Spec.props and type dependencies = Spec.props} =>
     *
     *)
    mkmty(Pmty_with(_1, List.rev _3))
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_type) =                                                      (
    (* below_EQUALGREATER to prevent following shift reduce conflict:
     *  1158: shift/reduce conflict (shift 1285, reduce 75) on EQUALGREATER
     *  state 1158
     *    module_binding_body_functor : functor_args COLON non_arrowed_module_type . EQUALGREATER module_expr  (59)
     *    module_type : non_arrowed_module_type .  (75)
     *
     *    EQUALGREATER  shift 1285
     *    LBRACKETAT  reduce 75
     *    WITH  reduce 75
     *)
    _1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Parsetree.module_type) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.module_type) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                                               (
    (* Why does this rule cause a conflict with core_type2? It has nothing to do
     * with it.
     *
     * Update: I'm guessing it has something to do with the fact that this isn't
     * parsed correctly because the => is considered part of "type dependenences" :
     *
     *    let module CreateFactory
     *               (Spec: ContainerSpec)
     *               :DescriptorFactoryIntf.S with
     *                  type props = Spec.props and type dependencies = Spec.props =>
     *)
      mkmty(Pmty_functor(_2, Some _4, _7))
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_type) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                  (
      (**
       * In OCaml, this is invalid:
       * module MyFunctor: functor MT -> (sig end) = functor MT -> (struct end);;
       *
       * Not only must curried functor args have annotations, but functor
       * annotations must include *names* for each argument in a functor type.
       *
       * module MyFunctor: functor (MT:MT) -> (sig end) = functor (MT:MT) -> (struct end)
       *
       * In Reason, we will parse the functor type:
       *
       *    (AB:MT) -> ReturnSig
       *
       * as in:
       *                   /----------------\
       * module MyFunctor: (A:B) => ReturnSig = functor (C:D) => {}
       *
       * But only for the sake of compatibility with existing OCaml code (the
       * ability to "view" OCaml code in Reason's syntax without loss of
       * information.) Do not write identifiers in functor argument type
       * positions - you wouldn't do it with functions, and they are
       * meaningless in functors.
       *
       *  But for sake of consistency (and for sake of a syntax that truly
       *  unifies functor syntax with function syntax, the following "sugars"
       *  will be parsed (and printed):
       *
       *   A => B => C
       *
       * Is parsed into:
       *
       * functor (_:A) -> functor (_:B) -> C
       *
       * And a dummy "_" is inserted into the parse tree where no name has been
       * provided.
       *
       *   {SomeSig} => {} => {}
       *
       * Is parsed into:
       *
       * (_:SomeSig) => (_:{}) => {}
       *
       *
       *)
      let loc = mklocation _symbolstartpos _endpos in
      mkmty(Pmty_functor(ghloc ~loc "_", Some _1, _3))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_type) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_type) =                                          ( _2) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_type) =                        (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.module_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.module_type) =       ( mkmty(Pmty_typeof _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.module_type) =       ( Mty.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.core_type list) = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (core_type_object) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Core_type (mktyp(Ptyp_constr(_1, List.rev _2))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.core_type list) = Obj.magic _3 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (core_type_object) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Core_type (mktyp(Ptyp_class(_2, List.rev _3))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.attribute) = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (core_type_object) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Core_type (Typ.attr ct _2)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.core_type list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (core_type_object) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        match _2 with
        | [] -> raise (Syntaxerr.Error(Syntaxerr.Applicative_path loc))
        | one::[] -> Core_type one
        | moreThanOne -> Core_type (mktyp(Ptyp_tuple(List.rev moreThanOne))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (core_type_object) =       ( Core_type (mktyp(Ptyp_var _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (core_type_object) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Core_type (mktyp(Ptyp_class(_2, []))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       ( Core_type (mktyp(Ptyp_any)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (core_type_object) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Core_type (mktyp(Ptyp_constr(_1, []))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : ((Parsetree.label_declaration * Parsetree.attributes) list * object_record) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       (
        let (labels, object_record) = _1 in
        match object_record with
        | Record -> Record_type(only_labels labels)
        | Object_open -> (
          Core_type(mktyp(Ptyp_object (List.map (fun l -> let (label, attr) = l in if label.pld_mutable == Mutable then syntax_error(); label.pld_name.txt, attr, label.pld_type ) labels, Open)))
        )
        | Object_closed -> Core_type(mktyp(Ptyp_object (List.map (fun l -> let (label, attr) = l in if label.pld_mutable == Mutable then syntax_error(); label.pld_name.txt, attr, label.pld_type ) labels, Closed)))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.row_field) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant([_2], Closed, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.row_field list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(List.rev _3, Closed, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.row_field list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.row_field) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(_2 :: List.rev _4, Closed, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.row_field list) = Obj.magic _3 in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(List.rev _3, Open, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant([], Open, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.row_field list) = Obj.magic _3 in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(List.rev _3, Closed, Some []))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Asttypes.label list) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.row_field list) = Obj.magic _3 in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_variant(List.rev _3, Closed, Some (List.rev _5)))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.package_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_package _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =       ( Core_type(mktyp(Ptyp_extension _1)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type * Asttypes.variance) =                                                 ( mktyp (Ptyp_var _2), Invariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.core_type * Asttypes.variance) =                                                 ( mktyp (Ptyp_any), Invariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Asttypes.label) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.core_type * Asttypes.variance) =                                                 ( mktyp (Ptyp_var _3), Covariant) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type * Asttypes.variance) =                                                 ( mktyp (Ptyp_any), Covariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Asttypes.label) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.core_type * Asttypes.variance) =                                                 ( mktyp (Ptyp_var _3), Contravariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type * Asttypes.variance) =                                                 ( mktyp Ptyp_any, Contravariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern) =     ( mkpat(Ppat_or(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern) =                                 (
    let core_loc = mklocation _startpos__3_ _endpos__3_ in
    let ct = only_core_type _3 core_loc in
    mkpat(Ppat_constraint(_1, ct))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x0 : (string) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_alias(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( expecting_pat (with_txt _3 "identifier") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.pattern list) = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
            (
      match is_pattern_list_single_any _2 with
        | Some singleAnyPat ->
            mkpat
              (Ppat_construct(_1, Some singleAnyPat))
        | None ->
          let loc = mklocation _symbolstartpos _endpos in
          let argPattern = simple_pattern_list_to_tuple ~loc _2 in
          mkExplicitArityTuplePat (Ppat_construct(_1, Some argPattern))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : (Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern) =     (
      mkpat (Ppat_variant(_1, Some _2))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.pattern) = Obj.magic _3 in
        let x0 : unit = Obj.magic x0 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Location.raise_errorf ~loc:_2.loc ":: is not supported in Reason, please use [hd, ...tl] instead" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( expecting_pat (with_txt _3 "pattern") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (Parsetree.pattern) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.pattern) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Parsetree.pattern) = let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc_coloncolon = mklocation _startpos__2_ _endpos__2_ in
         let loc = mklocation _symbolstartpos _endpos in
         mkpat_cons loc_coloncolon (mkpat ~ghost:true ~loc (Ppat_tuple[_5;_7])) loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = x0;
                        MenhirLib.EngineTypes.startp = _startpos_x0_;
                        MenhirLib.EngineTypes.endp = _endpos_x0_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _7 : (Parsetree.pattern) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.pattern) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.pattern) = let _8 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "(") (with_txt _8 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_lazy _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_exception _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.attribute) = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern) =       ( Pat.attr _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.core_type) =           ( only_core_type _1 (mklocation _startpos__1_ _endpos__1_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Asttypes.label list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.core_type) =           ( mktyp(Ptyp_poly(List.rev _1, only_core_type _3 (mklocation _startpos__3_ _endpos__3_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : (Ast_helper.attrs * string Asttypes.loc) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =                                                       (
      extension_expression _1 _2
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =                                  (
      _1
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =                                                (
      expr_of_let_bindings _1 _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                  (
      let loc = mklocation _symbolstartpos _endpos in
      expr_of_let_bindings _1 @@ ghunit ~loc ()
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =                                         (
      let expr = _1 in
      let item_attrs = _2 in
      (* Final item in the sequence - just append item attributes to the
       * expression attributes *)
      {expr with pexp_attributes = item_attrs @ expr.pexp_attributes}
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Parsetree.expression) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Parsetree.module_expr) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                                                 (
      let item_attrs = _4 in
      mkexp ~attrs:item_attrs (Pexp_letmodule(_2, _3, _6))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Ast_helper.attrs) = Obj.magic _5 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _3 : (Asttypes.override_flag) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (unit option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.expression) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                                             (
      let item_attrs = _5 in
      mkexp ~attrs:item_attrs (Pexp_open(_3, _4, _7))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) =                                                              (
      let item_attrs = _2 in
      mkexp ~attrs:item_attrs (Pexp_sequence(_1, _4))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Ast_helper.attrs) = Obj.magic _5 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.signature_item) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
                                                                       (
        let loc = mklocation _symbolstartpos _endpos in
        let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
        mksig(Psig_value (Val.mk _2 (only_core_type _4 core_type_loc) ~attrs:_5 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Ast_helper.attrs) = Obj.magic _7 in
        let _6 : (string list) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.signature_item) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                                        (
      let loc = mklocation _symbolstartpos _endpos in
      let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
      mksig(Psig_value (Val.mk _2 (only_core_type _4 core_type_loc) ~prim:_6 ~attrs:_7 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.type_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.signature_item) =                            (
      mksig(Psig_type (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.type_extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.signature_item) =                        (
      mksig(Psig_typext _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.signature_item) =                               (
      mksig(Psig_exception _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Parsetree.module_type) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.signature_item) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                  (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_module (Md.mk _2 _3 ~attrs:_4 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x1;
            MenhirLib.EngineTypes.startp = _startpos_x1_;
            MenhirLib.EngineTypes.endp = _endpos_x1_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Ast_helper.attrs) = Obj.magic _5 in
        let x1 : (Longident.t) = Obj.magic x1 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.signature_item) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos__4_ = _endpos_x1_ in
        let _startpos__4_ = _startpos_x1_ in
        let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                           (
      let loc = mklocation _symbolstartpos _endpos in
      let loc_mod = mklocation _startpos__4_ _endpos__4_ in
      mksig(
        Psig_module (
          Md.mk
            _2
            (Mty.alias ~loc:loc_mod _4)
            ~attrs:_5
            ~loc
        )
      )
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.signature_item) =                                  (
      mksig(Psig_recmodule (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let x0 : (Asttypes.label) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.signature_item) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                           (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_modtype (Mtd.mk _3 ~attrs:_4 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Ast_helper.attrs) = Obj.magic _6 in
        let _5 : (Parsetree.module_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (Asttypes.label) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.signature_item) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
                                                                             (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_modtype (Mtd.mk _3 ~typ:_5 ~loc ~attrs:_6))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.open_description) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.signature_item) =                    (
      mksig(Psig_open _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.signature_item) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                     (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_include (Incl.mk _2 ~attrs:_3 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_description list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.signature_item) =                             (
      mksig(Psig_class (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_type_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.signature_item) =                                  (
      mksig(Psig_class_type (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.signature_item) =                                         (
      mksig(Psig_extension (_1, _2))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.signature_item) =                        (
      mksig(Psig_attribute _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp (Pexp_ident _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.constant) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =              ( mkexp (Pexp_constant _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            (
      mkexp (Pexp_construct (_1, None))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_variant (_1, None)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =         ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.expression list * Parsetree.expression option) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) =                                                                          (
      let entireLoc = mklocation _startpos__1_ _endpos__4_ in
      let (seq, ext_opt) = _4 in
      mktailexp_extension entireLoc (_2::seq) ext_opt
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =                                                    (
      let entireLoc = mklocation _startpos__1_ _endpos__3_ in
      mktailexp_extension entireLoc (_2::[]) None
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.core_type option * Parsetree.core_type option) = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        ghexp_constraint loc _2 _3
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let x0 : (Parsetree.expression) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( syntax_error_exp _2.loc "SyntaxError in block" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Parsetree.expression list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) =       ( mkexp(Pexp_tuple(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.expression list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_field(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_open(Fresh, _1, _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.expression list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp(Pexp_open(Fresh, _1, mkexp(Pexp_tuple(List.rev _4)))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let pat = mkpat (Ppat_var (mkloc "this" loc)) in
        mkexp(Pexp_open (Fresh, _1,
                         mkexp(Pexp_object(Cstr.mk pat [])))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "Array" "get")),
                         ["",_1; "",_4])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "String" "get")),
                         ["",_1; "",_4])) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "[") (with_txt _5 "]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        bigarray_get ~loc _1 _4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (unit) = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let msg = "Record construction must have at least one field explicitly set" in
        syntax_error_exp loc msg
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =       ( let (exten, fields) = _2 in mkexp (Pexp_record(fields, exten)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (exten, fields) = _2 in
        mkexp ~loc (Pexp_extension (mkloc ("bs.obj") loc,
               PStr [mkstrexp (mkexp ~loc (Pexp_record(fields, exten))) []]))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.class_structure) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_object _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.class_structure) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              ( let (exten, fields) = _4 in
        let loc = mklocation _symbolstartpos _endpos in
        let rec_exp = mkexp ~loc (Pexp_record (fields, exten)) in
        mkexp(Pexp_open(Fresh, _1, rec_exp)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "{") (with_txt _5 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Parsetree.expression list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_array(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Parsetree.expression list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "[|") (with_txt _4 "|]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_array []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (unit) = Obj.magic _5 in
        let _4 : (Parsetree.expression list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let rec_exp = Exp.mk ~loc ~attrs:[] (Pexp_array(List.rev _4)) in
        mkexp(Pexp_open(Fresh, _1, rec_exp))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _5 : (unit) = Obj.magic _5 in
        let _4 : (Parsetree.expression list) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _6 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "[|") (with_txt _6 "|]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression list * Parsetree.expression option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =       ( let seq, ext_opt = _2 in
        let loc = mklocation _startpos__2_ _endpos__2_ in
        make_real_exp (mktailexp_extension loc seq ext_opt) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.expression list * Parsetree.expression option) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( let seq, ext_opt = _4 in
        let loc = mklocation _startpos__4_ _endpos__4_ in
        let list_exp = make_real_exp (mktailexp_extension loc seq ext_opt) in
        let list_exp = { list_exp with pexp_loc = loc } in
        mkexp (Pexp_open (Fresh, _1, list_exp)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        mkexp(Pexp_apply(mkoperator _1, ["",_2]))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        let bang = {_1 with txt="!"} in
        mkexp(Pexp_apply(mkoperator bang, ["",_2]))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkexp (Pexp_new _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : ((string Asttypes.loc * Parsetree.expression) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_override(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : ((string Asttypes.loc * Parsetree.expression) list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "{<") (with_txt _4 ">}" ) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_override [])) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (unit) = Obj.magic _5 in
        let _4 : ((string Asttypes.loc * Parsetree.expression) list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let exp = Exp.mk ~loc ~attrs:[] (Pexp_override(List.rev _4)) in
        mkexp(Pexp_open(Fresh, _1, exp))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _5 : (unit) = Obj.magic _5 in
        let _4 : ((string Asttypes.loc * Parsetree.expression) list) = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _6 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "{<") (with_txt _6 ">}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) =       ( mkexp(Pexp_send(_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkinfix _1 _2 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_pack _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _3),
                                mktyp ~ghost:true ~loc (Ptyp_package _5))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = x0;
                        MenhirLib.EngineTypes.startp = _startpos_x0_;
                        MenhirLib.EngineTypes.endp = _endpos_x0_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (Parsetree.package_type) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.module_expr) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__8_ in
        let _v : (Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_open(Fresh, _1,
        mkexp ~loc (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _5),
                                     mktyp ~ghost:true ~loc (Ptyp_package _7))))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.module_expr) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : unit = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.expression) = let _7 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_exp (with_txt _3 "(") (with_txt _7 ")")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =       ( mkexp (Pexp_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.module_expr) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkmod(Pmod_ident _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.structure) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_expr) =       ( mkmod(Pmod_structure(_2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.module_expr) =       ( mkmod(Pmod_constraint(_2, _4)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.module_expr) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.module_expr) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.module_expr) =       ( mkmod(Pmod_unpack _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.module_expr) = let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod (Pmod_unpack(
               mkexp ~ghost:true ~loc (Pexp_constraint(_3, mktyp ~ghost:true ~loc (Ptyp_package _5))))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (Parsetree.package_type) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Parsetree.module_expr) = let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod (Pmod_unpack(
               mkexp ~ghost:true ~loc (Pexp_coerce(_3, Some(mktyp ~ghost:true ~loc (Ptyp_package _5)),
                                      mktyp ~ghost:true ~loc (Ptyp_package _7))))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.module_expr) = let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod (Pmod_unpack(
               mkexp ~ghost:true ~loc (Pexp_coerce(_3, None, mktyp ~ghost:true ~loc (Ptyp_package _5))))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.module_expr) =       ( mkmod (Pmod_structure []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_expr) =       ( mkmod (Pmod_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_type) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.module_type) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.module_type) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mty (with_txt _1 "(") (with_txt _3 ")")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.module_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            ( mkmty(Pmty_ident _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.signature) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_type) =       ( mkmty(Pmty_signature _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.signature) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.module_type) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_mty (with_txt _1 "{") (with_txt _3 "}")) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_type) =       ( mkmty(Pmty_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =                                (
    mkexp (Pexp_tuple(List.rev _1))
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_var _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                              ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_any) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.constant) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_constant _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Asttypes.constant) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Asttypes.constant) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_interval (_1, _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_construct(_1, None)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_variant(_1, None)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.pattern) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_type (_2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : ((Longident.t Asttypes.loc * Parsetree.pattern) list * Asttypes.closed_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern) =       ( let (fields, closed) = _2 in mkpat(Ppat_record(fields, closed)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : ((Longident.t Asttypes.loc * Parsetree.pattern) list * Asttypes.closed_flag) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "{") (with_txt _3 "}") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Parsetree.pattern list * Parsetree.pattern option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.pattern) =       ( let seq, ext_opt = _2 in
        let loc_rbracket = mklocation _startpos__2_ _endpos__2_ in
        make_real_pat (mktailpat_extension loc_rbracket (List.rev seq) ext_opt) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Parsetree.pattern list * Parsetree.pattern option) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.pattern) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "[") (with_txt _4 "]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Parsetree.pattern list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_array(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_array []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Parsetree.pattern list) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.pattern) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "[|") (with_txt _4 "|]") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_tuple(List.rev _2)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "(") (with_txt _3 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_constraint(_2, only_core_type _4 (mklocation _startpos__4_ _endpos__4_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.pattern) = let _5 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "(") (with_txt _5 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x0 : unit = Obj.magic x0 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.pattern) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( expecting_pat (with_txt _4 "type") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( mkpat(Ppat_unpack _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.pattern) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkpat(Ppat_constraint(mkpat ~ghost:true ~loc (Ppat_unpack _3),
                              mktyp ~ghost:true ~loc (Ptyp_package _5))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let x1 : unit = Obj.magic x1 in
        let _5 : (Parsetree.package_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.pattern) = let _6 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( unclosed_pat (with_txt _1 "(") (with_txt _6 ")") ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =       ( mkpat(Ppat_extension _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.structure_item) = Obj.magic _2 in
        let _1 : (Ast_helper.attrs * string Asttypes.loc) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.structure_item) =                                                                      (
    struct_item_extension _1 _2
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                                                 (
    _1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                  ( val_of_let_bindings _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.structure_item) =                               (
      mkstrexp _1 _2
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = x0;
                    MenhirLib.EngineTypes.startp = _startpos_x0_;
                    MenhirLib.EngineTypes.endp = _endpos_x0_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Ast_helper.attrs) = Obj.magic _7 in
        let _6 : (string list) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.structure_item) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                                        (
      let loc = mklocation _symbolstartpos _endpos in
      let core_loc = mklocation _startpos__4_ _endpos__4_ in
      mkstr
        (Pstr_primitive (Val.mk _2 (only_core_type _4 core_loc) ~prim:_6 ~attrs:_7 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.type_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                            (
      mkstr(Pstr_type (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.type_extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                        (
      mkstr(Pstr_typext _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                               (
      mkstr(Pstr_exception _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Asttypes.loc * Parsetree.module_expr) = Obj.magic _2 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.structure_item) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                (
      let (ident, body) = _2 in
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_module (Mb.mk ident body ~attrs:_3 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_binding list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                                   (
      mkstr(Pstr_recmodule(List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Ast_helper.attrs) = Obj.magic _5 in
        let x0 : (Asttypes.label) = Obj.magic x0 in
        let _3 : (unit option) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.structure_item) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
                                                               (
      let item_attrs = _5 in
      let ident = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_modtype (Mtd.mk ident ~attrs:item_attrs ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Ast_helper.attrs) = Obj.magic _7 in
        let _6 : (Parsetree.module_type) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let x0 : (Asttypes.label) = Obj.magic x0 in
        let _3 : (unit option) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.structure_item) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                 (
      let ident = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_modtype (Mtd.mk ident ~typ:_6 ~attrs:_7 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.open_description) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                    (
      mkstr(Pstr_open _1)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                             (
      (* Each declaration has their own preceeding post_item_attributes *)
      mkstr(Pstr_class (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_type_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                                  (
      (* Each declaration has their own preceeding post_item_attributes *)
      mkstr(Pstr_class_type (List.rev _1))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.structure_item) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                     (
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_include (Incl.mk _2 ~attrs:_3 ~loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Parsetree.extension) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.structure_item) =                                         (
    (* No sense in having item_extension_sugar for something that's already an
     * item_extension *)
    mkstr(Pstr_extension (_1, _2))
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =       ( mkstr(Pstr_attribute _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.toplevel_phrase) =                                         ( Ptop_def [_1]) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.toplevel_phrase) =                                         ( raise End_of_file) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.toplevel_phrase) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.toplevel_phrase) =                                         ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type) =                                                 ( mktyp (Ptyp_var _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.toplevel_phrase list) =                                                    ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.toplevel_phrase list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.toplevel_phrase list) =                                                    ( Ptop_def[_1] :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.toplevel_phrase list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.toplevel_phrase) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.toplevel_phrase list) =                                                    ( _1 :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.toplevel_phrase list) =                                                    ( [Ptop_def[_1]] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.toplevel_phrase) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.toplevel_phrase list) =                                                    ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "+" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "+." ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        [ct]
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.core_type list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__3_ _endpos__3_ in
        let ct = only_core_type _3 core_type_loc in
        ct :: _1
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Ast_helper.str * Parsetree.class_expr * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_declaration) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                             (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Ast_helper.str * Parsetree.class_type * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_description) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                               (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Ast_helper.str * Parsetree.class_type * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_type_declaration) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                  (
    let (ident, instance_type, virt, class_type_params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident instance_type ~virt:virt ~params:class_type_params ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Parsetree.pattern * Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (let_binding) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         mklb _2 _3 loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Asttypes.loc * Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_declaration) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                    (
      let (ident, body) = _2 in
      let loc = mklocation _symbolstartpos _endpos in
      Md.mk ident body ~attrs:_3 ~loc
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (string Asttypes.loc * Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.module_binding) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                     (
    let (ident, body) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Mb.mk ident body ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Ast_helper.str * (Parsetree.core_type * Asttypes.variance) list *
  (Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list *
  Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.type_declaration) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                              (
    let (ident, params, constraints, kind, priv, manifest) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.mk ident
      ~params:params ~cstrs:constraints
      ~kind ~priv ?manifest ~attrs:_3 ~loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (string Asttypes.loc) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                   ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string Asttypes.loc) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (string Asttypes.loc) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                       ( mkloc (_1 ^ "." ^ _3.txt) (mklocation _symbolstartpos _endpos) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.attribute) =                                       ( (_2, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.attributes) =                ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.attributes) = Obj.magic _2 in
        let _1 : (Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.attributes) =                          ( _1 :: _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_type) =                                                                    (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.class_expr) = Obj.magic _4 in
        let _3 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Ast_helper.str * Parsetree.class_expr * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
       (_2, _4, _1, List.rev _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.class_expr) = Obj.magic _4 in
        let _3 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Ast_helper.str * Parsetree.class_expr * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            (
       (_2, _4, _1, List.rev _3)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.class_expr) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Ast_helper.str * Parsetree.class_expr * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            (
       (_2, _5, _1, List.rev _3)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.class_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Ast_helper.str * Parsetree.class_type * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                           (
    (_2, _5, _1, List.rev _3)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =                                           (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =                                                                       (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_field) =                                             (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =                                                         (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =                                                (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.class_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.class_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.class_expr) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkclass ~loc (Pcl_constraint(_4, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_type) =                                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_field list) = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_structure) =     ( Cstr.mk _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.core_type) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        only_core_type _2 core_type_loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.core_type) = let _endpos = _endpos__0_ in
        let _symbolstartpos = _endpos in
              (
        let loc = mklocation _symbolstartpos _endpos in
        Typ.mk ~loc Ptyp_any
       ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : (Parsetree.class_type_field list) = Obj.magic _2 in
        let _1 : (Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_signature) =     ( Csig.mk _1 (List.rev _2 )) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_type_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_type_field) =                                                       (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.class_type_field list) =                                         ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_type_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_type_field list) =                   ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.class_type_field) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.class_type_field list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_type_field list) =                                         ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =                                                         (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.class_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.virtual_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Ast_helper.str * Parsetree.class_type * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                                        (
      (_2, _5, _1, List.rev _3)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Parsetree.core_type * Asttypes.variance) list) =               ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.core_type * Asttypes.variance) = Obj.magic _2 in
        let _1 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Parsetree.core_type * Asttypes.variance) list) =                                          (
      _2::_1
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (int) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.constant) =                                       ( Const_int _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (char) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.constant) =                                       ( Const_char _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.constant) =                                       ( let (s, d) = _1 in Const_string (s, d) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.constant) =                                       ( Const_float _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (int32) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.constant) =                                       ( Const_int32 _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (int64) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.constant) =                                       ( Const_int64 _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (nativeint) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.constant) =                                       ( Const_nativeint _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Longident.t) =                                                 ( Lident "[]" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Longident.t) =                                                 ( Lident "()" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident "false" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident "true" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                      (
    let loc = mklocation _symbolstartpos _endpos in
    (only_core_type _1 (mklocation _startpos__1_ _endpos__1_), only_core_type _3 (mklocation _startpos__3_ _endpos__3_), loc)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.core_type * Parsetree.core_type) =                                            ( only_core_type _1 (mklocation _startpos__1_ _endpos__1_), only_core_type _3 (mklocation _startpos__3_ _endpos__3_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_expr) =                                                                                 (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list) =                                                 ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list) =                                                 ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _3 in
        let _100 : (string) = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.constructor_declaration) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _200;
              MenhirLib.EngineTypes.startp = _startpos__200_;
              MenhirLib.EngineTypes.endp = _endpos__200_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _3 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.constructor_declaration) = let _2 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "()" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.constructor_declaration) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "::" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.constructor_declaration) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "false" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let _3 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _3 in
        let _100 : unit = Obj.magic _100 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.constructor_declaration) = let _2 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "true" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _100 : (string) = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.constructor_declaration) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _200;
              MenhirLib.EngineTypes.startp = _startpos__200_;
              MenhirLib.EngineTypes.endp = _endpos__200_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.constructor_declaration) = let _1 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "()" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.constructor_declaration) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "::" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.constructor_declaration) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "false" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.constructor_declaration) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "true" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.constructor_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.constructor_declaration list) =                                                                                 ( List.rev _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.constructor_declaration) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.constructor_declaration list) =                                                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.constructor_declaration list) = Obj.magic _2 in
        let _1 : (Parsetree.constructor_declaration) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.constructor_declaration list) =                                                                                  ( _1 :: List.rev _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.constructor_declaration) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.constructor_declaration list) =                                                                              ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.constructor_declaration) = Obj.magic _2 in
        let _1 : (Parsetree.constructor_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.constructor_declaration list) =                                                                              ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =                                           (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =                                             (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        [ct]
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.core_type list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__3_ _endpos__3_ in
        let ct = only_core_type _3 core_type_loc in
        ct :: _1
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (l, o, p) = _1 in
        mkexp ~loc (Pexp_fun(l, o, p, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp ~loc (Pexp_newtype(_3, _5))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =                                                                                (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =     (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_loc in
        ghexp_constraint loc _4 (Some ct, None)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.direction_flag) =                                                 ( Upto ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.direction_flag) =                                                 ( Downto ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =                                (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression list) =       ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression list) =       ( [_3; _1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression list) =       ( _3::_1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression list) =       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression list * Parsetree.expression option) =     ( ([], Some _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (unit) = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression list * Parsetree.expression option) =     ( ([_1], None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression list * Parsetree.expression option) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression list * Parsetree.expression option) =     ( let seq, ext = _3 in (_1::seq, ext) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =                          ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.core_type option * Parsetree.core_type option) = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                 (
      let loc = mklocation _symbolstartpos _endpos in
      ghexp_constraint loc _1 _2
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.extension) =                                            ( (_2, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _100 : (string) = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _200;
              MenhirLib.EngineTypes.startp = _startpos__200_;
              MenhirLib.EngineTypes.endp = _endpos__200_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor) = let _1 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "()" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "::" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "false" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _100;
              MenhirLib.EngineTypes.startp = _startpos__100_;
              MenhirLib.EngineTypes.endp = _endpos__100_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let _2 : (Parsetree.core_type list * Parsetree.core_type option) = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor) = let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "true" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _100 : (string) = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( _1 )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _200;
                MenhirLib.EngineTypes.startp = _startpos__200_;
                MenhirLib.EngineTypes.endp = _endpos__200_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _100;
                  MenhirLib.EngineTypes.startp = _startpos__100_;
                  MenhirLib.EngineTypes.endp = _endpos__100_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _200 : unit = Obj.magic _200 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__20_ = _endpos__200_ in
          let _startpos__10_ = _startpos__100_ in
          let _20 = _200 in
          let _10 = _100 in
          let x =
            let _2 = _20 in
            let _1 = _10 in
                                                            ( "()" )
          in
          let _endpos_x_ = _endpos__20_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "::" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "false" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _100;
                MenhirLib.EngineTypes.startp = _startpos__100_;
                MenhirLib.EngineTypes.endp = _endpos__100_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.attributes) = Obj.magic _4 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _100 : unit = Obj.magic _100 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.extension_constructor) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _1 =
          let _endpos__10_ = _endpos__100_ in
          let _startpos__10_ = _startpos__100_ in
          let _10 = _100 in
          let x =
            let _1 = _10 in
                                                            ( "true" )
          in
          let _endpos_x_ = _endpos__10_ in
          let _startpos_x_ = _startpos__10_ in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__1_ = _startpos__100_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (string Asttypes.loc * Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
            ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string Asttypes.loc * Parsetree.expression) = let _endpos = _endpos__1_ in
        let _symbolstartpos = _startpos__1_ in
            (
      let loc = mklocation _symbolstartpos _endpos in
      let lident_loc = mkloc _1 loc in
      let lident_lident_loc = mkloc (Lident _1) loc in
      (lident_loc, mkexp (Pexp_ident lident_lident_loc))
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((string Asttypes.loc * Parsetree.expression) list) =      ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string Asttypes.loc * Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((string Asttypes.loc * Parsetree.expression) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((string Asttypes.loc * Parsetree.expression) list) =       ( _3::_1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.attribute) =                                             ((_2, _3)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =                       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_loc in
        mkexp ~loc (Pexp_constraint(_4, ct))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
              (
       let (l,o,p) = _1 in
       let loc = mklocation _symbolstartpos _endpos in
       mkexp ~ghost:true ~loc (Pexp_fun(l, o, p, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp ~loc (Pexp_newtype(_3, _5))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (string Asttypes.loc * Parsetree.module_type option) =  ( mkloc "*" (mklocation _startpos__2_ _endpos__2_), None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.module_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string Asttypes.loc * Parsetree.module_type option) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( _2, Some _4 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                ( "_" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string Asttypes.loc * Parsetree.module_type option) = Obj.magic _2 in
        let _1 : ((string Asttypes.loc * Parsetree.module_type option) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((string Asttypes.loc * Parsetree.module_type option) list) =       ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string Asttypes.loc * Parsetree.module_type option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((string Asttypes.loc * Parsetree.module_type option) list) =       ( [ _1 ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.core_type list * Parsetree.core_type option) =                                                 ( ([],None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _2 : (Parsetree.core_type list) = Obj.magic _2 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__2_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type list * Parsetree.core_type option) = let _1 =
                                                         (  )
        in
                                                              ( (List.rev _2, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.core_type list) = Obj.magic _2 in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type list * Parsetree.core_type option) = let _1 =
          let _1 = _10 in
                                                         (  )
        in
                                                              ( (List.rev _2, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.core_type list) = Obj.magic _2 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__2_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.core_type list * Parsetree.core_type option) = let _1 =
                                                         (  )
        in
                                                        ( (List.rev _2,Some (only_core_type _4 (mklocation _startpos__4_ _endpos__4_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _10;
                MenhirLib.EngineTypes.startp = _startpos__10_;
                MenhirLib.EngineTypes.endp = _endpos__10_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.core_type list) = Obj.magic _2 in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.core_type list * Parsetree.core_type option) = let _1 =
          let _1 = _10 in
                                                         (  )
        in
                                                        ( (List.rev _2,Some (only_core_type _4 (mklocation _startpos__4_ _endpos__4_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type list * Parsetree.core_type option) =                                                 ( ([],Some (only_core_type _2 (mklocation _startpos__2_ _endpos__2_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.label) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.label) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.structure) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.structure) =                                          ( apply_mapper_chain_to_structure _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.signature) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.signature) =                                          ( apply_mapper_chain_to_signature _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.attribute) =                                         ( (_2, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.payload) = Obj.magic _3 in
        let _2 : (string Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.extension) =                                                   ( (_2, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string Asttypes.loc) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast_helper.attrs * string Asttypes.loc) =                     (
      ([], _2)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                          (
    let loc = mklocation _symbolstartpos _endpos in
    let body = mktailexp_extension loc _2 None in
    makeFrag loc body
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (((Asttypes.label * Parsetree.expression) list ->
   Location.t -> Parsetree.expression) *
  Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                                (
    let (component, _) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    component [
      ("children", mktailexp_extension loc [] None);
      ("", mkexp_constructor_unit loc loc)
    ] loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (string) = Obj.magic _4 in
        let _3 : (Parsetree.expression list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (((Asttypes.label * Parsetree.expression) list ->
   Location.t -> Parsetree.expression) *
  Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                  (
    let (component, start) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    (* TODO: Make this tag check simply a warning *)
    let endName = Longident.parse _4 in
    let _ = ensureTagsAreEqual start endName loc in
    let siblings = if List.length _3 > 0 then _3 else [] in
    component [
      ("children", mktailexp_extension loc siblings None);
      ("", mkexp_constructor_unit loc loc)
    ] loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Asttypes.label * Parsetree.expression) list) =               ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Asttypes.label * Parsetree.expression) list) = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Asttypes.label * Parsetree.expression) list) =       (
        (* a=?b *)
        [("?" ^ _1, _3)] @ _4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Asttypes.label * Parsetree.expression) list) = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Asttypes.label * Parsetree.expression) list) =       (
        (* a=b *)
        [(_1, _3)] @ _4
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Asttypes.label * Parsetree.expression) list) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Asttypes.label * Parsetree.expression) list) =       (
        (* a (punning) *)
        let loc_lident = mklocation _startpos__1_ _endpos__1_ in
        [(_1, mkexp (Pexp_ident {txt = Lident _1; loc = loc_lident}) ~loc:loc_lident)] @ _2
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Asttypes.label * Parsetree.expression) list) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (((Asttypes.label * Parsetree.expression) list ->
   Location.t -> Parsetree.expression) *
  Longident.t) =                             (
    let name = Longident.parse _1 in
    (jsx_component name _2, name)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Asttypes.label * Parsetree.expression) list) = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (((Asttypes.label * Parsetree.expression) list ->
   Location.t -> Parsetree.expression) *
  Longident.t) =                                 (
    (jsx_component _1 _2, _1)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                      (
    let loc = mklocation _symbolstartpos _endpos in
    let body = mktailexp_extension loc _2 None in
    makeFrag loc body
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (((Asttypes.label * Parsetree.expression) list ->
   Location.t -> Parsetree.expression) *
  Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                                                     (
    let (component, _) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    component [
      ("children", mktailexp_extension loc [] None);
      ("", mkexp_constructor_unit loc loc)
    ] loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (string) = Obj.magic _4 in
        let _3 : (Parsetree.expression list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (((Asttypes.label * Parsetree.expression) list ->
   Location.t -> Parsetree.expression) *
  Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                                       (
    let (component, start) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    (* TODO: Make this tag check simply a warning *)
    let endName = Longident.parse _4 in
    let _ = ensureTagsAreEqual start endName loc in
    let siblings = if List.length _3 > 0 then _3 else [] in
    component [
      ("children", mktailexp_extension loc siblings None);
      ("", mkexp_constructor_unit loc loc)
    ] loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.mutable_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.label_declaration * Parsetree.attributes) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              (
       let loc = mklocation _symbolstartpos _endpos in
       let ct = mkct _2 in
       (Type.field _2 ct ~mut:_1 ~loc, _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Parsetree.attributes) = Obj.magic _6 in
        let _5 : (Parsetree.core_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.attributes) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.mutable_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.label_declaration * Parsetree.attributes) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              (
       let loc = mklocation _symbolstartpos _endpos in
       (Type.field _2 _5 ~mut:_1 ~attrs:_6 ~loc, _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.label_declaration * Parsetree.attributes) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Parsetree.label_declaration * Parsetree.attributes) list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.label_declaration * Parsetree.attributes) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : ((Parsetree.label_declaration * Parsetree.attributes) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Parsetree.label_declaration * Parsetree.attributes) list) =                                                  ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.label * Parsetree.expression) = let _endpos = _endpos__1_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        (_1, mkexp (Pexp_ident(mkloc (Lident _1) loc)) ~loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.label * Parsetree.expression) =       ( (_1, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Longident.t) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Asttypes.label * Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
             (
       let loc = mklocation _symbolstartpos _endpos in
       ("?" ^ (String.concat "" (Longident.flatten _3)), mkexp (Pexp_ident(mkloc _3 loc)) ~loc)
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Asttypes.label * Parsetree.expression) =       ( ("?" ^ _1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.label * Parsetree.expression) =       ( ("", _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.label * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.label * Parsetree.expression) =       ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) =       (
        let loc = mklocation _startpos__1_ _endpos__1_ in
        (_1, None, mkpat(Ppat_var (mkloc _1 loc)) ~loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        ("?" ^ _1, None, mkpat(Ppat_var (mkloc _1 loc)) ~loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        ("?" ^ _1, Some _3, mkpat(Ppat_var (mkloc _1 loc)) ~loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) =       ( (_1, None, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) =       ( ("?" ^ _1, None, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) =       ( ("?" ^ _1, Some _4, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.label * Parsetree.expression option * Parsetree.pattern) =       ( ("", None, _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t Asttypes.loc * Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Longident.t Asttypes.loc * Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        (_1, exp_of_label _1)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =               ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =                                   ( _1 :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =                     ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =      ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =       ( _1::_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t Asttypes.loc * Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( (_1,_3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Longident.t Asttypes.loc * Parsetree.pattern) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        (_1, pat_of_label _1)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Longident.t Asttypes.loc * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.pattern) list * Asttypes.closed_flag) =                 ( [_1], Closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.pattern) list * Asttypes.closed_flag) =                       ( [_1], Closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (unit) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.pattern) list * Asttypes.closed_flag) =                                            ( [_1], Open ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Longident.t Asttypes.loc * Parsetree.pattern) list * Asttypes.closed_flag) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.pattern) list * Asttypes.closed_flag) =       ( let (fields, closed) = _3 in _1 :: fields, closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.case) =                                        (
      Exp.case _1 _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.case) =       ( Exp.case _1 ~guard:_3 _5 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.case) =       ( Exp.case _1 _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.case) =       ( Exp.case _1 ~guard:_3 _5 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.case) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.case list) =                            ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.case) = Obj.magic _2 in
        let _1 : (Parsetree.case list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.case list) =                                                    ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.case) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.case list) =                                             ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.case) = Obj.magic _2 in
        let _1 : (Parsetree.case list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.case list) =                                                                                      ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =               (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.rec_flag * (Parsetree.pattern * Parsetree.expression) *
  Ast_helper.attrs) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (let_bindings) = let _endpos = _endpos__1_ in
        let _symbolstartpos = _startpos__1_ in
                             (
    let (rec_flag, body, item_attrs) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    mklbs ([], None) rec_flag (mklb body item_attrs loc) loc
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Asttypes.rec_flag * (Parsetree.pattern * Parsetree.expression) *
  Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Ast_helper.attrs * string Asttypes.loc) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (let_bindings) = let _endpos = _endpos__2_ in
        let _symbolstartpos = _startpos__1_ in
                                                  (
      let (rec_flag, body, item_attrs) = _2 in
      let (ext_attrs, ext_id) = _1 in
      let loc = mklocation _symbolstartpos _endpos in
      mklbs (ext_attrs, Some ext_id) rec_flag (mklb body item_attrs loc) loc
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.core_type option * Parsetree.core_type option) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.pattern * Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
              ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        (_1, ghexp_constraint loc _4 _2)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern * Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
              ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
        in
              ( (_1, _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = x0;
                      MenhirLib.EngineTypes.startp = _startpos_x0_;
                      MenhirLib.EngineTypes.endp = _endpos_x0_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : (Parsetree.expression) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Asttypes.label list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__7_ in
        let _v : (Parsetree.pattern * Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
              ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__7_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__5_ _endpos__5_ in
        (mkpat ~ghost:true ~loc (Ppat_constraint(_1, mktyp ~ghost:true (Ptyp_poly(List.rev _3, only_core_type _5 core_loc)))), _7)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = x0;
                        MenhirLib.EngineTypes.startp = _startpos_x0_;
                        MenhirLib.EngineTypes.endp = _endpos_x0_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : (Parsetree.expression) = Obj.magic _8 in
        let _7 : unit = Obj.magic _7 in
        let _6 : (core_type_object) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (string list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__8_ in
        let _v : (Parsetree.pattern * Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
              ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
        in
        let _startpos__1_ = _startpos_x0_ in
        let _endpos = _endpos__8_ in
        let _symbolstartpos = _startpos__1_ in
             (
       let core_loc = mklocation _startpos__6_ _endpos__6_ in
       let exp, poly = wrap_type_annotation _4 (only_core_type _6 core_loc) _8 in
       let loc = mklocation _symbolstartpos _endpos in
       (mkpat ~ghost:true ~loc (Ppat_constraint(_1, poly)), exp)
     ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern * Parsetree.expression) =       ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.pattern * Parsetree.expression) = let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__3_ _endpos__3_ in
        (mkpat ~loc (Ppat_constraint(_1, only_core_type _3 core_loc)), _5)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Parsetree.pattern * Parsetree.expression) = Obj.magic _3 in
        let _2 : (Asttypes.rec_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Asttypes.rec_flag * (Parsetree.pattern * Parsetree.expression) *
  Ast_helper.attrs) =                                                        (
      (_2, _3, _4)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (let_bindings) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (let_binding) = Obj.magic _2 in
        let _1 : (let_bindings) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (let_bindings) =                                                 ( addlb _1 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string list) =                                       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string list) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (string list) =                                       ( _1 :: _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Ast_helper.str * Parsetree.class_expr * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_declaration list) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                 (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    [Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc]
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_declaration) = Obj.magic _2 in
        let _1 : (Parsetree.class_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_declaration list) =                                                   (
    _2::_1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Ast_helper.str * Parsetree.class_type * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_description list) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
                                                                 (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    [Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc]
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_description) = Obj.magic _2 in
        let _1 : (Parsetree.class_description list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_description list) =                                                   (
    _2 :: _1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Ast_helper.str * Parsetree.class_type * Asttypes.virtual_flag *
  (Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.class_type_declaration list) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                           (
    let (ident, instance_type, virt, class_type_params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    [Ci.mk ident instance_type ~virt:virt ~params:class_type_params ~attrs:_4 ~loc]
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.class_type_declaration) = Obj.magic _2 in
        let _1 : (Parsetree.class_type_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.class_type_declaration list) =                                                             (
    _2::_1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (string Asttypes.loc * Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.module_declaration list) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                   (
      let (ident, body) = _3 in
      let loc = mklocation _symbolstartpos _endpos in
      [Md.mk ident body ~attrs:_4 ~loc]
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.module_declaration) = Obj.magic _2 in
        let _1 : (Parsetree.module_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.module_declaration list) =                                                              (
      _2::_1
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (string Asttypes.loc * Parsetree.module_expr) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (unit) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.module_binding list) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                    (
    let (ident, body) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    [Mb.mk ident body ~attrs:_4 ~loc]
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.module_binding) = Obj.magic _2 in
        let _1 : (Parsetree.module_binding list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.module_binding list) =                                                                (
    _2::_1
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let _3 : (Ast_helper.str * (Parsetree.core_type * Asttypes.variance) list *
  (Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list *
  Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) = Obj.magic _3 in
        let x0 : (Asttypes.rec_flag) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.type_declaration list) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = if Pervasives.(!=) _startpos_x_ _endpos_x_ then
            _startpos_x_
          else
            _endpos in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                                                   (
      let (ident, params, constraints, kind, priv, manifest) = _3 in
      let loc = mklocation _symbolstartpos _endpos in
      [Type.mk ident
       ~params:params ~cstrs:constraints
       ~kind ~priv ?manifest ~attrs:(add_nonrec _2 _4) ~loc]
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.type_declaration) = Obj.magic _2 in
        let _1 : (Parsetree.type_declaration list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.type_declaration list) =                                                 ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_field) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_field) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos_x_ _endpos_x_ then
          _startpos_x_
        else
          _endpos in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_type_field) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_type_field) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.class_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.class_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.expression) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.expression) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.module_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.module_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.module_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.module_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.module_expr) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.module_expr) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.module_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.module_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.module_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.module_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.module_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.module_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.module_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.module_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos_x_ _endpos_x_ then
          _startpos_x_
        else
          _endpos in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.pattern) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.pattern) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.signature_item) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.signature_item) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with psig_loc = {x.psig_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.structure_item) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.structure_item) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.structure_item) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.structure_item) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.core_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.core_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.core_type) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.core_type) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (core_type_object) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (core_type_object) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (core_type_object) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (core_type_object) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (core_type_object) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (core_type_object) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (core_type_object) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (core_type_object) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
         (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.core_type) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string Asttypes.loc * Parsetree.class_field_kind) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( if _1 = Override then syntax_error ();
        _3, Cfk_virtual _5 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (string Asttypes.loc * Parsetree.class_field_kind) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              ( _2,
        Cfk_concrete (_1, let loc = mklocation _symbolstartpos _endpos in mkexp ~ghost:true ~loc (Pexp_poly (_3, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Parsetree.expression) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.core_type) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (string Asttypes.loc * Parsetree.class_field_kind) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              ( _2,
        Cfk_concrete (_1, let loc = mklocation _symbolstartpos _endpos in mkexp ~ghost:true ~loc (Pexp_poly(_6, Some _4))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (string Asttypes.loc * Parsetree.class_field_kind) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              ( _2,
        Cfk_concrete (_1, let loc = mklocation _symbolstartpos _endpos in mkexp ~ghost:true ~loc (Pexp_poly(_4, None))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _9;
          MenhirLib.EngineTypes.startp = _startpos__9_;
          MenhirLib.EngineTypes.endp = _endpos__9_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _8;
            MenhirLib.EngineTypes.startp = _startpos__8_;
            MenhirLib.EngineTypes.endp = _endpos__8_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _7;
              MenhirLib.EngineTypes.startp = _startpos__7_;
              MenhirLib.EngineTypes.endp = _endpos__7_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _6;
                MenhirLib.EngineTypes.startp = _startpos__6_;
                MenhirLib.EngineTypes.endp = _endpos__6_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _5;
                  MenhirLib.EngineTypes.startp = _startpos__5_;
                  MenhirLib.EngineTypes.endp = _endpos__5_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _4;
                    MenhirLib.EngineTypes.startp = _startpos__4_;
                    MenhirLib.EngineTypes.endp = _endpos__4_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _3;
                      MenhirLib.EngineTypes.startp = _startpos__3_;
                      MenhirLib.EngineTypes.endp = _endpos__3_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.semv = x0;
                        MenhirLib.EngineTypes.startp = _startpos_x0_;
                        MenhirLib.EngineTypes.endp = _endpos_x0_;
                        MenhirLib.EngineTypes.next = {
                          MenhirLib.EngineTypes.state = _menhir_s;
                          MenhirLib.EngineTypes.semv = _1;
                          MenhirLib.EngineTypes.startp = _startpos__1_;
                          MenhirLib.EngineTypes.endp = _endpos__1_;
                          MenhirLib.EngineTypes.next = _menhir_stack;
                        };
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _9 : (Parsetree.expression) = Obj.magic _9 in
        let _8 : unit = Obj.magic _8 in
        let _7 : (core_type_object) = Obj.magic _7 in
        let _6 : unit = Obj.magic _6 in
        let _5 : (string list) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : (Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__9_ in
        let _v : (string Asttypes.loc * Parsetree.class_field_kind) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__9_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
              (
        let core_type_loc = mklocation _startpos__7_ _endpos__7_ in
        (* For non, methods we'd create a pattern binding:
           ((Ppat_constraint(mkpatvar ..., Ptyp_poly (typeVars, poly_type_varified))),
            exp_with_newtypes_constrained_by_non_varified)

           For methods, we create:
           Pexp_poly (Pexp_constraint (methodFunWithNewtypes, non_varified), Some (Ptyp_poly newTypes varified))
         *)
        let (exp_with_newtypes_constrained_by_non_varified, poly_type_varified) =
          wrap_type_annotation _5 (only_core_type _7 core_type_loc) _9 in
        (
          _2,
          Cfk_concrete (
            _1,
            let loc = mklocation _symbolstartpos _endpos in
            mkexp ~ghost:true ~loc (Pexp_poly(exp_with_newtypes_constrained_by_non_varified, Some poly_type_varified))
          )
        )
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (Longident.t) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Longident.t) = let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
                                                                          (
     lapply ( Ldot(_1, _3)) _5 _symbolstartpos _endpos
   ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Longident.t) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Longident.t) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                      ( lapply _1 _3 _symbolstartpos _endpos ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Longident.t) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Longident.t) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
                                                    ( lapply (Lident(_1)) _3 _symbolstartpos _endpos ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =              ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_expr) =                              ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_expr) =                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.module_expr) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.module_expr) =       ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.module_expr) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.module_type) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.module_expr) = let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod ~loc (Pmod_constraint(_4, _2))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_expr) =                                                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_type) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_expr) =                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.module_type) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (string Asttypes.loc * Parsetree.module_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                             ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_type) =                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Asttypes.label) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Asttypes.mutable_flag) =                                                 ( Immutable ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.mutable_flag) =                                                 ( Mutable ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.label) =                                                 ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.label list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : (Asttypes.label list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.label list) =                                                 ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_type) =                                                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =     ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =     ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_type) =                                                                      (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =                                                                                         (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (core_type_object) =                                                                                 (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        [ct]
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : (Parsetree.core_type list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type list) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_type_loc in
        ct :: _1
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t Asttypes.loc * Parsetree.expression) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t Asttypes.loc * Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (s, d) = _1 in
        let lident_lident_loc = mkloc (Lident s) loc in
        (lident_lident_loc, _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.module_expr) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (string Asttypes.loc * Parsetree.module_expr) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                              (
      (_1, _2)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Asttypes.rec_flag) =                                                 ( Recursive ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.rec_flag) =                                                 ( Nonrecursive ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Parsetree.label_declaration * Parsetree.attributes) list * object_record) =       ( syntax_error () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Parsetree.label_declaration * Parsetree.attributes) list * object_record) =       ( [], Object_closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Parsetree.label_declaration * Parsetree.attributes) list * object_record) =       ( [], Object_open ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : (unit) = Obj.magic _3 in
        let _2 : ((Parsetree.label_declaration * Parsetree.attributes) list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Parsetree.label_declaration * Parsetree.attributes) list * object_record) =       ( List.rev _2, Record ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Parsetree.label_declaration * Parsetree.attributes) list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Parsetree.label_declaration * Parsetree.attributes) list * object_record) =       ( List.rev _3, Object_closed ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Parsetree.label_declaration * Parsetree.attributes) list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : ((Parsetree.label_declaration * Parsetree.attributes) list * object_record) =       ( List.rev _3, Object_open ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Ast_helper.attrs) = Obj.magic _4 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _2 : (Asttypes.override_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.open_description) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__4_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        Opn.mk _3 ~override:_2 ~attrs:_4 ~loc
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "!" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "/>" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : (string) = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( _1 )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "+" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "+." )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "-" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "-." )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "*" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "<" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( ">" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "or" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "||" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "&" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "&&" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( ":=" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "+=" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "%" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (string) = let _1 =
          let _1 = _10 in
                                                          ( "<..>" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _20;
          MenhirLib.EngineTypes.startp = _startpos__20_;
          MenhirLib.EngineTypes.endp = _endpos__20_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _10;
            MenhirLib.EngineTypes.startp = _startpos__10_;
            MenhirLib.EngineTypes.endp = _endpos__10_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _20 : unit = Obj.magic _20 in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__20_ in
        let _v : (string) = let _1 =
          let _2 = _20 in
          let _1 = _10 in
                                                          ( ">>" )
        in
                                                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (bool) =                                                 ( true ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (bool) =                                                 ( false ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (unit) =                  ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) =              ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) =                                                 ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit option) =     ( None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : unit = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (unit option) =     ( Some x ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit option) =     ( None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : unit = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (unit option) =     ( Some x ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.core_type * Asttypes.variance) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Parsetree.core_type * Asttypes.variance) list) =                                                                          ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.core_type * Asttypes.variance) = Obj.magic _2 in
        let _1 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Parsetree.core_type * Asttypes.variance) list) =                                                                          ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Parsetree.core_type * Asttypes.variance) list) =                                    ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Parsetree.core_type * Asttypes.variance) list) =                                    ( List.rev _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Parsetree.core_type * Asttypes.variance) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Parsetree.core_type * Asttypes.variance) = let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
                                                                                        (
      let first = fst x in
      let second = snd x in
      ({
        first with ptyp_loc = {
        first.ptyp_loc with
        loc_start = _symbolstartpos;
        loc_end = _endpos}}, second )
) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Asttypes.override_flag) =                                                 ( Fresh ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.override_flag) =                                                 ( Override ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x0;
          MenhirLib.EngineTypes.startp = _startpos_x0_;
          MenhirLib.EngineTypes.endp = _endpos_x0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos_x0_ in
        let _v : (Parsetree.package_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                  ( (_1, []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Longident.t Asttypes.loc * Parsetree.core_type) list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.package_type) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                          ( (_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (core_type_object) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Longident.t Asttypes.loc * Parsetree.core_type) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
        let ct = only_core_type _4 core_type_loc in
        (_2, ct)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Longident.t Asttypes.loc * Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.core_type) list) =                       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Longident.t Asttypes.loc * Parsetree.core_type) list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.core_type) list) =                                              ( _1::_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (string option) =           ( Some _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (string option) =           ( None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type) =       (
        let core_loc = mklocation _startpos__1_ _endpos__1_ in
        apply_mapper_chain_to_type (only_core_type _1 core_loc) (default_mapper_chain ())
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression) =              ( apply_mapper_chain_to_expr _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern) =                 ( apply_mapper_chain_to_pattern _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                        ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern list) =                                                   ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern list * Parsetree.pattern option) =                                                 ( [_1], None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.pattern) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.pattern list * Parsetree.pattern option) =                                                 ( (_1, Some _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern list * Parsetree.pattern option) =                                                 ( (_3 :: _1, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                                                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern list) =     ( _3::_1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.pattern) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.pattern list) =     ( [_3; _1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern) =                                (
  _2
) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.structure) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.payload) =               ( PStr _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.payload) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_type_loc in
        PTyp ct
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.payload) =                      ( PPat (_2, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.expression) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.payload) =                                ( PPat (_2, Some _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.core_type) =                                          (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast_helper.attrs) =                ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Ast_helper.attrs) = Obj.magic _2 in
        let _1 : (Parsetree.attribute) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast_helper.attrs) =                                         ( _1 :: _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast_helper.lid * (Parsetree.core_type * Asttypes.variance) list) =                                   (
      let loc = mklocation _startpos__1_ _endpos__1_ in
      let lident_lident_loc = mkloc (Lident _1) loc in
      (lident_lident_loc, _2)
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _2 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast_helper.lid * (Parsetree.core_type * Asttypes.variance) list) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                                     ((_1, _2)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string list) =                                                 ( [fst _1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string list) = Obj.magic _2 in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (string list) =                                                 ( fst _1 :: _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Asttypes.private_flag) =                                                 ( Public ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.private_flag) =                                             ( Private ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Asttypes.virtual_flag) =                  ( Concrete ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.virtual_flag) =             ( Virtual ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Asttypes.rec_flag) =                                                 ( Nonrecursive ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.rec_flag) =                                                 ( Recursive ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) =                                                            ( (Some _2, _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : ((Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) =                                                            ( (None, _1) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) =                                                                       ( (Some _2, _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : ((Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression option *
  (Longident.t Asttypes.loc * Parsetree.expression) list) =                                                                       ( (None, _1)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.row_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.row_field) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.row_field) =       (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Rinherit ct
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.row_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.row_field list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.row_field) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.row_field list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.row_field list) =                                                 ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.class_field list) =                           ([]) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.class_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.class_field list) =                           ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.class_field list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.class_field) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.class_field list) =                                                     ( _1::_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =                                                                         (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =                                                                                 (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Parsetree.extension_constructor) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor) =       (
        let ext = _2 in
        {ext with pext_attributes = ext.pext_attributes @ _3}
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.extension_constructor list) =                                                           ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.extension_constructor) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.extension_constructor list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor list) =       ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : (Ast_helper.attrs) = Obj.magic _8 in
        let _7 : (Parsetree.extension_constructor list) = Obj.magic _7 in
        let _6 : (unit) = Obj.magic _6 in
        let _5 : (Asttypes.private_flag) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Ast_helper.lid * (Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let _2 : (Asttypes.rec_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Parsetree.type_extension) =   (
    if _2 <> Recursive then not_expecting _startpos__2_ _endpos__2_ "nonrec flag";
    let (potentially_long_ident, optional_type_parameters) = _3 in
    Te.mk potentially_long_ident (List.rev _7)
          ~params:optional_type_parameters ~priv:_5 ~attrs:_8
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.signature) =                          ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.signature) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.signature_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.signature) =                                   ( _1 :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.signature_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.signature_item) =                                                    ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.constant) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.constant) =                                            ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (int) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_int(- _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_float("-" ^ _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (int32) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_int32(Int32.neg _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (int64) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_int64(Int64.neg _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (nativeint) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_nativeint(Nativeint.neg _2) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (int) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_int _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (string) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_float _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (int32) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_int32 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (int64) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_int64 _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (nativeint) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.constant) =                                            ( Const_nativeint _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =                                              (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.expression list) =             ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression list) = Obj.magic _2 in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression list) =                                 ( [_1] @ _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Asttypes.label * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Asttypes.label * Parsetree.expression) list) =       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Asttypes.label * Parsetree.expression) = Obj.magic _2 in
        let _1 : ((Asttypes.label * Parsetree.expression) list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Asttypes.label * Parsetree.expression) list) =       ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_expr) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_expr) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.module_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.module_type) =                                                            (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression list) =       ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.expression) = Obj.magic _2 in
        let _1 : (Parsetree.expression list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.expression list) =       ( _2 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.expression) =                                                                                                  (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                                                    (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.pattern) = Obj.magic _2 in
        let _1 : (Parsetree.pattern list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.pattern list) =     ( _2::_1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern list) =     ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.pattern) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.pattern) =                                                                        (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "and" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "as" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "assert" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =           ( "begin" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =           ( "class" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                ( "constraint" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "do" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "done" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "downto" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "else" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "end" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =               ( "exception" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =              ( "external" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =           ( "false" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "for" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "fun" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =              ( "function" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "functor" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "if" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "in" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "include" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "inherit" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                 ( "initializer" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "lazy" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "let" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "switch" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "module" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "mutable" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "new" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "nonrec" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "object" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "of" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "open" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "or" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "private" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "rec" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "sig" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =            ( "struct" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "then" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =        ( "to" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "true" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "try" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "type" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =         ( "val" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =             ( "virtual" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "when" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =           ( "while" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =          ( "with" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Parsetree.extension_constructor) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor) =       (
        let ext = _2 in
        {ext with pext_attributes = ext.pext_attributes @ _3}
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Ast_helper.attrs) = Obj.magic _3 in
        let _2 : (Parsetree.extension_constructor) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor) =       (
        let ext = _2 in
        {ext with pext_attributes = ext.pext_attributes @ _3}
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.extension_constructor list) =                                                           ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.extension_constructor) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.extension_constructor list) =                                                           ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.extension_constructor) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.extension_constructor list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor list) =       ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.extension_constructor) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.extension_constructor list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.extension_constructor list) =       ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : (Ast_helper.attrs) = Obj.magic _8 in
        let _7 : (Parsetree.extension_constructor list) = Obj.magic _7 in
        let _6 : (unit) = Obj.magic _6 in
        let _5 : (Asttypes.private_flag) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (Ast_helper.lid * (Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let _2 : (Asttypes.rec_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Parsetree.type_extension) =   (
    if _2 <> Recursive then not_expecting _startpos__2_ _endpos__2_ "nonrec flag";
    let (potentially_long_ident, optional_type_parameters) = _3 in
    Te.mk potentially_long_ident (List.rev _7)
          ~params:optional_type_parameters ~priv:_5 ~attrs:_8
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.expression) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t Asttypes.loc * Parsetree.expression) = let _endpos = _endpos__3_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (s, d) = _1 in
        let lident_lident_loc = mkloc (Lident s) loc in
        (lident_lident_loc, _3)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string * string option) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t Asttypes.loc * Parsetree.expression) = let _endpos = _endpos__1_ in
        let _symbolstartpos = _startpos__1_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let (s, d) = _1 in
        let lident_lident_loc = mkloc (Lident s) loc in
        (lident_lident_loc, mkexp (Pexp_ident lident_lident_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =                          ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =                                                         ( _1 :: _3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =                                ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =     ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : ((Longident.t Asttypes.loc * Parsetree.expression) list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t Asttypes.loc * Parsetree.expression) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : ((Longident.t Asttypes.loc * Parsetree.expression) list) =     ( _1::_3 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.structure) =                 ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.structure) = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.structure) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                    (
    let menhirError = Syntax_util.findMenhirErrorMessage _1.loc in
    match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _2
      | _ -> (syntax_error_str _1.loc "Invalid statement") :: _2
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.structure) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : unit = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.structure) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                         (
    let menhirError = Syntax_util.findMenhirErrorMessage _1.loc in
    match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _3
      | _ -> (syntax_error_str _1.loc "Invalid statement") :: _3
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure) =                    ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.structure) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let x0 : (Parsetree.structure_item) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.structure) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                                   (
    let menhirError = Syntax_util.findMenhirErrorMessage _1.loc in
    match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _3
      | _ -> (syntax_error_str _1.loc "Statement has to end with a semicolon") :: _3
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.structure) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.structure) =                                   (
      let effective_loc = mklocation _startpos__1_ _endpos__2_ in
      set_structure_item_location _1 effective_loc :: _3
  ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                                                    (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.structure_item) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.structure_item) =                                                                   (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "-" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( "-." ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.attributes) = Obj.magic _5 in
        let _4 : (Parsetree.core_type list) = Obj.magic _4 in
        let _3 : (bool) = Obj.magic _3 in
        let _2 : (unit option) = Obj.magic _2 in
        let _1 : (Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.row_field) =       ( Rtag (_1, _5, _3, List.rev _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.attributes) = Obj.magic _2 in
        let _1 : (Asttypes.label) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.row_field) =       ( Rtag (_1, _2, true, []) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_none) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string * string option) = Obj.magic _3 in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_string (fst _3)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (int) = Obj.magic _3 in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_int _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Longident.t) = Obj.magic _3 in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_ident _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Longident.t) = Obj.magic _3 in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_ident _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_bool false) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.toplevel_phrase) =                                 ( Ptop_dir(_2, Pdir_bool true) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.toplevel_phrase) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.toplevel_phrase) =                                   (apply_mapper_chain_to_toplevel_phrase _1 (default_mapper_chain ()) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.core_type option * Parsetree.core_type option) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type option * Parsetree.core_type option) =                                                 ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type option * Parsetree.core_type option) =                                                 ( (None, Some (only_core_type _2 (mklocation _startpos__2_ _endpos__2_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.core_type option * Parsetree.core_type option) =                                           ( (Some (only_core_type _1 (mklocation _startpos__1_ _endpos__1_)), None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (core_type_object) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.core_type option * Parsetree.core_type option) =                                           ( (Some (only_core_type _1 (mklocation _startpos__1_ _endpos__1_)), Some (only_core_type _3 (mklocation _startpos__3_ _endpos__3_))) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list) = Obj.magic _4 in
        let _3 : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) = Obj.magic _3 in
        let _2 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Ast_helper.str * (Parsetree.core_type * Asttypes.variance) list *
  (Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list *
  Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Location.raise_errorf ~loc:_1.loc "A type's name need to begin with a lower-case letter or _" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : ((Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list) = Obj.magic _4 in
        let _3 : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) = Obj.magic _3 in
        let _2 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _2 in
        let x0 : (string) = Obj.magic x0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x0_ in
        let _endpos = _endpos__4_ in
        let _v : (Ast_helper.str * (Parsetree.core_type * Asttypes.variance) list *
  (Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list *
  Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) = let _1 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( let (kind, priv, manifest) = _3 in
        (_1, _2, List.rev _4, kind, priv, manifest)
       ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =       ( (Ptype_abstract, Public, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =       (
      match _2 with
      | Core_type ct -> (Ptype_abstract, Public, Some ct)
      | Record_type rt -> (Ptype_record rt, Public, None)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =                         (
      match _3 with
      | Core_type ct -> (Ptype_abstract, Private, Some ct)
      | Record_type rt -> (Ptype_record rt, Private, None)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.constructor_declaration list) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =       ( (Ptype_variant(_2),  Public, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.constructor_declaration list) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =       ( (Ptype_variant(_3), Private, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =       ( (Ptype_open, Public, None) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : (Parsetree.constructor_declaration list) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_variant(_4), Public,  Some (only_core_type _2 core_type_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.constructor_declaration list) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_variant(_5), Private, Some (only_core_type _2 core_type_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_open, Public, Some (only_core_type _2 core_type_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _8;
          MenhirLib.EngineTypes.startp = _startpos__8_;
          MenhirLib.EngineTypes.endp = _endpos__8_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _6;
              MenhirLib.EngineTypes.startp = _startpos__6_;
              MenhirLib.EngineTypes.endp = _endpos__6_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _5;
                MenhirLib.EngineTypes.startp = _startpos__5_;
                MenhirLib.EngineTypes.endp = _endpos__5_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _4;
                  MenhirLib.EngineTypes.startp = _startpos__4_;
                  MenhirLib.EngineTypes.endp = _endpos__4_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.semv = _2;
                      MenhirLib.EngineTypes.startp = _startpos__2_;
                      MenhirLib.EngineTypes.endp = _endpos__2_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _8 : unit = Obj.magic _8 in
        let _7 : (unit) = Obj.magic _7 in
        let _6 : ((Parsetree.label_declaration * Parsetree.attributes) list) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Asttypes.private_flag) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : (core_type_object) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__8_ in
        let _v : (Parsetree.type_kind * Asttypes.private_flag * Parsetree.core_type option) =       (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_record(List.rev (only_labels _6)), _4, Some (only_core_type _2 core_type_loc))
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Parsetree.core_type) = Obj.magic _2 in
        let _1 : (Asttypes.variance) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Parsetree.core_type * Asttypes.variance) =                                                   ( _2, _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.core_type) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.core_type) =                                                  (_1) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Asttypes.variance) =                                                 ( Invariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.variance) =                                                 ( Covariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.variance) =                                                 ( Contravariant ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : (Asttypes.label) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.label list) =                                                 ( [_2] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Asttypes.label) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Asttypes.label list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Asttypes.label list) =                                                 ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.toplevel_phrase list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.toplevel_phrase list) =                     (apply_mapper_chain_to_use_file _1 (default_mapper_chain ())) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string) =                                                 ( _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let _2 : (string) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (string) =                                                 ( _2 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Longident.t) =                                                 ( Lident _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (string) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Longident.t) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Longident.t) =                                                 ( Ldot(_1, _3) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (core_type_object) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let x0 : (string) = Obj.magic x0 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (string Asttypes.loc * Asttypes.mutable_flag * Parsetree.class_field_kind) = let _4 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos__4_ = _endpos_x0_ in
        let _startpos__4_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          _startpos__2_ in
                                                                        (
      let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
      if _1 = Override
      then not_expecting _symbolstartpos _endpos "members marked virtual may not also be marked overridden"
      else _4, Mutable, Cfk_virtual (only_core_type _6 core_type_loc)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _7;
          MenhirLib.EngineTypes.startp = _startpos__7_;
          MenhirLib.EngineTypes.endp = _endpos__7_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _6;
            MenhirLib.EngineTypes.startp = _startpos__6_;
            MenhirLib.EngineTypes.endp = _endpos__6_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _5;
              MenhirLib.EngineTypes.startp = _startpos__5_;
              MenhirLib.EngineTypes.endp = _endpos__5_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _4;
                MenhirLib.EngineTypes.startp = _startpos__4_;
                MenhirLib.EngineTypes.endp = _endpos__4_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _3;
                  MenhirLib.EngineTypes.startp = _startpos__3_;
                  MenhirLib.EngineTypes.endp = _endpos__3_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.semv = _2;
                    MenhirLib.EngineTypes.startp = _startpos__2_;
                    MenhirLib.EngineTypes.endp = _endpos__2_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _menhir_s;
                      MenhirLib.EngineTypes.semv = _1;
                      MenhirLib.EngineTypes.startp = _startpos__1_;
                      MenhirLib.EngineTypes.endp = _endpos__1_;
                      MenhirLib.EngineTypes.next = _menhir_stack;
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _7 : unit = Obj.magic _7 in
        let _6 : (core_type_object) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (string) = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__7_ in
        let _v : (string Asttypes.loc * Asttypes.mutable_flag * Parsetree.class_field_kind) =       ( not_expecting _startpos__7_ _endpos__7_ "not expecting equal - cannot specify value for virtual val" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : (Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string Asttypes.loc * Asttypes.mutable_flag * Parsetree.class_field_kind) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              (
        let core_type_loc = mklocation _startpos__5_ _endpos__5_ in
        _3, _2, Cfk_virtual (only_core_type _5 core_type_loc)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (string Asttypes.loc * Asttypes.mutable_flag * Parsetree.class_field_kind) =       ( not_expecting _startpos__6_ _endpos__6_ "not expecting equal - cannot specify value for virtual val" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (Parsetree.expression) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : (Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : (Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string Asttypes.loc * Asttypes.mutable_flag * Parsetree.class_field_kind) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( _3, _2, Cfk_concrete (_1, _5) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : (Parsetree.expression) = Obj.magic _6 in
        let _5 : unit = Obj.magic _5 in
        let _4 : (Parsetree.core_type option * Parsetree.core_type option) = Obj.magic _4 in
        let x0 : (string) = Obj.magic x0 in
        let _2 : (Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : (Asttypes.override_flag) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (string Asttypes.loc * Asttypes.mutable_flag * Parsetree.class_field_kind) = let _3 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _startpos__3_ = _startpos_x0_ in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = if Pervasives.(!=) _startpos__1_ _endpos__1_ then
          _startpos__1_
        else
          if Pervasives.(!=) _startpos__2_ _endpos__2_ then
            _startpos__2_
          else
            _startpos__3_ in
              (
        let loc = mklocation _symbolstartpos _endpos in
        let e = ghexp_constraint loc _6 _4 in
        _3, _2, Cfk_concrete (_1, e)
      ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Asttypes.mutable_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string * Asttypes.mutable_flag * Asttypes.virtual_flag *
  Parsetree.core_type) =       ( _3, _2, Virtual, only_core_type _5 (mklocation _startpos__5_ _endpos__5_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _2;
                MenhirLib.EngineTypes.startp = _startpos__2_;
                MenhirLib.EngineTypes.endp = _endpos__2_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : (string) = Obj.magic _3 in
        let _2 : (Asttypes.virtual_flag) = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (string * Asttypes.mutable_flag * Asttypes.virtual_flag *
  Parsetree.core_type) =       ( _3, Mutable, _2, only_core_type _5 (mklocation _startpos__5_ _endpos__5_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (core_type_object) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (string) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (string * Asttypes.mutable_flag * Asttypes.virtual_flag *
  Parsetree.core_type) =       ( _1, Immutable, Concrete, only_core_type _3 (mklocation _startpos__3_ _endpos__3_)) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Asttypes.virtual_flag) =                                                 ( Concrete ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.virtual_flag) =                                                 ( Virtual ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = x0;
                  MenhirLib.EngineTypes.startp = _startpos_x0_;
                  MenhirLib.EngineTypes.endp = _endpos_x0_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : ((Parsetree.core_type * Parsetree.core_type * Ast_helper.loc) list) = Obj.magic _6 in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : (Asttypes.private_flag) = Obj.magic _4 in
        let _3 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v : (Parsetree.with_constraint) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos = _endpos__6_ in
        let _symbolstartpos = _startpos__1_ in
              (
         let loc = mklocation _symbolstartpos _endpos in
         let core_type_loc = mklocation _startpos__5_ _endpos__5_ in
         Pwith_type
          (_2,
           (Type.mk {_2 with txt=Longident.last _2.txt}
              ~params:_3
              ~cstrs:(List.rev _6)
              ~manifest:(only_core_type _5 core_type_loc)
              ~priv:_4
              ~loc)) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _5;
          MenhirLib.EngineTypes.startp = _startpos__5_;
          MenhirLib.EngineTypes.endp = _endpos__5_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _4;
            MenhirLib.EngineTypes.startp = _startpos__4_;
            MenhirLib.EngineTypes.endp = _endpos__4_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = x0;
                MenhirLib.EngineTypes.startp = _startpos_x0_;
                MenhirLib.EngineTypes.endp = _endpos_x0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _5 : (core_type_object) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let _3 : ((Parsetree.core_type * Asttypes.variance) list) = Obj.magic _3 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__5_ in
        let _v : (Parsetree.with_constraint) = let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _endpos__2_ = _endpos_x0_ in
        let _startpos__2_ = _startpos_x0_ in
        let _endpos = _endpos__5_ in
        let _symbolstartpos = _startpos__1_ in
            (
      let last = (
        match _2.txt with
            | Lident s -> s
            | _ -> not_expecting _startpos__2_ _endpos__2_ "Long type identifier"
      ) in
     let loc = mklocation _symbolstartpos _endpos in
     let core_type_loc = mklocation _startpos__5_ _endpos__5_ in
      Pwith_typesubst
          (Type.mk {_2 with txt=last}
             ~params:_3
             ~manifest:(only_core_type _5 core_type_loc)
             ~loc)
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : (Longident.t) = Obj.magic x1 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (Longident.t) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.with_constraint) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Pwith_module (_2, _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = x1;
          MenhirLib.EngineTypes.startp = _startpos_x1_;
          MenhirLib.EngineTypes.endp = _endpos_x1_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = x0;
              MenhirLib.EngineTypes.startp = _startpos_x0_;
              MenhirLib.EngineTypes.endp = _endpos_x0_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let x1 : (Longident.t) = Obj.magic x1 in
        let _3 : unit = Obj.magic _3 in
        let x0 : (string) = Obj.magic x0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_x1_ in
        let _v : (Parsetree.with_constraint) = let _4 =
          let _endpos_x_ = _endpos_x1_ in
          let _startpos_x_ = _startpos_x1_ in
          let x = x1 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
        let _2 =
          let _endpos_x_ = _endpos_x0_ in
          let _startpos_x_ = _startpos_x0_ in
          let x = x0 in
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
           ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
              ( Pwith_modsubst (_2, _4) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : (Parsetree.with_constraint) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Parsetree.with_constraint list) =                                                 ( [_1] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : (Parsetree.with_constraint) = Obj.magic _3 in
        let _2 : unit = Obj.magic _2 in
        let _1 : (Parsetree.with_constraint list) = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Parsetree.with_constraint list) =                                                 ( _3 :: _1 ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Asttypes.private_flag) =                    ( Public ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (Asttypes.private_flag) =                ( Private ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
    |]
  
  and trace =
    None
  
end

module MenhirInterpreter = struct
  
  module TI = MenhirLib.TableInterpreter.Make (Tables)
  
  include TI
  
end

let use_file =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2870 lexer lexbuf) : (Parsetree.toplevel_phrase list))

and toplevel_phrase =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2699 lexer lexbuf) : (Parsetree.toplevel_phrase))

and parse_pattern =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2695 lexer lexbuf) : (Parsetree.pattern))

and parse_expression =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2691 lexer lexbuf) : (Parsetree.expression))

and parse_core_type =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2687 lexer lexbuf) : (Parsetree.core_type))

and interface =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 2680 lexer lexbuf) : (Parsetree.signature))

and implementation =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 0 lexer lexbuf) : (Parsetree.structure))

module Incremental = struct
  
  let use_file =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2870 initial_position) : (Parsetree.toplevel_phrase list) MenhirInterpreter.checkpoint)
  
  and toplevel_phrase =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2699 initial_position) : (Parsetree.toplevel_phrase) MenhirInterpreter.checkpoint)
  
  and parse_pattern =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2695 initial_position) : (Parsetree.pattern) MenhirInterpreter.checkpoint)
  
  and parse_expression =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2691 initial_position) : (Parsetree.expression) MenhirInterpreter.checkpoint)
  
  and parse_core_type =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2687 initial_position) : (Parsetree.core_type) MenhirInterpreter.checkpoint)
  
  and interface =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 2680 initial_position) : (Parsetree.signature) MenhirInterpreter.checkpoint)
  
  and implementation =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 0 initial_position) : (Parsetree.structure) MenhirInterpreter.checkpoint)
  
end
  
  


end
module Reason_lexer
= struct
#1 "reason_lexer.ml"
# 52 "src/reason_lexer.mll"
 
open Lexing
open Misc
open Reason_parser

type error =
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment of Location.t
  | Unterminated_string
  | Unterminated_string_in_comment of Location.t * Location.t
  | Keyword_as_label of string
  | Literal_overflow of string
;;

exception Error of error * Location.t;;

(* The table of keywords *)

let keyword_table =
  create_hashtable 149 [
    "and", AND;
    "as", AS;
    "assert", ASSERT;
    "begin", BEGIN;
    "class", CLASS;
    "constraint", CONSTRAINT;
    "do", DO;
    "done", DONE;
    "downto", DOWNTO;
    "else", ELSE;
    "end", END;
    "exception", EXCEPTION;
    "external", EXTERNAL;
    "false", FALSE;
    "for", FOR;
    "fun", FUN;
    "function", FUNCTION;
    "functor", FUNCTOR;
    "if", IF;
    "in", IN;
    "include", INCLUDE;
    "inherit", INHERIT;
    "initializer", INITIALIZER;
    "lazy", LAZY;
    "let", LET;
    "switch", SWITCH;
    "module", MODULE;
    "pub", PUB;
    "mutable", MUTABLE;
    "new", NEW;
    "nonrec", NONREC;
    "object", OBJECT;
    "of", OF;
    "open", OPEN;
    "or", OR;
(*  "parser", PARSER; *)
    "pri", PRI;
    "rec", REC;
    "sig", SIG;
    "struct", STRUCT;
    "then", THEN;
    "to", TO;
    "true", TRUE;
    "try", TRY;
    "type", TYPE;
    "val", VAL;
    "virtual", VIRTUAL;
    "when", WHEN;
    "while", WHILE;
    "with", WITH;

    "mod", INFIXOP3("mod");
    "land", INFIXOP3("land");
    "lor", INFIXOP3("lor");
    "lxor", INFIXOP3("lxor");
    "lsl", INFIXOP4("lsl");
    "lsr", INFIXOP4("lsr");
    "asr", INFIXOP4("asr")
]

(* To buffer string literals *)

let initial_string_buffer = Bytes.create 256
let string_buff = ref initial_string_buffer
let string_index = ref 0

let reset_string_buffer () =
  string_buff := initial_string_buffer;
  string_index := 0

let store_string_char c =
  if !string_index >= Bytes.length !string_buff then begin
    let new_buff = Bytes.create (Bytes.length (!string_buff) * 2) in
    Bytes.blit !string_buff 0 new_buff 0 (Bytes.length !string_buff);
    string_buff := new_buff
  end;
  Bytes.unsafe_set !string_buff !string_index c;
  incr string_index

let store_string s =
  for i = 0 to String.length s - 1 do
    store_string_char s.[i];
  done

let store_lexeme lexbuf =
  store_string (Lexing.lexeme lexbuf)

let get_stored_string () =
  let s = Bytes.sub_string !string_buff 0 !string_index in
  string_buff := initial_string_buffer;
  s

(* To store the position of the beginning of a string and comment *)
let string_start_loc = ref Location.none;;
let comment_start_loc = ref [];;
let in_comment () = !comment_start_loc <> [];;
let is_in_string = ref false
let in_string () = !is_in_string
let print_warnings = ref true

(* To translate escape sequences *)

let char_for_backslash = function
  | 'n' -> '\010'
  | 'r' -> '\013'
  | 'b' -> '\008'
  | 't' -> '\009'
  | c   -> c

let char_for_decimal_code lexbuf i =
  let c = 100 * (Char.code(Lexing.lexeme_char lexbuf i) - 48) +
           10 * (Char.code(Lexing.lexeme_char lexbuf (i+1)) - 48) +
                (Char.code(Lexing.lexeme_char lexbuf (i+2)) - 48) in
  if (c < 0 || c > 255) then
    if in_comment ()
    then 'x'
    else raise (Error(Illegal_escape (Lexing.lexeme lexbuf),
                      Location.curr lexbuf))
  else Char.chr c

let char_for_hexadecimal_code lexbuf i =
  let d1 = Char.code (Lexing.lexeme_char lexbuf i) in
  let val1 = if d1 >= 97 then d1 - 87
             else if d1 >= 65 then d1 - 55
             else d1 - 48
  in
  let d2 = Char.code (Lexing.lexeme_char lexbuf (i+1)) in
  let val2 = if d2 >= 97 then d2 - 87
             else if d2 >= 65 then d2 - 55
             else d2 - 48
  in
  Char.chr (val1 * 16 + val2)

(* To convert integer literals, allowing max_int + 1 (PR#4210) *)

let cvt_int_literal s =
  - int_of_string ("-" ^ s)
let cvt_int32_literal s =
  Int32.neg (Int32.of_string ("-" ^ String.sub s 0 (String.length s - 1)))
let cvt_int64_literal s =
  Int64.neg (Int64.of_string ("-" ^ String.sub s 0 (String.length s - 1)))
let cvt_nativeint_literal s =
  Nativeint.neg (Nativeint.of_string ("-" ^ String.sub s 0
                                                       (String.length s - 1)))

(* Remove underscores from float literals *)

let remove_underscores s =
  let l = String.length s in
  let b = Bytes.create l in
  let rec remove src dst =
    if src >= l then
      if dst >= l then s else Bytes.sub_string b 0 dst
    else
      match s.[src] with
        '_' -> remove (src + 1) dst
      |  c  -> Bytes.set b dst c; remove (src + 1) (dst + 1)
  in remove 0 0

(* Update the current location with file name and line number. *)

let update_loc lexbuf file line absolute chars =
  let pos = lexbuf.lex_curr_p in
  let new_file = match file with
                 | None -> pos.pos_fname
                 | Some s -> s
  in
  lexbuf.lex_curr_p <- { pos with
    pos_fname = new_file;
    pos_lnum = if absolute then line else pos.pos_lnum + line;
    pos_bol = pos.pos_cnum - chars;
  }
;;

let preprocessor = ref None

(* Warn about Latin-1 characters used in idents *)

let warn_latin1 lexbuf =
  Location.prerr_warning (Location.curr lexbuf)
    (Warnings.Deprecated "ISO-Latin1 characters in identifiers")
;;

(* Error report *)

open Format

let report_error ppf = function
  | Illegal_character c ->
      fprintf ppf "Illegal character (%s)" (Char.escaped c)
  | Illegal_escape s ->
      fprintf ppf "Illegal backslash escape in string or character (%s)" s
  | Unterminated_comment _ ->
      fprintf ppf "Comment not terminated"
  | Unterminated_string ->
      fprintf ppf "String literal not terminated"
  | Unterminated_string_in_comment (_, loc) ->
      fprintf ppf "This comment contains an unterminated string literal@.\
                   %aString literal begins here"
              Location.print_error loc
  | Keyword_as_label kwd ->
      fprintf ppf "`%s' is a keyword, it cannot be used as label name" kwd
  | Literal_overflow ty ->
      fprintf ppf "Integer literal exceeds the range of representable \
                   integers of type %s" ty

let () =
  Location.register_error_of_exn
    (function
      | Error (err, loc) ->
          Some (Location.error_of_printer loc report_error err)
      | _ ->
          None
    )

# 239 "src/reason_lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\155\255\156\255\224\000\235\000\018\001\053\001\088\001\
    \188\255\123\001\158\001\195\255\091\000\225\001\068\000\083\000\
    \061\002\217\255\219\255\220\255\222\255\072\002\156\002\191\002\
    \226\002\008\001\000\003\237\255\077\003\110\003\183\003\135\004\
    \087\005\054\006\065\006\104\006\166\006\118\007\072\000\126\000\
    \254\255\001\000\108\008\121\008\158\008\193\008\228\008\007\009\
    \042\009\255\255\005\000\089\000\077\009\112\009\147\009\090\000\
    \182\009\097\000\217\009\098\000\252\009\099\000\031\010\100\000\
    \101\000\107\000\110\000\006\000\207\255\208\255\064\000\061\010\
    \092\000\251\255\216\000\151\010\162\010\238\255\239\255\240\255\
    \180\001\089\002\139\000\190\001\243\002\002\004\210\004\116\001\
    \120\002\017\003\193\255\236\255\115\005\210\010\117\000\121\000\
    \007\000\235\255\234\255\230\255\224\004\087\003\150\000\233\255\
    \031\004\151\000\232\255\241\006\152\000\231\255\235\010\200\000\
    \228\255\227\255\233\007\040\007\020\011\217\000\225\255\011\000\
    \010\001\023\001\244\001\025\001\225\255\012\000\055\011\090\011\
    \125\011\219\000\211\255\205\255\160\011\195\011\228\011\056\012\
    \146\012\170\255\179\012\196\255\013\013\024\013\229\000\211\000\
    \198\255\199\255\200\255\219\000\182\255\184\255\190\255\063\013\
    \187\255\098\013\133\013\168\013\203\013\002\001\002\008\243\255\
    \244\255\013\000\245\255\062\001\143\005\253\255\243\000\003\001\
    \255\255\254\255\252\255\201\013\036\014\007\001\009\001\017\000\
    \251\255\250\255\249\255\070\014\247\004\011\001\248\255\002\005\
    \013\001\247\255\109\014\014\001\246\255\018\000\096\001\247\255\
    \248\255\249\255\055\001\180\014\255\255\250\255\214\014\220\005\
    \253\255\061\001\056\001\064\001\008\007\252\255\253\014\251\255\
    \074\001\197\001\252\255\005\015\254\255\255\255\075\001\094\001\
    \253\255\034\015\023\001\026\001\092\001\112\001\034\001\113\001\
    \048\001\019\000\255\255";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\095\000\090\000\089\000\079\000\074\000\
    \255\255\066\000\063\000\255\255\054\000\051\000\049\000\042\000\
    \082\000\255\255\255\255\255\255\255\255\031\000\041\000\037\000\
    \097\000\034\000\061\000\255\255\013\000\013\000\012\000\011\000\
    \010\000\053\000\007\000\006\000\009\000\005\000\045\000\002\000\
    \255\255\100\000\100\000\098\000\097\000\096\000\091\000\255\255\
    \255\255\255\255\255\255\255\255\087\000\077\000\078\000\255\255\
    \088\000\255\255\096\000\255\255\093\000\255\255\094\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\046\000\003\000\
    \255\255\255\255\255\255\040\000\008\000\255\255\255\255\255\255\
    \255\255\014\000\255\255\255\255\255\255\013\000\013\000\013\000\
    \014\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\025\000\025\000\025\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\092\000\026\000\
    \255\255\255\255\255\255\255\255\029\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\032\000\083\000\
    \039\000\043\000\255\255\255\255\089\000\084\000\255\255\058\000\
    \052\000\255\255\255\255\255\255\089\000\086\000\070\000\069\000\
    \255\255\255\255\255\255\072\000\255\255\255\255\255\255\064\000\
    \255\255\075\000\076\000\081\000\080\000\255\255\255\255\255\255\
    \255\255\012\000\255\255\012\000\012\000\255\255\012\000\012\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\008\000\008\000\255\255\255\255\005\000\005\000\
    \255\255\001\000\005\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\003\000\255\255\255\255\003\000\255\255\
    \255\255\255\255\002\000\255\255\255\255\001\000\255\255\255\255\
    \255\255\255\255\255\255";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\255\255\255\255\255\255\
    \255\255\094\000\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\255\255\255\255\
    \255\255\000\000\255\255\255\255\255\255\000\000\000\000\000\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\000\000\000\000\255\255\099\000\255\255\255\255\
    \255\255\000\000\000\000\000\000\255\255\255\255\255\255\000\000\
    \255\255\255\255\000\000\255\255\255\255\000\000\255\255\255\255\
    \000\000\000\000\120\000\255\255\255\255\255\255\000\000\255\255\
    \120\000\121\000\120\000\123\000\000\000\255\255\255\255\255\255\
    \255\255\255\255\000\000\000\000\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\000\000\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\255\255\000\000\000\000\000\000\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\159\000\000\000\
    \000\000\255\255\000\000\173\000\255\255\000\000\255\255\255\255\
    \000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\255\255\255\255\255\255\000\000\255\255\
    \255\255\000\000\255\255\255\255\000\000\255\255\191\000\000\000\
    \000\000\000\000\255\255\197\000\000\000\000\000\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\000\000\255\255\000\000\
    \255\255\210\000\000\000\255\255\000\000\000\000\255\255\255\255\
    \000\000\255\255\255\255\255\255\220\000\223\000\255\255\223\000\
    \255\255\255\255\000\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\039\000\040\000\040\000\039\000\041\000\067\000\049\000\
    \040\000\095\000\050\000\067\000\096\000\118\000\124\000\160\000\
    \119\000\125\000\189\000\174\000\160\000\226\000\175\000\189\000\
    \039\000\007\000\027\000\022\000\005\000\003\000\021\000\025\000\
    \019\000\018\000\023\000\006\000\017\000\016\000\015\000\024\000\
    \029\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\038\000\014\000\013\000\033\000\009\000\034\000\
    \004\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\012\000\042\000\011\000\004\000\037\000\
    \020\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\026\000\010\000\008\000\035\000\131\000\
    \142\000\129\000\070\000\052\000\056\000\069\000\068\000\039\000\
    \052\000\056\000\039\000\046\000\062\000\060\000\062\000\058\000\
    \046\000\058\000\060\000\062\000\058\000\044\000\073\000\145\000\
    \043\000\144\000\044\000\143\000\098\000\043\000\039\000\071\000\
    \097\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\087\000\087\000\103\000\106\000\109\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\146\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\112\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \002\000\043\000\005\000\116\000\043\000\043\000\043\000\005\000\
    \116\000\130\000\149\000\043\000\004\000\043\000\043\000\004\000\
    \004\000\004\000\095\000\147\000\118\000\096\000\004\000\119\000\
    \004\000\004\000\043\000\148\000\043\000\043\000\043\000\043\000\
    \043\000\118\000\169\000\124\000\119\000\004\000\125\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\168\000\178\000\255\255\
    \177\000\004\000\182\000\005\000\185\000\188\000\005\000\005\000\
    \005\000\123\000\219\000\220\000\066\000\005\000\043\000\005\000\
    \005\000\193\000\201\000\224\000\208\000\203\000\201\000\157\000\
    \174\000\004\000\201\000\175\000\005\000\203\000\005\000\005\000\
    \005\000\005\000\005\000\225\000\193\000\213\000\046\000\208\000\
    \215\000\046\000\046\000\046\000\043\000\201\000\043\000\000\000\
    \046\000\000\000\046\000\156\000\093\000\176\000\221\000\004\000\
    \213\000\004\000\193\000\215\000\000\000\194\000\074\000\046\000\
    \005\000\046\000\155\000\046\000\046\000\046\000\000\000\000\000\
    \000\000\052\000\222\000\222\000\052\000\052\000\052\000\000\000\
    \000\000\000\000\196\000\052\000\000\000\052\000\052\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\005\000\000\000\
    \005\000\057\000\052\000\046\000\052\000\153\000\052\000\052\000\
    \052\000\000\000\172\000\000\000\005\000\000\000\000\000\005\000\
    \005\000\005\000\000\000\000\000\087\000\087\000\005\000\000\000\
    \005\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\046\000\000\000\046\000\051\000\005\000\052\000\005\000\
    \005\000\005\000\005\000\005\000\195\000\000\000\000\000\005\000\
    \078\000\000\000\005\000\005\000\005\000\000\000\000\000\000\000\
    \000\000\005\000\000\000\005\000\005\000\000\000\000\000\213\000\
    \000\000\000\000\214\000\087\000\052\000\000\000\052\000\074\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\089\000\
    \079\000\089\000\077\000\000\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\000\000\005\000\
    \152\000\005\000\074\000\150\000\005\000\122\000\118\000\000\000\
    \000\000\119\000\005\000\000\000\000\000\005\000\005\000\005\000\
    \255\255\000\000\255\255\000\000\005\000\000\000\136\000\132\000\
    \134\000\000\000\000\000\000\000\122\000\000\000\121\000\255\255\
    \000\000\255\255\151\000\005\000\005\000\005\000\005\000\133\000\
    \005\000\005\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\000\000\074\000\255\255\005\000\
    \135\000\211\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\255\255\005\000\046\000\005\000\
    \192\000\046\000\046\000\046\000\000\000\000\000\000\000\000\000\
    \046\000\005\000\046\000\127\000\005\000\005\000\126\000\000\000\
    \255\255\255\255\000\000\005\000\000\000\005\000\005\000\046\000\
    \000\000\046\000\046\000\128\000\046\000\046\000\000\000\000\000\
    \000\000\000\000\005\000\000\000\005\000\005\000\005\000\005\000\
    \005\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\057\000\000\000\046\000\000\000\000\000\080\000\000\000\
    \000\000\000\000\000\000\000\000\074\000\115\000\005\000\000\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \081\000\046\000\000\000\046\000\115\000\116\000\080\000\116\000\
    \116\000\116\000\116\000\000\000\005\000\212\000\005\000\116\000\
    \000\000\116\000\116\000\000\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\116\000\088\000\
    \116\000\116\000\116\000\116\000\116\000\000\000\000\000\000\000\
    \058\000\000\000\000\000\058\000\058\000\058\000\000\000\000\000\
    \000\000\060\000\058\000\000\000\058\000\058\000\113\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\000\000\000\000\000\000\
    \117\000\058\000\116\000\058\000\058\000\058\000\058\000\058\000\
    \000\000\000\000\000\000\044\000\000\000\000\000\044\000\044\000\
    \044\000\000\000\000\000\000\000\111\000\044\000\000\000\044\000\
    \044\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \116\000\000\000\116\000\059\000\044\000\058\000\044\000\044\000\
    \110\000\044\000\044\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\000\000\058\000\090\000\058\000\065\000\000\000\
    \044\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\000\000\000\000\000\000\000\000\044\000\092\000\
    \044\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\081\000\091\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\000\000\080\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\078\000\000\000\000\000\081\000\000\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \000\000\000\000\000\000\000\000\028\000\000\000\000\000\000\000\
    \082\000\000\000\080\000\080\000\000\000\000\000\000\000\000\000\
    \000\000\079\000\078\000\077\000\000\000\083\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\084\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\028\000\000\000\000\000\
    \082\000\000\000\000\000\080\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\079\000\000\000\077\000\083\000\030\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\084\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\000\000\000\000\000\000\000\000\030\000\000\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\000\000\000\000\000\000\000\000\000\000\078\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\085\000\000\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\000\000\000\000\000\000\000\000\000\000\079\000\000\000\
    \077\000\000\000\000\000\000\000\000\000\000\000\000\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\000\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\031\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\000\000\000\000\000\000\000\000\031\000\000\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\000\000\000\000\000\000\000\000\078\000\000\000\
    \000\000\107\000\107\000\107\000\107\000\107\000\107\000\183\000\
    \183\000\183\000\183\000\183\000\183\000\183\000\183\000\183\000\
    \183\000\086\000\184\000\184\000\184\000\184\000\184\000\184\000\
    \184\000\184\000\184\000\184\000\000\000\000\000\079\000\000\000\
    \077\000\107\000\107\000\107\000\107\000\107\000\107\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\000\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\032\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\000\000\000\000\000\000\000\000\032\000\000\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\092\000\000\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\171\000\091\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\000\000\170\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\000\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\000\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\000\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\005\000\
    \000\000\000\000\005\000\005\000\005\000\000\000\000\000\000\000\
    \000\000\005\000\056\000\005\000\005\000\056\000\056\000\056\000\
    \000\000\000\000\000\000\000\000\056\000\000\000\056\000\056\000\
    \005\000\000\000\005\000\005\000\075\000\076\000\005\000\000\000\
    \000\000\000\000\000\000\056\000\000\000\056\000\056\000\056\000\
    \056\000\056\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\056\000\000\000\000\000\056\000\056\000\056\000\000\000\
    \000\000\000\000\074\000\056\000\005\000\056\000\056\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\055\000\000\000\056\000\
    \000\000\000\000\056\000\000\000\056\000\056\000\056\000\056\000\
    \056\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\005\000\000\000\005\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\056\000\000\000\056\000\
    \000\000\000\000\000\000\000\000\055\000\000\000\056\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\036\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \072\000\000\000\000\000\000\000\056\000\000\000\056\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\000\000\000\000\000\000\000\000\036\000\000\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\115\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \205\000\205\000\205\000\205\000\205\000\205\000\205\000\205\000\
    \205\000\205\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \115\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\000\000\000\000\000\000\000\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\000\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\036\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \072\000\000\000\000\000\000\000\000\000\000\000\000\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\000\000\000\000\000\000\000\000\036\000\000\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\000\000\122\000\118\000\000\000\000\000\119\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\122\000\000\000\121\000\160\000\000\000\000\000\161\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\000\000\165\000\000\000\000\000\000\000\
    \000\000\163\000\000\000\000\000\166\000\000\000\000\000\000\000\
    \000\000\167\000\000\000\000\000\000\000\000\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\000\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\000\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\049\000\000\000\
    \000\000\050\000\000\000\000\000\000\000\164\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\048\000\000\000\000\000\
    \005\000\043\000\005\000\000\000\000\000\000\000\045\000\046\000\
    \000\000\046\000\043\000\044\000\000\000\043\000\043\000\043\000\
    \000\000\000\000\000\000\000\000\043\000\000\000\043\000\043\000\
    \005\000\005\000\005\000\047\000\004\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\043\000\000\000\043\000\043\000\043\000\
    \043\000\043\000\000\000\000\000\000\000\000\000\000\000\044\000\
    \000\000\000\000\044\000\044\000\044\000\000\000\000\000\000\000\
    \000\000\044\000\004\000\044\000\044\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\066\000\000\000\043\000\
    \044\000\000\000\044\000\044\000\044\000\044\000\044\000\000\000\
    \000\000\000\000\058\000\000\000\000\000\058\000\058\000\058\000\
    \005\000\255\255\047\000\060\000\058\000\000\000\058\000\058\000\
    \000\000\000\000\000\000\000\000\000\000\043\000\000\000\043\000\
    \000\000\000\000\065\000\058\000\044\000\058\000\058\000\058\000\
    \058\000\058\000\162\000\000\000\000\000\046\000\000\000\000\000\
    \046\000\046\000\046\000\000\000\000\000\000\000\000\000\046\000\
    \000\000\046\000\046\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\044\000\000\000\044\000\059\000\046\000\058\000\
    \046\000\046\000\046\000\046\000\046\000\000\000\000\000\000\000\
    \056\000\000\000\000\000\056\000\056\000\056\000\000\000\000\000\
    \000\000\000\000\056\000\000\000\056\000\056\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\058\000\000\000\058\000\
    \057\000\056\000\046\000\056\000\056\000\056\000\056\000\056\000\
    \000\000\000\000\000\000\052\000\000\000\000\000\052\000\052\000\
    \052\000\000\000\000\000\000\000\000\000\052\000\000\000\052\000\
    \052\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \046\000\000\000\046\000\055\000\052\000\056\000\052\000\053\000\
    \052\000\052\000\052\000\000\000\000\000\000\000\052\000\000\000\
    \000\000\052\000\052\000\052\000\000\000\000\000\000\000\000\000\
    \052\000\000\000\052\000\052\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\056\000\000\000\056\000\051\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\000\000\000\000\
    \000\000\052\000\000\000\000\000\052\000\052\000\052\000\000\000\
    \000\000\000\000\000\000\052\000\000\000\052\000\052\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\052\000\000\000\
    \052\000\051\000\052\000\052\000\052\000\054\000\052\000\052\000\
    \052\000\000\000\000\000\000\000\052\000\000\000\000\000\052\000\
    \052\000\052\000\000\000\000\000\000\000\000\000\052\000\000\000\
    \052\000\052\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\052\000\000\000\052\000\051\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\000\000\000\000\000\000\056\000\
    \000\000\000\000\056\000\056\000\056\000\000\000\000\000\000\000\
    \000\000\056\000\000\000\056\000\056\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\052\000\000\000\052\000\051\000\
    \056\000\052\000\056\000\056\000\056\000\056\000\056\000\000\000\
    \000\000\000\000\058\000\000\000\000\000\058\000\058\000\058\000\
    \000\000\000\000\000\000\000\000\058\000\000\000\058\000\058\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\052\000\
    \000\000\052\000\055\000\058\000\056\000\058\000\058\000\058\000\
    \058\000\058\000\000\000\000\000\000\000\060\000\000\000\000\000\
    \060\000\060\000\060\000\000\000\000\000\000\000\000\000\060\000\
    \000\000\060\000\060\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\056\000\000\000\056\000\064\000\060\000\058\000\
    \060\000\060\000\060\000\060\000\060\000\000\000\000\000\000\000\
    \062\000\000\000\000\000\062\000\062\000\062\000\000\000\000\000\
    \000\000\000\000\062\000\000\000\062\000\062\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\058\000\000\000\058\000\
    \061\000\062\000\060\000\062\000\062\000\062\000\062\000\062\000\
    \000\000\000\000\000\000\000\000\071\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\000\000\
    \060\000\000\000\060\000\063\000\000\000\062\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \000\000\000\000\000\000\062\000\071\000\062\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \005\000\000\000\000\000\005\000\005\000\005\000\000\000\000\000\
    \000\000\000\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\000\000\000\000\000\000\000\000\005\000\000\000\005\000\
    \005\000\005\000\000\000\005\000\005\000\005\000\005\000\005\000\
    \000\000\000\000\000\000\000\000\005\000\000\000\005\000\005\000\
    \005\000\005\000\005\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\102\000\074\000\102\000\005\000\000\000\000\000\
    \000\000\102\000\000\000\000\000\000\000\000\000\074\000\000\000\
    \005\000\000\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\044\000\000\000\000\000\044\000\
    \044\000\044\000\000\000\005\000\000\000\005\000\044\000\000\000\
    \044\000\044\000\000\000\000\000\000\000\000\000\005\000\000\000\
    \005\000\000\000\000\000\000\000\000\000\044\000\000\000\044\000\
    \044\000\044\000\044\000\044\000\000\000\000\000\102\000\000\000\
    \000\000\000\000\000\000\000\000\102\000\116\000\000\000\116\000\
    \116\000\116\000\116\000\000\000\000\000\000\000\000\000\116\000\
    \102\000\116\000\116\000\000\000\102\000\000\000\102\000\065\000\
    \000\000\044\000\100\000\000\000\000\000\000\000\116\000\000\000\
    \116\000\116\000\116\000\116\000\116\000\000\000\000\000\000\000\
    \005\000\000\000\000\000\005\000\005\000\005\000\000\000\000\000\
    \000\000\000\000\005\000\000\000\005\000\005\000\000\000\044\000\
    \000\000\044\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \117\000\005\000\116\000\005\000\005\000\005\000\005\000\005\000\
    \000\000\000\000\000\000\046\000\000\000\000\000\046\000\046\000\
    \046\000\000\000\000\000\000\000\000\000\046\000\000\000\046\000\
    \046\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \116\000\000\000\116\000\074\000\046\000\005\000\046\000\046\000\
    \046\000\046\000\046\000\000\000\000\000\000\000\046\000\000\000\
    \000\000\046\000\046\000\046\000\000\000\000\000\000\000\000\000\
    \046\000\000\000\046\000\046\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\005\000\000\000\005\000\057\000\046\000\
    \046\000\046\000\046\000\046\000\046\000\046\000\000\000\000\000\
    \000\000\005\000\000\000\000\000\005\000\005\000\005\000\000\000\
    \000\000\000\000\000\000\005\000\000\000\005\000\140\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\000\000\046\000\000\000\
    \046\000\057\000\005\000\046\000\005\000\005\000\005\000\005\000\
    \005\000\000\000\000\000\000\000\005\000\000\000\000\000\005\000\
    \005\000\005\000\000\000\000\000\000\000\000\000\005\000\000\000\
    \005\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\046\000\000\000\046\000\074\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\005\000\000\000\005\000\074\000\
    \000\000\005\000\137\000\000\000\000\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\005\000\
    \000\000\005\000\000\000\138\000\000\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\135\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\135\000\000\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\000\000\000\000\000\000\000\000\135\000\
    \000\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\005\000\000\000\000\000\005\000\005\000\
    \005\000\000\000\000\000\000\000\000\000\005\000\000\000\005\000\
    \005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\005\000\000\000\005\000\005\000\
    \005\000\005\000\005\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\138\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\138\000\000\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\000\000\074\000\000\000\
    \005\000\139\000\000\000\000\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\005\000\000\000\
    \005\000\000\000\138\000\000\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\005\000\000\000\
    \000\000\005\000\005\000\005\000\000\000\000\000\000\000\000\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\000\000\
    \000\000\000\000\000\000\005\000\000\000\005\000\005\000\005\000\
    \000\000\005\000\005\000\141\000\005\000\005\000\000\000\000\000\
    \000\000\000\000\005\000\000\000\005\000\005\000\005\000\005\000\
    \005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \005\000\000\000\000\000\005\000\005\000\005\000\000\000\000\000\
    \000\000\074\000\005\000\005\000\005\000\005\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\074\000\000\000\005\000\000\000\
    \000\000\005\000\000\000\005\000\005\000\005\000\005\000\005\000\
    \000\000\000\000\000\000\052\000\000\000\000\000\052\000\052\000\
    \052\000\005\000\000\000\005\000\000\000\052\000\000\000\052\000\
    \052\000\000\000\000\000\000\000\005\000\000\000\005\000\000\000\
    \000\000\000\000\000\000\074\000\052\000\005\000\052\000\154\000\
    \052\000\052\000\052\000\000\000\000\000\000\000\052\000\000\000\
    \000\000\052\000\052\000\052\000\000\000\000\000\000\000\000\000\
    \052\000\000\000\052\000\052\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\005\000\000\000\005\000\051\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\000\000\000\000\
    \000\000\046\000\000\000\000\000\046\000\046\000\046\000\000\000\
    \000\000\000\000\000\000\046\000\000\000\046\000\046\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\052\000\000\000\
    \052\000\051\000\046\000\052\000\046\000\046\000\046\000\046\000\
    \046\000\000\000\000\000\000\000\046\000\000\000\000\000\046\000\
    \046\000\046\000\000\000\000\000\000\000\000\000\046\000\000\000\
    \046\000\046\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\052\000\000\000\052\000\057\000\046\000\046\000\046\000\
    \046\000\046\000\046\000\046\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\046\000\000\000\046\000\057\000\
    \171\000\046\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\181\000\170\000\181\000\046\000\
    \000\000\046\000\000\000\181\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\180\000\180\000\180\000\180\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\186\000\186\000\
    \186\000\186\000\186\000\186\000\186\000\186\000\186\000\186\000\
    \181\000\000\000\000\000\000\000\000\000\000\000\181\000\186\000\
    \186\000\186\000\186\000\186\000\186\000\000\000\000\000\000\000\
    \000\000\000\000\181\000\000\000\000\000\000\000\181\000\000\000\
    \181\000\000\000\000\000\000\000\179\000\187\000\187\000\187\000\
    \187\000\187\000\187\000\187\000\187\000\187\000\187\000\186\000\
    \186\000\186\000\186\000\186\000\186\000\000\000\187\000\187\000\
    \187\000\187\000\187\000\187\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\201\000\000\000\
    \000\000\202\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\187\000\187\000\
    \187\000\187\000\187\000\187\000\200\000\000\000\200\000\000\000\
    \000\000\000\000\000\000\200\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\199\000\199\000\199\000\199\000\
    \199\000\199\000\199\000\199\000\199\000\199\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\206\000\206\000\
    \206\000\206\000\206\000\206\000\206\000\206\000\206\000\206\000\
    \200\000\000\000\000\000\000\000\000\000\000\000\200\000\206\000\
    \206\000\206\000\206\000\206\000\206\000\000\000\000\000\000\000\
    \000\000\000\000\200\000\000\000\000\000\000\000\200\000\000\000\
    \200\000\000\000\000\000\000\000\198\000\207\000\207\000\207\000\
    \207\000\207\000\207\000\207\000\207\000\207\000\207\000\206\000\
    \206\000\206\000\206\000\206\000\206\000\000\000\207\000\207\000\
    \207\000\207\000\207\000\207\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\207\000\207\000\
    \207\000\207\000\207\000\207\000\217\000\000\000\217\000\217\000\
    \217\000\217\000\217\000\217\000\217\000\217\000\217\000\217\000\
    \217\000\217\000\217\000\217\000\217\000\217\000\217\000\217\000\
    \217\000\217\000\217\000\217\000\217\000\217\000\217\000\217\000\
    \000\000\217\000\216\000\217\000\217\000\217\000\217\000\217\000\
    \217\000\217\000\217\000\217\000\217\000\217\000\217\000\217\000\
    \217\000\217\000\217\000\217\000\217\000\217\000\217\000\217\000\
    \217\000\217\000\217\000\217\000\217\000\000\000\000\000\216\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\041\000\000\000\000\000\041\000\050\000\
    \067\000\096\000\050\000\067\000\096\000\119\000\125\000\161\000\
    \119\000\125\000\161\000\175\000\189\000\225\000\175\000\189\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\014\000\
    \012\000\015\000\038\000\051\000\055\000\038\000\038\000\039\000\
    \051\000\055\000\039\000\057\000\059\000\061\000\063\000\064\000\
    \057\000\059\000\061\000\063\000\064\000\065\000\072\000\012\000\
    \066\000\012\000\065\000\012\000\094\000\066\000\039\000\070\000\
    \095\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\082\000\082\000\102\000\105\000\108\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\111\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\003\000\074\000\117\000\003\000\003\000\003\000\074\000\
    \117\000\129\000\142\000\003\000\004\000\003\000\003\000\004\000\
    \004\000\004\000\025\000\143\000\120\000\025\000\004\000\120\000\
    \004\000\004\000\003\000\147\000\003\000\003\000\003\000\003\000\
    \003\000\121\000\166\000\123\000\121\000\004\000\123\000\004\000\
    \004\000\004\000\004\000\004\000\157\000\167\000\173\000\025\000\
    \174\000\157\000\181\000\005\000\184\000\187\000\005\000\005\000\
    \005\000\121\000\218\000\219\000\003\000\005\000\003\000\005\000\
    \005\000\194\000\202\000\222\000\194\000\202\000\201\000\004\000\
    \163\000\004\000\203\000\163\000\005\000\203\000\005\000\005\000\
    \005\000\005\000\005\000\224\000\208\000\214\000\006\000\208\000\
    \214\000\006\000\006\000\006\000\003\000\201\000\003\000\255\255\
    \006\000\255\255\006\000\006\000\025\000\163\000\220\000\004\000\
    \215\000\004\000\190\000\215\000\255\255\190\000\005\000\006\000\
    \005\000\006\000\006\000\006\000\006\000\006\000\255\255\255\255\
    \255\255\007\000\221\000\223\000\007\000\007\000\007\000\255\255\
    \255\255\255\255\190\000\007\000\255\255\007\000\007\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\005\000\255\255\
    \005\000\006\000\007\000\006\000\007\000\007\000\007\000\007\000\
    \007\000\255\255\163\000\255\255\009\000\255\255\255\255\009\000\
    \009\000\009\000\255\255\255\255\087\000\087\000\009\000\255\255\
    \009\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\006\000\255\255\006\000\007\000\009\000\007\000\009\000\
    \009\000\009\000\009\000\009\000\190\000\255\255\255\255\010\000\
    \087\000\255\255\010\000\010\000\010\000\255\255\255\255\255\255\
    \255\255\010\000\255\255\010\000\010\000\255\255\255\255\209\000\
    \255\255\255\255\209\000\087\000\007\000\255\255\007\000\009\000\
    \010\000\009\000\010\000\010\000\010\000\010\000\010\000\080\000\
    \087\000\080\000\087\000\255\255\080\000\080\000\080\000\080\000\
    \080\000\080\000\080\000\080\000\080\000\080\000\083\000\083\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\255\255\009\000\
    \009\000\009\000\010\000\010\000\010\000\122\000\122\000\255\255\
    \255\255\122\000\013\000\255\255\255\255\013\000\013\000\013\000\
    \025\000\255\255\120\000\255\255\013\000\255\255\013\000\013\000\
    \013\000\255\255\255\255\255\255\122\000\255\255\122\000\121\000\
    \255\255\123\000\010\000\013\000\010\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\255\255\013\000\163\000\013\000\
    \013\000\209\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\220\000\013\000\016\000\013\000\
    \190\000\016\000\016\000\016\000\255\255\255\255\255\255\255\255\
    \016\000\021\000\016\000\016\000\021\000\021\000\021\000\255\255\
    \221\000\223\000\255\255\021\000\255\255\021\000\021\000\016\000\
    \255\255\016\000\016\000\016\000\016\000\016\000\255\255\255\255\
    \255\255\255\255\021\000\255\255\021\000\021\000\021\000\021\000\
    \021\000\081\000\081\000\081\000\081\000\081\000\081\000\081\000\
    \081\000\081\000\081\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\016\000\255\255\016\000\255\255\255\255\081\000\255\255\
    \255\255\255\255\255\255\255\255\021\000\022\000\021\000\255\255\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \081\000\016\000\255\255\016\000\022\000\022\000\081\000\022\000\
    \022\000\022\000\022\000\255\255\021\000\209\000\021\000\022\000\
    \255\255\022\000\022\000\255\255\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\088\000\
    \022\000\022\000\022\000\022\000\022\000\255\255\255\255\255\255\
    \023\000\255\255\255\255\023\000\023\000\023\000\255\255\255\255\
    \255\255\023\000\023\000\255\255\023\000\023\000\023\000\255\255\
    \255\255\255\255\255\255\255\255\122\000\255\255\255\255\255\255\
    \022\000\023\000\022\000\023\000\023\000\023\000\023\000\023\000\
    \255\255\255\255\255\255\024\000\255\255\255\255\024\000\024\000\
    \024\000\255\255\255\255\255\255\024\000\024\000\255\255\024\000\
    \024\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \022\000\255\255\022\000\023\000\024\000\023\000\024\000\024\000\
    \024\000\024\000\024\000\084\000\084\000\084\000\084\000\084\000\
    \084\000\084\000\084\000\084\000\084\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\084\000\084\000\084\000\084\000\
    \084\000\084\000\255\255\023\000\026\000\023\000\024\000\255\255\
    \024\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\084\000\084\000\084\000\084\000\
    \084\000\084\000\255\255\255\255\255\255\255\255\024\000\026\000\
    \024\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\028\000\026\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\255\255\028\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\028\000\255\255\255\255\029\000\255\255\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \255\255\255\255\255\255\255\255\028\000\255\255\255\255\255\255\
    \029\000\255\255\028\000\029\000\255\255\255\255\255\255\255\255\
    \255\255\028\000\029\000\028\000\255\255\029\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\029\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\029\000\255\255\255\255\
    \029\000\255\255\255\255\029\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\029\000\255\255\029\000\029\000\030\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\029\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\255\255\255\255\255\255\255\255\030\000\255\255\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\085\000\085\000\085\000\085\000\085\000\
    \085\000\255\255\255\255\255\255\255\255\255\255\085\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\085\000\255\255\085\000\085\000\085\000\085\000\085\000\
    \085\000\255\255\255\255\255\255\255\255\255\255\085\000\255\255\
    \085\000\255\255\255\255\255\255\255\255\255\255\255\255\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\255\255\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\031\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\255\255\255\255\255\255\255\255\031\000\255\255\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\255\255\255\255\255\255\255\255\086\000\255\255\
    \255\255\100\000\100\000\100\000\100\000\100\000\100\000\180\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\180\000\180\000\
    \180\000\086\000\183\000\183\000\183\000\183\000\183\000\183\000\
    \183\000\183\000\183\000\183\000\255\255\255\255\086\000\255\255\
    \086\000\100\000\100\000\100\000\100\000\100\000\100\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\255\255\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\032\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\255\255\255\255\255\255\255\255\032\000\255\255\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\092\000\255\255\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
    \092\000\092\000\092\000\092\000\092\000\092\000\164\000\092\000\
    \164\000\164\000\164\000\164\000\164\000\164\000\164\000\164\000\
    \164\000\164\000\164\000\164\000\164\000\164\000\164\000\164\000\
    \164\000\164\000\164\000\164\000\164\000\164\000\164\000\164\000\
    \164\000\164\000\255\255\164\000\199\000\199\000\199\000\199\000\
    \199\000\199\000\199\000\199\000\199\000\199\000\255\255\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\255\255\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\255\255\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\033\000\
    \255\255\255\255\033\000\033\000\033\000\255\255\255\255\255\255\
    \255\255\033\000\034\000\033\000\033\000\034\000\034\000\034\000\
    \255\255\255\255\255\255\255\255\034\000\255\255\034\000\034\000\
    \033\000\255\255\033\000\033\000\033\000\033\000\033\000\255\255\
    \255\255\255\255\255\255\034\000\255\255\034\000\034\000\034\000\
    \034\000\034\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\035\000\255\255\255\255\035\000\035\000\035\000\255\255\
    \255\255\255\255\033\000\035\000\033\000\035\000\035\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\034\000\255\255\034\000\
    \255\255\255\255\035\000\255\255\035\000\035\000\035\000\035\000\
    \035\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\033\000\255\255\033\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\034\000\255\255\034\000\
    \255\255\255\255\255\255\255\255\035\000\255\255\035\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\036\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\255\255\255\255\255\255\035\000\255\255\035\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\255\255\255\255\255\255\255\255\036\000\255\255\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\115\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \115\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\107\000\107\000\107\000\107\000\107\000\107\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\255\255\255\255\255\255\255\255\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\255\255\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\037\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\255\255\255\255\255\255\255\255\255\255\255\255\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\255\255\255\255\255\255\255\255\037\000\255\255\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\255\255\114\000\114\000\255\255\255\255\114\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\114\000\255\255\114\000\158\000\255\255\255\255\158\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\255\255\158\000\255\255\255\255\255\255\
    \255\255\158\000\255\255\255\255\158\000\255\255\255\255\255\255\
    \255\255\158\000\255\255\255\255\255\255\255\255\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\255\255\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\255\255\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\042\000\255\255\
    \255\255\042\000\255\255\255\255\255\255\158\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\042\000\255\255\255\255\
    \042\000\042\000\042\000\255\255\255\255\255\255\042\000\042\000\
    \255\255\042\000\043\000\042\000\255\255\043\000\043\000\043\000\
    \255\255\255\255\255\255\255\255\043\000\255\255\043\000\043\000\
    \042\000\042\000\042\000\042\000\042\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\043\000\255\255\043\000\043\000\043\000\
    \043\000\043\000\255\255\255\255\255\255\255\255\255\255\044\000\
    \255\255\255\255\044\000\044\000\044\000\255\255\255\255\255\255\
    \255\255\044\000\042\000\044\000\044\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\043\000\255\255\043\000\
    \044\000\255\255\044\000\044\000\044\000\044\000\044\000\255\255\
    \255\255\255\255\045\000\255\255\255\255\045\000\045\000\045\000\
    \042\000\114\000\042\000\045\000\045\000\255\255\045\000\045\000\
    \255\255\255\255\255\255\255\255\255\255\043\000\255\255\043\000\
    \255\255\255\255\044\000\045\000\044\000\045\000\045\000\045\000\
    \045\000\045\000\158\000\255\255\255\255\046\000\255\255\255\255\
    \046\000\046\000\046\000\255\255\255\255\255\255\255\255\046\000\
    \255\255\046\000\046\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\044\000\255\255\044\000\045\000\046\000\045\000\
    \046\000\046\000\046\000\046\000\046\000\255\255\255\255\255\255\
    \047\000\255\255\255\255\047\000\047\000\047\000\255\255\255\255\
    \255\255\255\255\047\000\255\255\047\000\047\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\045\000\255\255\045\000\
    \046\000\047\000\046\000\047\000\047\000\047\000\047\000\047\000\
    \255\255\255\255\255\255\048\000\255\255\255\255\048\000\048\000\
    \048\000\255\255\255\255\255\255\255\255\048\000\255\255\048\000\
    \048\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \046\000\255\255\046\000\047\000\048\000\047\000\048\000\048\000\
    \048\000\048\000\048\000\255\255\255\255\255\255\052\000\255\255\
    \255\255\052\000\052\000\052\000\255\255\255\255\255\255\255\255\
    \052\000\255\255\052\000\052\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\047\000\255\255\047\000\048\000\052\000\
    \048\000\052\000\052\000\052\000\052\000\052\000\255\255\255\255\
    \255\255\053\000\255\255\255\255\053\000\053\000\053\000\255\255\
    \255\255\255\255\255\255\053\000\255\255\053\000\053\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\048\000\255\255\
    \048\000\052\000\053\000\052\000\053\000\053\000\053\000\053\000\
    \053\000\255\255\255\255\255\255\054\000\255\255\255\255\054\000\
    \054\000\054\000\255\255\255\255\255\255\255\255\054\000\255\255\
    \054\000\054\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\052\000\255\255\052\000\053\000\054\000\053\000\054\000\
    \054\000\054\000\054\000\054\000\255\255\255\255\255\255\056\000\
    \255\255\255\255\056\000\056\000\056\000\255\255\255\255\255\255\
    \255\255\056\000\255\255\056\000\056\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\053\000\255\255\053\000\054\000\
    \056\000\054\000\056\000\056\000\056\000\056\000\056\000\255\255\
    \255\255\255\255\058\000\255\255\255\255\058\000\058\000\058\000\
    \255\255\255\255\255\255\255\255\058\000\255\255\058\000\058\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\054\000\
    \255\255\054\000\056\000\058\000\056\000\058\000\058\000\058\000\
    \058\000\058\000\255\255\255\255\255\255\060\000\255\255\255\255\
    \060\000\060\000\060\000\255\255\255\255\255\255\255\255\060\000\
    \255\255\060\000\060\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\056\000\255\255\056\000\058\000\060\000\058\000\
    \060\000\060\000\060\000\060\000\060\000\255\255\255\255\255\255\
    \062\000\255\255\255\255\062\000\062\000\062\000\255\255\255\255\
    \255\255\255\255\062\000\255\255\062\000\062\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\058\000\255\255\058\000\
    \060\000\062\000\060\000\062\000\062\000\062\000\062\000\062\000\
    \255\255\255\255\255\255\255\255\071\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\255\255\
    \060\000\255\255\060\000\062\000\255\255\062\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \255\255\255\255\255\255\062\000\071\000\062\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\071\000\071\000\
    \075\000\255\255\255\255\075\000\075\000\075\000\255\255\255\255\
    \255\255\255\255\075\000\076\000\075\000\075\000\076\000\076\000\
    \076\000\255\255\255\255\255\255\255\255\076\000\255\255\076\000\
    \076\000\075\000\255\255\075\000\075\000\075\000\075\000\075\000\
    \255\255\255\255\255\255\255\255\076\000\255\255\076\000\076\000\
    \076\000\076\000\076\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\093\000\075\000\093\000\075\000\255\255\255\255\
    \255\255\093\000\255\255\255\255\255\255\255\255\076\000\255\255\
    \076\000\255\255\093\000\093\000\093\000\093\000\093\000\093\000\
    \093\000\093\000\093\000\093\000\110\000\255\255\255\255\110\000\
    \110\000\110\000\255\255\075\000\255\255\075\000\110\000\255\255\
    \110\000\110\000\255\255\255\255\255\255\255\255\076\000\255\255\
    \076\000\255\255\255\255\255\255\255\255\110\000\255\255\110\000\
    \110\000\110\000\110\000\110\000\255\255\255\255\093\000\255\255\
    \255\255\255\255\255\255\255\255\093\000\116\000\255\255\116\000\
    \116\000\116\000\116\000\255\255\255\255\255\255\255\255\116\000\
    \093\000\116\000\116\000\255\255\093\000\255\255\093\000\110\000\
    \255\255\110\000\093\000\255\255\255\255\255\255\116\000\255\255\
    \116\000\116\000\116\000\116\000\116\000\255\255\255\255\255\255\
    \126\000\255\255\255\255\126\000\126\000\126\000\255\255\255\255\
    \255\255\255\255\126\000\255\255\126\000\126\000\255\255\110\000\
    \255\255\110\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \116\000\126\000\116\000\126\000\126\000\126\000\126\000\126\000\
    \255\255\255\255\255\255\127\000\255\255\255\255\127\000\127\000\
    \127\000\255\255\255\255\255\255\255\255\127\000\255\255\127\000\
    \127\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \116\000\255\255\116\000\126\000\127\000\126\000\127\000\127\000\
    \127\000\127\000\127\000\255\255\255\255\255\255\128\000\255\255\
    \255\255\128\000\128\000\128\000\255\255\255\255\255\255\255\255\
    \128\000\255\255\128\000\128\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\126\000\255\255\126\000\127\000\128\000\
    \127\000\128\000\128\000\128\000\128\000\128\000\255\255\255\255\
    \255\255\132\000\255\255\255\255\132\000\132\000\132\000\255\255\
    \255\255\255\255\255\255\132\000\255\255\132\000\132\000\255\255\
    \255\255\255\255\093\000\255\255\255\255\255\255\127\000\255\255\
    \127\000\128\000\132\000\128\000\132\000\132\000\132\000\132\000\
    \132\000\255\255\255\255\255\255\133\000\255\255\255\255\133\000\
    \133\000\133\000\255\255\255\255\255\255\255\255\133\000\255\255\
    \133\000\133\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\128\000\255\255\128\000\132\000\133\000\132\000\133\000\
    \133\000\133\000\133\000\133\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\132\000\255\255\132\000\133\000\
    \255\255\133\000\134\000\255\255\255\255\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\133\000\
    \255\255\133\000\255\255\134\000\255\255\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\134\000\
    \134\000\134\000\134\000\134\000\134\000\134\000\134\000\135\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\135\000\255\255\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\255\255\255\255\255\255\255\255\135\000\
    \255\255\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\136\000\255\255\255\255\136\000\136\000\
    \136\000\255\255\255\255\255\255\255\255\136\000\255\255\136\000\
    \136\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\136\000\255\255\136\000\136\000\
    \136\000\136\000\136\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\138\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\138\000\255\255\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\255\255\136\000\255\255\
    \136\000\138\000\255\255\255\255\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\136\000\255\255\
    \136\000\255\255\138\000\255\255\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\140\000\255\255\
    \255\255\140\000\140\000\140\000\255\255\255\255\255\255\255\255\
    \140\000\141\000\140\000\140\000\141\000\141\000\141\000\255\255\
    \255\255\255\255\255\255\141\000\255\255\141\000\141\000\140\000\
    \255\255\140\000\140\000\140\000\140\000\140\000\255\255\255\255\
    \255\255\255\255\141\000\255\255\141\000\141\000\141\000\141\000\
    \141\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \151\000\255\255\255\255\151\000\151\000\151\000\255\255\255\255\
    \255\255\140\000\151\000\140\000\151\000\151\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\141\000\255\255\141\000\255\255\
    \255\255\151\000\255\255\151\000\151\000\151\000\151\000\151\000\
    \255\255\255\255\255\255\153\000\255\255\255\255\153\000\153\000\
    \153\000\140\000\255\255\140\000\255\255\153\000\255\255\153\000\
    \153\000\255\255\255\255\255\255\141\000\255\255\141\000\255\255\
    \255\255\255\255\255\255\151\000\153\000\151\000\153\000\153\000\
    \153\000\153\000\153\000\255\255\255\255\255\255\154\000\255\255\
    \255\255\154\000\154\000\154\000\255\255\255\255\255\255\255\255\
    \154\000\255\255\154\000\154\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\151\000\255\255\151\000\153\000\154\000\
    \153\000\154\000\154\000\154\000\154\000\154\000\255\255\255\255\
    \255\255\155\000\255\255\255\255\155\000\155\000\155\000\255\255\
    \255\255\255\255\255\255\155\000\255\255\155\000\155\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\153\000\255\255\
    \153\000\154\000\155\000\154\000\155\000\155\000\155\000\155\000\
    \155\000\255\255\255\255\255\255\156\000\255\255\255\255\156\000\
    \156\000\156\000\255\255\255\255\255\255\255\255\156\000\255\255\
    \156\000\156\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\154\000\255\255\154\000\155\000\156\000\155\000\156\000\
    \156\000\156\000\156\000\156\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\155\000\255\255\155\000\156\000\
    \171\000\156\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\172\000\171\000\172\000\156\000\
    \255\255\156\000\255\255\172\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\172\000\172\000\172\000\172\000\
    \172\000\172\000\172\000\172\000\172\000\172\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\179\000\179\000\
    \179\000\179\000\179\000\179\000\179\000\179\000\179\000\179\000\
    \172\000\255\255\255\255\255\255\255\255\255\255\172\000\179\000\
    \179\000\179\000\179\000\179\000\179\000\255\255\255\255\255\255\
    \255\255\255\255\172\000\255\255\255\255\255\255\172\000\255\255\
    \172\000\255\255\255\255\255\255\172\000\186\000\186\000\186\000\
    \186\000\186\000\186\000\186\000\186\000\186\000\186\000\179\000\
    \179\000\179\000\179\000\179\000\179\000\255\255\186\000\186\000\
    \186\000\186\000\186\000\186\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\195\000\255\255\
    \255\255\195\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\186\000\186\000\
    \186\000\186\000\186\000\186\000\195\000\255\255\195\000\255\255\
    \255\255\255\255\255\255\195\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\195\000\195\000\195\000\195\000\
    \195\000\195\000\195\000\195\000\195\000\195\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\198\000\198\000\
    \198\000\198\000\198\000\198\000\198\000\198\000\198\000\198\000\
    \195\000\255\255\255\255\255\255\255\255\255\255\195\000\198\000\
    \198\000\198\000\198\000\198\000\198\000\255\255\255\255\255\255\
    \255\255\255\255\195\000\255\255\255\255\255\255\195\000\255\255\
    \195\000\255\255\255\255\255\255\195\000\206\000\206\000\206\000\
    \206\000\206\000\206\000\206\000\206\000\206\000\206\000\198\000\
    \198\000\198\000\198\000\198\000\198\000\255\255\206\000\206\000\
    \206\000\206\000\206\000\206\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\206\000\206\000\
    \206\000\206\000\206\000\206\000\211\000\255\255\211\000\211\000\
    \211\000\211\000\211\000\211\000\211\000\211\000\211\000\211\000\
    \211\000\211\000\211\000\211\000\211\000\211\000\211\000\211\000\
    \211\000\211\000\211\000\211\000\211\000\211\000\211\000\211\000\
    \255\255\217\000\211\000\217\000\217\000\217\000\217\000\217\000\
    \217\000\217\000\217\000\217\000\217\000\217\000\217\000\217\000\
    \217\000\217\000\217\000\217\000\217\000\217\000\217\000\217\000\
    \217\000\217\000\217\000\217\000\217\000\255\255\255\255\217\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\195\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255";
  Lexing.lex_base_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\010\000\036\000\000\000\000\000\012\000\000\000\
    \000\000\000\000\002\000\000\000\027\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\002\000\004\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
  Lexing.lex_backtrk_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\039\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
  Lexing.lex_default_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\019\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
  Lexing.lex_trans_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\000\000\036\000\036\000\000\000\036\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\000\000\000\000\001\000\022\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\007\000\001\000\000\000\000\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\001\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check_code = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\022\000\121\000\195\000\202\000\121\000\203\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \022\000\255\255\121\000\000\000\122\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\114\000\115\000\255\255\255\255\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\115\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \121\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_code = 
   "\255\004\255\255\005\255\255\007\255\006\255\255\003\255\000\004\
    \001\005\255\007\255\255\006\255\007\255\255\000\004\001\005\003\
    \006\002\007\255\001\255\255\000\001\255";
}

let rec token lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 8 (-1) ;   __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 325 "src/reason_lexer.mll"
                 (
      match !preprocessor with
      | None ->
        raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf))
      | Some _ ->
        update_loc lexbuf None 1 false 0;
        token lexbuf )
# 1553 "src/reason_lexer.ml"

  | 1 ->
# 334 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        match !preprocessor with
        | None -> token lexbuf
        | Some _ -> EOL
      )
# 1562 "src/reason_lexer.ml"

  | 2 ->
# 340 "src/reason_lexer.mll"
      ( token lexbuf )
# 1567 "src/reason_lexer.ml"

  | 3 ->
# 342 "src/reason_lexer.mll"
      (
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 2 (String.length delim - 2) in
        COLONCOLONLIDENT delim
      )
# 1576 "src/reason_lexer.ml"

  | 4 ->
# 348 "src/reason_lexer.mll"
      (
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 0 (String.length delim - 2) in
        LIDENTCOLONCOLON delim
      )
# 1585 "src/reason_lexer.ml"

  | 5 ->
# 354 "src/reason_lexer.mll"
      ( UNDERSCORE )
# 1590 "src/reason_lexer.ml"

  | 6 ->
# 356 "src/reason_lexer.mll"
      ( TILDE )
# 1595 "src/reason_lexer.ml"

  | 7 ->
# 358 "src/reason_lexer.mll"
      ( QUESTION )
# 1600 "src/reason_lexer.ml"

  | 8 ->
# 361 "src/reason_lexer.mll"
      ( OPTIONAL_NO_DEFAULT )
# 1605 "src/reason_lexer.ml"

  | 9 ->
# 363 "src/reason_lexer.mll"
      ( let s = Lexing.lexeme lexbuf in
        try Hashtbl.find keyword_table s
        with Not_found -> LIDENT s )
# 1612 "src/reason_lexer.ml"

  | 10 ->
# 367 "src/reason_lexer.mll"
      ( warn_latin1 lexbuf; LIDENT (Lexing.lexeme lexbuf) )
# 1617 "src/reason_lexer.ml"

  | 11 ->
# 369 "src/reason_lexer.mll"
      ( UIDENT(Lexing.lexeme lexbuf) )
# 1622 "src/reason_lexer.ml"

  | 12 ->
# 371 "src/reason_lexer.mll"
      ( warn_latin1 lexbuf; UIDENT(Lexing.lexeme lexbuf) )
# 1627 "src/reason_lexer.ml"

  | 13 ->
# 373 "src/reason_lexer.mll"
      ( try
          INT (cvt_int_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "int", Location.curr lexbuf))
      )
# 1636 "src/reason_lexer.ml"

  | 14 ->
# 379 "src/reason_lexer.mll"
      ( FLOAT (remove_underscores(Lexing.lexeme lexbuf)) )
# 1641 "src/reason_lexer.ml"

  | 15 ->
# 381 "src/reason_lexer.mll"
      ( try
          INT32 (cvt_int32_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "int32", Location.curr lexbuf)) )
# 1649 "src/reason_lexer.ml"

  | 16 ->
# 386 "src/reason_lexer.mll"
      ( try
          INT64 (cvt_int64_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "int64", Location.curr lexbuf)) )
# 1657 "src/reason_lexer.ml"

  | 17 ->
# 391 "src/reason_lexer.mll"
      ( try
          NATIVEINT (cvt_nativeint_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "nativeint", Location.curr lexbuf)) )
# 1665 "src/reason_lexer.ml"

  | 18 ->
# 396 "src/reason_lexer.mll"
      ( reset_string_buffer();
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        string lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), None) )
# 1677 "src/reason_lexer.ml"

  | 19 ->
# 405 "src/reason_lexer.mll"
      ( reset_string_buffer();
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        quoted_string delim lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), Some delim) )
# 1691 "src/reason_lexer.ml"

  | 20 ->
# 416 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 1;
        CHAR (Lexing.lexeme_char lexbuf 1) )
# 1697 "src/reason_lexer.ml"

  | 21 ->
# 419 "src/reason_lexer.mll"
      ( CHAR(Lexing.lexeme_char lexbuf 1) )
# 1702 "src/reason_lexer.ml"

  | 22 ->
# 421 "src/reason_lexer.mll"
      ( CHAR(char_for_backslash (Lexing.lexeme_char lexbuf 2)) )
# 1707 "src/reason_lexer.ml"

  | 23 ->
# 423 "src/reason_lexer.mll"
      ( CHAR(char_for_decimal_code lexbuf 2) )
# 1712 "src/reason_lexer.ml"

  | 24 ->
# 425 "src/reason_lexer.mll"
      ( CHAR(char_for_hexadecimal_code lexbuf 3) )
# 1717 "src/reason_lexer.ml"

  | 25 ->
# 427 "src/reason_lexer.mll"
      ( let l = Lexing.lexeme lexbuf in
        let esc = String.sub l 1 (String.length l - 1) in
        raise (Error(Illegal_escape esc, Location.curr lexbuf))
      )
# 1725 "src/reason_lexer.ml"

  | 26 ->
# 432 "src/reason_lexer.mll"
      ( let start_loc = Location.curr lexbuf  in
        comment_start_loc := [start_loc];
        reset_string_buffer ();
        let end_loc = comment lexbuf in
        let s = get_stored_string () in
        reset_string_buffer ();
        COMMENT (s, { start_loc with
                      Location.loc_end = end_loc.Location.loc_end })
      )
# 1738 "src/reason_lexer.ml"

  | 27 ->
# 442 "src/reason_lexer.mll"
      ( let loc = Location.curr lexbuf  in
        if !print_warnings then
          Location.prerr_warning loc Warnings.Comment_start;
        comment_start_loc := [loc];
        reset_string_buffer ();
        let end_loc = comment lexbuf in
        let s = get_stored_string () in
        reset_string_buffer ();
        COMMENT (s, { loc with Location.loc_end = end_loc.Location.loc_end })
      )
# 1752 "src/reason_lexer.ml"

  | 28 ->
# 453 "src/reason_lexer.mll"
      ( let loc = Location.curr lexbuf in
        Location.prerr_warning loc Warnings.Comment_not_end;
        lexbuf.Lexing.lex_curr_pos <- lexbuf.Lexing.lex_curr_pos - 1;
        let curpos = lexbuf.lex_curr_p in
        lexbuf.lex_curr_p <- { curpos with pos_cnum = curpos.pos_cnum - 1 };
        STAR
      )
# 1763 "src/reason_lexer.ml"

  | 29 ->
# 461 "src/reason_lexer.mll"
      ( SHARPOP(Lexing.lexeme lexbuf) )
# 1768 "src/reason_lexer.ml"

  | 30 ->
let
# 462 "src/reason_lexer.mll"
                                   num
# 1774 "src/reason_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_mem.(1)
and
# 463 "src/reason_lexer.mll"
                                           name
# 1779 "src/reason_lexer.ml"
= Lexing.sub_lexeme_opt lexbuf lexbuf.Lexing.lex_mem.(3) lexbuf.Lexing.lex_mem.(2) in
# 465 "src/reason_lexer.mll"
      ( update_loc lexbuf name (int_of_string num) true 0;
        token lexbuf
      )
# 1785 "src/reason_lexer.ml"

  | 31 ->
# 468 "src/reason_lexer.mll"
         ( AMPERSAND )
# 1790 "src/reason_lexer.ml"

  | 32 ->
# 469 "src/reason_lexer.mll"
         ( AMPERAMPER )
# 1795 "src/reason_lexer.ml"

  | 33 ->
# 470 "src/reason_lexer.mll"
         ( BACKQUOTE )
# 1800 "src/reason_lexer.ml"

  | 34 ->
# 471 "src/reason_lexer.mll"
         ( QUOTE )
# 1805 "src/reason_lexer.ml"

  | 35 ->
# 472 "src/reason_lexer.mll"
         ( LPAREN )
# 1810 "src/reason_lexer.ml"

  | 36 ->
# 473 "src/reason_lexer.mll"
         ( RPAREN )
# 1815 "src/reason_lexer.ml"

  | 37 ->
# 474 "src/reason_lexer.mll"
         ( STAR )
# 1820 "src/reason_lexer.ml"

  | 38 ->
# 475 "src/reason_lexer.mll"
         ( COMMA )
# 1825 "src/reason_lexer.ml"

  | 39 ->
# 476 "src/reason_lexer.mll"
         ( MINUSGREATER )
# 1830 "src/reason_lexer.ml"

  | 40 ->
# 477 "src/reason_lexer.mll"
         ( EQUALGREATER )
# 1835 "src/reason_lexer.ml"

  | 41 ->
# 478 "src/reason_lexer.mll"
         ( SHARP )
# 1840 "src/reason_lexer.ml"

  | 42 ->
# 479 "src/reason_lexer.mll"
         ( DOT )
# 1845 "src/reason_lexer.ml"

  | 43 ->
# 480 "src/reason_lexer.mll"
         ( DOTDOT )
# 1850 "src/reason_lexer.ml"

  | 44 ->
# 481 "src/reason_lexer.mll"
         ( DOTDOTDOT )
# 1855 "src/reason_lexer.ml"

  | 45 ->
# 482 "src/reason_lexer.mll"
         ( COLON )
# 1860 "src/reason_lexer.ml"

  | 46 ->
# 483 "src/reason_lexer.mll"
         ( COLONCOLON )
# 1865 "src/reason_lexer.ml"

  | 47 ->
# 484 "src/reason_lexer.mll"
         ( COLONEQUAL )
# 1870 "src/reason_lexer.ml"

  | 48 ->
# 485 "src/reason_lexer.mll"
         ( COLONGREATER )
# 1875 "src/reason_lexer.ml"

  | 49 ->
# 486 "src/reason_lexer.mll"
         ( SEMI )
# 1880 "src/reason_lexer.ml"

  | 50 ->
# 487 "src/reason_lexer.mll"
         ( SEMISEMI )
# 1885 "src/reason_lexer.ml"

  | 51 ->
# 488 "src/reason_lexer.mll"
         ( LESS )
# 1890 "src/reason_lexer.ml"

  | 52 ->
# 489 "src/reason_lexer.mll"
         ( LESSMINUS )
# 1895 "src/reason_lexer.ml"

  | 53 ->
# 490 "src/reason_lexer.mll"
         ( EQUAL )
# 1900 "src/reason_lexer.ml"

  | 54 ->
# 491 "src/reason_lexer.mll"
         ( LBRACKET )
# 1905 "src/reason_lexer.ml"

  | 55 ->
# 492 "src/reason_lexer.mll"
         ( LBRACKETBAR )
# 1910 "src/reason_lexer.ml"

  | 56 ->
# 493 "src/reason_lexer.mll"
         ( LBRACKETLESS )
# 1915 "src/reason_lexer.ml"

  | 57 ->
# 494 "src/reason_lexer.mll"
         ( LBRACKETGREATER )
# 1920 "src/reason_lexer.ml"

  | 58 ->
# 495 "src/reason_lexer.mll"
                                                   (
    let buf = Lexing.lexeme lexbuf in
    LESSIDENT (String.sub buf 1 (String.length buf - 1))
  )
# 1928 "src/reason_lexer.ml"

  | 59 ->
# 499 "src/reason_lexer.mll"
                                                        (
    let buf = Lexing.lexeme lexbuf in
    LESSSLASHIDENTGREATER (String.sub buf 2 (String.length buf - 2 - 1))
  )
# 1936 "src/reason_lexer.ml"

  | 60 ->
# 503 "src/reason_lexer.mll"
         ( RBRACKET )
# 1941 "src/reason_lexer.ml"

  | 61 ->
# 504 "src/reason_lexer.mll"
         ( LBRACE )
# 1946 "src/reason_lexer.ml"

  | 62 ->
# 505 "src/reason_lexer.mll"
         ( LBRACELESS )
# 1951 "src/reason_lexer.ml"

  | 63 ->
# 506 "src/reason_lexer.mll"
         ( BAR )
# 1956 "src/reason_lexer.ml"

  | 64 ->
# 507 "src/reason_lexer.mll"
         ( BARBAR )
# 1961 "src/reason_lexer.ml"

  | 65 ->
# 508 "src/reason_lexer.mll"
         ( BARRBRACKET )
# 1966 "src/reason_lexer.ml"

  | 66 ->
# 509 "src/reason_lexer.mll"
         ( GREATER )
# 1971 "src/reason_lexer.ml"

  | 67 ->
# 515 "src/reason_lexer.mll"
         ( RBRACE )
# 1976 "src/reason_lexer.ml"

  | 68 ->
# 516 "src/reason_lexer.mll"
         ( GREATERRBRACE )
# 1981 "src/reason_lexer.ml"

  | 69 ->
# 517 "src/reason_lexer.mll"
         ( LBRACKETAT )
# 1986 "src/reason_lexer.ml"

  | 70 ->
# 518 "src/reason_lexer.mll"
         ( LBRACKETPERCENT )
# 1991 "src/reason_lexer.ml"

  | 71 ->
# 519 "src/reason_lexer.mll"
          ( LBRACKETPERCENTPERCENT )
# 1996 "src/reason_lexer.ml"

  | 72 ->
# 520 "src/reason_lexer.mll"
          ( LBRACKETATAT )
# 2001 "src/reason_lexer.ml"

  | 73 ->
# 521 "src/reason_lexer.mll"
           ( LBRACKETATATAT )
# 2006 "src/reason_lexer.ml"

  | 74 ->
# 522 "src/reason_lexer.mll"
         ( BANG )
# 2011 "src/reason_lexer.ml"

  | 75 ->
# 523 "src/reason_lexer.mll"
         ( INFIXOP0 "!=" )
# 2016 "src/reason_lexer.ml"

  | 76 ->
# 524 "src/reason_lexer.mll"
          ( INFIXOP0 "!==" )
# 2021 "src/reason_lexer.ml"

  | 77 ->
# 525 "src/reason_lexer.mll"
           ( INFIXOP0 "!=" )
# 2026 "src/reason_lexer.ml"

  | 78 ->
# 526 "src/reason_lexer.mll"
            ( INFIXOP0 "!==" )
# 2031 "src/reason_lexer.ml"

  | 79 ->
# 527 "src/reason_lexer.mll"
         ( PLUS )
# 2036 "src/reason_lexer.ml"

  | 80 ->
# 528 "src/reason_lexer.mll"
         ( PLUSDOT )
# 2041 "src/reason_lexer.ml"

  | 81 ->
# 529 "src/reason_lexer.mll"
         ( PLUSEQ )
# 2046 "src/reason_lexer.ml"

  | 82 ->
# 530 "src/reason_lexer.mll"
         ( MINUS )
# 2051 "src/reason_lexer.ml"

  | 83 ->
# 531 "src/reason_lexer.mll"
         ( MINUSDOT )
# 2056 "src/reason_lexer.ml"

  | 84 ->
# 532 "src/reason_lexer.mll"
         ( LESSGREATER )
# 2061 "src/reason_lexer.ml"

  | 85 ->
# 533 "src/reason_lexer.mll"
          ( LESSSLASHGREATER )
# 2066 "src/reason_lexer.ml"

  | 86 ->
# 534 "src/reason_lexer.mll"
           ( LESSDOTDOTGREATER )
# 2071 "src/reason_lexer.ml"

  | 87 ->
# 536 "src/reason_lexer.mll"
            ( PREFIXOP(Lexing.lexeme lexbuf) )
# 2076 "src/reason_lexer.ml"

  | 88 ->
# 538 "src/reason_lexer.mll"
            ( PREFIXOP(Lexing.lexeme lexbuf) )
# 2081 "src/reason_lexer.ml"

  | 89 ->
# 540 "src/reason_lexer.mll"
            ( INFIXOP0(Lexing.lexeme lexbuf) )
# 2086 "src/reason_lexer.ml"

  | 90 ->
# 542 "src/reason_lexer.mll"
            ( INFIXOP1(Lexing.lexeme lexbuf) )
# 2091 "src/reason_lexer.ml"

  | 91 ->
# 544 "src/reason_lexer.mll"
            ( INFIXOP2(Lexing.lexeme lexbuf) )
# 2096 "src/reason_lexer.ml"

  | 92 ->
# 546 "src/reason_lexer.mll"
         ( SLASHGREATER )
# 2101 "src/reason_lexer.ml"

  | 93 ->
# 557 "src/reason_lexer.mll"
            ( INFIXOP4(Lexing.lexeme lexbuf))
# 2106 "src/reason_lexer.ml"

  | 94 ->
# 559 "src/reason_lexer.mll"
            ( INFIXOP4(Lexing.lexeme lexbuf))
# 2111 "src/reason_lexer.ml"

  | 95 ->
# 560 "src/reason_lexer.mll"
            ( PERCENT )
# 2116 "src/reason_lexer.ml"

  | 96 ->
# 562 "src/reason_lexer.mll"
            ( INFIXOP3(Lexing.lexeme lexbuf) )
# 2121 "src/reason_lexer.ml"

  | 97 ->
# 564 "src/reason_lexer.mll"
            ( INFIXOP3(Lexing.lexeme lexbuf))
# 2126 "src/reason_lexer.ml"

  | 98 ->
# 566 "src/reason_lexer.mll"
            ( INFIXOP3(Lexing.lexeme lexbuf) )
# 2131 "src/reason_lexer.ml"

  | 99 ->
# 567 "src/reason_lexer.mll"
        ( EOF )
# 2136 "src/reason_lexer.ml"

  | 100 ->
# 569 "src/reason_lexer.mll"
      ( raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf))
      )
# 2143 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and comment lexbuf =
    __ocaml_lex_comment_rec lexbuf 158
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 575 "src/reason_lexer.mll"
      ( comment_start_loc := (Location.curr lexbuf) :: !comment_start_loc;
        store_lexeme lexbuf;
        comment lexbuf;
      )
# 2158 "src/reason_lexer.ml"

  | 1 ->
# 580 "src/reason_lexer.mll"
      ( match !comment_start_loc with
        | [] -> assert false
        | [_] -> comment_start_loc := []; Location.curr lexbuf
        | _ :: l -> comment_start_loc := l;
                  store_lexeme lexbuf;
                  comment lexbuf;
       )
# 2169 "src/reason_lexer.ml"

  | 2 ->
# 588 "src/reason_lexer.mll"
      (
        string_start_loc := Location.curr lexbuf;
        store_string_char '"';
        is_in_string := true;
        begin try string lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '"';
        comment lexbuf )
# 2190 "src/reason_lexer.ml"

  | 3 ->
# 606 "src/reason_lexer.mll"
      (
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        string_start_loc := Location.curr lexbuf;
        store_lexeme lexbuf;
        is_in_string := true;
        begin try quoted_string delim lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '|';
        store_string delim;
        store_string_char '}';
        comment lexbuf )
# 2215 "src/reason_lexer.ml"

  | 4 ->
# 629 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2220 "src/reason_lexer.ml"

  | 5 ->
# 631 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 1;
        store_lexeme lexbuf;
        comment lexbuf
      )
# 2228 "src/reason_lexer.ml"

  | 6 ->
# 636 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2233 "src/reason_lexer.ml"

  | 7 ->
# 638 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2238 "src/reason_lexer.ml"

  | 8 ->
# 640 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2243 "src/reason_lexer.ml"

  | 9 ->
# 642 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2248 "src/reason_lexer.ml"

  | 10 ->
# 644 "src/reason_lexer.mll"
      ( match !comment_start_loc with
        | [] -> assert false
        | loc :: _ ->
          let start = List.hd (List.rev !comment_start_loc) in
          comment_start_loc := [];
          raise (Error (Unterminated_comment start, loc))
      )
# 2259 "src/reason_lexer.ml"

  | 11 ->
# 652 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        comment lexbuf
      )
# 2267 "src/reason_lexer.ml"

  | 12 ->
# 657 "src/reason_lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2272 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

and string lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 2 (-1) ;   __ocaml_lex_string_rec lexbuf 190
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 661 "src/reason_lexer.mll"
      ( () )
# 2284 "src/reason_lexer.ml"

  | 1 ->
let
# 662 "src/reason_lexer.mll"
                                  space
# 2290 "src/reason_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_curr_pos in
# 663 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false (String.length space);
        if in_comment () then store_lexeme lexbuf;
        string lexbuf
      )
# 2297 "src/reason_lexer.ml"

  | 2 ->
# 668 "src/reason_lexer.mll"
      ( if in_comment () then store_lexeme lexbuf
        else store_string_char(char_for_backslash(Lexing.lexeme_char lexbuf 1));
        string lexbuf )
# 2304 "src/reason_lexer.ml"

  | 3 ->
# 672 "src/reason_lexer.mll"
      ( if in_comment () then store_lexeme lexbuf
        else store_string_char(char_for_decimal_code lexbuf 1);
        string lexbuf )
# 2311 "src/reason_lexer.ml"

  | 4 ->
# 676 "src/reason_lexer.mll"
      ( if in_comment () then store_lexeme lexbuf
        else store_string_char(char_for_hexadecimal_code lexbuf 2);
        string lexbuf )
# 2318 "src/reason_lexer.ml"

  | 5 ->
# 680 "src/reason_lexer.mll"
      ( if in_comment ()
        then string lexbuf
        else begin
(*  Should be an error, but we are very lax.
          raise (Error (Illegal_escape (Lexing.lexeme lexbuf),
                        Location.curr lexbuf))
*)
          let loc = Location.curr lexbuf in
          Location.prerr_warning loc Warnings.Illegal_backslash;
          store_string_char (Lexing.lexeme_char lexbuf 0);
          store_string_char (Lexing.lexeme_char lexbuf 1);
          string lexbuf
        end
      )
# 2336 "src/reason_lexer.ml"

  | 6 ->
# 695 "src/reason_lexer.mll"
      ( if not (in_comment ()) then
          Location.prerr_warning (Location.curr lexbuf) Warnings.Eol_in_string;
        update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        string lexbuf
      )
# 2346 "src/reason_lexer.ml"

  | 7 ->
# 702 "src/reason_lexer.mll"
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
# 2352 "src/reason_lexer.ml"

  | 8 ->
# 705 "src/reason_lexer.mll"
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        string lexbuf )
# 2358 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_string_rec lexbuf __ocaml_lex_state

and quoted_string delim lexbuf =
    __ocaml_lex_quoted_string_rec delim lexbuf 209
and __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 710 "src/reason_lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        quoted_string delim lexbuf
      )
# 2373 "src/reason_lexer.ml"

  | 1 ->
# 715 "src/reason_lexer.mll"
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
# 2379 "src/reason_lexer.ml"

  | 2 ->
# 718 "src/reason_lexer.mll"
      (
        let edelim = Lexing.lexeme lexbuf in
        let edelim = String.sub edelim 1 (String.length edelim - 2) in
        if delim = edelim then ()
        else (store_lexeme lexbuf; quoted_string delim lexbuf)
      )
# 2389 "src/reason_lexer.ml"

  | 3 ->
# 725 "src/reason_lexer.mll"
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        quoted_string delim lexbuf )
# 2395 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state

and skip_sharp_bang lexbuf =
    __ocaml_lex_skip_sharp_bang_rec lexbuf 218
and __ocaml_lex_skip_sharp_bang_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 730 "src/reason_lexer.mll"
       ( update_loc lexbuf None 3 false 0 )
# 2407 "src/reason_lexer.ml"

  | 1 ->
# 732 "src/reason_lexer.mll"
       ( update_loc lexbuf None 1 false 0 )
# 2412 "src/reason_lexer.ml"

  | 2 ->
# 733 "src/reason_lexer.mll"
       ( () )
# 2417 "src/reason_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_skip_sharp_bang_rec lexbuf __ocaml_lex_state

;;

# 735 "src/reason_lexer.mll"
 

  let token_with_comments lexbuf =
    match !preprocessor with
    | None -> token lexbuf
    | Some (_init, preprocess) -> preprocess token lexbuf

  let last_comments = ref []
  let rec token lexbuf =
    match token_with_comments lexbuf with
        COMMENT (s, comment_loc) ->
          last_comments := (s, comment_loc) :: !last_comments;
          token lexbuf
      | tok -> tok
  let comments () = List.rev !last_comments

  let init () =
    is_in_string := false;
    last_comments := [];
    comment_start_loc := [];
    match !preprocessor with
    | None -> ()
    | Some (init, _preprocess) -> init ()

  let set_preprocessor init preprocess =
    preprocessor := Some (init, preprocess)


# 2453 "src/reason_lexer.ml"

end
module Reason_parser_message
= struct
#1 "reason_parser_message.ml"

(* This file was auto-generated based on "src/reason_parser.messages". *)

(* Please note that the function [message] can raise [Not_found]. *)

let message =
  fun s ->
    match s with
    | 0 ->
        "<SYNTAX ERROR>\n"
    | 749 ->
        "Expecting one of the following:\n  - an identifier to access a member of an object\n  - \"[\" + expression + \"]\" to access an element of a list\n  - \"(\" + expression + \")\"\n  - \"{\" + expression + \"}\"\n"
    | 750 ->
        "Expecting an expression\n"
    | 2193 ->
        "Expecting one of the following:\n  - an infix operation to connect two expressions\n  - \")\" to close the block\n"
    | 2195 ->
        "Expecting an expression\n"
    | 2196 ->
        "Expecting one of the following:\n  - an infix operation to connect two expressions\n  - \"}\" to close the block\n"
    | 2198 ->
        "Expecting an expression\n"
    | 2199 ->
        "Expecting one of the following:\n  - an infix operation to connect two expressions\n  - \"}\" to close the block\n"
    | 906 ->
        "Expecting an expression\n"
    | 754 ->
        "Expecting an identifier\n"
    | 2059 ->
        "Expecting a structure item\n"
    | 2677 ->
        "Invalid token\n"
    | 923 ->
        "Expecting an expression\n"
    | 1007 ->
        "Expecting one of the following:\n  - The continuation of the previous expression\n  - \":\" to start the next expression\n"
    | 1008 ->
        "Expecting an expression\n"
    | 1010 ->
        "Expecting an expression\n"
    | 1016 ->
        "Expecting an expression\n"
    | 1018 ->
        "Expecting an expression\n"
    | 1012 ->
        "Expecting an expression\n"
    | 1020 ->
        "Expecting an expression\n"
    | 1022 ->
        "Expecting an expression\n"
    | 1024 ->
        "Expecting an expression\n"
    | 174 ->
        "Expecting one of the following:\n  - \")\" to form a unit value \"()\"\n  - \"module\" to start a module expression\n  - an expression\n  - an operator to denote the prefix form of an operator\n"
    | 180 ->
        "Expecting an expression\n"
    | 1026 ->
        "Expecting an expression\n"
    | 1032 ->
        "Expecting an expression\n"
    | 2446 ->
        "Expecting \"]\"\n"
    | 417 ->
        "Expecting an attributed id\n"
    | 2449 ->
        "Expecting \"]\"\n"
    | 356 ->
        "Expecting an attribute id\n"
    | 908 ->
        "Expecting an expression\n"
    | 1014 ->
        "Expecting an expression\n"
    | 1028 ->
        "Expecting an expression\n"
    | 1030 ->
        "Expecting an expression\n"
    | 1034 ->
        "Expecting an expression\n"
    | 1036 ->
        "Expecting an expression\n"
    | 779 ->
        "<SYNTAX ERROR>\n"
    | 780 ->
        "<SYNTAX ERROR>\n"
    | 2113 ->
        "<SYNTAX ERROR>\n"
    | 781 ->
        "<SYNTAX ERROR>\n"
    | 2108 ->
        "<SYNTAX ERROR>\n"
    | 2109 ->
        "<SYNTAX ERROR>\n"
    | 2111 ->
        "<SYNTAX ERROR>\n"
    | 2125 ->
        "<SYNTAX ERROR>\n"
    | 2127 ->
        "<SYNTAX ERROR>\n"
    | 2133 ->
        "<SYNTAX ERROR>\n"
    | 2143 ->
        "<SYNTAX ERROR>\n"
    | 2148 ->
        "<SYNTAX ERROR>\n"
    | 2168 ->
        "<SYNTAX ERROR>\n"
    | 1046 ->
        "<SYNTAX ERROR>\n"
    | 1040 ->
        "<SYNTAX ERROR>\n"
    | 1042 ->
        "<SYNTAX ERROR>\n"
    | 1044 ->
        "<SYNTAX ERROR>\n"
    | 80 ->
        "<SYNTAX ERROR>\n"
    | 109 ->
        "Variant constructors need to begin with an uppercase character\n"
    | 2075 ->
        "<SYNTAX ERROR>\n"
    | 2640 ->
        "Expecting one of the following:\n  - \"=\" to start the body of the type declaration\n  - \"constraint\" to add constraints to the type declaration\n  - \";\" to finish type declaratoin\n  - \"+=\" to form a string type extension\n  - \"and\" to declare another type\n"
    | 83 ->
        "<SYNTAX ERROR>\n"
    | 2644 ->
        "<SYNTAX ERROR>\n"
    | 2648 ->
        "<SYNTAX ERROR>\n"
    | 2645 ->
        "<SYNTAX ERROR>\n"
    | 2646 ->
        "<SYNTAX ERROR>\n"
    | 87 ->
        "<SYNTAX ERROR>\n"
    | 89 ->
        "<SYNTAX ERROR>\n"
    | 91 ->
        "<SYNTAX ERROR>\n"
    | 93 ->
        "<SYNTAX ERROR>\n"
    | 1866 ->
        "<SYNTAX ERROR>\n"
    | 110 ->
        "<SYNTAX ERROR>\n"
    | 2623 ->
        "<SYNTAX ERROR>\n"
    | 2624 ->
        "<SYNTAX ERROR>\n"
    | 2619 ->
        "<SYNTAX ERROR>\n"
    | 2626 ->
        "<SYNTAX ERROR>\n"
    | 2631 ->
        "<SYNTAX ERROR>\n"
    | 2632 ->
        "<SYNTAX ERROR>\n"
    | 2598 ->
        "Variant constructors need to begin with an uppercase character\n"
    | 112 ->
        "<SYNTAX ERROR>\n"
    | 2587 ->
        "<SYNTAX ERROR>\n"
    | 2588 ->
        "<SYNTAX ERROR>\n"
    | 322 ->
        "Expecting at least one type field definition in the form of:\n  <field name> : <type>\n"
    | 160 ->
        "Expecting a type field definition in the form of:\n  <field name> : <type>\n"
    | 2532 ->
        "Expecting \":\"\n"
    | 2533 ->
        "Expecting a type name describing this field\n"
    | 335 ->
        "Expecting one of the following:\n  - \",\" to finish current type field\n  - \"}\" to finish type definition\n"
    | 1875 ->
        "<SYNTAX ERROR>\n"
    | 2616 ->
        "<SYNTAX ERROR>\n"
    | 1766 ->
        "<SYNTAX ERROR>\n"
    | 1767 ->
        "<SYNTAX ERROR>\n"
    | 1768 ->
        "<SYNTAX ERROR>\n"
    | 1867 ->
        "<SYNTAX ERROR>\n"
    | 1873 ->
        "<SYNTAX ERROR>\n"
    | 17 ->
        "<SYNTAX ERROR>\n"
    | 2666 ->
        "<SYNTAX ERROR>\n"
    | 2665 ->
        "<SYNTAX ERROR>\n"
    | 2661 ->
        "This is a reserved keyword. Consider using a different one. For BuckleScript, add an underscore at the end (http://bloomberg.github.io/bucklescript/Manual.html#_object_label_translation_convention).\n"
    | 2668 ->
        "<SYNTAX ERROR>\n"
    | 2359 ->
        "<SYNTAX ERROR>\n"
    | 2360 ->
        "<SYNTAX ERROR>\n"
    | 2361 ->
        "Expecting a sequence item\n"
    | 1103 ->
        "Expecting one of the following:\n  - \"|\" to open the next pattern\n  - \"=>\" to start the body of the matched pattern\n  - \"when\" to start a contitional guard for the previous pattern\n"
    | 2393 ->
        "Expecting the body of the matched pattern\n"
    | 2669 ->
        "Expecting one of the following:\n  - \"}\" to finish the block\n  - \"|\" to start another pattern matching case\n"
    | 2383 ->
        "<SYNTAX ERROR>\n"
    | 2362 ->
        "<SYNTAX ERROR>\n"
    | 2366 ->
        "<SYNTAX ERROR>\n"
    | 2369 ->
        "<SYNTAX ERROR>\n"
    | 2370 ->
        "<SYNTAX ERROR>\n"
    | 2367 ->
        "<SYNTAX ERROR>\n"
    | 2372 ->
        "<SYNTAX ERROR>\n"
    | 2373 ->
        "<SYNTAX ERROR>\n"
    | 2376 ->
        "<SYNTAX ERROR>\n"
    | 810 ->
        "<SYNTAX ERROR>\n"
    | 1102 ->
        "Expecting a match case\n"
    | 880 ->
        "<SYNTAX ERROR>\n"
    | 503 ->
        "<SYNTAX ERROR>\n"
    | 504 ->
        "<SYNTAX ERROR>\n"
    | 881 ->
        "<SYNTAX ERROR>\n"
    | 1048 ->
        "<SYNTAX ERROR>\n"
    | 1051 ->
        "<SYNTAX ERROR>\n"
    | 1065 ->
        "<SYNTAX ERROR>\n"
    | 1053 ->
        "<SYNTAX ERROR>\n"
    | 1054 ->
        "<SYNTAX ERROR>\n"
    | 1057 ->
        "<SYNTAX ERROR>\n"
    | 1059 ->
        "<SYNTAX ERROR>\n"
    | 1060 ->
        "<SYNTAX ERROR>\n"
    | 1062 ->
        "<SYNTAX ERROR>\n"
    | 165 ->
        "<SYNTAX ERROR>\n"
    | 2526 ->
        "<SYNTAX ERROR>\n"
    | 2527 ->
        "<SYNTAX ERROR>\n"
    | 2528 ->
        "The switch expression isn't closed.\n"
    | 1731 ->
        "Incomplete statement. Did you forget a \";\"?\n"
    | 887 ->
        "<SYNTAX ERROR>\n"
    | 886 ->
        "<SYNTAX ERROR>\n"
    | 409 ->
        "<SYNTAX ERROR>\n"
    | 410 ->
        "<SYNTAX ERROR>\n"
    | 358 ->
        "<SYNTAX ERROR>\n"
    | 413 ->
        "<SYNTAX ERROR>\n"
    | 415 ->
        "<SYNTAX ERROR>\n"
    | 1123 ->
        "<SYNTAX ERROR>\n"
    | 1136 ->
        "<SYNTAX ERROR>\n"
    | 1143 ->
        "<SYNTAX ERROR>\n"
    | 1122 ->
        "<SYNTAX ERROR>\n"
    | 1145 ->
        "<SYNTAX ERROR>\n"
    | 1148 ->
        "<SYNTAX ERROR>\n"
    | 576 ->
        "<SYNTAX ERROR>\n"
    | 178 ->
        "<SYNTAX ERROR>\n"
    | 192 ->
        "<SYNTAX ERROR>\n"
    | 193 ->
        "<SYNTAX ERROR>\n"
    | 171 ->
        "<SYNTAX ERROR>\n"
    | 115 ->
        "<SYNTAX ERROR>\n"
    | 116 ->
        "<SYNTAX ERROR>\n"
    | 2483 ->
        "<SYNTAX ERROR>\n"
    | 2485 ->
        "<SYNTAX ERROR>\n"
    | 817 ->
        "<SYNTAX ERROR>\n"
    | 818 ->
        "<SYNTAX ERROR>\n"
    | 190 ->
        "Expecting one of the following:\n  - \")\" to form a unit value \"()\"\n  - \"module\" to start a module expression\n  - an expression\n  - an operator to denote the prefix form of an operator\n"
    | 2494 ->
        "<SYNTAX ERROR>\n"
    | 196 ->
        "Expecting a module expression\n"
    | 2481 ->
        "<SYNTAX ERROR>\n"
    | 2487 ->
        "<SYNTAX ERROR>\n"
    | 2488 ->
        "<SYNTAX ERROR>\n"
    | 2489 ->
        "<SYNTAX ERROR>\n"
    | 2490 ->
        "<SYNTAX ERROR>\n"
    | 2491 ->
        "<SYNTAX ERROR>\n"
    | 2492 ->
        "<SYNTAX ERROR>\n"
    | 904 ->
        "<SYNTAX ERROR>\n"
    | 2471 ->
        "<SYNTAX ERROR>\n"
    | 200 ->
        "<SYNTAX ERROR>\n"
    | 440 ->
        "<SYNTAX ERROR>\n"
    | 2401 ->
        "<SYNTAX ERROR>\n"
    | 2138 ->
        "<SYNTAX ERROR>\n"
    | 2135 ->
        "<SYNTAX ERROR>\n"
    | 457 ->
        "<SYNTAX ERROR>\n"
    | 466 ->
        "<SYNTAX ERROR>\n"
    | 742 ->
        "<SYNTAX ERROR>\n"
    | 751 ->
        "<SYNTAX ERROR>\n"
    | 752 ->
        "<SYNTAX ERROR>\n"
    | 757 ->
        "<SYNTAX ERROR>\n"
    | 758 ->
        "<SYNTAX ERROR>\n"
    | 2190 ->
        "<SYNTAX ERROR>\n"
    | 2176 ->
        "<SYNTAX ERROR>\n"
    | 763 ->
        "<SYNTAX ERROR>\n"
    | 764 ->
        "<SYNTAX ERROR>\n"
    | 765 ->
        "<SYNTAX ERROR>\n"
    | 766 ->
        "<SYNTAX ERROR>\n"
    | 767 ->
        "<SYNTAX ERROR>\n"
    | 2171 ->
        "<SYNTAX ERROR>\n"
    | 759 ->
        "<SYNTAX ERROR>\n"
    | 760 ->
        "<SYNTAX ERROR>\n"
    | 761 ->
        "<SYNTAX ERROR>\n"
    | 762 ->
        "<SYNTAX ERROR>\n"
    | 2181 ->
        "<SYNTAX ERROR>\n"
    | 2182 ->
        "<SYNTAX ERROR>\n"
    | 2183 ->
        "<SYNTAX ERROR>\n"
    | 2184 ->
        "<SYNTAX ERROR>\n"
    | 2185 ->
        "<SYNTAX ERROR>\n"
    | 2186 ->
        "<SYNTAX ERROR>\n"
    | 768 ->
        "<SYNTAX ERROR>\n"
    | 770 ->
        "<SYNTAX ERROR>\n"
    | 771 ->
        "<SYNTAX ERROR>\n"
    | 774 ->
        "<SYNTAX ERROR>\n"
    | 1121 ->
        "<SYNTAX ERROR>\n"
    | 533 ->
        "<SYNTAX ERROR>\n"
    | 865 ->
        "<SYNTAX ERROR>\n"
    | 737 ->
        "Incomplete let binding\n"
    | 1896 ->
        "<SYNTAX ERROR>\n"
    | 1902 ->
        "<SYNTAX ERROR>\n"
    | 1897 ->
        "<SYNTAX ERROR>\n"
    | 1898 ->
        "<SYNTAX ERROR>\n"
    | 1899 ->
        "<SYNTAX ERROR>\n"
    | 1901 ->
        "<SYNTAX ERROR>\n"
    | 472 ->
        "<SYNTAX ERROR>\n"
    | 1736 ->
        "<SYNTAX ERROR>\n"
    | 1737 ->
        "<SYNTAX ERROR>\n"
    | 2043 ->
        "<SYNTAX ERROR>\n"
    | 2044 ->
        "<SYNTAX ERROR>\n"
    | 2045 ->
        "<SYNTAX ERROR>\n"
    | 2046 ->
        "<SYNTAX ERROR>\n"
    | 2050 ->
        "<SYNTAX ERROR>\n"
    | 2047 ->
        "<SYNTAX ERROR>\n"
    | 2048 ->
        "<SYNTAX ERROR>\n"
    | 2049 ->
        "<SYNTAX ERROR>\n"
    | 1738 ->
        "<SYNTAX ERROR>\n"
    | 1739 ->
        "<SYNTAX ERROR>\n"
    | 1748 ->
        "<SYNTAX ERROR>\n"
    | 2036 ->
        "<SYNTAX ERROR>\n"
    | 2037 ->
        "<SYNTAX ERROR>\n"
    | 2038 ->
        "<SYNTAX ERROR>\n"
    | 2054 ->
        "<SYNTAX ERROR>\n"
    | 1879 ->
        "<SYNTAX ERROR>\n"
    | 1880 ->
        "<SYNTAX ERROR>\n"
    | 714 ->
        "<SYNTAX ERROR>\n"
    | 2263 ->
        "Defining a function?\nExpecting one of the following:\n  - \"=>\" to start the function body\n  - an identifier to add a function parameter\n  - \":\" to specify the return type\n"
    | 1604 ->
        "<SYNTAX ERROR>\n"
    | 719 ->
        "<SYNTAX ERROR>\n"
    | 720 ->
        "<SYNTAX ERROR>\n"
    | 721 ->
        "<SYNTAX ERROR>\n"
    | 722 ->
        "<SYNTAX ERROR>\n"
    | 1584 ->
        "Expecting an expression as function body\n"
    | 1605 ->
        "<SYNTAX ERROR>\n"
    | 1606 ->
        "Defining a function?\nExpecting \"=>\" to start the function body\n"
    | 1607 ->
        "<SYNTAX ERROR>\n"
    | 1608 ->
        "<SYNTAX ERROR>\n"
    | 715 ->
        "<SYNTAX ERROR>\n"
    | 716 ->
        "<SYNTAX ERROR>\n"
    | 717 ->
        "<SYNTAX ERROR>\n"
    | 718 ->
        "<SYNTAX ERROR>\n"
    | 2259 ->
        "<SYNTAX ERROR>\n"
    | 2260 ->
        "<SYNTAX ERROR>\n"
    | 2246 ->
        "<SYNTAX ERROR>\n"
    | 2247 ->
        "<SYNTAX ERROR>\n"
    | 1486 ->
        "<SYNTAX ERROR>\n"
    | 2249 ->
        "<SYNTAX ERROR>\n"
    | 2250 ->
        "<SYNTAX ERROR>\n"
    | 2251 ->
        "<SYNTAX ERROR>\n"
    | 2254 ->
        "<SYNTAX ERROR>\n"
    | 2255 ->
        "<SYNTAX ERROR>\n"
    | 2256 ->
        "<SYNTAX ERROR>\n"
    | 2257 ->
        "<SYNTAX ERROR>\n"
    | 2253 ->
        "<SYNTAX ERROR>\n"
    | 1895 ->
        "<SYNTAX ERROR>\n"
    | 74 ->
        "<SYNTAX ERROR>\n"
    | 2205 ->
        "<SYNTAX ERROR>\n"
    | 202 ->
        "<SYNTAX ERROR>\n"
    | 2469 ->
        "<SYNTAX ERROR>\n"
    | 2470 ->
        "<SYNTAX ERROR>\n"
    | 2468 ->
        "<SYNTAX ERROR>\n"
    | 75 ->
        "<SYNTAX ERROR>\n"
    | 1356 ->
        "<SYNTAX ERROR>\n"
    | 738 ->
        "<SYNTAX ERROR>\n"
    | 2128 ->
        "<SYNTAX ERROR>\n"
    | 1126 ->
        "<SYNTAX ERROR>\n"
    | 1128 ->
        "<SYNTAX ERROR>\n"
    | 1131 ->
        "Expecting a type name\n"
    | 170 ->
        "Expecting an expression\n"
    | 918 ->
        "Expecting an expression\n"
    | 878 ->
        "Expecting an expression\n"
    | 743 ->
        "<SYNTAX ERROR>\n"
    | 2203 ->
        "Expecting \"]\" to finish current floating attribute\n"
    | 740 ->
        "<SYNTAX ERROR>\n"
    | 441 ->
        "Expecting one of the following:\n  - an list item\n  - \"]\" to finish this list\n"
    | 2137 ->
        "Expecting one of the following:\n  - \",\" to separate two items in a list\n  - \"]\" to finish this list\n"
    | 2134 ->
        "<SYNTAX ERROR>\n"
    | 184 ->
        "<SYNTAX ERROR>\n"
    | 460 ->
        "<SYNTAX ERROR>\n"
    | 185 ->
        "<SYNTAX ERROR>\n"
    | 2503 ->
        "<SYNTAX ERROR>\n"
    | 1554 ->
        "<SYNTAX ERROR>\n"
    | 1555 ->
        "<SYNTAX ERROR>\n"
    | 1556 ->
        "<SYNTAX ERROR>\n"
    | 1557 ->
        "<SYNTAX ERROR>\n"
    | 1558 ->
        "<SYNTAX ERROR>\n"
    | 1559 ->
        "<SYNTAX ERROR>\n"
    | 1564 ->
        "<SYNTAX ERROR>\n"
    | 1565 ->
        "<SYNTAX ERROR>\n"
    | 1566 ->
        "<SYNTAX ERROR>\n"
    | 1567 ->
        "<SYNTAX ERROR>\n"
    | 1568 ->
        "<SYNTAX ERROR>\n"
    | 1571 ->
        "<SYNTAX ERROR>\n"
    | 1572 ->
        "<SYNTAX ERROR>\n"
    | 1573 ->
        "<SYNTAX ERROR>\n"
    | 1574 ->
        "<SYNTAX ERROR>\n"
    | 1575 ->
        "<SYNTAX ERROR>\n"
    | 1576 ->
        "<SYNTAX ERROR>\n"
    | 1563 ->
        "<SYNTAX ERROR>\n"
    | 2342 ->
        "<SYNTAX ERROR>\n"
    | 2321 ->
        "<SYNTAX ERROR>\n"
    | 1577 ->
        "<SYNTAX ERROR>\n"
    | 1397 ->
        "<SYNTAX ERROR>\n"
    | 1399 ->
        "<SYNTAX ERROR>\n"
    | 1402 ->
        "<SYNTAX ERROR>\n"
    | 1614 ->
        "<SYNTAX ERROR>\n"
    | 1579 ->
        "<SYNTAX ERROR>\n"
    | 1580 ->
        "<SYNTAX ERROR>\n"
    | 1581 ->
        "<SYNTAX ERROR>\n"
    | 1636 ->
        "<SYNTAX ERROR>\n"
    | 1586 ->
        "<SYNTAX ERROR>\n"
    | 1587 ->
        "<SYNTAX ERROR>\n"
    | 1588 ->
        "<SYNTAX ERROR>\n"
    | 1598 ->
        "<SYNTAX ERROR>\n"
    | 1599 ->
        "<SYNTAX ERROR>\n"
    | 1600 ->
        "<SYNTAX ERROR>\n"
    | 1589 ->
        "<SYNTAX ERROR>\n"
    | 1591 ->
        "<SYNTAX ERROR>\n"
    | 1592 ->
        "<SYNTAX ERROR>\n"
    | 1593 ->
        "<SYNTAX ERROR>\n"
    | 1594 ->
        "<SYNTAX ERROR>\n"
    | 1578 ->
        "<SYNTAX ERROR>\n"
    | 2166 ->
        "<SYNTAX ERROR>\n"
    | 2157 ->
        "<SYNTAX ERROR>\n"
    | 2155 ->
        "<SYNTAX ERROR>\n"
    | 2158 ->
        "<SYNTAX ERROR>\n"
    | 2159 ->
        "<SYNTAX ERROR>\n"
    | 2169 ->
        "<SYNTAX ERROR>\n"
    | 2170 ->
        "<SYNTAX ERROR>\n"
    | 469 ->
        "<SYNTAX ERROR>\n"
    | 2296 ->
        "<SYNTAX ERROR>\n"
    | 2299 ->
        "<SYNTAX ERROR>\n"
    | 2300 ->
        "<SYNTAX ERROR>\n"
    | 2297 ->
        "<SYNTAX ERROR>\n"
    | 2302 ->
        "<SYNTAX ERROR>\n"
    | 2303 ->
        "<SYNTAX ERROR>\n"
    | 2314 ->
        "<SYNTAX ERROR>\n"
    | 2286 ->
        "Expecting \"}\" to finish the block\n"
    | 1617 ->
        "<SYNTAX ERROR>\n"
    | 1618 ->
        "<SYNTAX ERROR>\n"
    | 1621 ->
        "<SYNTAX ERROR>\n"
    | 1460 ->
        "<SYNTAX ERROR>\n"
    | 1651 ->
        "<SYNTAX ERROR>\n"
    | 1654 ->
        "<SYNTAX ERROR>\n"
    | 1662 ->
        "<SYNTAX ERROR>\n"
    | 1655 ->
        "<SYNTAX ERROR>\n"
    | 1416 ->
        "<SYNTAX ERROR>\n"
    | 1417 ->
        "<SYNTAX ERROR>\n"
    | 1421 ->
        "<SYNTAX ERROR>\n"
    | 1422 ->
        "<SYNTAX ERROR>\n"
    | 1656 ->
        "<SYNTAX ERROR>\n"
    | 1368 ->
        "<SYNTAX ERROR>\n"
    | 1661 ->
        "<SYNTAX ERROR>\n"
    | 1658 ->
        "<SYNTAX ERROR>\n"
    | 1659 ->
        "<SYNTAX ERROR>\n"
    | 1660 ->
        "<SYNTAX ERROR>\n"
    | 1657 ->
        "<SYNTAX ERROR>\n"
    | 1667 ->
        "<SYNTAX ERROR>\n"
    | 1668 ->
        "<SYNTAX ERROR>\n"
    | 1531 ->
        "<SYNTAX ERROR>\n"
    | 1532 ->
        "<SYNTAX ERROR>\n"
    | 1637 ->
        "<SYNTAX ERROR>\n"
    | 1623 ->
        "<SYNTAX ERROR>\n"
    | 1624 ->
        "<SYNTAX ERROR>\n"
    | 1461 ->
        "<SYNTAX ERROR>\n"
    | 1550 ->
        "<SYNTAX ERROR>\n"
    | 1641 ->
        "<SYNTAX ERROR>\n"
    | 1462 ->
        "<SYNTAX ERROR>\n"
    | 1546 ->
        "<SYNTAX ERROR>\n"
    | 1547 ->
        "<SYNTAX ERROR>\n"
    | 1521 ->
        "<SYNTAX ERROR>\n"
    | 1523 ->
        "<SYNTAX ERROR>\n"
    | 1524 ->
        "<SYNTAX ERROR>\n"
    | 1534 ->
        "<SYNTAX ERROR>\n"
    | 1525 ->
        "<SYNTAX ERROR>\n"
    | 1526 ->
        "<SYNTAX ERROR>\n"
    | 1527 ->
        "<SYNTAX ERROR>\n"
    | 1622 ->
        "<SYNTAX ERROR>\n"
    | 2269 ->
        "<SYNTAX ERROR>\n"
    | 2270 ->
        "<SYNTAX ERROR>\n"
    | 2271 ->
        "<SYNTAX ERROR>\n"
    | 1628 ->
        "<SYNTAX ERROR>\n"
    | 1429 ->
        "<SYNTAX ERROR>\n"
    | 1430 ->
        "<SYNTAX ERROR>\n"
    | 1541 ->
        "<SYNTAX ERROR>\n"
    | 1542 ->
        "<SYNTAX ERROR>\n"
    | 1553 ->
        "<SYNTAX ERROR>\n"
    | 1165 ->
        "<SYNTAX ERROR>\n"
    | 1741 ->
        "<SYNTAX ERROR>\n"
    | 1171 ->
        "<SYNTAX ERROR>\n"
    | 1172 ->
        "<SYNTAX ERROR>\n"
    | 1173 ->
        "<SYNTAX ERROR>\n"
    | 1175 ->
        "<SYNTAX ERROR>\n"
    | 1178 ->
        "<SYNTAX ERROR>\n"
    | 1185 ->
        "<SYNTAX ERROR>\n"
    | 1164 ->
        "<SYNTAX ERROR>\n"
    | 2094 ->
        "<SYNTAX ERROR>\n"
    | 427 ->
        "<SYNTAX ERROR>\n"
    | 428 ->
        "<SYNTAX ERROR>\n"
    | 2434 ->
        "<SYNTAX ERROR>\n"
    | 2436 ->
        "<SYNTAX ERROR>\n"
    | 1176 ->
        "<SYNTAX ERROR>\n"
    | 2438 ->
        "<SYNTAX ERROR>\n"
    | 1181 ->
        "<SYNTAX ERROR>\n"
    | 1182 ->
        "<SYNTAX ERROR>\n"
    | 2440 ->
        "<SYNTAX ERROR>\n"
    | 1188 ->
        "<SYNTAX ERROR>\n"
    | 2089 ->
        "<SYNTAX ERROR>\n"
    | 1166 ->
        "<SYNTAX ERROR>\n"
    | 1167 ->
        "<SYNTAX ERROR>\n"
    | 1168 ->
        "<SYNTAX ERROR>\n"
    | 1170 ->
        "<SYNTAX ERROR>\n"
    | 419 ->
        "A module's name needs to begin with a upper-case letter\n"
    | 420 ->
        "<SYNTAX ERROR>\n"
    | 423 ->
        "<SYNTAX ERROR>\n"
    | 1300 ->
        "<SYNTAX ERROR>\n"
    | 1301 ->
        "<SYNTAX ERROR>\n"
    | 1302 ->
        "<SYNTAX ERROR>\n"
    | 1303 ->
        "<SYNTAX ERROR>\n"
    | 1304 ->
        "<SYNTAX ERROR>\n"
    | 1305 ->
        "<SYNTAX ERROR>\n"
    | 1311 ->
        "<SYNTAX ERROR>\n"
    | 1312 ->
        "<SYNTAX ERROR>\n"
    | 1322 ->
        "<SYNTAX ERROR>\n"
    | 1323 ->
        "<SYNTAX ERROR>\n"
    | 1313 ->
        "<SYNTAX ERROR>\n"
    | 1314 ->
        "<SYNTAX ERROR>\n"
    | 1315 ->
        "<SYNTAX ERROR>\n"
    | 1320 ->
        "<SYNTAX ERROR>\n"
    | 1333 ->
        "<SYNTAX ERROR>\n"
    | 1358 ->
        "<SYNTAX ERROR>\n"
    | 1454 ->
        "<SYNTAX ERROR>\n"
    | 1360 ->
        "<SYNTAX ERROR>\n"
    | 1361 ->
        "<SYNTAX ERROR>\n"
    | 1363 ->
        "<SYNTAX ERROR>\n"
    | 1366 ->
        "<SYNTAX ERROR>\n"
    | 1444 ->
        "<SYNTAX ERROR>\n"
    | 1884 ->
        "<SYNTAX ERROR>\n"
    | 1885 ->
        "<SYNTAX ERROR>\n"
    | 1456 ->
        "<SYNTAX ERROR>\n"
    | 1709 ->
        "<SYNTAX ERROR>\n"
    | 1710 ->
        "<SYNTAX ERROR>\n"
    | 1711 ->
        "<SYNTAX ERROR>\n"
    | 1712 ->
        "<SYNTAX ERROR>\n"
    | 1716 ->
        "<SYNTAX ERROR>\n"
    | 1717 ->
        "<SYNTAX ERROR>\n"
    | 1718 ->
        "<SYNTAX ERROR>\n"
    | 1459 ->
        "<SYNTAX ERROR>\n"
    | 1673 ->
        "<SYNTAX ERROR>\n"
    | 1889 ->
        "<SYNTAX ERROR>\n"
    | 1890 ->
        "<SYNTAX ERROR>\n"
    | 1674 ->
        "<SYNTAX ERROR>\n"
    | 1704 ->
        "<SYNTAX ERROR>\n"
    | 1705 ->
        "<SYNTAX ERROR>\n"
    | 1706 ->
        "<SYNTAX ERROR>\n"
    | 783 ->
        "<SYNTAX ERROR>\n"
    | 787 ->
        "<SYNTAX ERROR>\n"
    | 788 ->
        "<SYNTAX ERROR>\n"
    | 2103 ->
        "<SYNTAX ERROR>\n"
    | 723 ->
        "<SYNTAX ERROR>\n"
    | 724 ->
        "<SYNTAX ERROR>\n"
    | 726 ->
        "<SYNTAX ERROR>\n"
    | 727 ->
        "<SYNTAX ERROR>\n"
    | 769 ->
        "<SYNTAX ERROR>\n"
    | 775 ->
        "<SYNTAX ERROR>\n"
    | 1681 ->
        "<SYNTAX ERROR>\n"
    | 1682 ->
        "<SYNTAX ERROR>\n"
    | 1713 ->
        "<SYNTAX ERROR>\n"
    | 1714 ->
        "<SYNTAX ERROR>\n"
    | 1686 ->
        "<SYNTAX ERROR>\n"
    | 1687 ->
        "<SYNTAX ERROR>\n"
    | 1720 ->
        "<SYNTAX ERROR>\n"
    | 1677 ->
        "<SYNTAX ERROR>\n"
    | 1376 ->
        "<SYNTAX ERROR>\n"
    | 1377 ->
        "<SYNTAX ERROR>\n"
    | 1378 ->
        "<SYNTAX ERROR>\n"
    | 1379 ->
        "<SYNTAX ERROR>\n"
    | 1380 ->
        "<SYNTAX ERROR>\n"
    | 1382 ->
        "<SYNTAX ERROR>\n"
    | 1383 ->
        "<SYNTAX ERROR>\n"
    | 1384 ->
        "<SYNTAX ERROR>\n"
    | 1385 ->
        "<SYNTAX ERROR>\n"
    | 1389 ->
        "<SYNTAX ERROR>\n"
    | 1390 ->
        "<SYNTAX ERROR>\n"
    | 1392 ->
        "<SYNTAX ERROR>\n"
    | 1394 ->
        "<SYNTAX ERROR>\n"
    | 1410 ->
        "<SYNTAX ERROR>\n"
    | 1409 ->
        "<SYNTAX ERROR>\n"
    | 1395 ->
        "<SYNTAX ERROR>\n"
    | 1396 ->
        "<SYNTAX ERROR>\n"
    | 1678 ->
        "<SYNTAX ERROR>\n"
    | 1415 ->
        "<SYNTAX ERROR>\n"
    | 1423 ->
        "<SYNTAX ERROR>\n"
    | 1428 ->
        "<SYNTAX ERROR>\n"
    | 1369 ->
        "<SYNTAX ERROR>\n"
    | 1370 ->
        "<SYNTAX ERROR>\n"
    | 1375 ->
        "<SYNTAX ERROR>\n"
    | 1446 ->
        "<SYNTAX ERROR>\n"
    | 1457 ->
        "<SYNTAX ERROR>\n"
    | 1458 ->
        "<SYNTAX ERROR>\n"
    | 1696 ->
        "<SYNTAX ERROR>\n"
    | 1675 ->
        "<SYNTAX ERROR>\n"
    | 1695 ->
        "<SYNTAX ERROR>\n"
    | 1692 ->
        "<SYNTAX ERROR>\n"
    | 1693 ->
        "<SYNTAX ERROR>\n"
    | 1694 ->
        "<SYNTAX ERROR>\n"
    | 1691 ->
        "<SYNTAX ERROR>\n"
    | 1702 ->
        "<SYNTAX ERROR>\n"
    | 2680 ->
        "<SYNTAX ERROR>\n"
    | 2064 ->
        "<SYNTAX ERROR>\n"
    | 1193 ->
        "<SYNTAX ERROR>\n"
    | 2682 ->
        "<SYNTAX ERROR>\n"
    | 1292 ->
        "<SYNTAX ERROR>\n"
    | 2065 ->
        "<SYNTAX ERROR>\n"
    | 2070 ->
        "<SYNTAX ERROR>\n"
    | 2067 ->
        "<SYNTAX ERROR>\n"
    | 2068 ->
        "<SYNTAX ERROR>\n"
    | 2681 ->
        "<SYNTAX ERROR>\n"
    | 1813 ->
        "<SYNTAX ERROR>\n"
    | 1814 ->
        "<SYNTAX ERROR>\n"
    | 1816 ->
        "<SYNTAX ERROR>\n"
    | 1853 ->
        "<SYNTAX ERROR>\n"
    | 1975 ->
        "<SYNTAX ERROR>\n"
    | 1976 ->
        "<SYNTAX ERROR>\n"
    | 1977 ->
        "<SYNTAX ERROR>\n"
    | 1978 ->
        "<SYNTAX ERROR>\n"
    | 1979 ->
        "<SYNTAX ERROR>\n"
    | 1980 ->
        "<SYNTAX ERROR>\n"
    | 1981 ->
        "<SYNTAX ERROR>\n"
    | 1987 ->
        "<SYNTAX ERROR>\n"
    | 1989 ->
        "<SYNTAX ERROR>\n"
    | 1982 ->
        "<SYNTAX ERROR>\n"
    | 1983 ->
        "<SYNTAX ERROR>\n"
    | 1994 ->
        "<SYNTAX ERROR>\n"
    | 1995 ->
        "<SYNTAX ERROR>\n"
    | 1996 ->
        "<SYNTAX ERROR>\n"
    | 1997 ->
        "<SYNTAX ERROR>\n"
    | 2010 ->
        "<SYNTAX ERROR>\n"
    | 2011 ->
        "<SYNTAX ERROR>\n"
    | 642 ->
        "<SYNTAX ERROR>\n"
    | 1854 ->
        "<SYNTAX ERROR>\n"
    | 1855 ->
        "<SYNTAX ERROR>\n"
    | 1923 ->
        "<SYNTAX ERROR>\n"
    | 1821 ->
        "<SYNTAX ERROR>\n"
    | 1822 ->
        "<SYNTAX ERROR>\n"
    | 1824 ->
        "<SYNTAX ERROR>\n"
    | 1759 ->
        "<SYNTAX ERROR>\n"
    | 1829 ->
        "<SYNTAX ERROR>\n"
    | 1827 ->
        "<SYNTAX ERROR>\n"
    | 1825 ->
        "<SYNTAX ERROR>\n"
    | 1837 ->
        "<SYNTAX ERROR>\n"
    | 1838 ->
        "<SYNTAX ERROR>\n"
    | 1830 ->
        "<SYNTAX ERROR>\n"
    | 1831 ->
        "<SYNTAX ERROR>\n"
    | 1835 ->
        "<SYNTAX ERROR>\n"
    | 96 ->
        "<SYNTAX ERROR>\n"
    | 1834 ->
        "<SYNTAX ERROR>\n"
    | 1832 ->
        "<SYNTAX ERROR>\n"
    | 134 ->
        "<SYNTAX ERROR>\n"
    | 804 ->
        "<SYNTAX ERROR>\n"
    | 1841 ->
        "<SYNTAX ERROR>\n"
    | 1842 ->
        "<SYNTAX ERROR>\n"
    | 805 ->
        "<SYNTAX ERROR>\n"
    | 806 ->
        "<SYNTAX ERROR>\n"
    | 789 ->
        "<SYNTAX ERROR>\n"
    | 790 ->
        "<SYNTAX ERROR>\n"
    | 1749 ->
        "<SYNTAX ERROR>\n"
    | 1806 ->
        "<SYNTAX ERROR>\n"
    | 1807 ->
        "<SYNTAX ERROR>\n"
    | 2032 ->
        "<SYNTAX ERROR>\n"
    | 2033 ->
        "<SYNTAX ERROR>\n"
    | 2034 ->
        "<SYNTAX ERROR>\n"
    | 2035 ->
        "<SYNTAX ERROR>\n"
    | 1755 ->
        "<SYNTAX ERROR>\n"
    | 1756 ->
        "<SYNTAX ERROR>\n"
    | 1758 ->
        "<SYNTAX ERROR>\n"
    | 1765 ->
        "<SYNTAX ERROR>\n"
    | 1763 ->
        "<SYNTAX ERROR>\n"
    | 1761 ->
        "<SYNTAX ERROR>\n"
    | 1791 ->
        "<SYNTAX ERROR>\n"
    | 1792 ->
        "<SYNTAX ERROR>\n"
    | 1771 ->
        "<SYNTAX ERROR>\n"
    | 1772 ->
        "<SYNTAX ERROR>\n"
    | 1789 ->
        "<SYNTAX ERROR>\n"
    | 1774 ->
        "<SYNTAX ERROR>\n"
    | 1788 ->
        "<SYNTAX ERROR>\n"
    | 1773 ->
        "<SYNTAX ERROR>\n"
    | 1775 ->
        "<SYNTAX ERROR>\n"
    | 1776 ->
        "<SYNTAX ERROR>\n"
    | 1779 ->
        "<SYNTAX ERROR>\n"
    | 1190 ->
        "<SYNTAX ERROR>\n"
    | 489 ->
        "<SYNTAX ERROR>\n"
    | 1796 ->
        "<SYNTAX ERROR>\n"
    | 1797 ->
        "<SYNTAX ERROR>\n"
    | 490 ->
        "<SYNTAX ERROR>\n"
    | 491 ->
        "<SYNTAX ERROR>\n"
    | 424 ->
        "<SYNTAX ERROR>\n"
    | 425 ->
        "<SYNTAX ERROR>\n"
    | 1189 ->
        "<SYNTAX ERROR>\n"
    | 2083 ->
        "<SYNTAX ERROR>\n"
    | 2084 ->
        "<SYNTAX ERROR>\n"
    | 2085 ->
        "<SYNTAX ERROR>\n"
    | 2086 ->
        "<SYNTAX ERROR>\n"
    | 2087 ->
        "<SYNTAX ERROR>\n"
    | 2088 ->
        "<SYNTAX ERROR>\n"
    | 2080 ->
        "<SYNTAX ERROR>\n"
    | 1753 ->
        "<SYNTAX ERROR>\n"
    | 1191 ->
        "<SYNTAX ERROR>\n"
    | 1808 ->
        "<SYNTAX ERROR>\n"
    | 1971 ->
        "<SYNTAX ERROR>\n"
    | 1970 ->
        "<SYNTAX ERROR>\n"
    | 1926 ->
        "<SYNTAX ERROR>\n"
    | 1927 ->
        "<SYNTAX ERROR>\n"
    | 1928 ->
        "<SYNTAX ERROR>\n"
    | 1929 ->
        "<SYNTAX ERROR>\n"
    | 1930 ->
        "<SYNTAX ERROR>\n"
    | 1935 ->
        "<SYNTAX ERROR>\n"
    | 1936 ->
        "<SYNTAX ERROR>\n"
    | 1954 ->
        "<SYNTAX ERROR>\n"
    | 1963 ->
        "<SYNTAX ERROR>\n"
    | 1965 ->
        "<SYNTAX ERROR>\n"
    | 1445 ->
        "<SYNTAX ERROR>\n"
    | 1966 ->
        "<SYNTAX ERROR>\n"
    | 2020 ->
        "<SYNTAX ERROR>\n"
    | 2021 ->
        "<SYNTAX ERROR>\n"
    | 2687 ->
        "<SYNTAX ERROR>\n"
    | 2689 ->
        "<SYNTAX ERROR>\n"
    | 290 ->
        "<SYNTAX ERROR>\n"
    | 294 ->
        "<SYNTAX ERROR>\n"
    | 295 ->
        "<SYNTAX ERROR>\n"
    | 206 ->
        "<SYNTAX ERROR>\n"
    | 95 ->
        "<SYNTAX ERROR>\n"
    | 97 ->
        "<SYNTAX ERROR>\n"
    | 99 ->
        "<SYNTAX ERROR>\n"
    | 207 ->
        "<SYNTAX ERROR>\n"
    | 124 ->
        "<SYNTAX ERROR>\n"
    | 9 ->
        "<SYNTAX ERROR>\n"
    | 10 ->
        "<SYNTAX ERROR>\n"
    | 2572 ->
        "<SYNTAX ERROR>\n"
    | 128 ->
        "<SYNTAX ERROR>\n"
    | 1216 ->
        "Expecting one of the following:\n  - \",\" to start the type in the tuple\n  - \")\" to finish the tuple type definition\n"
    | 1218 ->
        "<SYNTAX ERROR>\n"
    | 133 ->
        "<SYNTAX ERROR>\n"
    | 138 ->
        "<SYNTAX ERROR>\n"
    | 139 ->
        "<SYNTAX ERROR>\n"
    | 144 ->
        "<SYNTAX ERROR>\n"
    | 145 ->
        "<SYNTAX ERROR>\n"
    | 2569 ->
        "<SYNTAX ERROR>\n"
    | 2570 ->
        "<SYNTAX ERROR>\n"
    | 137 ->
        "<SYNTAX ERROR>\n"
    | 135 ->
        "<SYNTAX ERROR>\n"
    | 276 ->
        "<SYNTAX ERROR>\n"
    | 126 ->
        "<SYNTAX ERROR>\n"
    | 155 ->
        "<SYNTAX ERROR>\n"
    | 2542 ->
        "<SYNTAX ERROR>\n"
    | 1494 ->
        "<SYNTAX ERROR>\n"
    | 1400 ->
        "<SYNTAX ERROR>\n"
    | 1595 ->
        "<SYNTAX ERROR>\n"
    | 1596 ->
        "<SYNTAX ERROR>\n"
    | 336 ->
        "<SYNTAX ERROR>\n"
    | 158 ->
        "<SYNTAX ERROR>\n"
    | 148 ->
        "<SYNTAX ERROR>\n"
    | 2556 ->
        "<SYNTAX ERROR>\n"
    | 2558 ->
        "<SYNTAX ERROR>\n"
    | 2559 ->
        "<SYNTAX ERROR>\n"
    | 266 ->
        "<SYNTAX ERROR>\n"
    | 150 ->
        "<SYNTAX ERROR>\n"
    | 151 ->
        "<SYNTAX ERROR>\n"
    | 2554 ->
        "<SYNTAX ERROR>\n"
    | 153 ->
        "<SYNTAX ERROR>\n"
    | 154 ->
        "<SYNTAX ERROR>\n"
    | 2550 ->
        "<SYNTAX ERROR>\n"
    | 2551 ->
        "<SYNTAX ERROR>\n"
    | 2552 ->
        "<SYNTAX ERROR>\n"
    | 2545 ->
        "<SYNTAX ERROR>\n"
    | 2546 ->
        "<SYNTAX ERROR>\n"
    | 2548 ->
        "<SYNTAX ERROR>\n"
    | 299 ->
        "<SYNTAX ERROR>\n"
    | 274 ->
        "<SYNTAX ERROR>\n"
    | 2691 ->
        "<SYNTAX ERROR>\n"
    | 2693 ->
        "<SYNTAX ERROR>\n"
    | 2695 ->
        "<SYNTAX ERROR>\n"
    | 2696 ->
        "<SYNTAX ERROR>\n"
    | 650 ->
        "<SYNTAX ERROR>\n"
    | 632 ->
        "<SYNTAX ERROR>\n"
    | 605 ->
        "<SYNTAX ERROR>\n"
    | 431 ->
        "<SYNTAX ERROR>\n"
    | 615 ->
        "<SYNTAX ERROR>\n"
    | 204 ->
        "<SYNTAX ERROR>\n"
    | 209 ->
        "<SYNTAX ERROR>\n"
    | 215 ->
        "<SYNTAX ERROR>\n"
    | 221 ->
        "<SYNTAX ERROR>\n"
    | 608 ->
        "<SYNTAX ERROR>\n"
    | 609 ->
        "<SYNTAX ERROR>\n"
    | 606 ->
        "<SYNTAX ERROR>\n"
    | 648 ->
        "<SYNTAX ERROR>\n"
    | 581 ->
        "<SYNTAX ERROR>\n"
    | 660 ->
        "<SYNTAX ERROR>\n"
    | 666 ->
        "<SYNTAX ERROR>\n"
    | 670 ->
        "<SYNTAX ERROR>\n"
    | 671 ->
        "<SYNTAX ERROR>\n"
    | 251 ->
        "<SYNTAX ERROR>\n"
    | 341 ->
        "<SYNTAX ERROR>\n"
    | 119 ->
        "<SYNTAX ERROR>\n"
    | 2576 ->
        "<SYNTAX ERROR>\n"
    | 2573 ->
        "<SYNTAX ERROR>\n"
    | 2574 ->
        "<SYNTAX ERROR>\n"
    | 352 ->
        "<SYNTAX ERROR>\n"
    | 113 ->
        "<SYNTAX ERROR>\n"
    | 324 ->
        "<SYNTAX ERROR>\n"
    | 253 ->
        "<SYNTAX ERROR>\n"
    | 259 ->
        "<SYNTAX ERROR>\n"
    | 261 ->
        "<SYNTAX ERROR>\n"
    | 262 ->
        "<SYNTAX ERROR>\n"
    | 254 ->
        "<SYNTAX ERROR>\n"
    | 307 ->
        "<SYNTAX ERROR>\n"
    | 310 ->
        "<SYNTAX ERROR>\n"
    | 309 ->
        "<SYNTAX ERROR>\n"
    | 312 ->
        "<SYNTAX ERROR>\n"
    | 318 ->
        "<SYNTAX ERROR>\n"
    | 319 ->
        "<SYNTAX ERROR>\n"
    | 320 ->
        "<SYNTAX ERROR>\n"
    | 313 ->
        "<SYNTAX ERROR>\n"
    | 314 ->
        "<SYNTAX ERROR>\n"
    | 316 ->
        "<SYNTAX ERROR>\n"
    | 593 ->
        "<SYNTAX ERROR>\n"
    | 558 ->
        "<SYNTAX ERROR>\n"
    | 518 ->
        "<SYNTAX ERROR>\n"
    | 548 ->
        "<SYNTAX ERROR>\n"
    | 539 ->
        "<SYNTAX ERROR>\n"
    | 223 ->
        "<SYNTAX ERROR>\n"
    | 226 ->
        "<SYNTAX ERROR>\n"
    | 227 ->
        "<SYNTAX ERROR>\n"
    | 232 ->
        "<SYNTAX ERROR>\n"
    | 238 ->
        "<SYNTAX ERROR>\n"
    | 239 ->
        "<SYNTAX ERROR>\n"
    | 241 ->
        "<SYNTAX ERROR>\n"
    | 247 ->
        "<SYNTAX ERROR>\n"
    | 248 ->
        "<SYNTAX ERROR>\n"
    | 249 ->
        "<SYNTAX ERROR>\n"
    | 250 ->
        "<SYNTAX ERROR>\n"
    | 2457 ->
        "<SYNTAX ERROR>\n"
    | 2458 ->
        "<SYNTAX ERROR>\n"
    | 242 ->
        "<SYNTAX ERROR>\n"
    | 246 ->
        "<SYNTAX ERROR>\n"
    | 495 ->
        "<SYNTAX ERROR>\n"
    | 481 ->
        "<SYNTAX ERROR>\n"
    | 579 ->
        "<SYNTAX ERROR>\n"
    | 682 ->
        "<SYNTAX ERROR>\n"
    | 482 ->
        "<SYNTAX ERROR>\n"
    | 483 ->
        "<SYNTAX ERROR>\n"
    | 485 ->
        "<SYNTAX ERROR>\n"
    | 701 ->
        "<SYNTAX ERROR>\n"
    | 702 ->
        "<SYNTAX ERROR>\n"
    | 703 ->
        "<SYNTAX ERROR>\n"
    | 704 ->
        "<SYNTAX ERROR>\n"
    | 705 ->
        "<SYNTAX ERROR>\n"
    | 706 ->
        "<SYNTAX ERROR>\n"
    | 498 ->
        "<SYNTAX ERROR>\n"
    | 697 ->
        "<SYNTAX ERROR>\n"
    | 499 ->
        "<SYNTAX ERROR>\n"
    | 690 ->
        "<SYNTAX ERROR>\n"
    | 501 ->
        "<SYNTAX ERROR>\n"
    | 506 ->
        "<SYNTAX ERROR>\n"
    | 517 ->
        "<SYNTAX ERROR>\n"
    | 531 ->
        "<SYNTAX ERROR>\n"
    | 2460 ->
        "<SYNTAX ERROR>\n"
    | 2461 ->
        "<SYNTAX ERROR>\n"
    | 2462 ->
        "<SYNTAX ERROR>\n"
    | 2463 ->
        "<SYNTAX ERROR>\n"
    | 2464 ->
        "<SYNTAX ERROR>\n"
    | 2465 ->
        "<SYNTAX ERROR>\n"
    | 473 ->
        "<SYNTAX ERROR>\n"
    | 711 ->
        "<SYNTAX ERROR>\n"
    | 700 ->
        "<SYNTAX ERROR>\n"
    | 695 ->
        "<SYNTAX ERROR>\n"
    | 696 ->
        "<SYNTAX ERROR>\n"
    | 474 ->
        "<SYNTAX ERROR>\n"
    | 475 ->
        "<SYNTAX ERROR>\n"
    | 582 ->
        "<SYNTAX ERROR>\n"
    | 586 ->
        "<SYNTAX ERROR>\n"
    | 599 ->
        "<SYNTAX ERROR>\n"
    | 590 ->
        "<SYNTAX ERROR>\n"
    | 598 ->
        "<SYNTAX ERROR>\n"
    | 591 ->
        "Expecting a valid list identifier\n"
    | 592 ->
        "<SYNTAX ERROR>\n"
    | 600 ->
        "<SYNTAX ERROR>\n"
    | 515 ->
        "<SYNTAX ERROR>\n"
    | 510 ->
        "<SYNTAX ERROR>\n"
    | 511 ->
        "<SYNTAX ERROR>\n"
    | 601 ->
        "<SYNTAX ERROR>\n"
    | 516 ->
        "<SYNTAX ERROR>\n"
    | 688 ->
        "<SYNTAX ERROR>\n"
    | 604 ->
        "<SYNTAX ERROR>\n"
    | 610 ->
        "<SYNTAX ERROR>\n"
    | 2699 ->
        "<SYNTAX ERROR>\n"
    | 2832 ->
        "<SYNTAX ERROR>\n"
    | 2736 ->
        "<SYNTAX ERROR>\n"
    | 2737 ->
        "<SYNTAX ERROR>\n"
    | 2743 ->
        "<SYNTAX ERROR>\n"
    | 938 ->
        "<SYNTAX ERROR>\n"
    | 2829 ->
        "<SYNTAX ERROR>\n"
    | 2870 ->
        "<SYNTAX ERROR>\n"
    | 2877 ->
        "<SYNTAX ERROR>\n"
    | 2876 ->
        "<SYNTAX ERROR>\n"
    | 2873 ->
        "<SYNTAX ERROR>\n"
    | 2874 ->
        "<SYNTAX ERROR>\n"
    | _ ->
        raise Not_found

end
module Reason_toolchain
= struct
#1 "reason_toolchain.ml"
(***********************************************************************)
(*                                                                     *)
(*                                Reason                               *)
(*                                                                     *)
(***********************************************************************)
(* Portions Copyright (c) 2015-present, Facebook, Inc. All rights reserved. *)


(* Entry points in the parser *)

(**
 * Provides a simple interface to the most common parsing entrypoints required
 * by editor/IDE toolchains, preprocessors, and pretty printers.
 *
 * The form of this entrypoint includes more than what the standard OCaml
 * toolchain (oprof/ocamldoc) expects, but is still compatible.
 *
 * [implementation_with_comments] and [interface_with_comments] includes
 * additional information (about comments) suitable for building pretty
 * printers, editor, IDE and VCS integration.
 *
 * The comments include the full text of the comment (typically in between the
 * "(*" and the "*)", as well as location information for that comment.
 *
 * WARNING: The "end" location is one greater than the actual final position!
 * (for both [associatedTextLoc] and [commentLoc]).
 *
 * Currently, the location information for comments is of the form:
 *
 *  (associatedTextLoc)
 *
 * But we should quickly change it to be of the form:
 *
 *  (associatedTextLoc, commentLoc)
 *
 * Where the [commentLoc] is the actual original location of the comment,
 * and the [associatedTextLoc] records the location in the file that the
 * comment is attached to. If [associatedTextLoc] and [commentLoc] are the
 * same, then the comment is "free floating" in that it only attaches to itself.
 * The [Reason] pretty printer will try its best to interleave those comments
 * in the containing list etc. But if [associatedTextLoc] expands beyond
 * the [commentLoc] it means the comment and the AST that is captured by
 * the [associatedTextLoc] are related - where "related" is something
 * this [reason_toolchain] decides (but in short it handles "end of line
 * comments"). Various pretty printers can decide how to preserve this
 * relatedness. Ideally, it would preserve end of line comments, but in the
 * short term, it might merely use that relatedness to correctly attach
 * end of line comments to the "top" of the AST node.
 *
 *    let lst = [
 *
 *    ];   (*    Comment    *)
 *         ----commentLoc-----
 *    ---associatedTextLoc----
 *
 *
 * Ideally that would be formatted as:
 *
 *    let lst = [
 *
 *    ];   (*    Comment    *)
 *
 * Or:
 *
 *    let lst = [ ];   (*    Comment    *)
 *
 *
 * But a shorter term solution would use that [associatedTextLoc] to at least
 * correctly attach the comment to the correct node, even if not "end of line".
 *
 *   (*    Comment    *)
 *   let lst = [ ];
 *)

open Location
open Lexing

module S = MenhirLib.General (* Streams *)

let invalidLex = "invalidCharacter.orComment.orString"
let syntax_error_str err loc =
    if !Reason_config.recoverable = false then
      raise err
    else
      match err with
      | Location.Error err ->
        [
          Ast_helper.Str.mk ~loc:err.loc (Parsetree.Pstr_extension (Syntax_util.syntax_error_extension_node err.loc err.msg, []))
        ]
      | _ ->
        let menhirError = Syntax_util.findMenhirErrorMessage loc in
        match menhirError with
          | Syntax_util.MenhirMessagesError errMessage ->
              [Ast_helper.Str.mk ~loc:errMessage.Syntax_util.loc (Parsetree.Pstr_extension (Syntax_util.syntax_error_extension_node errMessage.Syntax_util.loc errMessage.Syntax_util.msg, []))]
          | _ ->
              [Ast_helper.Str.mk ~loc:loc (Parsetree.Pstr_extension (Syntax_util.syntax_error_extension_node loc invalidLex, []))]

let syntax_error_core_type err loc =
  if !Reason_config.recoverable = false then
    raise err
  else
    match err with
    | Location.Error err ->
      Ast_helper.Typ.mk ~loc:err.loc (Parsetree.Ptyp_extension (Syntax_util.syntax_error_extension_node err.loc err.msg))
    | _ ->
      Ast_helper.Typ.mk ~loc:loc (Parsetree.Ptyp_extension (Syntax_util.syntax_error_extension_node loc invalidLex))

let syntax_error_sig err loc =
  if !Reason_config.recoverable = false then
    raise err
  else
    match err with
    | Location.Error err ->
      [Ast_helper.Sig.mk ~loc:err.loc (Parsetree.Psig_extension (Syntax_util.syntax_error_extension_node err.loc err.msg, []))]
    | _ ->
      [Ast_helper.Sig.mk ~loc:loc (Parsetree.Psig_extension (Syntax_util.syntax_error_extension_node loc invalidLex, []))]


let chan_input = ref ""

(* replaces Lexing.from_channel so we can keep track of the input for comment modification *)
let keep_from_chan chan =
  Lexing.from_function (fun buf n -> (
    (* keep input from chan in memory so that it can be used to reformat comment tokens *)
    let nchar = input chan buf 0 n in
    chan_input := !chan_input ^ Bytes.sub_string buf 0 nchar;
    nchar
  ))

let setup_lexbuf use_stdin filename =
  (* Use custom method of lexing from the channel to keep track of the input so that we can
     reformat tokens in the toolchain*)
  let lexbuf =
    match use_stdin with
      | true ->
        keep_from_chan stdin
      | false ->
        let file_chan = open_in filename in
        seek_in file_chan 0;
        keep_from_chan file_chan
  in
  Location.init lexbuf filename;
  lexbuf


module type Toolchain = sig
  (* Parsing *)
  val canonical_core_type_with_comments: Lexing.lexbuf -> (Parsetree.core_type * Reason_pprint_ast.commentWithCategory)
  val canonical_implementation_with_comments: Lexing.lexbuf -> (Parsetree.structure * Reason_pprint_ast.commentWithCategory)
  val canonical_interface_with_comments: Lexing.lexbuf -> (Parsetree.signature * Reason_pprint_ast.commentWithCategory)

  val canonical_core_type: Lexing.lexbuf -> Parsetree.core_type
  val canonical_implementation: Lexing.lexbuf -> Parsetree.structure
  val canonical_interface: Lexing.lexbuf -> Parsetree.signature
  val canonical_toplevel_phrase: Lexing.lexbuf -> Parsetree.toplevel_phrase
  val canonical_use_file: Lexing.lexbuf -> Parsetree.toplevel_phrase list

  (* Printing *)
  val print_canonical_interface_with_comments: Format.formatter -> (Parsetree.signature * Reason_pprint_ast.commentWithCategory) -> unit
  val print_canonical_implementation_with_comments: Format.formatter -> (Parsetree.structure * Reason_pprint_ast.commentWithCategory) -> unit

end

module type Toolchain_spec = sig
  val safeguard_parsing: Lexing.lexbuf ->
    (unit -> ('a * Reason_pprint_ast.commentWithCategory)) -> ('a * Reason_pprint_ast.commentWithCategory)

  module rec Lexer_impl: sig
    val init: unit -> unit
    val token: Lexing.lexbuf -> Parser_impl.token
    val comments: unit -> (String.t * Location.t) list
  end

  and Parser_impl: sig
    type token
  end

  val core_type: Lexing.lexbuf -> Parsetree.core_type
  val implementation: Lexing.lexbuf -> Parsetree.structure
  val interface: Lexing.lexbuf -> Parsetree.signature
  val toplevel_phrase: Lexing.lexbuf -> Parsetree.toplevel_phrase
  val use_file: Lexing.lexbuf -> Parsetree.toplevel_phrase list

  val format_interface_with_comments: (Parsetree.signature * Reason_pprint_ast.commentWithCategory) -> Format.formatter -> unit
  val format_implementation_with_comments: (Parsetree.structure * Reason_pprint_ast.commentWithCategory) -> Format.formatter -> unit
end

let rec left_expand_comment should_scan_prev_line source loc_start =
  if loc_start = 0 then
    (String.unsafe_get source 0, true, 0)
  else
    let c = String.unsafe_get source (loc_start - 1) in
    match c with
    | '\t' | ' ' -> left_expand_comment should_scan_prev_line source (loc_start - 1)
    | '\n' when should_scan_prev_line -> left_expand_comment should_scan_prev_line source (loc_start - 1)
    | '\n' -> (c, true, loc_start)
    | _ -> (c, false, loc_start)

let rec right_expand_comment should_scan_next_line source loc_start =
  if loc_start = String.length source then
    (String.unsafe_get source (String.length source - 1), true, String.length source)
  else
    let c = String.unsafe_get source loc_start in
    match c with
    | '\t' | ' ' -> right_expand_comment should_scan_next_line source (loc_start + 1)
    | '\n' when should_scan_next_line -> right_expand_comment should_scan_next_line source (loc_start + 1)
    | '\n' -> (c, true, loc_start)
    | _ -> (c, false, loc_start)


module Create_parse_entrypoint (Toolchain_impl: Toolchain_spec) :Toolchain = struct
  let wrap_with_comments parsing_fun lexbuf =
    Toolchain_impl.safeguard_parsing lexbuf (fun () ->
      let _ = Toolchain_impl.Lexer_impl.init () in
      let ast = parsing_fun lexbuf in
      let unmodified_comments = Toolchain_impl.Lexer_impl.comments() in
      match !chan_input with
        | "" ->
          let _  = Parsing.clear_parser() in
          (ast, unmodified_comments |> List.map (fun (txt, phys_loc) -> (txt, Reason_pprint_ast.Regular, phys_loc)))
        | _ ->
          let modified_and_comment_with_category =
            List.map (fun (str, physical_loc) ->
              (* When searching for "^" regexp, returns location of newline + 1 *)
              let (stop_char, eol_start, virtual_start_pos) = left_expand_comment false !chan_input physical_loc.loc_start.pos_cnum in
              let one_char_before_stop_char =
                if virtual_start_pos <= 1 then
                  ' '
                else
                  String.unsafe_get !chan_input (virtual_start_pos - 2)
              in
              (*
               *
               * The following logic are designed for cases like:
               * | (* comment *)
               *   X => 1
               * we want to extend the comment to the next line so it can be
               * correctly attached to X
               *
               * But we don't want it to extend to next line in this case:
               *
               * true || (* comment *)
               *   fasle
               *
               *)
              let should_scan_next_line = stop_char = '|' &&
                                          (one_char_before_stop_char = ' ' ||
                                          one_char_before_stop_char = '\n' ||
                                          one_char_before_stop_char = '\t' ) in
              let (stop_char, eol_end, virtual_end_pos) = right_expand_comment should_scan_next_line !chan_input physical_loc.loc_end.pos_cnum in
              let end_pos_plus_one = physical_loc.loc_end.pos_cnum in
              let comment_length = (end_pos_plus_one - physical_loc.loc_start.pos_cnum - 4) in
              let original_comment_contents = String.sub !chan_input (physical_loc.loc_start.pos_cnum + 2) comment_length in
              let t = match (eol_start, eol_end) with
              | (true, true) -> Reason_pprint_ast.SingleLine
              | (false, true) -> Reason_pprint_ast.EndOfLine
              | _ -> Reason_pprint_ast.Regular
              in
              let start_pos = virtual_start_pos in
              (original_comment_contents, t,
               {physical_loc with loc_start = {physical_loc.loc_start with pos_cnum = start_pos};
                                  loc_end = {physical_loc.loc_end with pos_cnum = virtual_end_pos}})
            )
            unmodified_comments
          in
          let _  = Parsing.clear_parser() in
          (ast, modified_and_comment_with_category)
    )

  (*
   * The canonical interface/implementations (with comments) are used with
   * recovering mode for IDE integration. The parser itself likely
   * implements its own recovery, but we need to recover in the event
   * that the file couldn't even lex.
   * Note, the location reported here is broken for some lexing errors
   * (nested comments or unbalanced strings in comments) but at least we don't
   * crash the process. TODO: Report more accurate location in those cases.
   *)
  let canonical_implementation_with_comments lexbuf =
    try wrap_with_comments Toolchain_impl.implementation lexbuf with
    | err -> (syntax_error_str err (Location.curr lexbuf), [])

  let canonical_core_type_with_comments lexbuf =
    try wrap_with_comments Toolchain_impl.core_type lexbuf with
    | err -> (syntax_error_core_type err (Location.curr lexbuf), [])

  let canonical_interface_with_comments lexbuf =
    try wrap_with_comments Toolchain_impl.interface lexbuf with
    | err -> (syntax_error_sig err (Location.curr lexbuf), [])

  let canonical_toplevel_phrase_with_comments lexbuf =
    wrap_with_comments Toolchain_impl.toplevel_phrase lexbuf

  let canonical_use_file_with_comments lexbuf =
    wrap_with_comments Toolchain_impl.use_file lexbuf

  (** [ast_only] wraps a function to return only the ast component
   *)
  let ast_only f =
    (fun lexbuf -> lexbuf |> f |> fst)

  let canonical_implementation = ast_only canonical_implementation_with_comments

  let canonical_core_type = ast_only canonical_core_type_with_comments

  let canonical_interface = ast_only canonical_interface_with_comments

  let canonical_toplevel_phrase = ast_only canonical_toplevel_phrase_with_comments

  let canonical_use_file = ast_only canonical_use_file_with_comments

  (* Printing *)
  let print_canonical_interface_with_comments formatter interface =
    Toolchain_impl.format_interface_with_comments interface formatter

  let print_canonical_implementation_with_comments formatter implementation =
    Toolchain_impl.format_implementation_with_comments implementation formatter
end

module OCaml_syntax = struct
  module Lexer_impl = Lexer
  module Parser_impl = Parser

  let implementation = Parser.implementation Lexer.token
  let core_type = Parser.parse_core_type Lexer.token
  let interface = Parser.interface Lexer.token
  let toplevel_phrase = Parser.toplevel_phrase Lexer.token
  let use_file = Parser.use_file Lexer.token

  (* Skip tokens to the end of the phrase *)
  (* TODO: consolidate these copy-paste skip/trys into something that works for
   * every syntax (also see [syntax_util]). *)
  let rec skip_phrase lexbuf =
    try
      match Lexer_impl.token lexbuf with
        Parser_impl.SEMISEMI | Parser_impl.EOF -> ()
      | _ -> skip_phrase lexbuf
    with
      | Lexer_impl.Error (Lexer_impl.Unterminated_comment _, _)
      | Lexer_impl.Error (Lexer_impl.Unterminated_string, _)
      | Lexer_impl.Error (Lexer_impl.Unterminated_string_in_comment _, _)
      | Lexer_impl.Error (Lexer_impl.Illegal_character _, _) ->
          skip_phrase lexbuf

  let maybe_skip_phrase lexbuf =
    if Parsing.is_current_lookahead Parser_impl.SEMISEMI
    || Parsing.is_current_lookahead Parser_impl.EOF
    then ()
    else skip_phrase lexbuf

  let safeguard_parsing lexbuf fn =
    try fn ()
    with
    | Lexer_impl.Error(Lexer_impl.Illegal_character _, _) as err
      when !Location.input_name = "//toplevel//"->
        skip_phrase lexbuf;
        raise err
    | Syntaxerr.Error _ as err
      when !Location.input_name = "//toplevel//" ->
        maybe_skip_phrase lexbuf;
        raise err
    | Parsing.Parse_error | Syntaxerr.Escape_error ->
        let loc = Location.curr lexbuf in
        if !Location.input_name = "//toplevel//"
        then maybe_skip_phrase lexbuf;
        raise(Syntaxerr.Error(Syntaxerr.Other loc))

  (* Unfortunately we drop the comments because there doesn't exist an ML
   * printer that formats comments *and* line wrapping! (yet) *)
  let format_interface_with_comments (signature, _) formatter =
    Pprintast.signature formatter signature
  let format_implementation_with_comments (implementation, _) formatter =
    Pprintast.structure formatter implementation
end

module JS_syntax = struct
  module I = Reason_parser.MenhirInterpreter
  module Lexer_impl = Reason_lexer
  module Parser_impl = Reason_parser

  let initial_checkpoint constructor lexbuf =
    (constructor lexbuf.lex_curr_p)

  (* [tracking_supplier] is a supplier that tracks the last token read *)
  type tracking_supplier = {
      (* The last token that was obtained from the lexer, together with its start
     and end positions. Warning: before the first call to the lexer has taken
     place, a None value is stored here. *)

      mutable last_token: (Reason_parser.token * Lexing.position * Lexing.position) option;

      (* A supplier function that returns one token at a time*)
      get_token: unit -> (Reason_parser.token * Lexing.position * Lexing.position)
    }

  (* [lexbuf_to_supplier] returns a supplier to be feed into Menhir's incremental API.
   * Each time the supplier is called, a new token in the lexbuf is returned.
   * If the supplier is called after an EOF is already returned, a syntax error will be raised.
   *
   * This makes sure at most one EOF token is returned by supplier, which
   * is the default behavior of ocamlyacc.
   *)
  let lexbuf_to_supplier lexbuf =
    let s = I.lexer_lexbuf_to_supplier Reason_lexer.token lexbuf in
    let eof_met = ref false in
    let get_token = fun () ->
      let (token, s, e) = s () in
      if token = Reason_parser.EOF then
        if not !eof_met then
          let _ = eof_met := true in
          (token, s, e)
        else
          raise(Syntaxerr.Error(Syntaxerr.Other (Location.curr lexbuf)))
      else
        (token, s, e)
    in
    let last_token = None in
    {last_token; get_token}

  let read supplier =
    let t = supplier.get_token () in
    supplier.last_token <- Some t;
    t

  (* read last token's location from a supplier *)
  let last_token_loc supplier =
    match supplier.last_token with
    | Some (_, s, e) ->
       {
         loc_start = s;
         loc_end = e;
         loc_ghost = false;
       }
    | None -> assert false

  (* get the stack of a checkpoint *)
  let stack checkpoint =
    match checkpoint with
    | I.HandlingError env ->
       I.stack env
    | _ ->
       assert false

  (* get state number of a checkpoint *)
  let state checkpoint : int =
    match Lazy.force (stack checkpoint) with
    | S.Nil ->
       0
    | S.Cons (I.Element (s, _, _, _), _) ->
             I.number s

  (* [loop_handle_yacc] mimic yacc's error handling mechanism in menhir.
     When it hits an error state, it pops up the stack until it finds a
     state when the error can be shifted or reduced.

     This is similar to Menhir's default behavior for error handling, with
     one subtle difference:
     When loop_handle_yacc recovers from the error, unlike Menhir, it doesn't
     discard the input token immediately. Instead, it restarts the parsing
     from recovered state with the original lookahead token that caused the
     error. If there is still an error, the look ahead token is then discarded.

     yacc's behavior gives us a chance to recover the following code :
     ```
     {
       let a = 1;
       Js.
     }
     ```
     , where "}" is the lookahead token that triggers an error state. With
     yacc's behavior, "}" will still be shifted once we recover from "Js.",
     giving the parser the ability to reduce the whole program to a sequence
     expression.
  *)

  let rec loop_handle_yacc supplier in_error checkpoint =

    match checkpoint with
    | I.InputNeeded _ ->
       if in_error then
         begin
           match supplier.last_token with
           | Some triple ->
              (* We just recovered from the error state, try the original token again *)
              let checkpoint_with_previous_token = I.offer checkpoint triple in
              let accept_new = I.loop_test
                                 (fun _ _ -> true)
                                 checkpoint_with_previous_token
                                 false
              in
              if accept_new then
                loop_handle_yacc supplier false checkpoint_with_previous_token
              else
                (* The original token still fail to be parsed, discard *)
                loop_handle_yacc supplier false checkpoint
           | None -> assert false
         end
       else
         let triple = read supplier in
         let checkpoint = I.offer checkpoint triple in
         loop_handle_yacc supplier false checkpoint
    | I.Shifting _
      | I.AboutToReduce _ ->
       let checkpoint = I.resume checkpoint in
       loop_handle_yacc supplier in_error checkpoint
    | I.HandlingError env ->
       if !Reason_config.recoverable then
         (
         let loc = last_token_loc supplier in
         (match Syntax_util.findMenhirErrorMessage loc with
         | Syntax_util.MenhirMessagesError err -> ()
         | Syntax_util.NoMenhirMessagesError -> (
           let state = state checkpoint in
           let msg = try
             Reason_parser_message.message state
           with
             | Not_found -> "<SYNTAX ERROR>\n"
           in
           Syntax_util.add_error_message Syntax_util.{loc = loc; msg = msg};
         ));
         let checkpoint = I.resume checkpoint in
         (* Enter error recovery state *)
         loop_handle_yacc supplier true checkpoint)
       else
         (* If not in a recoverable state, fail early by raising a
          * customized Error object
          *)
         let loc = last_token_loc supplier in
         let state = state checkpoint in
         (* Check the error database to see what's the error message
          * associated with the current parser state
          *)
         let msg =
           try
             Reason_parser_message.message state
           with
             | Not_found -> "<UNKNOWN SYNTAX ERROR>"
         in
         let msg_with_state = Printf.sprintf "%d: %s" state msg in
         raise (Syntax_util.Error (loc, (Syntax_util.Syntax_error msg_with_state)))
    | I.Rejected ->
       begin
         let loc = last_token_loc supplier in
         raise Syntaxerr.(Error(Syntaxerr.Other loc))
       end
    | I.Accepted v ->
       (* The parser has succeeded and produced a semantic value. *)
       v

  let implementation lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.implementation lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  let interface lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.interface lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  let core_type lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.parse_core_type lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  let toplevel_phrase lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.toplevel_phrase lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  let use_file lexbuf =
    let cp = initial_checkpoint Reason_parser.Incremental.use_file lexbuf in
    loop_handle_yacc (lexbuf_to_supplier lexbuf) false cp

  (* Skip tokens to the end of the phrase *)
  let rec skip_phrase lexbuf =
    try
      match Lexer_impl.token lexbuf with
        Parser_impl.SEMI | Parser_impl.EOF -> ()
      | _ -> skip_phrase lexbuf
    with
      | Lexer_impl.Error (Lexer_impl.Unterminated_comment _, _)
      | Lexer_impl.Error (Lexer_impl.Unterminated_string, _)
      | Lexer_impl.Error (Lexer_impl.Unterminated_string_in_comment _, _)
      | Lexer_impl.Error (Lexer_impl.Illegal_character _, _) -> skip_phrase lexbuf

  let maybe_skip_phrase lexbuf =
    if Parsing.is_current_lookahead Parser_impl.SEMI
    || Parsing.is_current_lookahead Parser_impl.EOF
    then ()
    else skip_phrase lexbuf

  let safeguard_parsing lexbuf fn =
    try fn ()
    with
    | Lexer_impl.Error(Lexer_impl.Illegal_character _, _) as err
      when !Location.input_name = "//toplevel//"->
        skip_phrase lexbuf;
        raise err
    | Syntaxerr.Error _ as err
      when !Location.input_name = "//toplevel//" ->
        maybe_skip_phrase lexbuf;
        raise err
    | Parsing.Parse_error | Syntaxerr.Escape_error ->
        let loc = Location.curr lexbuf in
        if !Location.input_name = "//toplevel//"
        then maybe_skip_phrase lexbuf;
        raise(Syntaxerr.Error(Syntaxerr.Other loc))
    | Error _ as x ->
       let loc = Location.curr lexbuf in
       if !Location.input_name = "//toplevel//"
       then
         let _ = maybe_skip_phrase lexbuf in
         raise(Syntaxerr.Error(Syntaxerr.Other loc))
       else
         raise x
    | x -> raise x

  let format_interface_with_comments (signature, comments) formatter =
    let reason_formatter = Reason_pprint_ast.createFormatter () in
    reason_formatter#signature comments formatter signature
  let format_implementation_with_comments (implementation, comments) formatter =
    let reason_formatter = Reason_pprint_ast.createFormatter () in
    reason_formatter#structure comments formatter implementation
end

module ML = Create_parse_entrypoint (OCaml_syntax)
module JS = Create_parse_entrypoint (JS_syntax)

end
module Reason_implementation_printer
= struct
#1 "reason_implementation_printer.ml"
module Reason_implementation_printer : Printer_maker.PRINTER =
    struct
        type t = Parsetree.structure
        exception Invalid_config = Printer_maker.Invalid_config

        (* Note: filename should only be used with .ml files. See reason_toolchain. *)
        let defaultImplementationParserFor use_stdin filename =
          if Filename.check_suffix filename ".re" then (Reason_toolchain.JS.canonical_implementation_with_comments (Reason_toolchain.setup_lexbuf use_stdin filename), false, false)
          else if Filename.check_suffix filename ".ml" then (Reason_toolchain.ML.canonical_implementation_with_comments (Reason_toolchain.setup_lexbuf use_stdin filename), true, false)
          else (
            raise (Invalid_config ("Cannot determine default implementation parser for filename '" ^ filename ^ "'."))
          )

        (* NB: Not idempotent. *)
        let ppx_show_runtime =
          let open Asttypes in
          let open Parsetree in
          let open Longident in
          let open Ast_helper in
          let open Location in
          let mktypealias (name, params, types) =
            (* Unsure if this is correct. *)
            let attrs = [(mknoloc "nonrec"), PStr []] in
            let manifest = Typ.constr (mknoloc (Lident name)) types in
            Str.type_ [Type.mk ~params ~kind:Ptype_abstract ~manifest ~attrs (mknoloc name)]
          in
          let mkmodulealias name =
            Str.module_ (Mb.mk (mknoloc name) (Mod.ident (mknoloc (Lident name))))
          in
          let mkmoduleinclude name =
            Str.include_ (Incl.mk (Mod.ident (mknoloc (Lident name))))
          in
          let type_aliases =
            let n s = (s, [], []) in
            let a s = (s, [(Typ.var "a"), Invariant], [Typ.var "a"]) in
            List.map mktypealias [n "int"; n "char"; n "string"; n "float"; n "bool";
                                  n "unit"; n "exn"; a "array"; a "list"; a "option";
                                  n "nativeint"; n "int32"; n "int64"; a "lazy_t";
                                  n "bytes"]
          in
          let module_aliases = List.map mkmodulealias ["Pervasives"; "Char"; "String";
            "Printexc"; "Array"; "List"; "Nativeint"; "Int32"; "Int64"; "Lazy";
            "Bytes"; "Hashtbl"; "Queue"; "Stack"; "Set"; "Weak"; "Printf"; "Format";
            "Buffer"]
          in
          let module_includes = List.map mkmoduleinclude ["Pervasives"]
          in
          let structure_items = type_aliases @ module_aliases @ module_includes in
          Str.module_ (Mb.mk (mknoloc "Ppx_deriving_runtime")
                             (Mod.structure structure_items))

        let parse filetype use_stdin filename =
            let ((ast, comments), parsedAsML, parsedAsInterface) =
            (match filetype with
            | `Auto -> defaultImplementationParserFor use_stdin filename
            | `BinaryReason -> Printer_maker.reasonBinaryParser use_stdin filename
            | `Binary -> Printer_maker.ocamlBinaryParser use_stdin filename false
            | `ML ->
                    let lexbuf = Reason_toolchain.setup_lexbuf use_stdin filename in
                    let impl = Reason_toolchain.ML.canonical_implementation_with_comments in
                    (impl lexbuf, true, false)
            | `Reason ->
                    let lexbuf = Reason_toolchain.setup_lexbuf use_stdin filename in
                    let impl = Reason_toolchain.JS.canonical_implementation_with_comments in
                    (impl lexbuf, false, false))
            in
            if parsedAsInterface then
              raise (Invalid_config ("The file parsed does not appear to be an implementation file."))
            else if !Reason_config.add_printers then
              ((ppx_show_runtime::ast, comments), parsedAsML)
            else ((ast, comments), parsedAsML)

        let print printtype filename parsedAsML output_chan output_formatter =
            match printtype with
            | `BinaryReason -> fun (ast, comments) -> (
              (* Our special format for interchange between reason should keep the
               * comments separate.  This is not compatible for input into the
               * ocaml compiler - only for input into another version of Reason. We
               * also store whether or not the binary was originally *parsed* as an
               * interface file.
               *)
              output_value output_chan (
                Config.ast_impl_magic_number, filename, ast, comments, parsedAsML, false
              );
            )
            | `Binary -> fun (ast, comments) -> (
              output_string output_chan Config.ast_impl_magic_number;
              output_value  output_chan filename;
              output_value  output_chan ast
            )
            | `AST -> fun (ast, comments) -> (
              Printast.implementation output_formatter ast
            )
            (* If you don't wrap the function in parens, it's a totally different
             * meaning #thanksOCaml *)
            | `None -> (fun (ast, comments) -> ())
            | `ML -> Reason_toolchain.ML.print_canonical_implementation_with_comments output_formatter
            | `Reason -> Reason_toolchain.JS.print_canonical_implementation_with_comments output_formatter
    end;;

end
module Reason_interface_printer
= struct
#1 "reason_interface_printer.ml"
module Reason_interface_printer : Printer_maker.PRINTER =
    struct
        type t = Parsetree.signature
        exception Invalid_config = Printer_maker.Invalid_config

        (* Note: filename should only be used with .mli files. See reason_toolchain. *)
        let defaultInterfaceParserFor use_stdin filename =
            if Filename.check_suffix filename ".rei"
            then (Reason_toolchain.JS.canonical_interface_with_comments (Reason_toolchain.setup_lexbuf use_stdin filename) , false, true)
            else if Filename.check_suffix filename ".mli"
            then (Reason_toolchain.ML.canonical_interface_with_comments (Reason_toolchain.setup_lexbuf use_stdin filename), true, true)
            else (
                raise (Invalid_config ("Cannot determine default interface parser for filename '" ^ filename ^ "'."))
                )

        let parse filetype use_stdin filename =
            let ((ast, comments), parsedAsML, parsedAsInterface) =
            (match filetype with
            | `Auto -> defaultInterfaceParserFor use_stdin filename
            | `BinaryReason -> Printer_maker.reasonBinaryParser use_stdin filename
            | `Binary -> Printer_maker.ocamlBinaryParser use_stdin filename true
            | `ML ->
                    let lexbuf = Reason_toolchain.setup_lexbuf use_stdin filename in
                    let intf = Reason_toolchain.ML.canonical_interface_with_comments in
                    ((intf lexbuf), true, true)
            | `Reason ->
                    let lexbuf = Reason_toolchain.setup_lexbuf use_stdin filename in
                    let intf = Reason_toolchain.JS.canonical_interface_with_comments in
                    ((intf lexbuf), false, true))
            in
            if not parsedAsInterface then
                raise (Invalid_config ("The file parsed does not appear to be an interface file."))
            else ((ast, comments), parsedAsML)

        let print printtype filename parsedAsML output_chan output_formatter =
            match printtype with
                    | `BinaryReason -> fun (ast, comments) -> (
                      (* Our special format for interchange between reason should keep the
                       * comments separate.  This is not compatible for input into the
                       * ocaml compiler - only for input into another version of Reason. We
                       * also store whether or not the binary was originally *parsed* as an
                       * interface file.
                       *)
                      output_value output_chan (
                        Config.ast_intf_magic_number, filename, ast, comments, parsedAsML, true
                      );
                    )
                    | `Binary -> fun (ast, comments) -> (
                      output_string output_chan Config.ast_intf_magic_number;
                      output_value  output_chan filename;
                      output_value  output_chan ast
                    )
                    | `AST -> fun (ast, comments) -> (
                      Printast.interface output_formatter ast
                    )
                    (* If you don't wrap the function in parens, it's a totally different
                     * meaning #thanksOCaml *)
                    | `None -> (fun (ast, comments) -> ())
                    | `ML -> Reason_toolchain.ML.print_canonical_interface_with_comments output_formatter
                    | `Reason -> Reason_toolchain.JS.print_canonical_interface_with_comments output_formatter
    end;;

end
module Refmt_args
= struct
#1 "refmt_args.ml"
open Cmdliner

let interface =
  let doc = "parse AST as an interface" in
  Arg.(value & opt (bool) false & info ["i"; "interface"] ~doc)

let recoverable =
  let doc = "enable recoverable parser" in
  Arg.(value & flag & info ["r"; "recoverable"] ~doc)

let explicit_arity =
  let doc =
    "if a constructor's argument is a tuple, always interpret it as \
     multiple arguments"
  in
  Arg.(value & flag & info ["e"; "assume-explicit-arity"] ~doc)

let parse_ast =
  let docv = "FORM" in
  let doc = "parse AST in FORM, which is one of: (ml | re | \
             binary (for compiler input) | \
             binary_reason (for interchange between Reason versions))"
  in
  let opts = Arg.enum ["ml", `ML; "re", `Reason;
                       "binary_reason", `BinaryReason; "auto", `Auto]
  in
  Arg.(value & opt (some opts) None & info ["parse"] ~docv ~doc)

let print =
  let docv = "FORM" in
  let doc = "print AST in FORM, which is one of: (ml | re (default) | \
             binary (for compiler input) | \
             binary_reason (for interchange between Reason versions) | \
             ast (print human readable AST directly) | none)"
  in
  let opts = Arg.enum ["ml", `ML; "re", `Reason; "binary", `Binary;
                       "binary_reason", `BinaryReason; "ast", `AST;
                       "none", `None]
  in
  Arg.(value & opt opts `Reason & info ["p"; "print"] ~docv ~doc)

let print_width =
  let docv = "COLS" in
  let doc = "wrapping width for printing the AST" in
  Arg.(value & opt (int) (100) & info ["w"; "print-width"] ~docv ~doc)

let heuristics_file =
  let doc =
    "load path as a heuristics file to specify which constructors are defined with \
     multi-arguments. Mostly used in removing [@implicit_arity] introduced from \
     OCaml conversion.\n\t\texample.txt:\n\t\tConstructor1\n\t\tConstructor2"
  in
  Arg.(value & opt (some file) None & info ["h"; "heuristics-file"] ~doc)

let in_place =
  let doc = "reformat a file in-place" in
  Arg.(value & flag & info ["in-place"] ~doc)

let add_printers =
  let doc = "add auto-printers to user-defined types" in
  Arg.(value & flag & info ["add-printers"] ~doc)

let input =
  let docv = "FILENAME" in
  let doc = "input file" in
  Arg.(value & pos ~rev:true 0 (some file) None & info [] ~docv ~doc)

(* DEPRECATED *)

let is_interface_pp =
  let doc = "is-interface-pp is DEPRECATED; use -i or --interface instead" in
  Arg.(value & flag & info ["is-interface-pp"] ~doc)

let use_stdin =
  let doc = "use-stdin is DEPRECATED; usage is assumed if not specifying a \
             filename"
  in
  Arg.(value & flag & info ["use-stdin"] ~doc)

end
module Refmt_impl
= struct
#1 "refmt_impl.ml"
(* Portions Copyright (c) 2015-present, Facebook, Inc. All rights reserved. *)

open Lexing
open Cmdliner

exception Invalid_config = Printer_maker.Invalid_config

let read_lines file =
  let list = ref [] in
  let chan = open_in file in
  try
    while true do
      list := input_line chan :: !list
    done;
    []
  with End_of_file ->
    close_in chan;
    List.rev !list

let warn s =
  let red s = "\027[31m" ^ s ^ "\x1b[m" in
  prerr_endline (red "WARNING:" ^ " " ^ s)


let refmt
    interface
    is_recoverable
    explicit_arity
    parse_ast
    print
    print_width
    h_file
    in_place
    input_file
    add_printers
    is_interface_pp
    use_stdin
  =
  let err s = raise (Invalid_config s) in
  let () =
    if is_interface_pp then err "--is-interface-pp is deprecated."
    else if use_stdin then err "--use-stdin is deprecated."
  in
  let (use_stdin, input_file) = match input_file with
    | Some name -> (false, name)
    | None -> (true, "")
  in
  let parse_ast = match parse_ast, use_stdin with
    | (Some x, _) -> x
    | (None, false) -> `Auto
    | (None, true) -> `Reason (* default *)
  in
  let constructorLists = match h_file with
    | Some f_name -> read_lines f_name
    | None -> []
  in
  let interface = match interface with
    | true -> true
    | false -> (Filename.check_suffix input_file ".rei" || Filename.check_suffix input_file ".mli")
  in
  let () =
    if interface && add_printers then
      warn "File is an interface. Printers not added."
  in
  let output_file =
    match in_place, use_stdin with
    | (true, true) -> err "Cannot write in place to stdin."
    | (true,    _) -> Some input_file
    | (false,   _) -> None
  in
  let (module Printer : Printer_maker.PRINTER) =
    if interface then (module Reason_interface_printer.Reason_interface_printer)
    else (module Reason_implementation_printer.Reason_implementation_printer)
  in
  Reason_config.configure ~r:is_recoverable ~ap:add_printers;
  Location.input_name := input_file;
  let _ = Reason_pprint_ast.configure
      ~width: print_width
      ~assumeExplicitArity: explicit_arity
      ~constructorLists
  in
  let (ast, parsedAsML) = Printer.parse parse_ast use_stdin input_file in
  let output_chan = Printer_maker.prepare_output_file output_file in
  (* If you run into trouble with this (or need to use std_formatter by
     itself at the same time for some reason), try breaking this out so that
     it's not possible to call Format.formatter_of_out_channel on stdout. *)
  let output_formatter = Format.formatter_of_out_channel output_chan in
  (
    Printer.print print input_file parsedAsML output_chan output_formatter ast;
    (* Also closes all open boxes. *)
    Format.pp_print_flush output_formatter ();
    flush output_chan;
    Printer_maker.close_output_file output_file output_chan;
    `Ok ()
  )

let top_level_info =
  let doc = "Meta language utility" in
  let man = [`S "DESCRIPTION"; `P "refmt is a parser and pretty-printer"] in
  let version = "Reason " ^ Package.version ^ " @ " ^ Package.git_short_version
  in
  Term.info "refmt" ~version ~doc ~man

let refmt_t =
  let open Term in
  let open Refmt_args in
  let open Cmdliner_shim in
  let handler = function
    | Invalid_config msg -> msg
    | exn ->
            Location.report_exception Format.err_formatter exn;
            exit 1
  in
  let refmt = wrap refmt handler in
  load (const refmt $ interface
                    $ recoverable
                    $ explicit_arity
                    $ parse_ast
                    $ print
                    $ print_width
                    $ heuristics_file
                    $ in_place
                    $ input
                    $ add_printers
                    $ is_interface_pp
                    $ use_stdin)

let () =
  match Term.eval ((Term.ret refmt_t), top_level_info) with
  | `Error s -> exit 1
  | _ -> exit 0

end
