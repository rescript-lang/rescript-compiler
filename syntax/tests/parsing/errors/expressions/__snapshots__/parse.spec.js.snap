// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ambiguousArrow.js 1`] = `
"=====Parsetree==========================================
let a b = (\\"hi\\" : int)
let x = ((let a = 1 in let b = 2 in fun pattern -> (\\"test\\" : int))
  [@ns.braces ])
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/ambiguousArrow.js\\", line 1, characters 8-21:


[31m1[0m â”‚  let a = [31mb:int => \\"hi\\"[0m
2 â”‚  
3 â”‚  let x = {

Did you mean to annotate the parameter type or the return type?
  1) (b): int => \\"hi\\"
  2) (b: int) => \\"hi\\"



File \\"/syntax/tests/parsing/errors/expressions/ambiguousArrow.js\\", line 6, characters 2-23:


4 â”‚    let a = 1
5 â”‚    let b = 2
[31m6[0m â”‚    [31ma + b : int => \\"test\\"[0m
7 â”‚  }

Did you mean to annotate the parameter type or the return type?
  1) (pattern): int => \\"test\\"
  2) (pattern: int) => \\"test\\"




========================================================"
`;

exports[`array.js 1`] = `
"=====Parsetree==========================================
let xs = x.map (fun key -> [|key;(predicates.(key))|])
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/array.js\\", line 2, characters 43-44:


1 â”‚  // missing ] before )
[31m2[0m â”‚  let xs = x.map(key => [key, predicates[key])          
                                                 [31m^[0m

Did you forget a \`]\` here? 



========================================================"
`;

exports[`arrow.js 1`] = `
"=====Parsetree==========================================
;;(Object.keys providers).reduce
    (fun elements ->
       fun providerId -> ((let x = 1 in let b = 2 in x + b)[@ns.braces ]))
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/arrow.js\\", line 1, characters 51-52:


[31m1[0m â”‚  Object.keys(providers).reduce((elements, providerId] => {          
                                                         [31m^[0m
2 â”‚    let x = 1
3 â”‚    let b = 2

Did you forget a \`,\` here? 



========================================================"
`;

exports[`block.js 1`] = `
"=====Parsetree==========================================
let findThreadByIdLinearScan ~threads:((threads)[@ns.namedArgLoc ]) 
  ~id:((id)[@ns.namedArgLoc ])  =
  ((Js.Array2.findi ThreadsModel.threads
      (fun thread ->
         fun i ->
           ((let thisId =
               match thread with
               | ServerData.OneToOne { otherPersonIDWhichIsAlsoThreadID } ->
                   otherPersonIDWhichIsAlsoThreadID
               | Group { id } -> id
               | Unknown { id } ->
                   (unknown.id |. Js.String.make) |. FBID.ofStringUnsafe in
             thisId == id)
           [@ns.braces ])))
  [@ns.braces ])
let x = ((loop 0 (Nil |. (push doc)))[@ns.braces ])
;;match stack with
  | Empty -> [%napkinscript.exprhole ]
  | Cons (doc, rest) -> ()
  | Join (doc1, doc2) -> (buffer |. (Buffer.add_string indentation); loop ())
let pipeline =
  match scheduler with | Some -> [%napkinscript.exprhole ] | None -> ()
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/block.js\\", line 14, characters 3-5:


12 â”‚  
13 â”‚      thisId === id
[31m14[0m â”‚    }          
         [31m^[0m
15 â”‚  }
16 â”‚  

Did you forget a \`)\` here? 


File \\"/syntax/tests/parsing/errors/expressions/block.js\\", line 18, characters 24-26:


16 â”‚  
17 â”‚  let x = {
[31m18[0m â”‚    loop(0, Nil->push(doc)          
                              [31m^[0m
19 â”‚  } // closing ) above is missing
20 â”‚  

Did you forget a \`)\` here? 


File \\"/syntax/tests/parsing/errors/expressions/block.js\\", line 22, characters 10-12:


20 â”‚  
21 â”‚  switch stack {
[31m22[0m â”‚  | Empty =>
23 â”‚  | Cons(doc, rest) => ()
24 â”‚  | Join(doc1, doc2) =>

Looks like there might be an expression missing here


File \\"/syntax/tests/parsing/errors/expressions/block.js\\", line 26, characters 6-8:


24 â”‚  | Join(doc1, doc2) =>
25 â”‚  	buffer->Buffer.add_string(indentation)
[31m26[0m â”‚  	loop(          
            [31m^[0m
27 â”‚  }
28 â”‚  

Did you forget a \`)\` here? 


File \\"/syntax/tests/parsing/errors/expressions/block.js\\", line 30, characters 9-11:


28 â”‚  
29 â”‚  let pipeline = switch scheduler {
[31m30[0m â”‚  | Some =>
31 â”‚  | None => ()
32 â”‚  }

Looks like there might be an expression missing here



========================================================"
`;

exports[`consecutive.ns 1`] = `
"=====Parsetree==========================================
let f a b = a + 3
;;b
let f g h = ((a + 3; b)[@ns.braces ])
let () = ((sideEffect1 (); sideEffect2 ())[@ns.braces ])
let () = ((let open Foo in let exception End  in x ())[@ns.braces ])
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/consecutive.ns\\", line 1, characters 22-23:


[31m1[0m â”‚  let f = (a,b) => a + 3[31mb[0m;
2 â”‚  
3 â”‚  let f = (g, h) => {

consecutive statements on a line must be separated by ';' or a newline


File \\"/syntax/tests/parsing/errors/expressions/consecutive.ns\\", line 4, characters 6-7:


2 â”‚  
3 â”‚  let f = (g, h) => {
[31m4[0m â”‚   a + 3[31mb[0m
5 â”‚  }
6 â”‚  

consecutive expressions on a line must be separated by ';' or a newline


File \\"/syntax/tests/parsing/errors/expressions/consecutive.ns\\", line 8, characters 15-27:


6 â”‚  
7 â”‚  let () = {
[31m8[0m â”‚    sideEffect1()[31m sideEffect2[0m()
9 â”‚  }
10 â”‚  

consecutive expressions on a line must be separated by ';' or a newline


File \\"/syntax/tests/parsing/errors/expressions/consecutive.ns\\", line 12, characters 10-20:


10 â”‚  
11 â”‚  let () = {
[31m12[0m â”‚    open Foo[31m exception[0m End
13 â”‚    x()
14 â”‚  }

consecutive expressions on a line must be separated by ';' or a newline



========================================================"
`;

exports[`emptyBlock.js 1`] = `
"=====Parsetree==========================================
let x = ((())[@ns.braces ])
let f a b = ((())[@ns.braces ])
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/emptyBlock.js\\", line 1, characters 9-10:


[31m1[0m â”‚  let x = {[31m}[0m
2 â”‚  
3 â”‚  let f = (a, b) => {}

This let-binding misses an expression


File \\"/syntax/tests/parsing/errors/expressions/emptyBlock.js\\", line 3, characters 19-20:


1 â”‚  let x = {}
2 â”‚  
[31m3[0m â”‚  let f = (a, b) => {[31m}[0m

Missing expression



========================================================"
`;

exports[`if.js 1`] = `
"=====Parsetree==========================================
;;if match then let a = 1 in a + 1
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/if.js\\", line 2, characters 10-16:


1 â”‚  // missing brace below
[31m2[0m â”‚  if (match)          
                [31m^[0m
3 â”‚    let a = 1
4 â”‚    a + 1

Did you forget a \`{\` here? 



========================================================"
`;

exports[`misc.js 1`] = `
"=====Parsetree==========================================
let x = ([%napkinscript.exprhole ]) + 1
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/misc.js\\", line 1, characters 8-9:


[31m1[0m â”‚  let x = [31m_[0m + 1

\`_\` isn't a valid name.



========================================================"
`;

exports[`record.js 1`] = `
"=====Parsetree==========================================
let newWrapper = { updateF; value = (f xWrapper.currentValue) }
let newWrapper = { updateF; updateF2; value = (f xWrapper.currentValue) }
let record = { field = ([%napkinscript.exprhole ]) }
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/record.js\\", line 2, characters 9-17:


1 â”‚  let newWrapper = {
[31m2[0m â”‚    updateF          
               [31m^[0m
3 â”‚    value: f(xWrapper.currentValue),
4 â”‚  }

Did you forget a \`,\` here? 


File \\"/syntax/tests/parsing/errors/expressions/record.js\\", line 8, characters 9-18:


6 â”‚  
7 â”‚  let newWrapper = {
[31m8[0m â”‚    updateF updateF2          
               [31m^[0m
9 â”‚    value: f(xWrapper.currentValue),
10 â”‚  }

Did you forget a \`:\` here? 


File \\"/syntax/tests/parsing/errors/expressions/record.js\\", line 13, characters 8-13:


11 â”‚  
12 â”‚  let record = {
[31m13[0m â”‚    field:
14 â”‚  }
15 â”‚  

Missing expression



========================================================"
`;

exports[`setField.js 1`] = `
"=====Parsetree==========================================
;;if match
  then
    let a = 1 in (m.left).compatibleTypeArgs <- ([%napkinscript.exprhole ])
  else sideEffect ()
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/setField.js\\", line 4, characters 29-31:


2 â”‚    let a = 1
3 â”‚  	// notice missing expression after = 
[31m4[0m â”‚    m.left.compatibleTypeArgs =
5 â”‚  } else {
6 â”‚    sideEffect()

It seems that this record field mutation misses an expression



========================================================"
`;

exports[`taggedTemplateLiterals.js 1`] = `
"=====Parsetree==========================================
;;{js|null|js}
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/taggedTemplateLiterals.js\\", line 1, characters 0-5:


[31m1[0m â”‚  [31mfoo()[0m\`null\`

Tagged template literals are currently restricted to identifiers like: json\`null\`.



========================================================"
`;

exports[`try.js 1`] = `
"=====Parsetree==========================================
let parsedPayload = try Js.Json.parseExn response with | _ -> Js.Json.null
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/try.js\\", line 2, characters 36-38:


1 â”‚    let parsedPayload =
[31m2[0m â”‚      try (Js.Json.parseExn(response)) {          
                                          [31m^^^^^[0m
3 â”‚      | _ => Js.Json.null
4 â”‚      }

Did you forget a \`catch\` here? 



========================================================"
`;

exports[`unexpectedConstraint.js 1`] = `
"=====Parsetree==========================================
let x = ((let a = 1 in let b = 2 in (a + b : int))[@ns.braces ])
let x = (\\"hi\\" : string)
=====Errors=============================================

File \\"/syntax/tests/parsing/errors/expressions/unexpectedConstraint.js\\", line 4, characters 2-13:


2 â”‚    let a = 1
3 â”‚    let b = 2
[31m4[0m â”‚    [31ma + b : int[0m
5 â”‚  }
6 â”‚  

Expressions with type constraints need to be wrapped in parens:
  (a + b: int)



File \\"/syntax/tests/parsing/errors/expressions/unexpectedConstraint.js\\", line 7, characters 8-20:


5 â”‚  }
6 â”‚  
[31m7[0m â”‚  let x = [31m\\"hi\\": string[0m 

Expressions with type constraints need to be wrapped in parens:
  (\\"hi\\": string)




========================================================"
`;
