// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`apply.js 1`] = `
"console.log()
Js.log(\\"arg1\\", \\"arg2\\")
let rbt = make(~compare)
let rbt = make(~compare?)
let rbt = make(~compare=intCompare)
let rbt = make(~compare=?intCompare)
let rbt = make(~compare=?(intCompare: (int, int) => int))

let () = applyFunctionToArguments(
  superLongIdentifierWooooooowThisIsSuchLong,
  superLongIdentifierWooooooowThisIsSuchLong,
  superLongIdentifierWooooooowThisIsSuchLong,
  superLongIdentifierWooooooowThisIsSuchLong,
)

let cmp = rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value)
let cmp = rbt.compare2(.
  Js.Array2.unsafe_get(old, oldIter.contents),
  longerNode.longValue,
)
let uncurriedUnit = apply(.)

let coordinate = make2dCoordinate({x: 1, y: 2})
let coordinate = make3dCoordinate({
  ...base,
  field1: thisIsAPrettyLongNameHere,
  field2: thisIsAPrettyLongNameHere,
  field3: thisIsAPrettyLongNameHere,
})

let coordinate = make2dCoordinateArray([x, y])
let coordinate = make3dCoordinateArray([
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
])

let coordinate = make2dCoordinateTuple((x, y))
let coordinate = make3dCoordinateTuple((
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
))

let coordinate = make2dCoordinateList(list{x, y})
let coordinate = make3dCoordinateList(list{
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  thisIsAPrettyLongNameHere,
  ...allCoords,
})

let coordinate = makeJsCoordinate({\\"x\\": 1, \\"y\\": 1})
let user = makeJsUser({
  \\"name\\": \\"steve\\",
  \\"age\\": 32,
})

let x = @attr callFunction()
let x =
  @attrWithLongName @attrWithLongName @attrWithLongName @attrWithLongName
  callFunction()

(a |> f)(b, c)

call(~a: int)
call(~\\\\\\"let\\": int)

document.createElementWithOptions(.
  \\"div\\",
  elementProps(~onClick=_ => Js.log(\\"hello world\\")),
)
"
`;

exports[`array.js 1`] = `
"let x = []
let x = [a, b, c]
let x = [
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
]

let x = @attr [a, b, c]
let x = @attr [@attr a, @attr b, @attr c]

let x =
  @attr
  [
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
    @attr superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  ]

let x = [biggerThanZero ? 1 : 0, biggerThanZero ? 1 : 0]
"
`;

exports[`arrayGet.js 1`] = `
"let street = streets[0]

let streetWithAVeryVeryVerrrrrrryVeeeeeeeeeryLongName =
  streetsAddressBookThisIsALongName[0]

let streetWithAVeryVeryVerrrrrrryVeeeeeeeeeryLongName =
  streetsAddressBookThisIsALongName[streets->Belt.Array.length - 1]

let streetWithAVeryVeryVerrrrrrryVeeeeeeeeeryLongName =
  streetsAddressBookThisIsALongName[
    streetsAddressBookThisIsALongName.streets->Belt.Array.length - 1
  ]

let street = @attr streets[0]
"
`;

exports[`arraySet.js 1`] = `
"numbers[20] = 10

streetsAddressBookThisIsALongName[
  streets->Belt.Array.length - 1
] = streetWithAVeryVeryVerrrrrrryVeeeeeeeeeryLongName
"
`;

exports[`assert.js 1`] = `
"assert false

assert truth

let x = assert true
let x = assert 12
let x = assert (12: int)
let x = assert 12
let x = assert list{1, 2, ...x}
let x = assert module(Foo: Bar)
let x = assert module(Foo)
let x = assert Rgb(1, 2, 3)
let x = assert [a, b, c]
let x = assert {x: 1, y: 3}
let x = assert (1, 2, 3)
let x = assert %extension
let x = assert user.name
let x = assert streets[0]
let x = assert apply(arg1, arg2)
let x = assert apply(. arg1, arg2)
let x = assert -1
let x = assert !true
let x = assert (x => print(x))
let x = assert (
  switch x {
  | Blue => ()
  | Yello => ()
  }
)

let x = assert (
  for i in 0 to 10 {
    print_int(i)
  }
)

let x = assert (
  if i < 10 {
    print_int(i)
  } else {
    print_int(1000)
  }
)

let x = assert (
  while i < 10 {
    print_int(i)
  }
)

let x = assert (lazy false)
let x = assert (
  try sideEffect() catch {
  | Exit => ()
  }
)

let x = assert (@attr expr)

let x = assert (a + b)

let x = @attr assert false

assert invariant[\\"fatal\\"]
assert invariants[0]

assert address[\\"street\\"] = \\"Brusselsestraat\\"

assert (true ? 0 : 1)
"
`;

exports[`binary.js 1`] = `
"let x = a + b
let x = @attr (a + b)
let x = @attr (@attr a + @attr b)
let x = a && b + c
let x = (a && b) + c
let x = (a && b) || c

let x = (a && b) + (c && d)

while (
  continuePrefix.contents &&
  aPrefixLen.contents &&
  bPrefixLen.contents &&
  foobarLen.contents
) {
  ()
}

// uncurried attribute shouldn't result in parens
while (
  rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value) < 0
) {
  ()
}

// unary expr as child of binary expr doesn't need parens
let x =
  !filePath.includes(allMlSuffixesCategory) &&
  !filePath.endsWith(allScriptDirectoriesCategory)

let name = names[0] ++ names[1]
let name = user[\\"firstName\\"] ++ user[\\"lastName\\"]

let x = foo ++ bar
let x = foo != bar
let x = foo !== bar

let x = foo ++ bar
let x = 1 + 1
let x = (a => a + 1) + (b => b + 2)
let x = -1 + -1
let x = switch z {
| Red => 1
} |> switch y {
| Blue => 2
}
let x = try z catch {
| Exit => 1
} |> try y catch {
| Blue => 2
}
let x =
  if true {
    1
  } else {
    2
  } + if false {
    2
  } else {
    3
  }
let x = for i in 0 to 10 {
  ()
} |> for i in 0 to 10 {
  ()
}

let x = (a, b) + (b, c)
let x = Vec3(a, b, c) + Vec4(a, b, c, d)
let x = {x: 1, y: 2} + {x: 2, y: 3}
let x = user.firstName ++ user.lastName
let x = x.left = value |> x.right = value
let x = (x.left = value) |> x.right = value
let x = (x.left = value) |> x.right = value
let () = (x.left = value) |> logMutation
let () = x.left = value |> logMutation
let () = x.left = value |> process |> x.right = value |> process
let () = (x: int) |> (print_int: int => unit)

// math
x + y / z
x / y + z
100 * x / total
2 / 3 * 10 / 2 + 2
let rotateX =
  (range / rect.height * refY - range / 2) * getXMultiplication(rect.width)
let rotateY =
  (range / rect.width * refX - range / 2) * getYMultiplication(rect.width)

let x = longIdentifier + longIdentifier + longIdentifier
let x =
  longIdentifier +
  longIdentifier +
  longIdentifier +
  longIdentifier -
  longIdentifier +
  longIdentifier
let x =
  longIdentifier +
  longIdentifier * longIdentifier +
  longIdentifier -
  longIdentifier +
  longIdentifier
let x =
  longIdentifier +
  longIdentifier * longIdentifier * longIdentifier / longIdentifier +
  longIdentifier

let x =
  longIdentifier &&
  longIdentifier &&
  longIdentifier &&
  longIdentifier &&
  longIdentifier &&
  longIdentifier
let x =
  (longIdentifier && longIdentifier) ||
  longIdentifier && longIdentifier ||
  (longIdentifier && longIdentifier)

if (
  successorParent.color === Black &&
    (sibling === None ||
      ((siblingNN.color === Black && siblingNN.left === None) ||
      (siblingNN.left->castNotOption).color === Black &&
        (siblingNN.right === None ||
          (siblingNN.right->castNotOption).color === Black)))
) {
  if sibling !== None {
    siblingNN.color = Red
  }
  successorRef.contents = successorParent
}

let truth =
  longEqualityExpression.someRecordField ==
    wowThisDoesHaveToBePrettyLong.someRecordField &&
    longEqualityExpression.someRecordField ==
      wowThisDoesHaveToBePrettyLong.someRecordField

while (
  continuePrefix.contents &&
  aPrefixLen.contents <= aLen &&
  bPrefixLen.contents <= bLen
) {
  let nextNonwhiteA = nextNonWhiteChar(aStr, 1, aPrefixLen.contents - 1)
  let nextNonwhiteB = nextNonWhiteChar(bStr, 1, bPrefixLen.contents - 1)
}
let () = {
  let () = sideEffect()
  if (
    (isLeft(successor) && sibling.right === None) ||
      ((sibling.right->castNotOption).color === Black &&
      sibling.left !== None &&
      (sibling.left->castNotOption).color === Red)
  ) {
    sibling.color = Red
    sibling.left->castNotOption.color = Black
    rotateRight(rbt, sibling)
  }
  if sibling !== None && (sibling->castNotOption).color === Black {
    let sibling = sibling->castNotOption
    if (
      (isLeft(successor) && sibling.right === None) ||
        ((sibling.right->castNotOption).color === Black &&
        sibling.left !== None &&
        (sibling.left->castNotOption).color === Red)
    ) {
      sibling.color = Red
      sibling.left->castNotOption.color = Black
      rotateRight(rbt, sibling)
    } else if (
      (!isLeft(successor) && sibling.left === None) ||
        ((sibling.left->castNotOption).color === Black &&
        sibling.right !== None &&
        (sibling.right->castNotOption).color === Red)
    ) {
      sibling.color = Red
      sibling.right->castNotOption.color = Black
      rotateLeft(rbt, sibling)
    }
    break.contents = true
  } else {
    let sibling = siblingOf(successor)
    let sibling = sibling->castNotOption
    sibling.color = successorParent.color
    if isLeft(successor) {
      sibling.right->castNotOption.color = Black
      rotateRight(rbt, successorParent)
    } else {
      sibling.left->castNotOption.color = Black
      rotateLeft(rbt, successorParent)
    }
  }
}

let x = a && (b || c)
let x = a && (b || c) && d
let x = a && b + c
let x = a && b + c && d

let x = a && @attr b && c
let x = @attr a && @attr b && @attr c
let x = a && @attr (b && c)
let x = a && @attr (b && c) && @attr (d && e)

let x = a && @attr (x |> f(g))
let x = a && @attr (x |> f(g)) && @attr (y |> f(h))

let x = a && a.b
let x = a && x.y && g.h
let x = a && true
let x = a && true && true
let x =
  a && {
    let a = true
    let b = true
    a || b
  }
let x =
  a &&
  {
    let a = true
    let b = true
    a || b
  } && {
    let a = true
    let b = true
    a || b
  }

let x = a && (x => x->Js.log)
let x = a && (x => x->Js.log) && (x => x->Js.log)

let x = a && !b
let x = a && !b && !c

let x = a && f(b)
let x = a && f(b) && f(c)

let x = a && f(. b)
let x = a && f(. b) && f(. c)

let x = a && x |> f(g)
let x = a && x |> f(g) && y |> f(h)

let x =
  a &&
  switch color {
  | Blue => \\"blue\\"
  | Red => \\"red\\"
  }
let x =
  a &&
  switch color {
  | Blue => \\"blue\\"
  | Red => \\"red\\"
  } &&
  switch color {
  | Blue => \\"blue\\"
  | Red => \\"red\\"
  }

let x =
  a && try unsafe() catch {
  | Error => ()
  }

let x =
  a &&
  try unsafe() catch {
  | Error => ()
  } && try unsafe() catch {
  | Error => ()
  }

let x = a && (a, b)
let x = a && (a, b) && (c, d)

let x = a && Foo(x, y)
let x = a && Foo(x, y) && Foo(x, y, z)

let x = a && {x: 1, y: 2}
let x = a && {x: 1, y: 2} && {x: 3, y: 3}

let x = a && b.c
let x = a && b.c && d.e

let x = a && row.id = 1
let x = a && (row.id = 1) && row2.id = 3

let x = a && [a, b]
let x = a && [a, b] && [c, d]

let x =
  a && if true {
    true
  } else {
    false
  }
let x =
  a &&
  if true {
    true
  } else {
    false
  } && if false {
    false
  } else {
    true
  }

let x =
  a && {
    sideEffect()
    do()
  }
let x =
  a &&
  {
    sideEffect()
    do()
  } && {
    sideEffect()
    do()
  }

let x =
  a && while true {
    do()
  }
let x =
  a &&
  while true {
    do()
  } && while true {
    do()
  }

let x =
  a && for i in 0 to 10 {
    true
  }
let x =
  a &&
  for i in 0 to 10 {
    true
  } && for i in 0 to 10 {
    false
  }

let x = a && (truth: bool)
let x = a && (truth: bool) && (otherTruth: bool)

let x =
  a && {
    module L = Log
    L.log()
  }
let x =
  a &&
  {
    module L = Log
    L.log()
  } && {
    module L = Log
    L.log()
  }

let x =
  a && {
    exception Exit
    raise(Exit)
  }
let x =
  a &&
  {
    exception Exit
    raise(Exit)
  } && {
    exception Exit
    raise(Exit)
  }

let x = a && assert false
let x = a && assert false && assert true

let x = a && lazy false
let x = a && lazy false && lazy true

let x =
  a && {
    open React
    killPerform()
  }
let x =
  a &&
  {
    open React
    killPerform()
  } && {
    open Dom
    regainPerform()
  }

let x = a && %bs.raw(\\"true\\")
let x = a && %bs.raw(\\"true\\") && %bs.raw(\\"false\\")

let x = a && module(Foo)
let x = a && module(Foo) && module(Bar)

let x = a && module(Foo: Bool)
let x = a && module(Foo: Bool) && module(Bar: Bool)

let x = a && truths[0]
let x = a && truths[0] && truths[1]

let () = node.left := value |> process |> node.right = value |> process
let () = (node.left := value |> process) |> node.right = value |> process

let x = (true ? 0 : 1) + (false ? 1 : 0)
let x = (true ? 0 : 1) + (false ? 1 : 0) + (false ? 1 : 0)

while (
  oldIter.contents < oldLen &&
    rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value)
) {
  disappear(. Js.Array2.unsafe_get(old, oldIter.contents))
  oldIter.contents = oldIter.contents + 1
}

while (
  oldIter.contents < oldLen &&
    rbt.compare(. Js.Array2.unsafe_get(old, oldIter.contents), node.value) < 0
) {
  disappear(. Js.Array2.unsafe_get(old, oldIter.contents))
  oldIter.contents = oldIter.contents + 1
}

let x =
  oldIter.contents < oldLen &&
    rbt.compare(Js.Array2.unsafe_get(old, oldIter.contents), node.value) <
    veryLongIdentifier

// should be formatted on one line, i.e. NOT break
let fullCircle = 2. *. pi

a + b + c
a + b - c
a < b < c

a + (b + c)
a + (b + (c + d))
a + (b - (c - d))
a < (b < c)
a < (b < (c < d))

a || b || c
a || (b || c)
a || (b || (c || d))

a && b && c
a && (b && c)
a && (b && (c && d))

(a && b) || c
a && (b || c)

x->(y->z)
x->(y->(z->w))
x->(y && (w && z))
x->y->z

x |> y |> z
x |> (y |> z)
x |> (y |> (z |> w))

let x = \\"z\\" ++ (a |> f) ++ \\"x\\"
let toString = functionArgs => {
  functionArgs == []
    ? \\"\\"
    : \\"<\\" ++
      (functionArgs |> List.map(argToString) |> String.concat(\\",\\")) ++ \\">\\"
}

a |> Author.id != (author |> Author.id)

// should indent the switch
foo :=
  switch bar.contents {
  | _ => 1
  }

<div>
  {possibleGradeValues
  |> List.filter(g => g < state.maxGrade)
  |> List.map(possibleGradeValue =>
    <option
      key={possibleGradeValue |> string_of_int}
      value={possibleGradeValue |> string_of_int}>
      {possibleGradeValue |> string_of_int |> str}
    </option>
  )
  |> Array.of_list
  |> ReasonReact.array}
</div>

let aggregateTotal = (forecast, ~audienceType) =>
  Js.Nullable.toOption(forecast[\\"audiences\\"])
  ->Option.flatMap(item => Js.Dict.get(item, audienceType))
  ->Option.map(item => {
    pages: item[\\"reach\\"][\\"pages\\"],
    views: item[\\"reach\\"][\\"views\\"],
    sample: item[\\"reach\\"][\\"sample\\"],
  })
"
`;

exports[`block.js 1`] = `
"let x = {
  module Foo = Bar
  exception Exit
  open Belt
  let a = 1
  let b = 2
  sideEffect()
  sideEffect2()
  ()
}

let () = {
  let () = foo() // don't print unit on the next line
}

let reifyStyle = (type a, x: 'a): (style<a>, a) => {
  module Internal = {
    type rec constructor
    @bs.val
    external canvasGradient: constructor = \\"CanvasGradient\\" /* internal */
    @bs.val external canvasPattern: constructor = \\"CanvasPattern\\" /* internal */
    let instanceOf = (
      %bs.raw(\`function(x,y) {return +(x instanceof y)}\`): (
        'a,
        constructor,
      ) => bool
    ) /* internal */
  }

  (
    if Js.typeof(x) == \\"string\\" {
      Obj.magic(String)
    } else if Internal.instanceOf(x, Internal.canvasGradient) {
      Obj.magic(Gradient)
    } else if Internal.instanceOf(x, Internal.canvasPattern) {
      Obj.magic(Pattern)
    } else {
      raise(
        Invalid_argument(
          \\"Unknown canvas style kind. Known values are: String, CanvasGradient, CanvasPattern\\",
        ),
      )
    },
    Obj.magic(x),
  )
}

React.useEffect0(() => {
  let watcherId = watchUrl(url => setUrl(_ => url))

  @ocaml.doc(
    \\"\\\\n      * check for updates that may have occured between\\\\n      * the initial state and the subscribe above\\\\n      \\"
  )
  let newUrl = dangerouslyGetInitialUrl()
  if urlNotEqual(newUrl, url) {
    setUrl(_ => newUrl)
  }

  Some(() => unwatchUrl(watcherId))
})

<div
  onClick={event => {
    switch videoContainerRect {
    | Some(videoContainerRect) =>
      let newChapter = ({startTime: percent *. duration}: Video.chapter)
      {a: a, b: b}->onChange
    | _ => ()
    }
  }}
/>

let calc_fps = (t0, t1) => {
  let delta = (t1 -. t0) /. 1000.
  1. /. delta
}
"
`;

exports[`braced.js 1`] = `
"let f = (a, b) => {a + b}
let f = (a, b) => {a}

let f = (a, b) => {
  a + b
}

let f = (a, b) => {
  a
}

let x = {a}
let x = {a + b}

let x = {
  // here
  a
}

let x = {
  // here
  a + b
}

let _ = {a}

let _ = {\\"constant\\"}

let _ = {() => Js.log(\\"test\\")}
let _ = {
  switch b {
  | true => ()
  | false => ()
  }
}
let _ = switch {b} {
| true => ()
| false => ()
}
let _ = {apply(a, b)}
let _ = {apply}(a, b)

let _ = {
  try danger() catch {
  | Exit => ()
  }
}
let _ = try {danger()} catch {
| Exit => ()
}

let _ = ({a}, {b}, {x + y})
let _ = {({a}, {b}, {x + y})}

let _ = {Rgb(r, g, b)}
let _ = Rgb({r}, {g}, {b})
let _ = Rgb(
  {
    r
  },
  {
    g
  },
  {
    b
  },
)

let _ = {{name: \\"steve\\", age: 30}}
let _ = {name: {\\"steve\\"}, age: {30}}
let _ = {
  name: {
    \\"steve\\"
  },
  age: {
    30
  },
}

let _ = {user.name}.toString()
let _ = {{user.name}.toString()}
let _ = {user.name}.first
let _ = {{user.name}.first}

let _ = {[a, b, c]}
let _ = [{a}, {b}, {c}]
let _ = [
  {
    a
  },
  {
    b
  },
  {
    c
  },
]

let _ = {list{a, b, c}}
let _ = {list{{a}, {b}, {c}}}
let _ = {
  list{
    {
      a
    },
    {
      b
    },
    {
      c
    },
  }
}

let _ = list{1, 2, ...{list2}}

let _ = {true} ? {true} : {false}
let _ = {{true} ? {true} : {false}}

let _ = {
  if true {
    ()
  } else {
    ()
  }
}
let _ = {
  if {true} {
    ()
  } else {
    ()
  }
}

if {
  true
} {
  ()
} else if {
  false
} {
  ()
}

if {
  true
} {
  ()
} else if {
  false
} {
  ()
} else {
  ()
}

let _ = {
  while true {
    ()
  }
}
let _ = while {true} {
  ()
}
while {/* c0 */ true /* c1 */} {
  ()
}
while (
  {
    true
  }
) {
  ()
}
while (
  {
    /* c0 */ true // c1
  }
) {
  ()
}

let _ = {
  for _ in {0} to {10} {
    ()
  }
}
for _ in {
  0
} to {
  10
} {
  ()
}

let _ = {(foo: string)}
let f = (): string => {foo} // equivalent to  (): string => ...

let localToGlobalX = (
  x: coordinate<localCoordinates>,
  ~centering: coordinate<localCoordinates>,
): coordinate<globalCoordinates> => {
  x +. (Environment.width /. 2. -. centering.x)
}
map((arr, i): coordinate<globalCoordinates> => {
  x +. (Environment.width /. 2. -. centering.x)
})

let _ = assert {true}
let _ = {assert {true}}
let _ = {lazy {true}}

let _ = {%extension}
let _ = {module(ME)}
let _ = {module(ME: MyMod)}

{myArray}[{0}]
{
  myArray
}[{
  0
}]
{myArray}[{0}] = {20}
{
  myArray
}[{
  0
}] = {
  20
}

myArray[20] = {
  a + b
}

{jsObject}[\\"foo\\"]
{jsObject}[\\"foo\\"] = {\\"bar\\"}
{jsObject}[\\"foo\\"] = {
  a + b
}

{
  jsObject
}[\\"foo\\"]
{jsObject}[\\"foo\\"] = {\\"bar\\"}

apply({a}, {b}, {c})
apply(
  {
    a
  },
  {
    b
  },
  {
    c
  },
)

Thing.map(foo, (arg1, arg2) => {MyModuleBlah.toList(argument)})
Thing.map({foo}, (arg1, arg2) => {
  MyModuleBlah.toList(argument)
})

Thing.map(
  {fooSuperLongIdentifierName},
  {fooSuperLongIdentifierName},
  {fooSuperLongIdentifierName},
  (arg1, arg2) => {
    MyModuleBlah.toList(argument)
  },
)

arr->Belt.Array.map(x => {
  a
})

apply(~a={a})
apply({
  a
})
apply(.{
  a
})

let x = {<div> child </div>}

// not valid jsx
let x = {@JSX child}

let x = {
  // comment1
  a + b
}

let x = {
  // commment2
  !truth
}

{
  /* c0 */
  x
  /* c1 */
}

{
  // comment
  a +
  b
}

{a} + {b}
{
  a
} +
{
  b
}
"
`;

exports[`bsObj.js 1`] = `
"let user = {
  \\"name\\": \\"Steve\\",
  \\"age\\": 30,
}

let coord = {\\"x\\": 1, \\"y\\": 2}

let person = {
  \\"name\\": {
    \\"first\\": \\"Bob\\",
    \\"last\\": \\"Zhmith\\",
  },
  \\"age\\": 32,
}
"
`;

exports[`callback.js 1`] = `
"array->Js.Array2.forEach(((value, height)) => add(rbt, value, ~height)->ignore)
someArray->Js.Array2.forEach(((value, height)) =>
  add(rbt, value, ~height)->ignore
)
someArraaaaaaayWithAVeryLooooooooooooooooooooooooooooooooooooooongName->Js.Array2.forEach(
  ((value, height)) => add(rbt, value, ~height)->ignore,
)

let make = (arr, ~compare) => {
  let rbt = make(~compare)
  array->Js.Array2.forEach(((value, height)) =>
    add(rbt, value, ~height)->ignore
  )
  rbt
}

Thing.map(foo, (arg1, arg2) => MyModuleBlah.toList(argument))
Thing.map(foo, bar, baz, (aaaaaaaaaaarg1, aaaaarg2) =>
  MyModuleBlah.toList(argument)
)
Thing.map(fooooooooooooooooooo, bar, baz, (abc, z) =>
  MyModuleBlah.toList(argument)
)
Thing.map(
  fooooooooooooooooooo,
  baaaaaaaaaaaaaaaaaar,
  baaaaaaaaaaaaaaaaaaaaaaaaaz,
  (abc, z) => MyModuleBlah.toList(argument),
)
Fooooooooooooooooooo.baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
  baaaz,
  quuuuux => something(here),
)

Fooooooooooooooooooo.baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
  baaaz,
  quuuuux => {
    let a = 1
    let b = 2
    a + b
  },
)

let make = (arr, ~compare) => {
  let rbt = make(~compare)
  array->Js.Array2.forEach(((value, height)) =>
    add(rbt, value, ~height)->ignore
  )
  rbt
}

let tbl = data->Js.Array2.reduce((map, curr) => {
  let (website, user) = curr
  if map->Belt.Map.String.has(website) {
    let set = map->Belt.Map.String.getExn(website)->Belt.Set.Int.add(user)
    map->Belt.Map.String.set(website, set)
  } else {
    let set = Belt.Set.Int.empty->Belt.Set.Int.add(user)
    map->Belt.Map.String.set(website, set)
  }
}, Belt.Map.String.empty)

let _ = {
  let similarity = (a, b) => {
    // nbr of users in common/number of users who have visited either in total
    let tbl = data->Js.Array2.reduce((map, curr) => {
      let (website, user) = curr
      if map->Belt.Map.String.has(website) {
        let set = map->Belt.Map.String.getExn(website)->Belt.Set.Int.add(user)
        map->Belt.Map.String.set(website, set)
      } else {
        let set = Belt.Set.Int.empty->Belt.Set.Int.add(user)
        map->Belt.Map.String.set(website, set)
      }
    }, Belt.Map.String.empty)
  }
}

let trees =
  possibilities->Belt.Array.mapU((. combination) =>
    combination->Belt.Array.reduceU(Nil, (. tree, curr) => tree->insert(curr))
  )

let set =
  mapThatHasAVeryLongName
  ->Belt.Map.String.getExn(website)
  ->Belt.Set.Int.add(user)

let add = (y: coll, e: key) =>
  if List.exists(x => eq(x, e), y) {
    y
  } else {
    list{e, ...y}
  }

let add2 = (y: coll, e: key) =>
  if List.exists(y, x => eq(x, e)) {
    y
  } else {
    list{e, ...y}
  }

let add2 = (y: coll, e: key) =>
  if (
    possibilities->Belt.Array.mapU((. combination) =>
      combination->Belt.Array.reduceU(Nil, (. tree, curr) => tree->insert(curr))
    )
  ) {
    y
  } else {
    list{e, ...y}
  }

let test =
  moduleTypeDeclaration
  |> TranslateSignature.translateModuleTypeDeclaration(
    ~config,
    ~outputFileRelative,
    ~resolver,
    ~typeEnv,
  )
  |> doStuff(~x, ~y)

// labelled arguments
// callback in last position
// case 1
Thing.map(foo, ~fn=(arg1, arg2) => MyModuleBlah.toList(argument))
Thing.map(foo, ~fn=?(arg1, arg2) => MyModuleBlah.toList(argument))

// case 2
Thing.map(longArgument, veryLooooongArgument, ~fn=(arg1, arg2) =>
  MyModuleBlah.toList(argument)
)
Thing.map(longArgument, veryLooooongArgument, ~fn=?(arg1, arg2) =>
  MyModuleBlah.toList(argument)
)

// case 3
Thing.map(
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg1,
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg2,
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg3,
  ~fn=(param1, parm2) => doStuff(param1, parm2),
)
Thing.map(
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg1,
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg2,
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg3,
  ~fn=?(param1, parm2) => doStuff(param1, parm2),
)

// callback in first position
// case 1
Thing.map(~fn=(arg1, arg2) => MyModuleBlah.toList(argument), foo)
Thing.map(~fn=?(arg1, arg2) => MyModuleBlah.toList(argument), foo)

// case 2
Thing.map(~fn=(arg1, arg2) => {
  MyModuleBlah.toList(argument)
}, longArgument, veryLooooongArgument)
Thing.map(~fn=?(arg1, arg2) => {
  MyModuleBlah.toList(argument)
}, longArgument, veryLooooongArgument)

// case 3
Thing.map(
  ~fn=(param1, parm2) => doStuff(param1, parm2),
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg2,
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg3,
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg4,
)
Thing.map(
  ~fn=?(param1, parm2) => doStuff(param1, parm2),
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg2,
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg3,
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarg4,
)

List.iter(x =>
  switch x {
  | ({txt: Lident(name)}, x) => field(name, x)
  | _ => ()
  }
, fields)

foo(key => {
  switch bla {
  // cancellation =D
  | None => true
  }
})

foo(_ => {
  switch bar {
  | None => ()
  | Some(_) =>
    a := b
    Js.log(\\"hi\\")
  }
})

foo(list => list())
foo(\\\\\\"switch\\" => \\\\\\"switch\\"())
"
`;

exports[`coerce.js 1`] = `
"let z = (x :> int)

let z2 = (x :> int)

let foo = (x: int) => (x :> int)

let foo2 = (x: int) => (x :> int)

let bar = x => (x: t :> int)

let bar2 = x => (x: t :> int)

call(~x=(y :> int), ~z=(w: int :> int), ~a, ~b)

let foo = (~a=3: int, b) => 34

let foo = (~a=(3 :> int), b) => 34

let foo = (~a=(3: int :> int), b) => 34

// THESE SHOULD NOT PARSE: no magic in the syntax
// let x: int :> string = y
// let x :> string = y
// let x : int1 :> int2 = 3 :> int3

let x = /* c0 */ (x /* c1 */ :> /* c2 */ int) /* c3 */
"
`;

exports[`constant.js 1`] = `
"let x = 1

let x = 3.14

let x = \\"mystring\\"

let x = @attr 1
let x = @attr 3.14
let x = @attr \\"mystring\\"
"
`;

exports[`constraint.js 1`] = `
"let x = (Numbers.ten: int)

let x = (@attr 10: int)
let x = (@attr 10: int)

let x = (street[\\"number\\"]: int)
let x = (streets[0]: int)

let x = (true ? 1 : 0: int)
"
`;

exports[`constructor.js 1`] = `
"let x = true
let y = false

let r = Reducer()
let r = Reducer(state, nexState, sideEffect)
let r = Reducer(
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)
let r = Reducer([state, nexState, sideEffect])
let r = Reducer([
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
])

let r = Reducer({state: nextState, sideEffects: []})

let c = Constr({
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
})

let forceBreak = Cartesian({
  x: Omega.x,
  y: Theta.y,
})

let c = Constr(list{
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  ...superLoooooooooooooooooooooooooooooongListHere,
})

let c = Constr(list{
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
})

let c = ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer([])
let c = ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer(list{})

let coordinate = JsCoord({\\"x\\": 1, \\"y\\": 1})
let user = JsUser({
  \\"name\\": \\"steve\\",
  \\"age\\": 32,
})

let rec peekMinNode = node =>
  switch node {
  | None => None
  | Some(node) =>
    if node.left === None {
      // this shouldn't break over multiple lines
      Some(node)
    } else {
      node.left->peekMinNode
    }
  }

let rec peekMinNode = node =>
  switch node {
  | None => None
  | Some(node) =>
    if node.left === None {
      // this shouldn't break over multiple lines
      MyConstructor(
        node,
        nodeLongIdentifiiiiieeeeeeer1,
        nodeLongIdentifiiiiieeeeeeer2,
      )
    } else {
      node.left->peekMinNode
    }
  }

let constructor = @attr Blue

let x = switch x {
| Bar =>
  ReasonReact.UpdateWithSideEffects(
    self => {
      let _ = 1
      apply(bar)
    },
  )
| Foo => ()
}

// tuple as single argument
let x = Some((1, 2))

let math = if discriminant < 0. {
  None
} else {
  Some((
    (-.b -. Js.Math.sqrt(discriminant)) /. (2. *. a),
    (-.b +. Js.Math.sqrt(discriminant)) /. (2. *. a),
  ))
}

// hug block expressions
let first = Some({
  let uidentLoc = mkLoc(uidentStartPos, uidentEndPos)
  Ast_helper.Type.constructor(
    ~loc=mkLoc(uidentStartPos, p.prevEndPos),
    ~res?,
    ~args,
    Location.mkloc(uident, uidentLoc),
  )
})

let first = Some({
  module D = Debug
  D.log()
})

let first = Some({
  exception Exit
  raise(Exit)
})

let first = Some({
  open Debug
  log()
})

let first = Some({
  sideEffect()
  sideEffect2()
})
"
`;

exports[`exoticIdent.js 1`] = `
"let x = \\\\\\"type\\"
let x = Extension.Type.\\\\\\"type\\"

let \\\\\\"+++\\" = (a, b) => a + b

\\\\\\"+++\\"(~a=\\\\\\"let\\", \\\\\\"module\\", ~\\\\\\"type\\")

switch \\\\\\"type\\" {
| () => ()
}

try \\\\\\"type\\" catch {
| () => ()
}

for pat in \\\\\\"type\\" to \\\\\\"let\\" {
  ()
}

if \\\\\\"let\\" {
  ()
} else if \\\\\\"module\\\\\\" {
  ()
}

while \\\\\\"let\\" {
  ()
}

let x = (\\\\\\"type\\", \\\\\\"module\\")
let x = [\\\\\\"type\\", \\\\\\"module\\"]
let x = list{\\\\\\"type\\", \\\\\\"module\\"}
let x = list{\\\\\\"type\\", \\\\\\"module\\", ...\\\\\\"let\\"}

Color(\\\\\\"let\\", \\\\\\"module\\")

let importType = {
  ...\\\\\\"let\\",
  \\\\\\"type\\": \\\\\\"module\\",
}

let userType = user.\\\\\\"type\\"
let m = user.\\\\\\"type\\".\\\\\\"module\\"

user.\\\\\\"type\\" = \\\\\\"module\\"

let () = {
  \\\\\\"let\\"()
  \\\\\\"module\\"
}

let x = (\\\\\\"type\\": \\\\\\"module\\")

assert \\\\\\"let\\"

lazy \\\\\\"let\\"

%let
%let(\`console.log\`)

@let
let x = 1

let x = <div \\\\\\"aria-foo\\"=\\\\\\"type\\"> \\\\\\"module\\" \\\\\\"let\\" </div>
"
`;

exports[`extension.js 1`] = `
"let x = %eval
let node = %bs.raw(\\"0\\")
let node = %bs.raw(@attr (\\"0\\"))
let node = %bs.raw(@attrStructureLvl (@attrOnExpr \\"0\\"))

let node = %bs.raw(
  @attrStructureLvl @attrStructureLvl2 @attrStructureLvl3
  (@attrOnExpr \\"0\\")
)
let node = %bs.raw(
  @attrStructureLvl @attrStructureLvl2 @attrStructureLvl3
  (
    @attrOnExpr @attrOnExpr2 @attrOnExpr3 @attrOnExpr4 @attrOnExpr5
    \\"unsafe raw js\\"
  )
)
let f: (int, int) => int = %raw((a, b) => \\"{return a + b}\\")

let f = (x, y) => {
  %debugger
  x + y
}

switch %external(__DEV__) {
| Some(_) => Js.log(\\"dev mode\\")
| None => Js.log(\\"production mode\\")
}

let node = @attr %bs.raw(\\"0\\")
"
`;

exports[`field.js 1`] = `
"let n = user.name

(currentNode.parent->castNotOption).color

let x = -a.bar

let x = true.x
let x = (12: int).x
let x = list{1, 2, ...x}.x
let x = module(Foo: Bar).x
let x = module(Foo).x
let x = Rgb(1, 2, 3).x
let x = [a, b, c].x
let x = {x: 1, y: 3}.x
let x = (1, 2, 3).x
let x = (%extension).x
let x = user.name.last
let x = streets[0].house
let x = apply(arg1, arg2).field
let x = apply(. arg1, arg2).field
let x = (-1).x
let x = (!true).x
let x = (x => print(x)).x
let x = (
  switch x {
  | Blue => ()
  | Yello => ()
  }
).x

let x = (
  for i in 0 to 10 {
    print_int(i)
  }
).x

let x = (
  if i < 10 {
    print_int(i)
  } else {
    print_int(1000)
  }
).x

let x = (
  while i < 10 {
    print_int(i)
  }
).x

let x = (assert false).x
let x = (lazy false).x
let x = (
  try sideEffect() catch {
  | Exit => ()
  }
).x

let x = (@attr expr).x

let x = (a + b).x

let x = @attr user.name
let x = (isLeft ? node.left : node.right).color
let x = (@attrOnTernary (isLeft ? node.left : node.right)).color
"
`;

exports[`firstClassModule.js 1`] = `
"module(Three)
module(Three: X_int)

let three = module(Three: X_int)
let three = module(Three)

let x = @attr module(Foo)
let x = @attr module(Foo: FirstClass)
"
`;

exports[`for.js 1`] = `
"let () = for i in 0 to 10 {
  ()
}

for i in 0 to 10 {
  let a = 1
  let b = 2
  sideEffect()
}

let x =
  @attr
  for i in 0 to 10 {
    ()
  }
"
`;

exports[`fun.js 1`] = `
"let f = (a, b) => ()
let greet = (~person, ~from as hometown) => ()
let greet = (~person=\\"Steve\\", ~from as hometown=\\"Cupertino\\") => ()

let onChangedVisible = (
  ~anchor=None,
  rbt,
  ~oldNewVisible,
  ~top as top_,
  ~bottom as bottom_,
  ~appear,
  ~remained,
  ~disappear,
) => ()

let greet = (~person, ~from as hometown) =>
  superLongIdentifiiiiiieeeeeeerExpression()

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) => superLongIdentifiiiiiieeeeeeerExpression()

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) =>
  superLongIdentislkdjflksjdfljslkjdflksjdklfjlskdjfklffiiiiiieeeeeeerExpression()

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) => superLongIdentier

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) =>
  superLongIdentislkdjflksjdfljslkjdflksjdklfjlskdjfklffiiiiiieeeeeeerExpression

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) => SuperLongConstructorrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr

let greet = (
  ~person,
  ~superLongIdentifiiiiiieeeeeeer as pat,
  ~superLongIdentifiiiiiieeeeeeer2 as pat2,
  ~from as hometown,
) =>
  SuperLongConstructorrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr

let f = () => ()
let f = a => ()
let f = _ => ()

let f = (~a=?) => ()
let f = (~from as hometown=?) => ()

let f = (. a) => ()
let f = (. a, b) => ()
let f = (. ()) => ()

let f = @attr (a, b) => @attr2 (c, d) => ()
let f = @attr (@attrOnA a, @attrOnB b) => @attr2 (@attrOnC c, @attrOnD d) => ()
let f = @attr (. a, b) => @attr2 (. c, d) => ()

let f = (@attr ~a, @attr ~b) => ()
let f = (. @attr ~a, . @attr ~b) => ()

let f = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => ()

let coordBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => {x: 1, y: 2}

let coordBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => {x: 1, y: 2}

let recordBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => {
  ...fields,
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
}

let arrayBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => [1, 2, 3, 4]

let arrayBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => [
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
]

let tupleBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => (1, 2, 3)

let tupleBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => (
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)

let constrBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => Cartesian({
  x: Omega.x,
  y: Theta.y,
})

let constrBuilder = (
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
  thisIsAVeryLongNaaaaaaaaaaaaaaaaaaameeeeeeeeeeeee,
) => Reducer(
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)

let genName = () => \\"Steve\\"

@react.component
let make = (
  ~onChange: option<(. {\\"testing\\": bool}, array<string>) => unit>=?,
  children,
) => {
  let doSomething = () =>
    switch onChange {
    | None => ()
    | Some(onChange) => onChange(. {\\"testing\\": true}, [\\"hey\\"])
    }
  <input onChange={_ => doSomething()} />
}

let add = (a, b): int => a + b

let add = (a, b): {
  \\"field1\\": int,
  \\"field2\\": string,
  \\"field3\\": int,
  \\"field4\\": int,
} => a + b
let add = (
  superLongParameterName1,
  superLongParameterName2,
  superLongParameterName3,
): {\\"field1\\": int, \\"field2\\": string, \\"field3\\": int, \\"field4\\": int} => a + b

let add = (
  superLongParameterName1,
  superLongParameterName2,
  superLongParameterName3,
): {
  \\"field1\\": int,
  \\"field2\\": string,
  \\"field3\\": int,
  \\"field4\\": int,
  \\"field5\\": int,
} => a + b

let add = ((a, b)): (int, string, int, int) => a + b
let add = ((a, b)): (
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
) => a + b
let add = ((
  superLongParameterName,
  bsuperLongParameterName,
  superLongParameterName,
  superLongParameterName,
)): (
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
) => a + b

let add = (list{a, b}): list<
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
> => a + b
let add = (list{
  superLongParameterName,
  bsuperLongParameterName,
  superLongParameterName,
  superLongParameterName,
}): list<
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
> => a + b

let add = ([a, b]): array<
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
> => a + b
let add = ([
  superLongParameterName,
  bsuperLongParameterName,
  superLongParameterName,
  superLongParameterName,
]): array<
  intWithSuperLongName,
  stringWithSuperLongName,
  intWithSuperLongName,
  intWithSuperLongName,
> => a + b

let add = ({
  x: superLongParameterName,
  y: superLongParameterName,
  z: superLongParameterName,
}) => x + y + z
let add = ({
  x: superLongParameterName,
  y: superLongParameterName,
  z: superLongParameterName,
}) => x + y + z
let add = ({
  x: x as superLongParameterName,
  y: y as superLongParameterName,
  z: z as superLongParameterName,
}) => x + y + z

let add = (Color(
  superLongParameterName,
  superLongParameterName,
  superLongParameterNameeeeeee,
)) => x + y + z
let add = (Color(
  superLongParameterName,
  superLongParameterName,
  superLongParameterNameeeee,
)): color<
  superLongTypeIdent,
  superLongType2,
  anotherLongOne,
  woooooooooooooooooooooooooooooooooooow,
> => x + y + z

let parseExceptionDef = (~attrs, p) => {
  let startPos = p.Parser.startPos
  Parser.expect(Token.Exception, p)
  let (_, name, kind) = parseConstrDef(~parseAttrs=false, p)
  let loc = mkLoc(startPos, p.prevEndPos)
  Ast_helper.Te.constructor(~loc, ~attrs, name, kind)
}

and parseStructure = (p): Parsetree.structure =>
  parseList(p, ~grammar=Grammar.Structure, ~f=parseStructureItem)

and parseStructureItem = (_): Parsetree.structure_item => {
  let startPos = p.Parser.startPos
  let attrs = parseAttributes(p)
  attrs
}

// block expressions should have braces on the same line as the =>
let equals = (c1, c2) => {
  open Float
  c1.red->equals(c2.red) &&
  c1.blue->equals(c2.blue) &&
  c1.green->equals(c2.green)
}

let equals2 = (c1, c2) => {
  module B = Belt
  c1.red->equals(c2.red) &&
  c1.blue->equals(c2.blue) &&
  c1.green->equals(c2.green)
}

let equals3 = (c1, c2) => {
  let a = 1
  let b = 2
  c1.red->equals(c2.red) &&
  c1.blue->equals(c2.blue) &&
  c1.green->equals(c2.green)
}

let equals4 = (c1, c2) => {
  exception Foo
  c1.red->equals(c2.red) &&
  c1.blue->equals(c2.blue) &&
  c1.green->equals(c2.green)
}

// ~d: e should stay ~d: e
let a = (~b as c, ~d: e) => 1

let f = list => list()
let f = \\\\\\"switch\\" => \\\\\\"switch\\" + 20

<div className=\\"max-w-3xl mx-auto\\">
  <CoursesReview__SubmissionsTab
    updateSubmissionsCB={(
      ~submissions,
      ~selectedTab,
      ~hasNextPage,
      ~totalCount,
      ~endCursor,
    ) =>
      send(
        SetSubmissions(
          submissions,
          selectedTab,
          hasNextPage,
          endCursor,
          totalCount,
        ),
      )}
  />
</div>

let f = (~\\\\\\"aria-b\\", ~\\\\\\"aria-c\\") => {
  Js.log(\\\\\\"aria-b\\", \\\\\\"aria-c\\")
}

let f = (~\\\\\\"aria-b\\": string, ~\\\\\\"aria-d\\" as \\\\\\"aria-xyz\\") => {
  Js.log(\\\\\\"aria-b\\", \\\\\\"aria-xyz\\")
}

let f = (type \\\\\\"ðŸ˜Ž\\", x) => Js.log(x)
"
`;

exports[`ident.js 1`] = `
"let x = a

let c = Configuration.config

let x = @attr identifier

let x =
  @attributeVeryLong @attributeVeryLong @attributeVeryLong @attributeVeryLong
  identifier
"
`;

exports[`if.js 1`] = `
"let name = if true {
  user.name
}

let name = if true {
  user.name
} else {
  \\"steve\\"
}

let name = if true {
  user.name
} else if false {
  user.lastName
} else {
  defaultName
}

let () = if true {
  let a = 1
  let b = 2
  open Belt
  sideEffect()
  ()
} else {
  let a = 5
  let b = 6
  open React
  render()
  ()
}

let x =
  @attr
  if truth {
    sideEffect()
  }

if inclusions[index] = (uid, url) {
  onChange(inclusions)
}

// Basic
if let Some(x) = foo() {
  doSomethingWithX(x)
}

// Else branch
if let Some(x) = foo() {
  doSomethingWithX(x)
} else {
  doSomethingElse()
}

// Else-if support
if let Some(x) = foo() {
  doSomethingWithX(x)
} else if let Some(y) = bar() {
  doSomethingWithY(y)
} else {
  doSomethingElse()
}

// Mixed conditions, pattern start
if let Some(x) = foo() {
  doSomethingWithX(x)
} else if n > 10 {
  doSomethingWithForN()
} else {
  doSomethingElse()
}

// Mixed conditions, condition start
if n > 10 {
  doSomethingWithForN()
} else if let Some(x) = foo() {
  doSomethingWithX(x)
} else {
  doSomethingElse()
}

// Maintains attrs correctly
if n > 10 {
  @aa
  doSomethingWithForN()
} else if let @bb Some(@cc x) = @dd
foo() {
  @ee
  doSomethingWithY(x)
} else {
  @ff
  doSomethingElse()
}

if let Some(x) = foo() {
  doSomethingWithX(x)
} else if let Some(y) = bar() {
  doSomethingWithY(y)
} else if let Some(z) = baz() {
  doSomethingWithZ(z)
}

// full destructuring
if let Some(Thing(With({many: Internal([Components, q])}))) as p = foo() {
  doSomethingWithE(e)
}

// Assignment
let a = if let Some(x) = foo() {
  x
} else {
  123
}

// Nesting
let getZ = nested =>
  if let Some(point) = nested.origin {
    if let Some(z) = point.z {
      z
    } else {
      0
    }
  } else {
    0
  }

// Deep nesting
let getZ = nested =>
  if let Some(nested) = nested.a {
    if let Some(nested) = nested.b {
      if let Some(nested) = nested.c {
        if let Some(nested) = nested.d {
          if let Some(nested) = nested.e {
            if let Some(nested) = nested.f {
              if let Some(nested) = nested.g {
                z
              } else {
                0
              }
            } else {
              0
            }
          } else if let Some(nested) = nested.g {
            z
          } else {
            0
          }
        } else if a {
          b
        } else {
          c
        }
      } else {
        0
      }
    } else {
      0
    }
  } else {
    0
  }

// Break testing
if let Some(
  suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuperLongName,
) = anotherSuuuuuuuuuuuuuuuuuuuuuuuuuuuperLongName() {
  foo()
}

if let Some(
  suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuperLongName,
) = anotherSuuuuuuuuuuuuuuuuuuuuuuuuuuuperLongNameanotherSuuuuuuuuuuuuuuuuuuuuuuuuuuuperLongName(
  withSomeArgsThatAreAlsoLarge,
  withManyArgsThatAreAlsoLarge,
) {
  foo()
}

if let {
  suuuuuuuuuuuuuuuuuuuuuuuuuuuperLongName,
  suuuuuuuuuuuuuuuuuuuuuuuuuuuperLongName2,
  suuuuuuuuuuuuuuuuuuuuuuuuuuuperLongName3,
} = buildMyRecord() {
  foo()
}

// Complex nesting
if let Some(Thing(With({many: Internal([Components, q])}))) as p = foo() {
  if let Other(Thing(With({many: Internal([Components, q])}))) as p = foo() {
    doSomethingElse(e)
  }
  doSomethingWithE(e)
} else if let Some(Thing(With({
  many: Internal([Components, q]),
}))) as p = foo() {
  doSomethingWithE(e)
} else if let Some(Thing(With({
  many: Internal([Components, q]),
}))) as p = foo() {
  doSomethingWithE(e)
}

// Ternary
let a = b
  ? if let Some(x) = foo() {
      1
    } else {
      2
    }
  : 3

let a = b
  ? 1
  : if let Some(x) = foo() {
      1
    } else {
      2
    }

let a = b
  ? if let Some(x) = foo() {
      1
    } else {
      2
    }
  : if let Some(x) = foo() {
      1
    } else {
      2
    }

// print parens correct
if let Some(x) = (3: option<int>) {
  (x: int)
} else {
  (20: int)
}
"
`;

exports[`jsObjectAccess.js 1`] = `
"let x = address[\\"street\\"]
let x = address[\\"street\\"][\\"number\\"]
let x = @attr address[\\"street\\"]

longEqualityExpression[\\"someRecordField\\"] ==
  wowThisDoesHaveToBePrettyLong[\\"someRecordField\\"] &&
  longEqualityExpression[\\"someRecordField\\"] ==
    wowThisDoesHaveToBePrettyLong[\\"someRecordField\\"]

let component = props[\\"Component\\"]
"
`;

exports[`jsObjectSet.js 1`] = `
"address[\\"street\\"] = \\"Brusselsestraat\\"
address[\\"street\\"] = newYork |> getExpensiveStreet

let () = @attr address[\\"street\\"] = \\"Brusselsestraat\\"
let () = node[\\"left\\"] = value |> process |> node[\\"right\\"] = value |> process
let () = (node[\\"left\\"] = value |> process) |> node[\\"right\\"] = value |> process
"
`;

exports[`jsx.js 1`] = `
"let x =
  <div
    className=\\"container\\"
    className2=\\"container2\\"
    className3=\\"container3\\"
    onClick
  />
let x = <Foo className=\\"container\\" />
let x = <Foo.Bar className=\\"container\\" />
let x = <Foo.Bar.Baz className=\\"container\\" />

let x =
  <div
    className=\\"container\\"
    className2=\\"container2\\"
    className3=\\"container3\\"
    onClick
  />

let nav =
  <Nav isMobile={isMobile} fullScreen={!isMobile ? false : isOpen}>
    <NavContent>
      <WidescreenMenu
        menuItems={props.items}
        trial={props.trial}
        user={props.user}
        viewer={props.viewer}
      />
    </NavContent>
  </Nav>

let nav2 =
  <Nav isMobile={isMobile} fullScreen={!isMobile ? false : isOpen}>
    <NavContent>
      {switch isMobile {
      | true =>
        <MobileMenu
          handleOpenToggle={_ => setOpen(open_ => !open_)}
          menuItems={props.items}
          isOpen={isOpen}
          forceOpen={_ => setOpen(true)}
          forceClose={_ => setOpen(false)}
          user={props.user}
        />

      | false =>
        <WidescreenMenu
          menuItems={props.items}
          trial={props.trial}
          user={props.user}
          viewer={props.viewer}
        />
      }}
    </NavContent>
  </Nav>

let nav3 =
  <Nav isMobile={isMobile} fullScreen={!isMobile ? false : isOpen}>
    <NavContent>
      {isMobile
        ? <MobileMenu
            handleOpenToggle={_ => setOpen(open_ => !open_)}
            menuItems={props.items}
            isOpen={isOpen}
            forceOpen={_ => setOpen(true)}
            forceClose={_ => setOpen(false)}
            user={props.user}
          />
        : <WidescreenMenu
            menuItems={props.items}
            trial={props.trial}
            user={props.user}
            viewer={props.viewer}
          />}
    </NavContent>
  </Nav>

let avatarSection =
  <>
    <div style={{\\"zIndex\\": \\"1\\", \\"opacity\\": opacityUser}}>
      <Avatar user={user} size={45} />
    </div>
    {user.email !== viewer.email
      ? <div
          style={{
            \\"marginLeft\\": marginLeft + \\"em\\",
            \\"opacity\\": opacityAdmin,
            \\"zIndex\\": \\"0\\",
            \\"cursor\\": \\"pointer\\",
          }}
          onMouseEnter={_ => setHoveringAdmin(true)}
          onMouseLeave={_ => setHoveringAdmin(false)}
          onClick={_e => {
            stopImpersonating(csrfToken)
          }}>
          <Avatar user={viewer} size={45} />
        </div>
      : React.nullElement}
  </>

let x = <> </>

let x =
  <div
    ident // punned
    ?ident // punned optional
    ident=?identifierExpr
    ident=identifierExpr
    constant=\\"constant\\"
    letExpr={
      let a = 1
      let b = 2
      a + b
    }
    onClick={event => handleClick(event)}
    onClick={(event1, event2, event3) => {
      Js.log(\\"debug click\\")
      handleClick(event)
    }}
    onClick={(
      aaaaaaaaaaaaaaarg1,
      aaaaaaaaaaaaaaaaaaaaaaarg2,
      aaaaaaaaaaaaaaarg3,
    ) => {
      sideEffect(aaaaaaaaaaaaaaarg1)
      sideEffect(aaaaaaaaaaaaaaaaaaaaaaarg2)
      sideEffect(aaaaaaaaaaaaaaarg3)
    }}
    apply={myFunction(x)}
    applyWithDot={myFunction(. x)}
    street={streets[0]}
    binary={a + b}
    int={-1}
    float={-1.2}
    matchExpression={switch color {
    | Blue => \\"blue\\"
    | Red => \\"red\\"
    }}
    tryExpression={try sideEffect() catch {
    | Error => ()
    }}
    tuple=(a, b, c)
    constr=Rgb(red, blue, green)
    list1=list{}
    list2=list{a, b}
    list3=list{a, b, ...x}
    array=[a, b, c]
    record={x: 1, y: 2}
    field=foo.bar
    setField={user.name = \\"Steve\\"}
    ifThenElse={if true {
      ()
    } else {
      ()
    }}
    seq={
      sideEffect1()
      sideEffect2()
    }
    whileExpr={while true {
      loop()
    }}
    forExpr={for i in 0 to 10 {
      do(i)
    }}
    constraintExpr={(20: int)}
    letModule={
      module L = Log
      L.log()
    }
    letException={
      exception Exit
      raise(Exit)
    }
    lazyExpr={lazy stuff()}
    assertExpr={assert true}
    pack=module(Foo)
    pack={module(Foo)}
    pack=module(Foo: Bar)
    pack={module(Foo: Bar)}
    openExpr={
      open React
      React.render()
    }
    extension=%bs.raw(\\"eval()\\")
    jsObject={\\"x\\": 1, \\"y\\": 2}
    withAttr={@attr foo}
  />

let x =
  <div>
    ident
    \\"constant\\"
    {
      let a = 1
      let b = 2
      a + b
    }
    {event => handleClick(event)}
    {(event1, event2, event3) => {
      Js.log(\\"debug click\\")
      handleClick(event)
    }}
    {(aaaaaaaaaaaaaaarg1, aaaaaaaaaaaaaaaaaaaaaaarg2, aaaaaaaaaaaaaaarg3) => {
      sideEffect(aaaaaaaaaaaaaaarg1)
      sideEffect(aaaaaaaaaaaaaaaaaaaaaaarg2)
      sideEffect(aaaaaaaaaaaaaaarg3)
    }}
    {myFunction(x)}
    {myFunction(. x)}
    {streets[0]}
    {a + b}
    {-1}
    {-1.2}
    {switch color {
    | Blue => \\"blue\\"
    | Red => \\"red\\"
    }}
    {try sideEffect() catch {
    | Error => ()
    }}
    {(a, b, c)}
    Rgb(red, blue, green)
    list{}
    list{a, b}
    list{a, b, ...x}
    [a, b, c]
    {x: 1, y: 2}
    foo.bar
    {user.name = \\"Steve\\"}
    {if true {
      ()
    } else {
      ()
    }}
    {
      sideEffect1()
      sideEffect2()
    }
    {while true {
      loop()
    }}
    {for i in 0 to 10 {
      do(i)
    }}
    {(20: int)}
    {
      module L = Log
      L.log()
    }
    {
      exception Exit
      raise(Exit)
    }
    {lazy stuff()}
    {assert true}
    {module(Foo)}
    module(Foo)
    {module(Foo: Bar)}
    module(Foo: Bar)
    {
      open React
      React.render()
    }
    %bs.raw(\\"eval()\\")
    {\\"x\\": 1, \\"y\\": 2}
    {@attr ident}
  </div>

let x = <MyComponent sidebar={<div> test </div>} nav={<Navbar />} />

<div>
  {possibleGradeValues
  |> List.filter(g => g <= state.maxGrade)
  |> List.map(possibleGradeValue =>
    <option
      key={possibleGradeValue |> string_of_int}
      value={possibleGradeValue |> string_of_int}>
      {possibleGradeValue |> string_of_int |> str}
    </option>
  )
  |> Array.of_list
  |> ReasonReact.array}
</div>
"
`;

exports[`lazy.js 1`] = `
"let x = lazy sideEffect

// parens
let x = lazy true
let x = lazy 12
let x = lazy (12: int)
let x = lazy 12
let x = lazy list{1, 2, ...x}
let x = lazy module(Foo: Bar)
let x = lazy module(Foo)
let x = lazy Rgb(1, 2, 3)
let x = lazy [a, b, c]
let x = lazy {x: 1, y: 3}
let x = lazy (1, 2, 3)
let x = lazy %extension
let x = lazy user.name
let x = lazy streets[0]
let x = lazy apply(arg1, arg2)
let x = lazy apply(. arg1, arg2)
let x = lazy -1
let x = lazy !true
let x = lazy (x => print(x))
let x = lazy (
  switch x {
  | Blue => ()
  | Yello => ()
  }
)

let x = lazy (
  for i in 0 to 10 {
    print_int(i)
  }
)

let x = lazy (
  if i < 10 {
    print_int(i)
  } else {
    print_int(1000)
  }
)

let x = lazy (
  while i < 10 {
    print_int(i)
  }
)

let x = lazy (assert false)
let x = lazy (
  try sideEffect() catch {
  | Exit => ()
  }
)

let x = lazy (@attr expr)

let x = lazy (a + b)

let x = @attr lazy x

let x = lazy street[\\"number\\"]
let x = lazy streets[0]

lazy address[\\"street\\"] = \\"Brusselsestraat\\"

lazy (true ? 0 : 1)
"
`;

exports[`let.js 1`] = `
"let z = {
  let a = 1
  a
}

let x = {
  let x = 1 and y = 2 and z = 3

  let x = 1
  and y = 2
  and z = 3

  let x = 1

  and y = 2

  and z = 3

  x + y + z
}

let x = {
  let a = true
  let b = false
  a || b
}

// don't add whitespace here
let highlight_dumb = (ppf, lb, loc) => {
  let line_start = ref(0)
  and line_end = ref(0)
  foo
}

// should contain a newline before foo
let highlight_dumb = (ppf, lb, loc) => {
  let line_start = ref(0)
  and line_end = ref(0)

  foo
}
"
`;

exports[`letexception.js 1`] = `
"let x = {
  exception Foo
  sideEffect
}
"
`;

exports[`letmodule.js 1`] = `
"let x = {
  module M = ME
  Me.x
}
"
`;

exports[`list.js 1`] = `
"let x = list{}
let x = list{1}
let x = list{1, 2}
let x = list{1, 2, 3}

let x = list{
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
}

let x = list{1, ...otherList}

let x = list{
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  ...superLoooooooooooooooooooooooooooooongListHere,
}
"
`;

exports[`newtype.js 1`] = `
"let f = (type t, xs: list<t>) => ()
let f = (@attr type t, xs: list<t>) => ()
let f = (type t, xs: list<t>, type s, ys: list<s>) => ()
let f = (@attr type t, xs: list<t>, @attr2 type s, ys: list<s>) => ()
let f = (type t u v, xs: list<(t, u, v)>) => ()
let f = (@attr type t u v, xs: list<(t, u, v)>) => ()
let f = (type t u v, xs: list<(t, u, v)>, type s w z, ys: list<(s, w, z)>) => ()
let f = (
  @attr type t u v,
  xs: list<(t, u, v)>,
  @attr2 type s w z,
  ys: list<(s, w, z)>,
) => ()
let f = (
  @attr type t,
  @attr type s,
  xs: list<(t, s)>,
  @attr type u,
  @attr type v w,
  ys: list<(u, v, w)>,
) => ()

let mk_formatting_gen:
  type a b c d e f. formatting_gen<a, b, c, d, e, f> => Parsetree.expression =
  fmting =>
    switch fmting {
    | Open_tag(Format(fmt', str')) =>
      mk_constr(\\"Open_tag\\", list{mk_format(fmt', str')})
    }

let cancel_and_collect_callbacks:
   'a 'u 'c. (
    list<packed_callbacks>,
    promise<'a, 'u, 'c>,
  ) => list<packed_callbacks> =
  (type x, callbacks_accumulator, p: promise<_, _, c>) => ()
"
`;

exports[`open.js 1`] = `
"let element = {
  open React
  element
}

let element = {
  open! React
  element
}
"
`;

exports[`polyvariant.js 1`] = `
"let r = #Reducer()
let r = #Reducer(state, nexState, sideEffect)
let r = #Reducer(
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)
let r = #Reducer([state, nexState, sideEffect])
let r = #Reducer([
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
])

let r = #Reducer({state: nextState, sideEffects: []})

let c = #Constr({
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
})

let forceBreak = #Cartesian({
  x: Omega.x,
  y: Theta.y,
})

let c = #Constr(list{
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  ...superLoooooooooooooooooooooooooooooongListHere,
})

let c = #Constr(list{
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
})

let c = #ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer([])
let c = #ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer(list{})

let coordinate = #JsCoord({\\"x\\": 1, \\"y\\": 1})
let user = #JsUser({
  \\"name\\": \\"steve\\",
  \\"age\\": 32,
})

let rec peekMinNode = node =>
  switch node {
  | #None => #None
  | #Some(node) =>
    if node.left === #None {
      // this shouldn't break over multiple lines
      #Some(node)
    } else {
      node.left->peekMinNode
    }
  }

let rec peekMinNode = node =>
  switch node {
  | #None => #None
  | #Some(node) =>
    if node.left === #None {
      // this shouldn't break over multiple lines
      #MyConstructor(
        node,
        nodeLongIdentifiiiiieeeeeeer1,
        nodeLongIdentifiiiiieeeeeeer2,
      )
    } else {
      node.left->peekMinNode
    }
  }

let constructor = @attr #Blue

let x = switch x {
| #Bar =>
  ReasonReact.UpdateWithSideEffects(
    self => {
      let _ = 1
      apply(bar)
    },
  )
| #Foo => ()
}

// tuple as single argument
let x = #Some((1, 2))

let math = if discriminant < 0. {
  #None
} else {
  #Some((
    (-.b -. Js.Math.sqrt(discriminant)) /. (2. *. a),
    (-.b +. Js.Math.sqrt(discriminant)) /. (2. *. a),
  ))
}

switch x {
| #...typevar => 42
}

let r = #\\\\\\"Reducerâ›ªï¸\\"
let r = #\\\\\\"type\\"(\\\\\\"module\\", \\\\\\"let\\")

let r = #lident
let r = #lident(a, b)
let r = #\\\\\\"exotic lident\\"
let r = #\\\\\\"exotic lident\\"(a, b)
"
`;

exports[`record.js 1`] = `
"let coord = {x: 3.13, y: 3.14}
let record = {
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
}

let forceBreak = {
  x: Omega.x,
  y: Theta.y,
}

let withSpread = {...initialState, time: nextTime}
let withSpreadAndForceBreak = {
  ...initialState,
  time: nextTime,
}

let withSpreadAndNaturalBreak = {
  ...fields,
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
}

let x = @attr {x: 1, y: 2}
let x =
  @attr {...initialState, superLongName: 1, superLongName: 2, superLongName: 5}
let x =
  @attr
  {
    ...initialState,
    superLongName: 1,
    superLongName: 2,
    superLongName: 5,
    superLongName: 20,
  }
"
`;

exports[`sequence.js 1`] = `
"let () = {
  foo()
  bar()
}

let () = {
  (foo(): unit)
  (bar(): unit)
}
"
`;

exports[`setfield.js 1`] = `
"user.name = \\"steve\\"
config.shouldSkip =
  !filePath.includes(allMlSuffixesCategory) &&
  !filePath.endsWith(allScriptDirectoriesCategory)

let () = @attr user.name = \\"steve\\"

let () = @attr user.name = \\"steve\\" |> @attr user.name = \\"steve\\"

user.name = steve[\\"name\\"]
user.address = addresses[2]

(currentNode.parent->castNotOption).color = Black
(isLeft ? node.left : node.right).color = Black
"
`;

exports[`sideEffects.js 1`] = `
"foo()
bar()

let () = {
  foo()
  bar()
}

let () = {
  let x = 1
  sideEffect()
  let y = 2
  sideEffect2()
  let z = 3
  sideEffect3()
}

while true {
  sideEffect1()
  let x = 1
  sideEffect2()
  let y = 2
  sideEffect3()
}

switch color {
| Blue =>
  getResult()
  sideEffect()
  let x = 1
  sideEffect2()
}
"
`;

exports[`switch.js 1`] = `
"switch x {
| A => ()
| B => ()
}

switch (a, b) {
| (Some(a), Some(b)) => 42
| _ => 3
}

let rec updateSum = (node, ~delta) =>
  switch node {
  | None => ()
  | Some(node) =>
    node.sum = node.sum +. delta
    node.parent->updateSum(~delta)
  }

let x =
  @attr
  switch x {
  | Universe => ()
  }
"
`;

exports[`templateLiteral.js 1`] = `
"let y = \`In winter the sky is never blue\`
let x = \`firstname: \${user.firstName} lastname: \${user.lastName}.\`
let z = \`\${user.name} is his name\`
let o = \`His name is \${user.name}\`

let s = \`multi
  line

string
\`

let s = foo

let s = \`before\${foo}\`
let s = \`before \${foo}\`
let s = \`before  \${foo}\`

let s = \`\${foo}after\`
let s = \`\${foo} after\`
let s = \`\${foo}  after\`

let s = foo ++ bar
let s = foo ++ bar ++ baz

let s = \`\${foo} \${bar}\`
let s = \`\${foo} \${bar} \${baz}\`

let s = \` before \${foo} \${bar} after \`
let s = \`before \${foo} middle \${bar} \${baz} wow \`

let s = \`
  multiline

  es6

  template

  expression

  so convenient

  :)
          :D
\`

let s = \`$dollar without $braces $interpolation\`

// don't sugar to one single template literal, keep the concatenation
\`the sky\` ++ \`is blue\`

// will print as one template literal
// \`my \${language.name} is \` ++ \`Bond, \${jamesbond.firstName}.\`

let x = json\`null\`

let x = sql\`select \${column} from \${table}\`
"
`;

exports[`ternary.js 1`] = `
"condition1 ? value1 : value2

let x = condition1 ? value1 : value2

let value = condition1
  ? value1
  : condition2
  ? value2
  : condition3
  ? value3
  : value4

let paymentMessage = condition
  ? \\"Payment completed successfully\\"
  : state == \\"processing\\"
  ? \\"Payment processing\\"
  : state == \\"invalid_cvc\\"
  ? \\"There was an issue with your CVC number\\"
  : state == \\"invalid_expiry\\"
  ? \\"Expiry must be sometime in the past.\\"
  : \\"There was an issue with the payment.  Please contact support.\\"

let paymentMessage =
  state == \\"success\\"
    ? \\"Payment completed successfully\\"
    : state == \\"processing\\"
    ? \\"Payment processing\\"
    : state == \\"invalid_cvc\\"
    ? \\"There was an issue with your CVC number\\"
    : state == \\"invalid_expiry\\"
    ? \\"Expiry must be sometime in the past.\\"
    : \\"There was an issue with the payment.  Please contact support.\\"

let record = truth ? {x: 1, y: 2} : {x: 3, y: 5}
let record = truth
  ? {
      thisIsASuperLongFieldHere: loooooooooooooongIdentifier,
      anotherLongField: superLoooooooooooooooooongIdentifier,
    }
  : {
      thisIsASuperLongFieldHere: loooooooooooooongIdentifier,
      anotherLongField: superLoooooooooooooooooongIdentifier,
    }

let arr = truth ? [1, 2, 3, 4] : [4, 5, 6, 7]
let arr = truth
  ? [
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    ]
  : [
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    ]

let lst = truth ? list{1, 2, 3, 4} : list{4, 5, 6, 7}
let lst = truth
  ? list{
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    }
  : list{
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    }

let construct = truth ? Constructor(1, 2, 3, 4) : Constructor(4, 5, 6, 7)
let construct = truth
  ? Constructor(
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
  : Constructor(
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )

let x = truth
  ? {
      let a = 1
      let b = 2
      a + b
    }
  : {
      let a = 1
      let b = 2
      a + b
    }
let x = truth
  ? {
      let a = 1
      let b = 2
      a + b
    }
  : {
      let a = 1
      let b = 2
      a + b
    }

let x = truth ? create(a, b) : create(b, c)
let x = truth
  ? create(
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
  : create(
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
let x = truth ? create(. a, b) : create(. b, c)
let x = truth
  ? create(.
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
  : create(.
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )

let street = newYork ? streets[0] : streets[20]
let street = newYork
  ? thisIsASuperLongIdentifieeeeeeeer[0]
  : thisIsASuperLongIdentifieeeeeeeer[20]

let x = isNegative ? -x : y

let x = isGreater ? a + b : z - c
let x = isGreater
  ? thisIsASuperLongIdentifieeeeeeeer + 20
  : thisIsASuperLongIdentifieeeeeeeer + 200

let x = isColor
  ? switch color {
    | Blue => ()
    | Red => ()
    }
  : switch color {
    | Blue => ()
    | Red => ()
    }

let x = exceptionLike
  ? try dangerousThing() catch {
    | Exit => ()
    }
  : try dangerousThing() catch {
    | Exit => ()
    }

let tuple = truth ? (1, 2, 3, 4) : (4, 5, 6, 7)
let tuple = truth
  ? (
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )
  : (
      thisIsASuperLongIdentifieeeeeeeer,
      thisIsASuperLongIdentifieeeeeeeer2,
      thisIsASuperLongIdentifieeeeeeeer3,
    )

let x = condition1 ? node.left : node.right
let x = condition1
  ? nodeWithVeryLooooooooooooooooongNameHere.left
  : nodeWithVeryLooooooooooooooooongNameHere.right

let x = condition ? node.left = Some(newNode) : node.right = Some(newNode)
let x = condition1
  ? nodeWithVeryLooooooooooooooooongNameHere.left = Some(newNode)
  : nodeWithVeryLooooooooooooooooongNameHere.right = Some(newNode)

let x = condition1
  ? if true {
      ()
    } else {
      ()
    }
  : if true {
      ()
    } else {
      ()
    }
let () = condition1
  ? {
      sideEffect()
      sideEffect2()
    }
  : {
      sideEffect()
      sideEffect2()
    }

let () = condition1
  ? while true {
      doThing()
    }
  : while true {
      doOtherThing()
    }
let () = condition1
  ? for i in 0 to 10 {
      ()
    }
  : for i in 10 to 20 {
      ()
    }

let () = (truth: bool) ? (10: int) : (20: int)

let () = condition
  ? {
      module L = Logger
      L.log()
    }
  : {
      exception Exit
      raise(Exit)
    }
let () = condition ? lazy foo() : assert false

let x = condition ? module(Foo) : module(Int: Number)
let x = condition
  ? module(ModuleWithVeryLooooooooooooooooongNameHere)
  : module(ModuleWithVeryLooooooooooooooooongNameHereInt: Number)

let x = condition
  ? {
      open React
      render()
    }
  : {
      open React
      render()
    }
let x = condition ? %eval(\\"console.log\\") : %eval(\\"console.err\\")
let x = condition
  ? %eval(\\"consoooooooooooooooooooooole.log\\")
  : %eval(\\"consoleeeeeeeeeeeeeee.err\\")

let jsObj = condition ? {\\"x\\": 1, \\"y\\": 2} : {\\"x\\": 20, \\"y\\": 100}
let jsObj = truth
  ? {
      \\"thisIsASuperLongFieldHere\\": loooooooooooooongIdentifier,
      \\"anotherLongField\\": superLoooooooooooooooooongIdentifier,
    }
  : {
      \\"thisIsASuperLongFieldHere\\": loooooooooooooongIdentifier,
      \\"anotherLongField\\": superLoooooooooooooooooongIdentifier,
    }

let f = isPositive ? x => x + 1 : y => y - 1
let f = isPositive ? ((a, b): int => a + b) : ((c, d): int => c - d)
let f = isPositive ? ((a, b): int => a + b) : ((c, d): int => c - d)

a => a ? () => {a} : () => {a}
a => a ? a : a
a =>
  a ? aasdasdasdasdasdasdaaasdasdasdasdasdasdasdasdasdasdasdasdasdaaaaaaaaa : a

let x = @attrOnTernary (truth ? true : false)
let x = @attrOnCondition truth ? true : false
"
`;

exports[`try.js 1`] = `
"try {
  let x = 1
  let y = 2
  dangerousCall()
} catch {
| Foo => Js.log()
| Exit => Js.log()
}

try myDangerousFn() catch {
| Foo => Js.log()
}

let x = {
  let y = 1
  try {
    apply()
  } catch {
  | _ => 2
  }
}

@attr @attr2
try myDangerousFn() catch {
| Foo => Js.log()
}

let () =
  @attr @attr2
  try myDangerousFn() catch {
  | Foo => Js.log()
  }
"
`;

exports[`tuple.js 1`] = `
"let x = (1, 2, 3)

let x = (
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
  superLongNameThatWillBreak,
)

let x =
  @attr
  (
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
    superLongNameThatWillBreak,
  )
"
`;

exports[`unary.js 1`] = `
"let x = -a
let x = -.a
let x = !a

let isMale = !user[\\"female\\"]

!(!a)
!(!(!a))
!(a |> f(b))

-1->add
-1->add
-(1->add)
!foo->print_bool
!foo->print_bool
!(foo->parseTruth)

node.left->peekMinNode
// same as the above
node.left->peekMinNode

// field access has higher precedence than unary -
let x = -a.bar
// same as above
let x = -a.bar

!(lazy x)
lazy !x
!(assert x)
assert !x
!(@attr expr)
!(arg => doStuffWith(arg))
let x = !(truth: bool)
let x = (!truth: bool)

let z = !(%extension)
// (!x.left) = value -> this does not parse, lhs of Pexp_setfield can't be a unary expression?
-[a, b, c]
!module(Foo: Bar)
!module(Foo)
let x = -apply(arg)
let x = -apply(. arg)
let x = -Foo(a, b, c)
let x = -{x: 1, y: 2}
let x = -list{1, 2, 3}
let x = -(
  if true {
    1
  } else {
    2
  }
)
let x = -(
  for i in 0 to 10 {
    ()
  }
)
let x = -(
  switch x {
  | Foo => 1
  }
)
let x = -(
  while i < 10 {
    i.contents = 20
  }
)
let x = -(1, 2, 3)
let x = -{
  let a = 1
  let b = 2
  a + b
}
let x = -{
  sideEffect()
  generateNumber()
}

-(true ? 0 : 1)

let () = {
  getResult()
  -10
}

let x = (!truths)[0]
(!streets)[0] = \\"foo-street\\"
"
`;

exports[`underscoreApply.res 1`] = `
"let x = f(a, _, c)
let x = f(a, g(x, _, z), _)
let x = f(_, x, c)
let x = f(_, _, _)
let x = f(g(_))
let x = f(~a=1, ~b=_, ~c=2)
let x = f(~a=_, ~b=_, ~c=_)
let x = f(~a=_, ~b=_, ~c=g(~x=2, ~y=_, ~z=_))

let nested = x => List.length(_)
let nested2 = (x, y, z) => List.length(_)

let l = [1, 2, 3] |> List.map(i => i + 1, _) |> List.filter(i => i > 0, _)

let l = (i => i + 1) |> List.map(_, [1, 2, 3])

let x = List.length(_)

let incr = (~v) => v + 1

let l1 = [1, 2, 3] |> List.map(incr(~v=_)) |> List.length

let l2 = [1, 2, 3] |> List.map(incr(~v=_)) |> List.length

let optParam = (~v=?, ()) => v == None ? 0 : 1

let l1 =
  [Some(1), None, Some(2)] |> List.map(optParam(~v=?_, ())) |> List.length

let l2 =
  [Some(1), None, Some(2)] |> List.map(optParam(~v=?_, ())) |> List.length

// callback in last position
f(a, b, (a, b) => List.length(_))
// callback in first position
f((a, b) => List.length(_), a, b)

f(a, b, _)(x, y)
-f(a, b, _)
f(a, b, _) + g(x, _, z)
f(a, b, _) + g(x, _, z) + h(alpha, beta, _)

assert f(a, b, _)
lazy f(a, b, _)

getDirector(a, b, _).name

f(a, b, _) ? g(x, y, _) : h(alpha, beta, _)

<div onClick={f(a, b, _)} />
<div> {f(a, b, _)} </div>

f(a, b, _)[ix]
f(a, b, _)[ix] = 2

getDirector(a, b, _).name = \\"Steve\\"
"
`;

exports[`while.js 1`] = `
"let () = while true {
  ()
}

while true {
  let a = 1
  let b = 2
  infiniteLoop()
  ()
}

// adds parens when condition breaks over multiple lines
while (
  continuePrefix.contents &&
  aPrefixLen.contents <= aLen &&
  bPrefixLen.contents <= bLen
) {
  let nextNonwhiteA = nextNonWhiteChar(aStr, 1, aPrefixLen.contents - 1)
  let nextNonwhiteB = nextNonWhiteChar(bStr, 1, bPrefixLen.contents - 1)
}

let x =
  @attr
  while true {
    break()
  }
"
`;

exports[`whitespace.js 1`] = `
"let x = {
  let a = 1
  let b = 2
  sideEffect()
  sideEffect2()
}

let x = {
  let a = 1

  let b = 2

  a + b
}

let x = {
  exception Exit

  exception Terminate

  module B = Belt

  sideEffect()

  open React

  sideEffect2()
}

let x = {
  exception Exit
  exception Terminate
  module B = Belt
  sideEffect()
  open React
  sideEffect2()
}
"
`;
