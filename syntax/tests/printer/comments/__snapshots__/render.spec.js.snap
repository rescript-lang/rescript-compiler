// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`binaryExpr.ns 1`] = `
"/* with comments */
compilation->Plugin.buildAssets // after
/* below compilation */ // trailing

compilation /* same line as compilation */->Plugin.buildAssets // trailing

/* with comments */
compilation
/* first */
->Plugin.buildAssets /* first trail */
/* second */
->Js.Json.stringify /* second trail */
/* last */
->Node.Fs.writeFileAsUtf8Sync(path) /* last trail */

if (
  // above1
  a == b &&
  // trailing1
  // above2
  c == d &&
  // trailing2
  // above3
  e == f &&
  // trailing3
  x
) {
  console.log(\\"foo bar\\")
}

let truth = a == b && c == d /* cmt */ && e == f

let truth =
  /* c0 */ a /* c1 */ == /* c2 */ b /* c3 */ &&
  /* c4 */ c /* c5 */ == /* c6 */ d /* c7 */ &&
  /* c8 */ e /* c9 */ == /* c10 */ f /* c11 */
"
`;

exports[`blockExpr.ns 1`] = `
"let () = /* c0 */ sideEffect1() /* c1 */

let () = {
  /* c0 */ sideEffect1() /* c1 */
}

let () = {
  /* c0 */ sideEffect1() /* c1 */
  /* c2 */ sideEffect2() /* c3 */
}

let () = {
  /* c0 */ sideEffect1() // c1
  // c2

  // c3
  /* c4 */ sideEffect2() // c5
}

let () = {
  /* c0 */ sideEffect1() /* c1 */
  /* c2 */ sideEffect2() /* c3 */
  /* c4 */ sideEffect3() /* c5 */
}

let () = {
  /* c0 */ sideEffect1() /* c1 */
  // k

  // k2
  /* k3 */
  // k4

  // k5
  /* c2 */ sideEffect2() /* c3 */
  // k

  // k2
  /* k3 */
  // k4

  // k5
  /* c4 */ sideEffect3() /* c5 */
}

let () = {
  /* c0 */ sideEffect1() /* c1 */
  /* c2 */ sideEffect2() /* c3 */
  /* c4 */ sideEffect3() /* c5 */
  /* c6 */ sideEffect4() /* c7 */
}

let () = {
  /* c0 */ let a /* inside */ = 1 /* c1 */
  /* c2 */ sideEffect2() /* c3 */
}

let () = {
  /* c0 */ let a /* inside */ = 1 /* c1 */
  // k

  // k2
  /* k3 */ /* k4 */

  // k5
  /* c2 */ sideEffect2() /* c3 */
}

let () = {
  /* c0 */ let a /* inside a */ = 1 /* c1 */
  /* c2 */ let b /* inside b */ = 2 /* c3 */
  /* c4 */ a + b /* c5 */
}

let () = {
  /* c0 */ let a /* inside a */ = 1 /* c1 */
  // k

  // k2
  /* k3 */ /* k4 */

  // k5
  /* c2 */ let b /* inside b */ = 2 /* c3 */
  // k

  // k2
  /* k3 */ /* k4 */

  // k5
  /* c4 */ a + b /* c5 */
}

let () = {
  /* c0 */ let a /* inside a */ = 1 /* c1 */
  /* c2 */ let b /* inside b */ = 2 /* c3 */
  /* c4 */ let c /* inside c */ = 3 /* c5 */
  /* c5 */ a + b + c /* c6 */
}

let () = {
  /* c0 */ exception /* inside */ Exit /* c1 */
  /* c2 */ raise(Exit) /* c3 */
}

let () = {
  /* c0 */ exception /* inside */ Exit // c1
  // k

  // k2
  /* c2 */ raise(Exit) // c3
}

let () = {
  /* c0 */ exception /* inside */ Exit /* c1 */
  /* c2 */ exception /* inside */ Terminate /* c3 */
  /* c4 */ raise(Exit) /* c5 */
}

let () = {
  /* c0 */ exception /* inside */ Exit // c1
  // k

  // k2

  // k3
  /* c2 */ exception /* inside */ Terminate // c3
  // k

  // k2

  // k3
  /* c4 */ raise(Exit) /* c5 */
}

let () = {
  /* c0 */ exception /* inside */ Exit /* c1 */
  /* c2 */ exception /* inside */ Terminate /* c3 */
  /* c4 */ exception /* inside */ Oom /* c5 */
  /* c6 */ raise(Exit) /* c7 */
}

let () = {
  /* c0 */ module /* c1 */ L /* c2 */ = /* c3 */ Logger /* c4 */
  /* c5 */ L.log() /* c6 */
}

let () = {
  /* c0 */ module /* c1 */ L /* c2 */ = /* c3 */ Logger // c4
  // k

  // k2

  // k3
  /* c5 */ L.log() /* c6 */
}

let () = {
  /* c0 */ module /* c1 */ L /* c2 */ = /* c3 */ Logger /* c4 */
  /* c5 */ module /* c6 */ L2 /* c7 */ = /* c8 */ Logger2 /* c9 */
  /* c10 */ L.log() /* c11 */
  /* c12 */ L2.log() /* c13 */
}

let () = {
  /* c0 */ module /* c1 */ L /* c2 */ = /* c3 */ Logger /* c4 */
  // k

  /* k1 */

  // k2
  /* c5 */ module /* c6 */ L2 /* c7 */ = /* c8 */ Logger2 /* c9 */
  // k

  /* k1 */

  // k2
  /* c10 */ L.log() /* c11 */
  // k

  /* k1 */

  // k2
  /* c12 */ L2.log() /* c13 */
}

let () = {
  /* c0 */ open /* c1 */ Belt /* c2 */
  /* c3 */ doSomething() /* c4 */
}

let () = {
  /* c0 */ open /* c1 */ Belt // c2
  // k

  /* k2 */

  // k3
  /* c3 */ doSomething() // c4
}

let () = {
  /* c0 */ open /* c1 */ Belt /* c2 */
  /* c3 */ open /* c4 */ React /* c5 */
  /* c6 */ doSomething() /* c7 */
}

let () = {
  /* c0 */ open /* c1 */ Belt /* c2 */
  // k

  /* k2 */

  // k3
  /* c3 */ open /* c4 */ React /* c5 */
  // k

  /* k2 */

  // k3
  /* c6 */ doSomething() /* c7 */
}

while true {
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8

  // here
}

for i in 0 to 10 {
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8

  // here
}

switch color {
| Blue =>
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8

| Red =>
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8
}

try danger() catch {
| Exc =>
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8
}

if {
  // here
  let a = true
  // okok

  // there
  let /* inside */ b = false // trailing

  // between
  true // test

  /* ws */
  // after
} {
  // here
  let a = true
  // okok

  // there
  let /* inside */ b = false
  false // here
} else {
  // here
  let a = true
  // okok

  // there
  let b = false
  true
} // trailing

if {
  // here
  let a = true
  // okok

  // there
  let /* inside */ b = false // trailing

  // between
  true // test

  /* ws */
  // after
} {
  // here
  let a = true
  // okok

  // there
  let /* inside */ b = false
  false // here
} else if {
  let u = universe() // c0
  // c1

  // c2
  let /* inside */ gc = forceGc() // stop the world
  // c3

  // c4
  f(u, gc) // c5
  /* c6 */
  // c7
} {
  // here
  let a = true
  // okok

  // there
  let b = false
  true
} // trailing

assert {
  // here
  open /* inside */ Matrix
  // c

  // c2
  compare(m1, m2)
  // after

  // test
}

lazy {
  // here
  open /* inside */ Matrix
  // c

  // c2
  compare(m1, m2)
  // after

  // test
}

user.name = {
  // here
  open /* inside */ Names

  // c

  // c2
  defaultName
  // after

  // test
}

switch {
  // here
  open Matrix
  // there

  // test
  arityCheck()
  // trailing

  // hmm
} {
| One => ()
| Two => ()
}

try {
  // here
  open Matrix
  // there

  // test
  arityCheck()
  // trailing

  // hmm
} catch {
| One => ()
| Two => ()
}

let () = {
  // here
  open Matrix

  // there

  // test
  arityCheck
  // trailing

  // hmm
}(arg1, arg2)

let name = {
  // here
  open Users

  // there

  // test
  defaultUser
  // trailing

  // hmm
}.name

let () = {
  // here
  open Users

  // there

  // test
  defaultUser
  // trailing

  // hmm
}.name = {
  // here
  open Names

  // there

  // test
  defaultName
  // trailing

  // hmm
}

while {
  // comment
  open Conditions
  // inside

  // inside2
  check()
  // foo

  // bar
} {
  Js.log(\\"test\\")
}

let multiply = (/* c0 */ m1 /* c1 */, /* c2 */ m2 /* c3 */) => {
  // here
  open Matrix4D

  let m3 = makeUninitializedUnsafe()

  // there

  // over there
  m3
  /* trailing */
  // test
}

switch x {
| Blue when /* c0 */ multicore.enabled /* c1 */ === /* c2 */ true /* c3 */ => ()
| Red
  when {
    // c0
    open /* c1 */ Multicore // c2
    // c3

    // c4
    isEnabled() // c5
    /* c6 */

    // c7
  } => ()
}
"
`;

exports[`case.ns 1`] = `
"let rec mergeU = (s1, s2, f) =>
  switch {
    open N
    (toOpt(s1), toOpt(s2))
  } {
  | (None, None) => N.empty
  | (Some(n) /* (Node (l1, v1, d1, r1, h1), _) */, _)
    when {
      open N
      heightGet(n) >=
      switch N.toOpt(s2) {
      | None => 0
      | Some(n) => N.heightGet(n)
      }
    } =>
    let (l1, v1, d1, r1) = {
      open N
      (leftGet(n), keyGet(n), valueGet(n), rightGet(n))
    }
    let (l2, d2, r2) = split(v1, s2)
    N.concatOrJoin(
      mergeU(l1, l2, f),
      v1,
      f(. v1, Some(d1), d2),
      mergeU(r1, r2, f),
    )
  | (_, Some(n)) /* Node (l2, v2, d2, r2, h2) */ =>
    let (l2, v2, d2, r2) = {
      open N
      (leftGet(n), keyGet(n), valueGet(n), rightGet(n))
    }
    let (l1, d1, r1) = split(v2, s1)
    N.concatOrJoin(
      mergeU(l1, l2, f),
      v2,
      f(. v2, d1, Some(d2)),
      mergeU(r1, r2, f),
    )
  | _ => assert false
  }
"
`;

exports[`expr.ns 1`] = `
"// Pexp_ident
let pi = /* before */ Math.pi // after

// Pexp_constant
let one = /* before */ 1 // after

// Pexp_let
let x = {
  let /* before a */ a /* after a */ = /* before 1 */ 1 // after 1
  /* before ident */ Pexp.ident /* after ident */
}

let x = {
  let /* before a */ a /* after a */ = /* before 1 */ 1 // after 1
  let /* before b */ b /* after b */ = /* before 2 */ 2 // after 2
  /* before ident */ Pexp.ident /* after ident */
}

let x = {
  let /* before a */ a /* after a */ = /* before 1 */ 1 // after 1
  let /* before b */ b /* after b */ = /* before 2 */ 2 // after 2
  /* before const */ \\"a string\\" /* after const */
}

// Pexp_extension
let x = /* c0 */ %ext(/* before */ \\"test\\" /* after */) /* c1 */

// Pexp_open
let x = {
  /* before open */ open /* c0 */ Belt /* c1 */ // after open
  /* before const */ \\"a string\\" /* after const */
}

let x = {
  /* before open */ open /* c0 */ Belt /* c1 */ // after open
  /* before open */ open! /* c0 */ Unsafe /* c1 */ // after open
  /* before const */ \\"a string\\" /* after const */
}

let x = {
  /* before let */ let a = 1 // after let
  open /* before ident */ Belt // after open
  /* before const */ \\"test\\" /* after const */
}

let x = {
  open /* before ident */ Belt // after open
  /* before let */ let a = 1 // after let
  /* before const */ \\"test\\" /* after const */
}

// Pexp_letexception
let x = {
  /* before */ exception /* c0 */ Foo /* c1 */ // after
  /* before */ \\"test\\" /* after */
}

// Pexp_letmodule
let x = {
  /* before */ module /* c0 */ B /* c1 */ = Belt // after
  /* before */ \\"test\\" /* after */
}

// Pexp_assert
let x = /* here */ assert /* c0 */ true /* c1 */

// Pexp_lazy
let x = /* here */ lazy /* c0 */ true /* c1 */

// Pexp_constraint
let x = (/* c0 */ \\"string\\" /* c1 */: /* c2 */ string /* c3 */) // after

// Pexp_construct
let x = /* before */ true /* after */
let x = /* before */ Red /* after */
let x = /* before */ Red(/* c0 */ shade /* c1 */) /* after */
let x = /* before */ Red /* after Red */(
  /* c0 */ r /* c1 */,
  /* c2 */ g /* c3 */,
  /* c4 */ b /* c5 */,
) /* after */

// lists
let x = /* c0 */ list[/* c1 */] /* c2 */
/* c0 */ list[/* c1 */] /* c2 */

let x = /* c0 */ list[/* c1 */ a /* c2 */] /* c3 */
/* c0 */ list[/* c1 */ a /* c2 */] /* c3 */

let x = /* c0 */ list[/* c1 */ a /* c2 */, /* c3 */ b /* c4 */] /* c5 */
/* c0 */ list[/* c1 */ a /* c2 */, /* c3 */ b /* c4 */] /* c5 */

let x = /* c0 */ list[
  /* c1 */ a /* c2 */,
  /* c3 */ b /* c4 */,
  /* c5 */ c /* c6 */,
] /* c7 */
/* c0 */ list[
  /* c1 */ a /* c2 */,
  /* c3 */ b /* c4 */,
  /* c5 */ c /* c6 */,
] /* c7 */

// Pexp_array
let x = [/* c0 */ a /* c1 */, /* c2 */ b /* c3 */, /* c4 */ c /* c5 */]
let x = [/* a */]
let x = [// test
]

// Pexp_record
let user = /* before */ {
  // above name
  /* c0 */ name /* c1 */: /* c2 */ \\"Steve\\" /* c3 */,
  // above age
  /* c4 */ age /* c5 */: /* c6 */ 31 /* c7 */,
} // after

// bs object sugar
let user = /* before */ {
  // above name
  /* c0 */ \\"name\\" /* c1 */: /* c2 */ \\"Steve\\" /* c3 */,
  // above age
  /* c4 */ \\"age\\" /* c5 */: /* c6 */ 31 /* c7 */,
} // after

let spreadUser = {
  .../* before */ user1 /* after */,
  /* c0 */ age /* c1 */: /* c2 */ 32 /* c3 */,
}

// Pexp_field
let x = /* before */ user /* c0 */./* c1 */ name /* c2 */

// Pexp_setfield
/* before */ user /* c0 */./* c1 */ name /* c2 */ = /* c3 */ \\"Steve\\" /* c4 */

// Pexp_ifthenelse
if /* c0 */ user.name === \\"Steve\\" /* c1 */ {
  /* c2 */ Js.log(\\"It's Steve\\") /* c3 */
} // trailing

if /* c0 */ user.name === \\"John\\" /* c1 */ {
  /* c2 */ Js.log(\\"It's John…\\") /* c3 */
} else {
  // c4
  /* c5 */ Js.log(\\"we need John\\") /* c6 */
} // trailing

// Pexp_while
while /* c0 */ condition.contents /* c1 */ {
  /* c2 */ doStuff() /* c3 */
} // trailing

// Pexp_for
for /* c0 */ i /* c1 */ in /* c2 */ 0 /* c3 */ to /* c4 */ 10 /* c5 */ {
  /* c6 */ doStuff() /* c7 */
} // trailing

// Pexp_pack
/* c0 */ module(/* c1 */ ModExpr /* c2 */) /* c3 */
/* c0 */ let /* c1 */ three /* c2 */ = /* c3 */ module(
  /* c4 */ Three /* c5 */
) /* c6 */

/* c0 */ module(/* c1 */ ModExpr: /* c4 */ MyModule /* c5 */) /* c6 */
/* c0 */ let /* c1 */ three /* c2 */ = /* c3 */ module(
  /* c4 */ Three: /* c6 */ MyModule /* c7 */
) /* c8 */

/* c0 */ switch /* c1 */ color /* c2 */ {
// above Red
/* c0 */ | Red /* c1 */ => /* c2 */ printColor(\\"red\\") /* ending */

// above Blue
/* c3 */ | Blue /* c4 */ => /* c5 */ printColor(\\"blue\\") /* ending */
}

/* c0 */ try /* c2 */ unsafeIdentifier /* c3 */ catch {
// Above
/* before */ | InfiniteLoop /* after */ => /* here */ () /* trailing */

// Above2
/* before */ | InfiniteLoop2 /* after */ => /* here */ () /* trailing */
} // trailing

// Pexp_fun
let f = (/* c0 */ a /* c1 */, /* c2 */ b /* c3 */): /* c4 */ int /* c5 */ =>
  /* c6 */ 20 /* c7 */
let multiply = (/* c0 */ m1 /* c1 */, /* c2 */ m2 /* c3 */) => {
  // here
  open Matrix4D

  let m3 = makeUninitializedUnsafe()

  // there

  // over there
  m3
  /* trailing */
  // test
}

let multiply = (~x=/* c0 */ m1 /* c1 */, ~y=/* c2 */ m2 /* c3 */) => ()

let f = (
  /* c0 */ ~greeting /* c1 */,
  /* c2 */ ~from as /* c3 */ /* c4 */ hometown /* c5 */,
  /* c6 */ ~x=?,
) => /* c7 */ ()

let multiply = (
  type /* c-2 */ t /* c-1 */,
  /* c0 */ m1 /* c1 */,
  /* c2 */ m2 /* c3 */,
) => ()
let multiply = (
  type /* c-4 */ t /* c-3 */,
  /* c0 */ m1 /* c1 */,
  type /* c-2 */ s /* c-1 */,
  /* c2 */ m2 /* c3 */,
) => ()

// ternary
let x = /* c0 */ test /* c1 */
  ? /* c2 */ true /* c3 */
  : /* c4 */ false /* c5 */

// Pexp_if case, don't duplicate comments
if next == Js.null {
  /* only one element */
  clear(q)
  Some(contentGet(x))
} else {
  lengthSet(q, lengthGet(q) - 1)
  firstSet(q, next)
  Some(contentGet(x))
}

// Pexp_if with parenthesized condition
if (
  /* Format.eprintf \\"@[%a@]@.\\" Printtyp.raw_type_expr ty; */
  switch ty0.desc {
  | Tconstr(p, _, _) => Path.same(p, path)
  | _ => false
  }
) {
  ()
}

// add end of list of nodes
Doc.concat(
  privateFlag,
  rows,
  /* a */
)
Doc.concat(list[
  privateFlag,
  rows,
  /* a */
])
"
`;

exports[`extensionConstructor.ns 1`] = `
"/* c0 */ exception /* c1 */ Exit /* c2 */ = /* c3 */ Terminate /* c4 */

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
) // after

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
): /* c8 */ gadt // after

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */</* c1.1 */ 'x /* c2.2 */> +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ += /* c3 */ Bar /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ +=
  | /* c3 */ Foo /* c4 */ = /* c5 */ Bar /* c6 */
"
`;

exports[`fileWithOneSingleLineComment.ns 1`] = `
"// retain this comment
"
`;

exports[`fileWithOnlyComments.ns 1`] = `
"// test

/* multi
line
comment
*/

// more comments
"
`;

exports[`interfaceWithOneSingleComment.nsi 1`] = `
"// retain this comment
"
`;

exports[`interfaceWithOnlyComments.nsi 1`] = `
"// test

/* test */

// ok
"
`;

exports[`jsx.ns 1`] = `
"module Cite = {
  @react.component
  let make = (~author: option<string>, ~children) => {
    // For semantics, check out
    // https://css-tricks.com/quoting-in-html-quotations-citations-and-blockquotes/
    <div> foo </div>
  }
}
"
`;

exports[`modExpr.ns 1`] = `
"// Pmod_ident
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ Y /* c4 */

// Pmod_structure
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ {
  let /* inside1 */ a /* inside2 */ = 2 /* trailing */
} // trailing

// Pmod_extension
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ %ext(
  /* c4 */ \\"test\\" /* c5 */
) /* c6 */

// Pmod_unpack
/* c0 */ module /* c1 */ New_three /* c2 */ = /* c3 */ unpack(
  /* c4 */ three /* c5 */: /* c6 */ X_int /* c7 */
) /* c8 */

// Pmod_constraint
/* c0 */ module /* c1 */ X /* c2 */: /* c5 */ Int /* c6 */ = /* c3 */ X /* c4 */
/* c0 */ module /* c1 */ X /* c2 */: /* c4 */ Int /* c5 */ = /* c6 */ X /* c7 */

// Pmod_apply
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ F /* c4 */(
  /* c4 */ Arg1 /* c5 */,
  /* c6 */ Arg2 /* c7 */,
  /* c8 */ Arg3 /* c9 */,
) /* c10 */
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ F(
  /* c4 */ A /* c5 */: /* c6 */ SetLike /* c7 */,
  /* c7 */ B /* c8 */: /* c9 */ TreeLike /* c10 */,
) /* c11 */
/* c0 */ module /* c1 */ S0 /* c2 */ = /* c3 */ Make /* c4 */(/* lbrace */ {
  type t = int /* c5 */
  let eq /* c6 */ = (x, y) => x == y
} /* rbrace */) // trailing

// Pmod_functor
/* c0 */ module /* c1 */ F /* c2 */ = /* before parameters */ (
  /* c3 */ A /* c4 */: /* c5 */ X /* c6 */,
  /* c7 */ B /* c8 */: /* c9 */ Y /* c 10 */,
  /* c7 */ C /* c8 */: /* c9 */ Z /* c 10 */,
) => /* c11 */ ReturnMod /* c12 */

module Make = /* before parameters */ (
  /* before A */ A /* after A */: /* before X */ X /* after X */,
  /* before B */ B /* after B */: /* before Y */ Y /* after Y */,
): /* c1 */ Set /* c2 */ => {
  let a /* inside */ = A.a + B.b
}

module Make = /* before parameters */ (
  /* before A */ A /* after A */: /* before X */ X /* after X */,
  /* before B */ B /* after B */: /* before Y */ Y /* after Y */,
): /* c1 */ Set /* c2 */ => {
  let a /* inside */ = A.a + B.b
}
"
`;

exports[`modType.ns 1`] = `
"// Pmty_ident
/* c0 */ module type /* c1 */ T /* c2 */ = /* c3 */ Tree /* c4 */

// Pmty_signature
/* c0 */ module type /* c1 */ T /* c2 */ = /* c3 */ {
  let a: int
} /* c4 */

// Pmty_extension
/* c0 */ module type /* c1 */ T /* c2 */ = /* c3 */ %ext(
  /* c4 */ \\"test\\" /* c5 */
) /* c6 */

// Pmty_typeof
/* c0 */ module type /* c1 */ A /* c2 */ = /* c3 */ module type of /* c4 */ {
  let a /* inside */ = 1
} /* c5 */

// Pmty_with
/* c0 */ module type /* c1 */ A /* c2 */ = /* c3 */ Foo /* c4 */
  with type t = string // end

// Pmty_functor
/* c0 */ module type /* c1 */ Functor /* c2 */ = /* c3 */ SetLike /* c4 */ =>
/* c5 */ Set /* c6 */
module type Functor = /* before */ (
  /* before S */ S /* after S */: /* before */ SetLike /* after */,
  /* before B */ B /* after B */: /* before */ BtreeLike /* after */,
) => /* before NeoTree */ NeoTree // after NeoTree
module type Functor = (
  /* c0 */ /* c1 */ /* c2 */ SetLike /* c3 */,
  /* c4 */ /* c5 */ /* c6 */ BtreeLike /* c7 */,
) => NeoTree

module type Functor = /* before */ (
  /* c0 */ SetLike /* c1 */,
  /* c2 */ BtreeLike /* c3 */,
) => NeoTree
"
`;

exports[`multiline.ns 1`] = `
"/* first line
 * the leading stars
 * should align here.
 */
let f = () => ()

/* first line
 * second line
 * third line */

/* first line
 *
 * third line */

/* x */
/*  */
/*  */
/*  */

/**
 * test
 */

/* BuckleScript outperforms a classic for-loop: 
   function equals3(m1, m2) {
    for (var i = 0; i < 4; i++) {
        for (var j = 0; j < 4; j++) {
            var x = m1[i][j];
            var y = m2[i][j];
            if(!floatEquals(x, y)) {
                return false
            }
        }
    }
    return true
  } */
let equals = (matrix1, matrix2) => {
  let rec loop = (i, j) =>
    if i > 3 {
      true
    } else {
      let x = matrix1->getUnsafe(~row=i, ~col=j)
      let y = matrix2->getUnsafe(~row=i, ~col=j)
      if !Float.equals(x, y) {
        false
      } else if j < 3 {
        loop(i, j + 1)
      } else {
        loop(i + 1, 0)
      }
    }

  loop(0, 0)
}

/*
foo
bar
*/

/*



foo
bar
*/

/*



foo




bar



*/

/* multi
line
comment
*/

/*
multi
line
comment */
"
`;

exports[`namedArgs.ns 1`] = `
"let wizard = Wizard.make(
  ~spriteSheet=wizard,
  ~hp=999999999999999,
  ~mp=50,
  // ~coordinates={x: 0., y:0. z: 0.},
  ~coordinates={x: 40, y: 100., z: 0.},
  /* c0 */ ~gpuCoordinates=/* c1 */ gpuBuffer[10] /* c2 */, // trailing
)

apply(
  // above
  ~aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  // below
  ~bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,
  // here
  ~cccccccccccccccccccccccccccccccc,
)

applyOptional(
  // above
  ~aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa?,
  // below
  ~bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb?,
  // here
  ~cccccccccccccccccccccccccccccccc?,
)

foo(
  // c0
  ~aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: int,
  // c1
  ~bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: int,
  // c2
  ~cccccccccccccccccccccccccccccc: int,
)

let f = (
  ~isItemActive=?,
  // array((name, href))
  ~headers: array<(string, string)>,
  ~moduleName: string,
  // foo
  ~x,
  // above
  /* c0 */ ~d: /* c1 */ e, // end
  // does it work
  ~from as hometown,
) => {
  let a = 1
  let b = 2
  a + b
}

@react.component
let make = (
  ~theme: ColorTheme.t,
  ~components: Mdx.Components.t,
  ~sidebarState: (bool, (bool => bool) => unit),
  // (Sidebar, toggleSidebar) ... for toggling sidebar in mobile view
  ~sidebar: React.element,
  ~breadcrumbs: option<list<UrlPath.breadcrumb>>=?,
  ~children,
) => {
  ()
}
"
`;

exports[`openDescription.ns 1`] = `
"open /* leading */ React /* trailing */
open /* leading */ React /* trailing */
open /* leading */ React // trailing
"
`;

exports[`pattern.ns 1`] = `
"// Ppat_any
let /* before */ _ /* after */ = 1

// Ppat_var
let /* before */ x /* after */ = 1

// Ppat_constant
let /* before */ 123 /* after */ = 123

// Ppat_interval not supported
// Ppat_interval of constant * constant

// Ppat_alias
let /* before pat */ p /* after pat */ as /* before alias */ x /* after alias */ = ()
let /* c0 */ (/* c1 */ p /* c2 */ as /* c3 */ x /* c4 */) as /* c5 */ y /* c6 */ = ()

// Ppat_array
let /* c0 */ [
  /* c1 */ a /* c2 */,
  /* c3 */ b /* c4 */,
  /* c5 */ c /* c6 */,
] /* c7 */ = [1, 2, 3]

// Ppat_construct
let /* here */ Black /* there */ = color

let /* here */ Black(/* inside */) /* there */ = color
let Black(/* inside */ /* inside2 */) = color
let Black(/* inside */ /* inside2 */ /* inside 3 */) = color
let Black(// singleLineComment
) = color

let module(/* c0 */ X /* c1 */: /* c2 */ X_int /* c3 */) /* c4 */ = x

let /* before */ Rgb(
  /* red */ r /* red2 */,
  /* green */ g /* green2 */,
  /* blue */ b /* blue2 */,
) /* after */ = color

let () = ()
let [/* inside */] = []
let list[/* inside */] = list[]

let /* before */ list[
  /* a1 */ a /* a2 */,
  /* b1 */ b /* b2 */,
] /* after */ = list[1, 2]
let /* before */ list[
  /* a1 */ a /* a2 */,
  .../* b1 */ b /* b2 */,
] /* after */ = list[1, 2]

// Ppat_record
let /* before */ {/* c0 */ name /* c1 */, /* c2 */ age /* c3 */} /* after */ = {
  name: \\"steve\\",
  age: 31,
}

let /* before */ {
  /* c0 */ name /* c1 */: /* c2 */ firstName /* c3 */,
  /* c3 */ age /* c4 */: /* c5 */ ageInYears /* c6 */,
} /* after */ = {name: \\"steve\\", age: 31}

// Ppat_or
let /* b1 */ Blue /* b2 */ | /* c1 */ Red /* c2 */ = color
let /* b1 */ Blue /* b2 */ | /* c1 */ Red | /* d1 */ Green /* d2 */ = color

// Ppat_constraint
let /* c0 */ number /* c1 */: /* c2 */ int /* c3 */ = 123

// Ppat_lazy
let /* before */ lazy /* a */ x /* b */ /* after */ = lazy 1

// Ppat_unpack
let /* before */ module(/* h1 */ Hashtbl /* h2 */) /* after */ = Hashtbl
let /* before */ module(/* h1 */ Hashtbl /* h2 */: /* h3 */ MutableTable /* h4 */) /* after */ = Hashtbl

// Ppat_exception
let /* before */ exception /* c0 */ Exit /* c1 */ /* after */ = exc

// Ppat_extension
let /* before */ %bs.raw(\\"eval(gc())\\") /* after */ = stuff

// Ppat_interval
let /* c0 */ 'a' .. 'z' /* c1 */ = x
"
`;

exports[`signatureItem.nsi 1`] = `
"// Psig_value
/* c0 */ external /* c1 */ force_gc /* c2 */: /* c3 */ unit /* c4 */ => /* c5 */ unit /* c6 */ =
  \\"gc\\" // trailing

// Psig_type
/* c0 */ type /* c1 */ t /* c2 */ = /* c3 */ string /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ = /* c4 */ string /* c5 */
// above
and /* c6 */ s /* c7 */ = /* c8 */ int /* c9 */

// Pstr_typext
/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */</* c1.1 */ 'x /* c2.2 */> +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ += /* c3 */ Bar /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ +=
  | /* c3 */ Foo /* c4 */ = /* c5 */ Bar /* c6 */

// Pstr_exception
/* c0 */ exception /* c1 */ Exit /* c2 */ = /* c3 */ Terminate /* c4 */

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
) // after

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
): /* c8 */ gadt // after

/* c0 */ exception /* c1 */ ExitEarly /* c2 */({
  /* c4 */ code /* inside */: /* inside2 */ int /* c5 */,
  /* c6 */ timeout /* inside */: /* inside2 */ int /* c7 */,
}): /* c8 */ gadt // after

// Psig_module
/* c0 */ module /* c1 */ X /* c2 */: /* c3 */ MT /* c4 */

// Psig_module
/* c0 */ module rec /* c1 */ X1 /* c2 */: /* c3 */ MT1
// above
and /* c4 */ Xn /* c5 */: /* c6 */ MTn /* c7 */

// Psig_modtype
/* c0 */ module type /* c1 */ S /* c2 */ = /* c3 */ MT /* c4 */
/* c0 */ module type /* c1 */ S /* c2 */

// Psig_open
/* c0 */ open /* c1 */ Belt /* c2 */

// Psig_include
/* c0 */ include /* c1 */ {
  let a /* inside */: int
} // after

// Psig_attribute
/* c0 */ @@attr(/* c1 */ payload /* c2 */) /* c3 */

// Psig_extension
/* c0 */ @@extension(/* c1 */ payload /* c2 */) /* c3 */
"
`;

exports[`structure1.ns 1`] = `
"// leading single line 1a
// leading single line 1b
/* leading multiline 1c */
/* leading multiline 1d */
/* leading multiline attached to node */ let a = 1 // trailing1

// leading2
/* before */ let b = 2 /* trailing2 */
/* under b */

/* here */

// lala

/* test */ /* okok */

// above open
open /* here */ React // after
// trailing
/* foo */
/* bar */

// another
// ok

// end
"
`;

exports[`structure2.ns 1`] = `
"let b = 2
/* test */ // sldkfj

// sldkfj

/* help */ /* help2 */

/* test2 */
open /* before lident */ React
"
`;

exports[`structure3.ns 1`] = `
"node.left->peekMinNode
// same as the above
node.left->peekMinNode

// field access has higher precedence than unary -
let x = -a.bar

let a = 1

/* test */
let b = 2
// a
// b
"
`;

exports[`structure4.ns 1`] = `
"let user = {
  name: \\"steve\\",
  age: 31,
}

/* A comment */
/**
 * A type that can be written to a buffer.
 */
/**
 * Describes the connection status of a ReactiveSocket/DuplexConnection.
 * - NOT_CONNECTED: no connection established or pending.
 * - CONNECTING: when \`connect()\` has been called but a connection is not yet
 *   established.
 * - CONNECTED: when a connection is established.
 * - CLOSED: when the connection has been explicitly closed via \`close()\`.
 * - ERROR: when the connection has been closed for any other reason.
 */
/**
 * A contract providing different interaction models per the [ReactiveSocket protocol]
 * (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
 */
/**
 * A single unit of data exchanged between the peers of a \`ReactiveSocket\`.
 */
"
`;

exports[`structureItem.ns 1`] = `
"// Pstr_attribute
@@attr(/* c0 */ \\"here\\" /* c1 */)

// Pstr_extension
%%extension(/* c0 */ \\"here\\" /* c1 */)

// Pstr_include
/* c0 */ include /* c1 */ Belt /* c2 */
/* c0 */ include /* c1 */ {
  let a /* inside */ = 2
} /* c2 */

// Pstr_open
/* c0 */ open /* c1 */ Belt /* c2 */

// Pstr_modtype
/* c0 */ module type /* c1 */ T /* c2 */ = /* c3 */ MT /* c4 */

// Pstr_recmodule
/* c0 */ module rec /* c1 */ X1 /* c2 */ = /* c3 */ ME1 /* c4 */
// above
and /* c5 */ Xn /* c6 */ = /* c7 */ MEn /* c8 */

// Pstr_module
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ Y /* c4 */

// Pstr_exception
/* c0 */ exception /* c1 */ Exit /* c2 */ = /* c3 */ Terminate /* c4 */

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
) // after

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
): /* c8 */ gadt // after

// Pstr_typext
/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */</* c1.1 */ 'x /* c2.2 */> +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ += /* c3 */ Bar /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ +=
  | /* c3 */ Foo /* c4 */ = /* c5 */ Bar /* c6 */

// Pstr_type
/* c0 */ type /* c1 */ t /* c2 */ = /* c3 */ string /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ = /* c4 */ string /* c5 */
// above
and /* c6 */ s /* c7 */ = /* c8 */ int /* c9 */

// Pstr_primitive
/* c0 */ external /* c1 */ force_gc /* c2 */: /* c3 */ unit /* c4 */ => /* c5 */ unit /* c6 */ =
  \\"gc\\" // trailing

// Pstr_eval
/* c0 */ user.name /* c1 */ = /* c2 */ \\"Steve\\" /* c3 */
"
`;

exports[`trailingComments.ns 1`] = `
"let user = {
  name: \\"steve\\",
  age: 31 /* here */, // test

  /* test */
  /* test2 */

  // test3

  /* test 4 */
}

/* A */
/**
 * A type that can be written to a buffer.
 */
/**
 * Describes the connection status of a ReactiveSocket/DuplexConnection.
 * - NOT_CONNECTED: no connection established or pending.
 * - CONNECTING: when \`connect()\` has been called but a connection is not yet
 *   established.
 * - CONNECTED: when a connection is established.
 * - CLOSED: when the connection has been explicitly closed via \`close()\`.
 * - ERROR: when the connection has been closed for any other reason.
 */
/**
 * A contract providing different interaction models per the [ReactiveSocket protocol]
 * (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
 */
/**
 * A single unit of data exchanged between the peers of a \`ReactiveSocket\`.
 */
"
`;

exports[`typeDefinition.js 1`] = `
"/* before */ type t /* after */
/* before */ type /* before name */ t /* after name */ /* after */

/* before */ type t = .. /* after */
/* before */ type /* before name */ t /* after name */ = .. /* after */

/* before */ type t<
  /* c0 */ 'err /* c1 */,
  /* c2 */ 'success /* c3 */,
> /* after */
/* before */ type /* before name */ t /* after name */<
  /* c0 */ 'err /* c1 */,
  /* c2 */ 'success /* c3 */,
> /* after */

/* before */ type t = /* before manifest */ string /* after */
/* before */ type /* before name */ t /* after name */ = /* before manifest */ string /* after */
/* before */ type /* before name */ t /* after name */<
  /* c0 */ 'err /* c1 */,
  /* c2 */ 'success /* c3 */,
> = /* before manifest */ string /* after */

/* before */ type /* before name */ t /* after name */ =
  // above Red
  | Red // trailing Red
  // above Blue
  | Blue // trailing Blue
  // above Green
  | Green // trailing Green

/* before */ type /* before name */ t /* after name */ = /* before manifest */ Colour.t /* after manifest */ =
  // above Red
  | /* before Red */ Red // trailing Red
  // above Blue
  | /* before Blue */ Blue // trailing Blue
  // above Green
  | /* before Green */ Green /* trailing Green */ // test

type color =
  | /* before Red */ Red /* after Red */: /* before gadt */ color /* after gadt */
  | /* before Blue */ Blue /* after Blue */: /* before gadt */ color /* after gadt */

type color =
  /* before constr */ | Rgb(
      /* after constructor */ /* before red */ red,
      green,
      blue,
    )

type color =
  | /* before constr */ Rgb /* after constructor */(
      /* before red */ red /* after red */,
      /* before green */ green /* after green */,
      /* before blue */ blue /* after blue */,
    )

type color =
  | /* before constr */ Rgb /* after constructor */({
      /* before red */ red /* after red */: /* before typ */ someNumber /* after typ */,
      /* before green */ green /* after green */: /* before typ */ someNumber /* after typ */,
      /* before blue */ blue /* after blue */: /* before typ */ someNumber /* after typ */,
    })

type color = {
  /* before red */ red /* after red */: /* before typ */ someNumber /* after typ */,
  /* before green */ green /* after green */: /* before typ */ someNumber /* after typ */,
  /* before blue */ blue /* after blue */: /* before typ */ someNumber /* after typ */,
}

type /* c0 */ color /* c1 */ = /* before manifest */ Colour.t /* after manifest */ = {
  /* before red */ red /* after red */: /* before typ */ someNumber /* after typ */,
  /* before green */ green /* after green */: /* before typ */ someNumber /* after typ */,
  /* before blue */ blue /* after blue */: /* before typ */ someNumber /* after typ */,
}

type domProps = {
  @bs.optional
  viewTarget: string,
  @bs.optional
  visibility: string,
  /* width::string? => */
  @bs.optional
  widths: string,
  @bs.optional
  wordSpacing: string,
  @bs.optional
  writingMode: string,
  @bs.optional
  x: string,
  @bs.optional
  x1: string,
}

@bs.deriving(abstract)
type t = {
  /* MDX shortnames for more advanced components */
  @bs.as(\\"Cite\\")
  cite: React.component<{
    \\"author\\": option<string>,
    \\"children\\": React.element,
  }>,
  @bs.as(\\"Info\\") @bs.optional
  info: React.component<props>,
}

type rec t = {
  facing: facing,
  // frames
}
"
`;

exports[`typexpr.ns 1`] = `
"// Ptyp_any
type t = /* before */ _ /* after */

// Ptyp_var
type t = /* before */ 'a /* after */

// Ptyp_tuple
// sigh… conflicts

// Ptyp_constr
type t = /* before */ string /* after */
type t = /* before */ option /* c0 */</* c1 */ string /* c2 */> /* after */
type t = /* before */ result /* c0 */<
  /* c1 */ success /* c2 */,
  /* c3 */ err /* c4 */,
> /* after */

// Ptyp_extension
type t = /* before */ %ext(/* before */ \\"here\\" /* after */) /* after */

// Ptyp_package
type t = /* c0 */ module(/* before */ S /* after */) /* c1 */

type t = /* c0 */ module(/* c1 */ Hashmap /* c2 */ with
  /* c3 */ type key /* c4 */ = /* c5 */ string /* c6 */
)

// Ptyp_alias
type t = /* c0 */ string /* c1 */ as 'x // after

// Ptyp_poly
type fn = {f: /* c0 */ 'a /* c1 */ 'b /* c2 */. /* c3 */ string /* c4 */}

// Ptyp_arrow
type add = /* before */ (
  /* c0 */ int /* c1 */,
  /* c2 */ int /* c3 */,
) => /* before return */ int /* after */
type add = /* before */ (
  ~a: /* c0 */ int /* c1 */,
  ~b: /* c2 */ int /* c3 */,
) => /* before return */ int /* after */
type multiply = /* before */ (
  ~fn: /* c0 */ (
    /* cinner0 */ int /* cinner1 */,
    /* cinner2 */ int /* cinner3 */,
  ) => /* cx */ int /* c1 */,
  ~b: /* c2 */ int /* c3 */,
) => int /* after */

// Ptyp_object
type jsUser = /* before */ {
  // above name
  /* before name */ \\"name\\" /* after name */: /* before typ */ string /* after typ */,
  // above age
  /* before age */ \\"age\\" /* after age */: /* before int */ int /* after int */,
} /* after */
"
`;

exports[`valueBindings.ns 1`] = `
"let x = 1
// trailing first value-binding

// leading snd value-binding
and y = 2
/* leading snd value-binding */

let walkList: 'node. unit = comments => {
  open Location
  let x /* comment */ = 0
}

let walkList: 'node. (
  ~prevLoc: Location.t=?,
  ~getLoc: 'node => Location.t,
  ~walkNode: ('node, t, list<Comment.t>) => unit,
  list<'node>,
  t,
  list<Comment.t>,
) => unit = (~prevLoc=?, ~getLoc, ~walkNode, l, t, comments) => {
  open Location
  switch l {
  | _ when comments == list[] => ()
  | list[] =>
    switch prevLoc {
    | Some(loc) => attach(t.trailing, loc, comments)
    | None => ()
    }
  | list[node, ...rest] =>
    let currLoc = getLoc(node)
    let (leading, inside, trailing) = partitionByLoc(comments, currLoc)
    switch prevLoc {
    | None =>
      /* first value binding, all leading comments attach here */
      attach(t.leading, currLoc, leading)
    | Some(prevLoc) =>
      /* Same line */
      if prevLoc.loc_end.pos_lnum === currLoc.loc_start.pos_lnum {
        let (afterPrev, beforeCurr) = partitionAdjacentTrailing(
          prevLoc,
          leading,
        )
        let () = attach(t.trailing, prevLoc, afterPrev)
        attach(t.leading, currLoc, beforeCurr)
      } else {
        let (onSameLineAsPrev, afterPrev) = partitionByOnSameLine(
          prevLoc,
          leading,
        )
        let () = attach(t.trailing, prevLoc, onSameLineAsPrev)
        let (leading, _inside, _trailing) = partitionByLoc(afterPrev, currLoc)
        attach(t.leading, currLoc, leading)
      }
    }
    walkNode(node, t, inside)
    walkList(~prevLoc=currLoc, ~getLoc, ~walkNode, rest, t, trailing)
  }
}

let /* c0 */ number /* c1 */: /* c2 */ int /* c3 */ = /* c4 */ 123 /* c5 */

// some comment

/* leading 3th value-binding */ /* test */
and z = 3
/* cmt a */
/* cmt b */
/* cmt c */
and z2 = 4
// trailing structure
"
`;

exports[`whitespaceCase1.ns 1`] = `
"let x = 1
// comment

let 123 = 123
// comment2
let f = ()
"
`;

exports[`whitespaceCase2.ns 1`] = `
"let a = 2 // c2

let b = 1
"
`;

exports[`whitespaceLeadingComment.ns 1`] = `
"// the comment \\"assert Tuple\\" should contain whitespace before/after
let () = {
  let point = Tuple.makePoint(0., 1., 0.)
  let halfQuarter = rotationX(Js.Math._PI /. 4.)
  let fullQuarter = rotationX(Js.Math._PI /. 2.)

  /* assert Tuple.equals(
    halfQuarter->applyTo(point),
    Tuple.makePoint(0., Js.Math.sqrt(2.) /. 2., Js.Math.sqrt(2.) /. 2.),
  ) */

  assert Tuple.equals(fullQuarter->applyTo(point), Tuple.makePoint(0., 0., 1.))
}
"
`;

exports[`whitespaceTrailingLeading.ns 1`] = `
"let a = 1 // single line trailing
// leading
let b = 2

let a = 1 /* comment */
// leading
let b = 2

let a = 1 // single line trailing

// leading
let b = 2

let a = 1 /* comment */

// leading
let b = 2
"
`;
